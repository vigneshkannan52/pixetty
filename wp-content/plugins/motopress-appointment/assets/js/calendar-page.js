(function (mpaData, React$1, ReactDOM, WPAPI) {
	'use strict';

	function _interopNamespaceDefault(e) {
		var n = Object.create(null);
		if (e) {
			Object.keys(e).forEach(function (k) {
				if (k !== 'default') {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		}
		n.default = e;
		return Object.freeze(n);
	}

	var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React$1);

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function getAugmentedNamespace(n) {
	  if (n.__esModule) return n;
	  var f = n.default;
		if (typeof f == "function") {
			var a = function a () {
				if (this instanceof a) {
					var args = [null];
					args.push.apply(args, arguments);
					var Ctor = Function.bind.apply(f, args);
					return new Ctor();
				}
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	function commonjsRequire(path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var moment$2 = {exports: {}};

	(function (module, exports) {
	(function (global, factory) {
		    module.exports = factory() ;
		}(commonjsGlobal, (function () {
		    var hookCallback;

		    function hooks() {
		        return hookCallback.apply(null, arguments);
		    }

		    // This is done to register the method called with moment()
		    // without creating circular dependencies.
		    function setHookCallback(callback) {
		        hookCallback = callback;
		    }

		    function isArray(input) {
		        return (
		            input instanceof Array ||
		            Object.prototype.toString.call(input) === '[object Array]'
		        );
		    }

		    function isObject(input) {
		        // IE8 will treat undefined and null as object if it wasn't for
		        // input != null
		        return (
		            input != null &&
		            Object.prototype.toString.call(input) === '[object Object]'
		        );
		    }

		    function hasOwnProp(a, b) {
		        return Object.prototype.hasOwnProperty.call(a, b);
		    }

		    function isObjectEmpty(obj) {
		        if (Object.getOwnPropertyNames) {
		            return Object.getOwnPropertyNames(obj).length === 0;
		        } else {
		            var k;
		            for (k in obj) {
		                if (hasOwnProp(obj, k)) {
		                    return false;
		                }
		            }
		            return true;
		        }
		    }

		    function isUndefined(input) {
		        return input === void 0;
		    }

		    function isNumber(input) {
		        return (
		            typeof input === 'number' ||
		            Object.prototype.toString.call(input) === '[object Number]'
		        );
		    }

		    function isDate(input) {
		        return (
		            input instanceof Date ||
		            Object.prototype.toString.call(input) === '[object Date]'
		        );
		    }

		    function map(arr, fn) {
		        var res = [],
		            i,
		            arrLen = arr.length;
		        for (i = 0; i < arrLen; ++i) {
		            res.push(fn(arr[i], i));
		        }
		        return res;
		    }

		    function extend(a, b) {
		        for (var i in b) {
		            if (hasOwnProp(b, i)) {
		                a[i] = b[i];
		            }
		        }

		        if (hasOwnProp(b, 'toString')) {
		            a.toString = b.toString;
		        }

		        if (hasOwnProp(b, 'valueOf')) {
		            a.valueOf = b.valueOf;
		        }

		        return a;
		    }

		    function createUTC(input, format, locale, strict) {
		        return createLocalOrUTC(input, format, locale, strict, true).utc();
		    }

		    function defaultParsingFlags() {
		        // We need to deep clone this object.
		        return {
		            empty: false,
		            unusedTokens: [],
		            unusedInput: [],
		            overflow: -2,
		            charsLeftOver: 0,
		            nullInput: false,
		            invalidEra: null,
		            invalidMonth: null,
		            invalidFormat: false,
		            userInvalidated: false,
		            iso: false,
		            parsedDateParts: [],
		            era: null,
		            meridiem: null,
		            rfc2822: false,
		            weekdayMismatch: false,
		        };
		    }

		    function getParsingFlags(m) {
		        if (m._pf == null) {
		            m._pf = defaultParsingFlags();
		        }
		        return m._pf;
		    }

		    var some;
		    if (Array.prototype.some) {
		        some = Array.prototype.some;
		    } else {
		        some = function (fun) {
		            var t = Object(this),
		                len = t.length >>> 0,
		                i;

		            for (i = 0; i < len; i++) {
		                if (i in t && fun.call(this, t[i], i, t)) {
		                    return true;
		                }
		            }

		            return false;
		        };
		    }

		    function isValid(m) {
		        if (m._isValid == null) {
		            var flags = getParsingFlags(m),
		                parsedParts = some.call(flags.parsedDateParts, function (i) {
		                    return i != null;
		                }),
		                isNowValid =
		                    !isNaN(m._d.getTime()) &&
		                    flags.overflow < 0 &&
		                    !flags.empty &&
		                    !flags.invalidEra &&
		                    !flags.invalidMonth &&
		                    !flags.invalidWeekday &&
		                    !flags.weekdayMismatch &&
		                    !flags.nullInput &&
		                    !flags.invalidFormat &&
		                    !flags.userInvalidated &&
		                    (!flags.meridiem || (flags.meridiem && parsedParts));

		            if (m._strict) {
		                isNowValid =
		                    isNowValid &&
		                    flags.charsLeftOver === 0 &&
		                    flags.unusedTokens.length === 0 &&
		                    flags.bigHour === undefined;
		            }

		            if (Object.isFrozen == null || !Object.isFrozen(m)) {
		                m._isValid = isNowValid;
		            } else {
		                return isNowValid;
		            }
		        }
		        return m._isValid;
		    }

		    function createInvalid(flags) {
		        var m = createUTC(NaN);
		        if (flags != null) {
		            extend(getParsingFlags(m), flags);
		        } else {
		            getParsingFlags(m).userInvalidated = true;
		        }

		        return m;
		    }

		    // Plugins that add properties should also add the key here (null value),
		    // so we can properly clone ourselves.
		    var momentProperties = (hooks.momentProperties = []),
		        updateInProgress = false;

		    function copyConfig(to, from) {
		        var i,
		            prop,
		            val,
		            momentPropertiesLen = momentProperties.length;

		        if (!isUndefined(from._isAMomentObject)) {
		            to._isAMomentObject = from._isAMomentObject;
		        }
		        if (!isUndefined(from._i)) {
		            to._i = from._i;
		        }
		        if (!isUndefined(from._f)) {
		            to._f = from._f;
		        }
		        if (!isUndefined(from._l)) {
		            to._l = from._l;
		        }
		        if (!isUndefined(from._strict)) {
		            to._strict = from._strict;
		        }
		        if (!isUndefined(from._tzm)) {
		            to._tzm = from._tzm;
		        }
		        if (!isUndefined(from._isUTC)) {
		            to._isUTC = from._isUTC;
		        }
		        if (!isUndefined(from._offset)) {
		            to._offset = from._offset;
		        }
		        if (!isUndefined(from._pf)) {
		            to._pf = getParsingFlags(from);
		        }
		        if (!isUndefined(from._locale)) {
		            to._locale = from._locale;
		        }

		        if (momentPropertiesLen > 0) {
		            for (i = 0; i < momentPropertiesLen; i++) {
		                prop = momentProperties[i];
		                val = from[prop];
		                if (!isUndefined(val)) {
		                    to[prop] = val;
		                }
		            }
		        }

		        return to;
		    }

		    // Moment prototype object
		    function Moment(config) {
		        copyConfig(this, config);
		        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
		        if (!this.isValid()) {
		            this._d = new Date(NaN);
		        }
		        // Prevent infinite loop in case updateOffset creates new moment
		        // objects.
		        if (updateInProgress === false) {
		            updateInProgress = true;
		            hooks.updateOffset(this);
		            updateInProgress = false;
		        }
		    }

		    function isMoment(obj) {
		        return (
		            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
		        );
		    }

		    function warn(msg) {
		        if (
		            hooks.suppressDeprecationWarnings === false &&
		            typeof console !== 'undefined' &&
		            console.warn
		        ) {
		            console.warn('Deprecation warning: ' + msg);
		        }
		    }

		    function deprecate(msg, fn) {
		        var firstTime = true;

		        return extend(function () {
		            if (hooks.deprecationHandler != null) {
		                hooks.deprecationHandler(null, msg);
		            }
		            if (firstTime) {
		                var args = [],
		                    arg,
		                    i,
		                    key,
		                    argLen = arguments.length;
		                for (i = 0; i < argLen; i++) {
		                    arg = '';
		                    if (typeof arguments[i] === 'object') {
		                        arg += '\n[' + i + '] ';
		                        for (key in arguments[0]) {
		                            if (hasOwnProp(arguments[0], key)) {
		                                arg += key + ': ' + arguments[0][key] + ', ';
		                            }
		                        }
		                        arg = arg.slice(0, -2); // Remove trailing comma and space
		                    } else {
		                        arg = arguments[i];
		                    }
		                    args.push(arg);
		                }
		                warn(
		                    msg +
		                        '\nArguments: ' +
		                        Array.prototype.slice.call(args).join('') +
		                        '\n' +
		                        new Error().stack
		                );
		                firstTime = false;
		            }
		            return fn.apply(this, arguments);
		        }, fn);
		    }

		    var deprecations = {};

		    function deprecateSimple(name, msg) {
		        if (hooks.deprecationHandler != null) {
		            hooks.deprecationHandler(name, msg);
		        }
		        if (!deprecations[name]) {
		            warn(msg);
		            deprecations[name] = true;
		        }
		    }

		    hooks.suppressDeprecationWarnings = false;
		    hooks.deprecationHandler = null;

		    function isFunction(input) {
		        return (
		            (typeof Function !== 'undefined' && input instanceof Function) ||
		            Object.prototype.toString.call(input) === '[object Function]'
		        );
		    }

		    function set(config) {
		        var prop, i;
		        for (i in config) {
		            if (hasOwnProp(config, i)) {
		                prop = config[i];
		                if (isFunction(prop)) {
		                    this[i] = prop;
		                } else {
		                    this['_' + i] = prop;
		                }
		            }
		        }
		        this._config = config;
		        // Lenient ordinal parsing accepts just a number in addition to
		        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
		        // TODO: Remove "ordinalParse" fallback in next major release.
		        this._dayOfMonthOrdinalParseLenient = new RegExp(
		            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
		                '|' +
		                /\d{1,2}/.source
		        );
		    }

		    function mergeConfigs(parentConfig, childConfig) {
		        var res = extend({}, parentConfig),
		            prop;
		        for (prop in childConfig) {
		            if (hasOwnProp(childConfig, prop)) {
		                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
		                    res[prop] = {};
		                    extend(res[prop], parentConfig[prop]);
		                    extend(res[prop], childConfig[prop]);
		                } else if (childConfig[prop] != null) {
		                    res[prop] = childConfig[prop];
		                } else {
		                    delete res[prop];
		                }
		            }
		        }
		        for (prop in parentConfig) {
		            if (
		                hasOwnProp(parentConfig, prop) &&
		                !hasOwnProp(childConfig, prop) &&
		                isObject(parentConfig[prop])
		            ) {
		                // make sure changes to properties don't modify parent config
		                res[prop] = extend({}, res[prop]);
		            }
		        }
		        return res;
		    }

		    function Locale(config) {
		        if (config != null) {
		            this.set(config);
		        }
		    }

		    var keys;

		    if (Object.keys) {
		        keys = Object.keys;
		    } else {
		        keys = function (obj) {
		            var i,
		                res = [];
		            for (i in obj) {
		                if (hasOwnProp(obj, i)) {
		                    res.push(i);
		                }
		            }
		            return res;
		        };
		    }

		    var defaultCalendar = {
		        sameDay: '[Today at] LT',
		        nextDay: '[Tomorrow at] LT',
		        nextWeek: 'dddd [at] LT',
		        lastDay: '[Yesterday at] LT',
		        lastWeek: '[Last] dddd [at] LT',
		        sameElse: 'L',
		    };

		    function calendar(key, mom, now) {
		        var output = this._calendar[key] || this._calendar['sameElse'];
		        return isFunction(output) ? output.call(mom, now) : output;
		    }

		    function zeroFill(number, targetLength, forceSign) {
		        var absNumber = '' + Math.abs(number),
		            zerosToFill = targetLength - absNumber.length,
		            sign = number >= 0;
		        return (
		            (sign ? (forceSign ? '+' : '') : '-') +
		            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
		            absNumber
		        );
		    }

		    var formattingTokens =
		            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
		        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
		        formatFunctions = {},
		        formatTokenFunctions = {};

		    // token:    'M'
		    // padded:   ['MM', 2]
		    // ordinal:  'Mo'
		    // callback: function () { this.month() + 1 }
		    function addFormatToken(token, padded, ordinal, callback) {
		        var func = callback;
		        if (typeof callback === 'string') {
		            func = function () {
		                return this[callback]();
		            };
		        }
		        if (token) {
		            formatTokenFunctions[token] = func;
		        }
		        if (padded) {
		            formatTokenFunctions[padded[0]] = function () {
		                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
		            };
		        }
		        if (ordinal) {
		            formatTokenFunctions[ordinal] = function () {
		                return this.localeData().ordinal(
		                    func.apply(this, arguments),
		                    token
		                );
		            };
		        }
		    }

		    function removeFormattingTokens(input) {
		        if (input.match(/\[[\s\S]/)) {
		            return input.replace(/^\[|\]$/g, '');
		        }
		        return input.replace(/\\/g, '');
		    }

		    function makeFormatFunction(format) {
		        var array = format.match(formattingTokens),
		            i,
		            length;

		        for (i = 0, length = array.length; i < length; i++) {
		            if (formatTokenFunctions[array[i]]) {
		                array[i] = formatTokenFunctions[array[i]];
		            } else {
		                array[i] = removeFormattingTokens(array[i]);
		            }
		        }

		        return function (mom) {
		            var output = '',
		                i;
		            for (i = 0; i < length; i++) {
		                output += isFunction(array[i])
		                    ? array[i].call(mom, format)
		                    : array[i];
		            }
		            return output;
		        };
		    }

		    // format date using native date object
		    function formatMoment(m, format) {
		        if (!m.isValid()) {
		            return m.localeData().invalidDate();
		        }

		        format = expandFormat(format, m.localeData());
		        formatFunctions[format] =
		            formatFunctions[format] || makeFormatFunction(format);

		        return formatFunctions[format](m);
		    }

		    function expandFormat(format, locale) {
		        var i = 5;

		        function replaceLongDateFormatTokens(input) {
		            return locale.longDateFormat(input) || input;
		        }

		        localFormattingTokens.lastIndex = 0;
		        while (i >= 0 && localFormattingTokens.test(format)) {
		            format = format.replace(
		                localFormattingTokens,
		                replaceLongDateFormatTokens
		            );
		            localFormattingTokens.lastIndex = 0;
		            i -= 1;
		        }

		        return format;
		    }

		    var defaultLongDateFormat = {
		        LTS: 'h:mm:ss A',
		        LT: 'h:mm A',
		        L: 'MM/DD/YYYY',
		        LL: 'MMMM D, YYYY',
		        LLL: 'MMMM D, YYYY h:mm A',
		        LLLL: 'dddd, MMMM D, YYYY h:mm A',
		    };

		    function longDateFormat(key) {
		        var format = this._longDateFormat[key],
		            formatUpper = this._longDateFormat[key.toUpperCase()];

		        if (format || !formatUpper) {
		            return format;
		        }

		        this._longDateFormat[key] = formatUpper
		            .match(formattingTokens)
		            .map(function (tok) {
		                if (
		                    tok === 'MMMM' ||
		                    tok === 'MM' ||
		                    tok === 'DD' ||
		                    tok === 'dddd'
		                ) {
		                    return tok.slice(1);
		                }
		                return tok;
		            })
		            .join('');

		        return this._longDateFormat[key];
		    }

		    var defaultInvalidDate = 'Invalid date';

		    function invalidDate() {
		        return this._invalidDate;
		    }

		    var defaultOrdinal = '%d',
		        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

		    function ordinal(number) {
		        return this._ordinal.replace('%d', number);
		    }

		    var defaultRelativeTime = {
		        future: 'in %s',
		        past: '%s ago',
		        s: 'a few seconds',
		        ss: '%d seconds',
		        m: 'a minute',
		        mm: '%d minutes',
		        h: 'an hour',
		        hh: '%d hours',
		        d: 'a day',
		        dd: '%d days',
		        w: 'a week',
		        ww: '%d weeks',
		        M: 'a month',
		        MM: '%d months',
		        y: 'a year',
		        yy: '%d years',
		    };

		    function relativeTime(number, withoutSuffix, string, isFuture) {
		        var output = this._relativeTime[string];
		        return isFunction(output)
		            ? output(number, withoutSuffix, string, isFuture)
		            : output.replace(/%d/i, number);
		    }

		    function pastFuture(diff, output) {
		        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
		        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
		    }

		    var aliases = {};

		    function addUnitAlias(unit, shorthand) {
		        var lowerCase = unit.toLowerCase();
		        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
		    }

		    function normalizeUnits(units) {
		        return typeof units === 'string'
		            ? aliases[units] || aliases[units.toLowerCase()]
		            : undefined;
		    }

		    function normalizeObjectUnits(inputObject) {
		        var normalizedInput = {},
		            normalizedProp,
		            prop;

		        for (prop in inputObject) {
		            if (hasOwnProp(inputObject, prop)) {
		                normalizedProp = normalizeUnits(prop);
		                if (normalizedProp) {
		                    normalizedInput[normalizedProp] = inputObject[prop];
		                }
		            }
		        }

		        return normalizedInput;
		    }

		    var priorities = {};

		    function addUnitPriority(unit, priority) {
		        priorities[unit] = priority;
		    }

		    function getPrioritizedUnits(unitsObj) {
		        var units = [],
		            u;
		        for (u in unitsObj) {
		            if (hasOwnProp(unitsObj, u)) {
		                units.push({ unit: u, priority: priorities[u] });
		            }
		        }
		        units.sort(function (a, b) {
		            return a.priority - b.priority;
		        });
		        return units;
		    }

		    function isLeapYear(year) {
		        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
		    }

		    function absFloor(number) {
		        if (number < 0) {
		            // -0 -> 0
		            return Math.ceil(number) || 0;
		        } else {
		            return Math.floor(number);
		        }
		    }

		    function toInt(argumentForCoercion) {
		        var coercedNumber = +argumentForCoercion,
		            value = 0;

		        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
		            value = absFloor(coercedNumber);
		        }

		        return value;
		    }

		    function makeGetSet(unit, keepTime) {
		        return function (value) {
		            if (value != null) {
		                set$1(this, unit, value);
		                hooks.updateOffset(this, keepTime);
		                return this;
		            } else {
		                return get(this, unit);
		            }
		        };
		    }

		    function get(mom, unit) {
		        return mom.isValid()
		            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
		            : NaN;
		    }

		    function set$1(mom, unit, value) {
		        if (mom.isValid() && !isNaN(value)) {
		            if (
		                unit === 'FullYear' &&
		                isLeapYear(mom.year()) &&
		                mom.month() === 1 &&
		                mom.date() === 29
		            ) {
		                value = toInt(value);
		                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
		                    value,
		                    mom.month(),
		                    daysInMonth(value, mom.month())
		                );
		            } else {
		                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
		            }
		        }
		    }

		    // MOMENTS

		    function stringGet(units) {
		        units = normalizeUnits(units);
		        if (isFunction(this[units])) {
		            return this[units]();
		        }
		        return this;
		    }

		    function stringSet(units, value) {
		        if (typeof units === 'object') {
		            units = normalizeObjectUnits(units);
		            var prioritized = getPrioritizedUnits(units),
		                i,
		                prioritizedLen = prioritized.length;
		            for (i = 0; i < prioritizedLen; i++) {
		                this[prioritized[i].unit](units[prioritized[i].unit]);
		            }
		        } else {
		            units = normalizeUnits(units);
		            if (isFunction(this[units])) {
		                return this[units](value);
		            }
		        }
		        return this;
		    }

		    var match1 = /\d/, //       0 - 9
		        match2 = /\d\d/, //      00 - 99
		        match3 = /\d{3}/, //     000 - 999
		        match4 = /\d{4}/, //    0000 - 9999
		        match6 = /[+-]?\d{6}/, // -999999 - 999999
		        match1to2 = /\d\d?/, //       0 - 99
		        match3to4 = /\d\d\d\d?/, //     999 - 9999
		        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
		        match1to3 = /\d{1,3}/, //       0 - 999
		        match1to4 = /\d{1,4}/, //       0 - 9999
		        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
		        matchUnsigned = /\d+/, //       0 - inf
		        matchSigned = /[+-]?\d+/, //    -inf - inf
		        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
		        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
		        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
		        // any word (or two) characters or numbers including two/three word month in arabic.
		        // includes scottish gaelic two word and hyphenated months
		        matchWord =
		            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
		        regexes;

		    regexes = {};

		    function addRegexToken(token, regex, strictRegex) {
		        regexes[token] = isFunction(regex)
		            ? regex
		            : function (isStrict, localeData) {
		                  return isStrict && strictRegex ? strictRegex : regex;
		              };
		    }

		    function getParseRegexForToken(token, config) {
		        if (!hasOwnProp(regexes, token)) {
		            return new RegExp(unescapeFormat(token));
		        }

		        return regexes[token](config._strict, config._locale);
		    }

		    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
		    function unescapeFormat(s) {
		        return regexEscape(
		            s
		                .replace('\\', '')
		                .replace(
		                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
		                    function (matched, p1, p2, p3, p4) {
		                        return p1 || p2 || p3 || p4;
		                    }
		                )
		        );
		    }

		    function regexEscape(s) {
		        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
		    }

		    var tokens = {};

		    function addParseToken(token, callback) {
		        var i,
		            func = callback,
		            tokenLen;
		        if (typeof token === 'string') {
		            token = [token];
		        }
		        if (isNumber(callback)) {
		            func = function (input, array) {
		                array[callback] = toInt(input);
		            };
		        }
		        tokenLen = token.length;
		        for (i = 0; i < tokenLen; i++) {
		            tokens[token[i]] = func;
		        }
		    }

		    function addWeekParseToken(token, callback) {
		        addParseToken(token, function (input, array, config, token) {
		            config._w = config._w || {};
		            callback(input, config._w, config, token);
		        });
		    }

		    function addTimeToArrayFromToken(token, input, config) {
		        if (input != null && hasOwnProp(tokens, token)) {
		            tokens[token](input, config._a, config, token);
		        }
		    }

		    var YEAR = 0,
		        MONTH = 1,
		        DATE = 2,
		        HOUR = 3,
		        MINUTE = 4,
		        SECOND = 5,
		        MILLISECOND = 6,
		        WEEK = 7,
		        WEEKDAY = 8;

		    function mod(n, x) {
		        return ((n % x) + x) % x;
		    }

		    var indexOf;

		    if (Array.prototype.indexOf) {
		        indexOf = Array.prototype.indexOf;
		    } else {
		        indexOf = function (o) {
		            // I know
		            var i;
		            for (i = 0; i < this.length; ++i) {
		                if (this[i] === o) {
		                    return i;
		                }
		            }
		            return -1;
		        };
		    }

		    function daysInMonth(year, month) {
		        if (isNaN(year) || isNaN(month)) {
		            return NaN;
		        }
		        var modMonth = mod(month, 12);
		        year += (month - modMonth) / 12;
		        return modMonth === 1
		            ? isLeapYear(year)
		                ? 29
		                : 28
		            : 31 - ((modMonth % 7) % 2);
		    }

		    // FORMATTING

		    addFormatToken('M', ['MM', 2], 'Mo', function () {
		        return this.month() + 1;
		    });

		    addFormatToken('MMM', 0, 0, function (format) {
		        return this.localeData().monthsShort(this, format);
		    });

		    addFormatToken('MMMM', 0, 0, function (format) {
		        return this.localeData().months(this, format);
		    });

		    // ALIASES

		    addUnitAlias('month', 'M');

		    // PRIORITY

		    addUnitPriority('month', 8);

		    // PARSING

		    addRegexToken('M', match1to2);
		    addRegexToken('MM', match1to2, match2);
		    addRegexToken('MMM', function (isStrict, locale) {
		        return locale.monthsShortRegex(isStrict);
		    });
		    addRegexToken('MMMM', function (isStrict, locale) {
		        return locale.monthsRegex(isStrict);
		    });

		    addParseToken(['M', 'MM'], function (input, array) {
		        array[MONTH] = toInt(input) - 1;
		    });

		    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
		        var month = config._locale.monthsParse(input, token, config._strict);
		        // if we didn't find a month name, mark the date as invalid.
		        if (month != null) {
		            array[MONTH] = month;
		        } else {
		            getParsingFlags(config).invalidMonth = input;
		        }
		    });

		    // LOCALES

		    var defaultLocaleMonths =
		            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
		                '_'
		            ),
		        defaultLocaleMonthsShort =
		            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
		        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
		        defaultMonthsShortRegex = matchWord,
		        defaultMonthsRegex = matchWord;

		    function localeMonths(m, format) {
		        if (!m) {
		            return isArray(this._months)
		                ? this._months
		                : this._months['standalone'];
		        }
		        return isArray(this._months)
		            ? this._months[m.month()]
		            : this._months[
		                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
		                      ? 'format'
		                      : 'standalone'
		              ][m.month()];
		    }

		    function localeMonthsShort(m, format) {
		        if (!m) {
		            return isArray(this._monthsShort)
		                ? this._monthsShort
		                : this._monthsShort['standalone'];
		        }
		        return isArray(this._monthsShort)
		            ? this._monthsShort[m.month()]
		            : this._monthsShort[
		                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
		              ][m.month()];
		    }

		    function handleStrictParse(monthName, format, strict) {
		        var i,
		            ii,
		            mom,
		            llc = monthName.toLocaleLowerCase();
		        if (!this._monthsParse) {
		            // this is not used
		            this._monthsParse = [];
		            this._longMonthsParse = [];
		            this._shortMonthsParse = [];
		            for (i = 0; i < 12; ++i) {
		                mom = createUTC([2000, i]);
		                this._shortMonthsParse[i] = this.monthsShort(
		                    mom,
		                    ''
		                ).toLocaleLowerCase();
		                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
		            }
		        }

		        if (strict) {
		            if (format === 'MMM') {
		                ii = indexOf.call(this._shortMonthsParse, llc);
		                return ii !== -1 ? ii : null;
		            } else {
		                ii = indexOf.call(this._longMonthsParse, llc);
		                return ii !== -1 ? ii : null;
		            }
		        } else {
		            if (format === 'MMM') {
		                ii = indexOf.call(this._shortMonthsParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._longMonthsParse, llc);
		                return ii !== -1 ? ii : null;
		            } else {
		                ii = indexOf.call(this._longMonthsParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._shortMonthsParse, llc);
		                return ii !== -1 ? ii : null;
		            }
		        }
		    }

		    function localeMonthsParse(monthName, format, strict) {
		        var i, mom, regex;

		        if (this._monthsParseExact) {
		            return handleStrictParse.call(this, monthName, format, strict);
		        }

		        if (!this._monthsParse) {
		            this._monthsParse = [];
		            this._longMonthsParse = [];
		            this._shortMonthsParse = [];
		        }

		        // TODO: add sorting
		        // Sorting makes sure if one month (or abbr) is a prefix of another
		        // see sorting in computeMonthsParse
		        for (i = 0; i < 12; i++) {
		            // make the regex if we don't have it already
		            mom = createUTC([2000, i]);
		            if (strict && !this._longMonthsParse[i]) {
		                this._longMonthsParse[i] = new RegExp(
		                    '^' + this.months(mom, '').replace('.', '') + '$',
		                    'i'
		                );
		                this._shortMonthsParse[i] = new RegExp(
		                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
		                    'i'
		                );
		            }
		            if (!strict && !this._monthsParse[i]) {
		                regex =
		                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
		                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
		            }
		            // test the regex
		            if (
		                strict &&
		                format === 'MMMM' &&
		                this._longMonthsParse[i].test(monthName)
		            ) {
		                return i;
		            } else if (
		                strict &&
		                format === 'MMM' &&
		                this._shortMonthsParse[i].test(monthName)
		            ) {
		                return i;
		            } else if (!strict && this._monthsParse[i].test(monthName)) {
		                return i;
		            }
		        }
		    }

		    // MOMENTS

		    function setMonth(mom, value) {
		        var dayOfMonth;

		        if (!mom.isValid()) {
		            // No op
		            return mom;
		        }

		        if (typeof value === 'string') {
		            if (/^\d+$/.test(value)) {
		                value = toInt(value);
		            } else {
		                value = mom.localeData().monthsParse(value);
		                // TODO: Another silent failure?
		                if (!isNumber(value)) {
		                    return mom;
		                }
		            }
		        }

		        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
		        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
		        return mom;
		    }

		    function getSetMonth(value) {
		        if (value != null) {
		            setMonth(this, value);
		            hooks.updateOffset(this, true);
		            return this;
		        } else {
		            return get(this, 'Month');
		        }
		    }

		    function getDaysInMonth() {
		        return daysInMonth(this.year(), this.month());
		    }

		    function monthsShortRegex(isStrict) {
		        if (this._monthsParseExact) {
		            if (!hasOwnProp(this, '_monthsRegex')) {
		                computeMonthsParse.call(this);
		            }
		            if (isStrict) {
		                return this._monthsShortStrictRegex;
		            } else {
		                return this._monthsShortRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_monthsShortRegex')) {
		                this._monthsShortRegex = defaultMonthsShortRegex;
		            }
		            return this._monthsShortStrictRegex && isStrict
		                ? this._monthsShortStrictRegex
		                : this._monthsShortRegex;
		        }
		    }

		    function monthsRegex(isStrict) {
		        if (this._monthsParseExact) {
		            if (!hasOwnProp(this, '_monthsRegex')) {
		                computeMonthsParse.call(this);
		            }
		            if (isStrict) {
		                return this._monthsStrictRegex;
		            } else {
		                return this._monthsRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_monthsRegex')) {
		                this._monthsRegex = defaultMonthsRegex;
		            }
		            return this._monthsStrictRegex && isStrict
		                ? this._monthsStrictRegex
		                : this._monthsRegex;
		        }
		    }

		    function computeMonthsParse() {
		        function cmpLenRev(a, b) {
		            return b.length - a.length;
		        }

		        var shortPieces = [],
		            longPieces = [],
		            mixedPieces = [],
		            i,
		            mom;
		        for (i = 0; i < 12; i++) {
		            // make the regex if we don't have it already
		            mom = createUTC([2000, i]);
		            shortPieces.push(this.monthsShort(mom, ''));
		            longPieces.push(this.months(mom, ''));
		            mixedPieces.push(this.months(mom, ''));
		            mixedPieces.push(this.monthsShort(mom, ''));
		        }
		        // Sorting makes sure if one month (or abbr) is a prefix of another it
		        // will match the longer piece.
		        shortPieces.sort(cmpLenRev);
		        longPieces.sort(cmpLenRev);
		        mixedPieces.sort(cmpLenRev);
		        for (i = 0; i < 12; i++) {
		            shortPieces[i] = regexEscape(shortPieces[i]);
		            longPieces[i] = regexEscape(longPieces[i]);
		        }
		        for (i = 0; i < 24; i++) {
		            mixedPieces[i] = regexEscape(mixedPieces[i]);
		        }

		        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
		        this._monthsShortRegex = this._monthsRegex;
		        this._monthsStrictRegex = new RegExp(
		            '^(' + longPieces.join('|') + ')',
		            'i'
		        );
		        this._monthsShortStrictRegex = new RegExp(
		            '^(' + shortPieces.join('|') + ')',
		            'i'
		        );
		    }

		    // FORMATTING

		    addFormatToken('Y', 0, 0, function () {
		        var y = this.year();
		        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
		    });

		    addFormatToken(0, ['YY', 2], 0, function () {
		        return this.year() % 100;
		    });

		    addFormatToken(0, ['YYYY', 4], 0, 'year');
		    addFormatToken(0, ['YYYYY', 5], 0, 'year');
		    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

		    // ALIASES

		    addUnitAlias('year', 'y');

		    // PRIORITIES

		    addUnitPriority('year', 1);

		    // PARSING

		    addRegexToken('Y', matchSigned);
		    addRegexToken('YY', match1to2, match2);
		    addRegexToken('YYYY', match1to4, match4);
		    addRegexToken('YYYYY', match1to6, match6);
		    addRegexToken('YYYYYY', match1to6, match6);

		    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
		    addParseToken('YYYY', function (input, array) {
		        array[YEAR] =
		            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
		    });
		    addParseToken('YY', function (input, array) {
		        array[YEAR] = hooks.parseTwoDigitYear(input);
		    });
		    addParseToken('Y', function (input, array) {
		        array[YEAR] = parseInt(input, 10);
		    });

		    // HELPERS

		    function daysInYear(year) {
		        return isLeapYear(year) ? 366 : 365;
		    }

		    // HOOKS

		    hooks.parseTwoDigitYear = function (input) {
		        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
		    };

		    // MOMENTS

		    var getSetYear = makeGetSet('FullYear', true);

		    function getIsLeapYear() {
		        return isLeapYear(this.year());
		    }

		    function createDate(y, m, d, h, M, s, ms) {
		        // can't just apply() to create a date:
		        // https://stackoverflow.com/q/181348
		        var date;
		        // the date constructor remaps years 0-99 to 1900-1999
		        if (y < 100 && y >= 0) {
		            // preserve leap years using a full 400 year cycle, then reset
		            date = new Date(y + 400, m, d, h, M, s, ms);
		            if (isFinite(date.getFullYear())) {
		                date.setFullYear(y);
		            }
		        } else {
		            date = new Date(y, m, d, h, M, s, ms);
		        }

		        return date;
		    }

		    function createUTCDate(y) {
		        var date, args;
		        // the Date.UTC function remaps years 0-99 to 1900-1999
		        if (y < 100 && y >= 0) {
		            args = Array.prototype.slice.call(arguments);
		            // preserve leap years using a full 400 year cycle, then reset
		            args[0] = y + 400;
		            date = new Date(Date.UTC.apply(null, args));
		            if (isFinite(date.getUTCFullYear())) {
		                date.setUTCFullYear(y);
		            }
		        } else {
		            date = new Date(Date.UTC.apply(null, arguments));
		        }

		        return date;
		    }

		    // start-of-first-week - start-of-year
		    function firstWeekOffset(year, dow, doy) {
		        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
		            fwd = 7 + dow - doy,
		            // first-week day local weekday -- which local weekday is fwd
		            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

		        return -fwdlw + fwd - 1;
		    }

		    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
		    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
		        var localWeekday = (7 + weekday - dow) % 7,
		            weekOffset = firstWeekOffset(year, dow, doy),
		            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
		            resYear,
		            resDayOfYear;

		        if (dayOfYear <= 0) {
		            resYear = year - 1;
		            resDayOfYear = daysInYear(resYear) + dayOfYear;
		        } else if (dayOfYear > daysInYear(year)) {
		            resYear = year + 1;
		            resDayOfYear = dayOfYear - daysInYear(year);
		        } else {
		            resYear = year;
		            resDayOfYear = dayOfYear;
		        }

		        return {
		            year: resYear,
		            dayOfYear: resDayOfYear,
		        };
		    }

		    function weekOfYear(mom, dow, doy) {
		        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
		            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
		            resWeek,
		            resYear;

		        if (week < 1) {
		            resYear = mom.year() - 1;
		            resWeek = week + weeksInYear(resYear, dow, doy);
		        } else if (week > weeksInYear(mom.year(), dow, doy)) {
		            resWeek = week - weeksInYear(mom.year(), dow, doy);
		            resYear = mom.year() + 1;
		        } else {
		            resYear = mom.year();
		            resWeek = week;
		        }

		        return {
		            week: resWeek,
		            year: resYear,
		        };
		    }

		    function weeksInYear(year, dow, doy) {
		        var weekOffset = firstWeekOffset(year, dow, doy),
		            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
		        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
		    }

		    // FORMATTING

		    addFormatToken('w', ['ww', 2], 'wo', 'week');
		    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

		    // ALIASES

		    addUnitAlias('week', 'w');
		    addUnitAlias('isoWeek', 'W');

		    // PRIORITIES

		    addUnitPriority('week', 5);
		    addUnitPriority('isoWeek', 5);

		    // PARSING

		    addRegexToken('w', match1to2);
		    addRegexToken('ww', match1to2, match2);
		    addRegexToken('W', match1to2);
		    addRegexToken('WW', match1to2, match2);

		    addWeekParseToken(
		        ['w', 'ww', 'W', 'WW'],
		        function (input, week, config, token) {
		            week[token.substr(0, 1)] = toInt(input);
		        }
		    );

		    // HELPERS

		    // LOCALES

		    function localeWeek(mom) {
		        return weekOfYear(mom, this._week.dow, this._week.doy).week;
		    }

		    var defaultLocaleWeek = {
		        dow: 0, // Sunday is the first day of the week.
		        doy: 6, // The week that contains Jan 6th is the first week of the year.
		    };

		    function localeFirstDayOfWeek() {
		        return this._week.dow;
		    }

		    function localeFirstDayOfYear() {
		        return this._week.doy;
		    }

		    // MOMENTS

		    function getSetWeek(input) {
		        var week = this.localeData().week(this);
		        return input == null ? week : this.add((input - week) * 7, 'd');
		    }

		    function getSetISOWeek(input) {
		        var week = weekOfYear(this, 1, 4).week;
		        return input == null ? week : this.add((input - week) * 7, 'd');
		    }

		    // FORMATTING

		    addFormatToken('d', 0, 'do', 'day');

		    addFormatToken('dd', 0, 0, function (format) {
		        return this.localeData().weekdaysMin(this, format);
		    });

		    addFormatToken('ddd', 0, 0, function (format) {
		        return this.localeData().weekdaysShort(this, format);
		    });

		    addFormatToken('dddd', 0, 0, function (format) {
		        return this.localeData().weekdays(this, format);
		    });

		    addFormatToken('e', 0, 0, 'weekday');
		    addFormatToken('E', 0, 0, 'isoWeekday');

		    // ALIASES

		    addUnitAlias('day', 'd');
		    addUnitAlias('weekday', 'e');
		    addUnitAlias('isoWeekday', 'E');

		    // PRIORITY
		    addUnitPriority('day', 11);
		    addUnitPriority('weekday', 11);
		    addUnitPriority('isoWeekday', 11);

		    // PARSING

		    addRegexToken('d', match1to2);
		    addRegexToken('e', match1to2);
		    addRegexToken('E', match1to2);
		    addRegexToken('dd', function (isStrict, locale) {
		        return locale.weekdaysMinRegex(isStrict);
		    });
		    addRegexToken('ddd', function (isStrict, locale) {
		        return locale.weekdaysShortRegex(isStrict);
		    });
		    addRegexToken('dddd', function (isStrict, locale) {
		        return locale.weekdaysRegex(isStrict);
		    });

		    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
		        var weekday = config._locale.weekdaysParse(input, token, config._strict);
		        // if we didn't get a weekday name, mark the date as invalid
		        if (weekday != null) {
		            week.d = weekday;
		        } else {
		            getParsingFlags(config).invalidWeekday = input;
		        }
		    });

		    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
		        week[token] = toInt(input);
		    });

		    // HELPERS

		    function parseWeekday(input, locale) {
		        if (typeof input !== 'string') {
		            return input;
		        }

		        if (!isNaN(input)) {
		            return parseInt(input, 10);
		        }

		        input = locale.weekdaysParse(input);
		        if (typeof input === 'number') {
		            return input;
		        }

		        return null;
		    }

		    function parseIsoWeekday(input, locale) {
		        if (typeof input === 'string') {
		            return locale.weekdaysParse(input) % 7 || 7;
		        }
		        return isNaN(input) ? null : input;
		    }

		    // LOCALES
		    function shiftWeekdays(ws, n) {
		        return ws.slice(n, 7).concat(ws.slice(0, n));
		    }

		    var defaultLocaleWeekdays =
		            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
		        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
		        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
		        defaultWeekdaysRegex = matchWord,
		        defaultWeekdaysShortRegex = matchWord,
		        defaultWeekdaysMinRegex = matchWord;

		    function localeWeekdays(m, format) {
		        var weekdays = isArray(this._weekdays)
		            ? this._weekdays
		            : this._weekdays[
		                  m && m !== true && this._weekdays.isFormat.test(format)
		                      ? 'format'
		                      : 'standalone'
		              ];
		        return m === true
		            ? shiftWeekdays(weekdays, this._week.dow)
		            : m
		            ? weekdays[m.day()]
		            : weekdays;
		    }

		    function localeWeekdaysShort(m) {
		        return m === true
		            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
		            : m
		            ? this._weekdaysShort[m.day()]
		            : this._weekdaysShort;
		    }

		    function localeWeekdaysMin(m) {
		        return m === true
		            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
		            : m
		            ? this._weekdaysMin[m.day()]
		            : this._weekdaysMin;
		    }

		    function handleStrictParse$1(weekdayName, format, strict) {
		        var i,
		            ii,
		            mom,
		            llc = weekdayName.toLocaleLowerCase();
		        if (!this._weekdaysParse) {
		            this._weekdaysParse = [];
		            this._shortWeekdaysParse = [];
		            this._minWeekdaysParse = [];

		            for (i = 0; i < 7; ++i) {
		                mom = createUTC([2000, 1]).day(i);
		                this._minWeekdaysParse[i] = this.weekdaysMin(
		                    mom,
		                    ''
		                ).toLocaleLowerCase();
		                this._shortWeekdaysParse[i] = this.weekdaysShort(
		                    mom,
		                    ''
		                ).toLocaleLowerCase();
		                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
		            }
		        }

		        if (strict) {
		            if (format === 'dddd') {
		                ii = indexOf.call(this._weekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            } else if (format === 'ddd') {
		                ii = indexOf.call(this._shortWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            } else {
		                ii = indexOf.call(this._minWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            }
		        } else {
		            if (format === 'dddd') {
		                ii = indexOf.call(this._weekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._shortWeekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._minWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            } else if (format === 'ddd') {
		                ii = indexOf.call(this._shortWeekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._weekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._minWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            } else {
		                ii = indexOf.call(this._minWeekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._weekdaysParse, llc);
		                if (ii !== -1) {
		                    return ii;
		                }
		                ii = indexOf.call(this._shortWeekdaysParse, llc);
		                return ii !== -1 ? ii : null;
		            }
		        }
		    }

		    function localeWeekdaysParse(weekdayName, format, strict) {
		        var i, mom, regex;

		        if (this._weekdaysParseExact) {
		            return handleStrictParse$1.call(this, weekdayName, format, strict);
		        }

		        if (!this._weekdaysParse) {
		            this._weekdaysParse = [];
		            this._minWeekdaysParse = [];
		            this._shortWeekdaysParse = [];
		            this._fullWeekdaysParse = [];
		        }

		        for (i = 0; i < 7; i++) {
		            // make the regex if we don't have it already

		            mom = createUTC([2000, 1]).day(i);
		            if (strict && !this._fullWeekdaysParse[i]) {
		                this._fullWeekdaysParse[i] = new RegExp(
		                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
		                    'i'
		                );
		                this._shortWeekdaysParse[i] = new RegExp(
		                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
		                    'i'
		                );
		                this._minWeekdaysParse[i] = new RegExp(
		                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
		                    'i'
		                );
		            }
		            if (!this._weekdaysParse[i]) {
		                regex =
		                    '^' +
		                    this.weekdays(mom, '') +
		                    '|^' +
		                    this.weekdaysShort(mom, '') +
		                    '|^' +
		                    this.weekdaysMin(mom, '');
		                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
		            }
		            // test the regex
		            if (
		                strict &&
		                format === 'dddd' &&
		                this._fullWeekdaysParse[i].test(weekdayName)
		            ) {
		                return i;
		            } else if (
		                strict &&
		                format === 'ddd' &&
		                this._shortWeekdaysParse[i].test(weekdayName)
		            ) {
		                return i;
		            } else if (
		                strict &&
		                format === 'dd' &&
		                this._minWeekdaysParse[i].test(weekdayName)
		            ) {
		                return i;
		            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
		                return i;
		            }
		        }
		    }

		    // MOMENTS

		    function getSetDayOfWeek(input) {
		        if (!this.isValid()) {
		            return input != null ? this : NaN;
		        }
		        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
		        if (input != null) {
		            input = parseWeekday(input, this.localeData());
		            return this.add(input - day, 'd');
		        } else {
		            return day;
		        }
		    }

		    function getSetLocaleDayOfWeek(input) {
		        if (!this.isValid()) {
		            return input != null ? this : NaN;
		        }
		        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
		        return input == null ? weekday : this.add(input - weekday, 'd');
		    }

		    function getSetISODayOfWeek(input) {
		        if (!this.isValid()) {
		            return input != null ? this : NaN;
		        }

		        // behaves the same as moment#day except
		        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
		        // as a setter, sunday should belong to the previous week.

		        if (input != null) {
		            var weekday = parseIsoWeekday(input, this.localeData());
		            return this.day(this.day() % 7 ? weekday : weekday - 7);
		        } else {
		            return this.day() || 7;
		        }
		    }

		    function weekdaysRegex(isStrict) {
		        if (this._weekdaysParseExact) {
		            if (!hasOwnProp(this, '_weekdaysRegex')) {
		                computeWeekdaysParse.call(this);
		            }
		            if (isStrict) {
		                return this._weekdaysStrictRegex;
		            } else {
		                return this._weekdaysRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_weekdaysRegex')) {
		                this._weekdaysRegex = defaultWeekdaysRegex;
		            }
		            return this._weekdaysStrictRegex && isStrict
		                ? this._weekdaysStrictRegex
		                : this._weekdaysRegex;
		        }
		    }

		    function weekdaysShortRegex(isStrict) {
		        if (this._weekdaysParseExact) {
		            if (!hasOwnProp(this, '_weekdaysRegex')) {
		                computeWeekdaysParse.call(this);
		            }
		            if (isStrict) {
		                return this._weekdaysShortStrictRegex;
		            } else {
		                return this._weekdaysShortRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
		                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
		            }
		            return this._weekdaysShortStrictRegex && isStrict
		                ? this._weekdaysShortStrictRegex
		                : this._weekdaysShortRegex;
		        }
		    }

		    function weekdaysMinRegex(isStrict) {
		        if (this._weekdaysParseExact) {
		            if (!hasOwnProp(this, '_weekdaysRegex')) {
		                computeWeekdaysParse.call(this);
		            }
		            if (isStrict) {
		                return this._weekdaysMinStrictRegex;
		            } else {
		                return this._weekdaysMinRegex;
		            }
		        } else {
		            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
		                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
		            }
		            return this._weekdaysMinStrictRegex && isStrict
		                ? this._weekdaysMinStrictRegex
		                : this._weekdaysMinRegex;
		        }
		    }

		    function computeWeekdaysParse() {
		        function cmpLenRev(a, b) {
		            return b.length - a.length;
		        }

		        var minPieces = [],
		            shortPieces = [],
		            longPieces = [],
		            mixedPieces = [],
		            i,
		            mom,
		            minp,
		            shortp,
		            longp;
		        for (i = 0; i < 7; i++) {
		            // make the regex if we don't have it already
		            mom = createUTC([2000, 1]).day(i);
		            minp = regexEscape(this.weekdaysMin(mom, ''));
		            shortp = regexEscape(this.weekdaysShort(mom, ''));
		            longp = regexEscape(this.weekdays(mom, ''));
		            minPieces.push(minp);
		            shortPieces.push(shortp);
		            longPieces.push(longp);
		            mixedPieces.push(minp);
		            mixedPieces.push(shortp);
		            mixedPieces.push(longp);
		        }
		        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
		        // will match the longer piece.
		        minPieces.sort(cmpLenRev);
		        shortPieces.sort(cmpLenRev);
		        longPieces.sort(cmpLenRev);
		        mixedPieces.sort(cmpLenRev);

		        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
		        this._weekdaysShortRegex = this._weekdaysRegex;
		        this._weekdaysMinRegex = this._weekdaysRegex;

		        this._weekdaysStrictRegex = new RegExp(
		            '^(' + longPieces.join('|') + ')',
		            'i'
		        );
		        this._weekdaysShortStrictRegex = new RegExp(
		            '^(' + shortPieces.join('|') + ')',
		            'i'
		        );
		        this._weekdaysMinStrictRegex = new RegExp(
		            '^(' + minPieces.join('|') + ')',
		            'i'
		        );
		    }

		    // FORMATTING

		    function hFormat() {
		        return this.hours() % 12 || 12;
		    }

		    function kFormat() {
		        return this.hours() || 24;
		    }

		    addFormatToken('H', ['HH', 2], 0, 'hour');
		    addFormatToken('h', ['hh', 2], 0, hFormat);
		    addFormatToken('k', ['kk', 2], 0, kFormat);

		    addFormatToken('hmm', 0, 0, function () {
		        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
		    });

		    addFormatToken('hmmss', 0, 0, function () {
		        return (
		            '' +
		            hFormat.apply(this) +
		            zeroFill(this.minutes(), 2) +
		            zeroFill(this.seconds(), 2)
		        );
		    });

		    addFormatToken('Hmm', 0, 0, function () {
		        return '' + this.hours() + zeroFill(this.minutes(), 2);
		    });

		    addFormatToken('Hmmss', 0, 0, function () {
		        return (
		            '' +
		            this.hours() +
		            zeroFill(this.minutes(), 2) +
		            zeroFill(this.seconds(), 2)
		        );
		    });

		    function meridiem(token, lowercase) {
		        addFormatToken(token, 0, 0, function () {
		            return this.localeData().meridiem(
		                this.hours(),
		                this.minutes(),
		                lowercase
		            );
		        });
		    }

		    meridiem('a', true);
		    meridiem('A', false);

		    // ALIASES

		    addUnitAlias('hour', 'h');

		    // PRIORITY
		    addUnitPriority('hour', 13);

		    // PARSING

		    function matchMeridiem(isStrict, locale) {
		        return locale._meridiemParse;
		    }

		    addRegexToken('a', matchMeridiem);
		    addRegexToken('A', matchMeridiem);
		    addRegexToken('H', match1to2);
		    addRegexToken('h', match1to2);
		    addRegexToken('k', match1to2);
		    addRegexToken('HH', match1to2, match2);
		    addRegexToken('hh', match1to2, match2);
		    addRegexToken('kk', match1to2, match2);

		    addRegexToken('hmm', match3to4);
		    addRegexToken('hmmss', match5to6);
		    addRegexToken('Hmm', match3to4);
		    addRegexToken('Hmmss', match5to6);

		    addParseToken(['H', 'HH'], HOUR);
		    addParseToken(['k', 'kk'], function (input, array, config) {
		        var kInput = toInt(input);
		        array[HOUR] = kInput === 24 ? 0 : kInput;
		    });
		    addParseToken(['a', 'A'], function (input, array, config) {
		        config._isPm = config._locale.isPM(input);
		        config._meridiem = input;
		    });
		    addParseToken(['h', 'hh'], function (input, array, config) {
		        array[HOUR] = toInt(input);
		        getParsingFlags(config).bigHour = true;
		    });
		    addParseToken('hmm', function (input, array, config) {
		        var pos = input.length - 2;
		        array[HOUR] = toInt(input.substr(0, pos));
		        array[MINUTE] = toInt(input.substr(pos));
		        getParsingFlags(config).bigHour = true;
		    });
		    addParseToken('hmmss', function (input, array, config) {
		        var pos1 = input.length - 4,
		            pos2 = input.length - 2;
		        array[HOUR] = toInt(input.substr(0, pos1));
		        array[MINUTE] = toInt(input.substr(pos1, 2));
		        array[SECOND] = toInt(input.substr(pos2));
		        getParsingFlags(config).bigHour = true;
		    });
		    addParseToken('Hmm', function (input, array, config) {
		        var pos = input.length - 2;
		        array[HOUR] = toInt(input.substr(0, pos));
		        array[MINUTE] = toInt(input.substr(pos));
		    });
		    addParseToken('Hmmss', function (input, array, config) {
		        var pos1 = input.length - 4,
		            pos2 = input.length - 2;
		        array[HOUR] = toInt(input.substr(0, pos1));
		        array[MINUTE] = toInt(input.substr(pos1, 2));
		        array[SECOND] = toInt(input.substr(pos2));
		    });

		    // LOCALES

		    function localeIsPM(input) {
		        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
		        // Using charAt should be more compatible.
		        return (input + '').toLowerCase().charAt(0) === 'p';
		    }

		    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
		        // Setting the hour should keep the time, because the user explicitly
		        // specified which hour they want. So trying to maintain the same hour (in
		        // a new timezone) makes sense. Adding/subtracting hours does not follow
		        // this rule.
		        getSetHour = makeGetSet('Hours', true);

		    function localeMeridiem(hours, minutes, isLower) {
		        if (hours > 11) {
		            return isLower ? 'pm' : 'PM';
		        } else {
		            return isLower ? 'am' : 'AM';
		        }
		    }

		    var baseConfig = {
		        calendar: defaultCalendar,
		        longDateFormat: defaultLongDateFormat,
		        invalidDate: defaultInvalidDate,
		        ordinal: defaultOrdinal,
		        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
		        relativeTime: defaultRelativeTime,

		        months: defaultLocaleMonths,
		        monthsShort: defaultLocaleMonthsShort,

		        week: defaultLocaleWeek,

		        weekdays: defaultLocaleWeekdays,
		        weekdaysMin: defaultLocaleWeekdaysMin,
		        weekdaysShort: defaultLocaleWeekdaysShort,

		        meridiemParse: defaultLocaleMeridiemParse,
		    };

		    // internal storage for locale config files
		    var locales = {},
		        localeFamilies = {},
		        globalLocale;

		    function commonPrefix(arr1, arr2) {
		        var i,
		            minl = Math.min(arr1.length, arr2.length);
		        for (i = 0; i < minl; i += 1) {
		            if (arr1[i] !== arr2[i]) {
		                return i;
		            }
		        }
		        return minl;
		    }

		    function normalizeLocale(key) {
		        return key ? key.toLowerCase().replace('_', '-') : key;
		    }

		    // pick the locale from the array
		    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
		    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
		    function chooseLocale(names) {
		        var i = 0,
		            j,
		            next,
		            locale,
		            split;

		        while (i < names.length) {
		            split = normalizeLocale(names[i]).split('-');
		            j = split.length;
		            next = normalizeLocale(names[i + 1]);
		            next = next ? next.split('-') : null;
		            while (j > 0) {
		                locale = loadLocale(split.slice(0, j).join('-'));
		                if (locale) {
		                    return locale;
		                }
		                if (
		                    next &&
		                    next.length >= j &&
		                    commonPrefix(split, next) >= j - 1
		                ) {
		                    //the next array item is better than a shallower substring of this one
		                    break;
		                }
		                j--;
		            }
		            i++;
		        }
		        return globalLocale;
		    }

		    function isLocaleNameSane(name) {
		        // Prevent names that look like filesystem paths, i.e contain '/' or '\'
		        return name.match('^[^/\\\\]*$') != null;
		    }

		    function loadLocale(name) {
		        var oldLocale = null,
		            aliasedRequire;
		        // TODO: Find a better way to register and load all the locales in Node
		        if (
		            locales[name] === undefined &&
		            'object' !== 'undefined' &&
		            module &&
		            module.exports &&
		            isLocaleNameSane(name)
		        ) {
		            try {
		                oldLocale = globalLocale._abbr;
		                aliasedRequire = commonjsRequire;
		                aliasedRequire('./locale/' + name);
		                getSetGlobalLocale(oldLocale);
		            } catch (e) {
		                // mark as not found to avoid repeating expensive file require call causing high CPU
		                // when trying to find en-US, en_US, en-us for every format call
		                locales[name] = null; // null means not found
		            }
		        }
		        return locales[name];
		    }

		    // This function will load locale and then set the global locale.  If
		    // no arguments are passed in, it will simply return the current global
		    // locale key.
		    function getSetGlobalLocale(key, values) {
		        var data;
		        if (key) {
		            if (isUndefined(values)) {
		                data = getLocale(key);
		            } else {
		                data = defineLocale(key, values);
		            }

		            if (data) {
		                // moment.duration._locale = moment._locale = data;
		                globalLocale = data;
		            } else {
		                if (typeof console !== 'undefined' && console.warn) {
		                    //warn user if arguments are passed but the locale could not be set
		                    console.warn(
		                        'Locale ' + key + ' not found. Did you forget to load it?'
		                    );
		                }
		            }
		        }

		        return globalLocale._abbr;
		    }

		    function defineLocale(name, config) {
		        if (config !== null) {
		            var locale,
		                parentConfig = baseConfig;
		            config.abbr = name;
		            if (locales[name] != null) {
		                deprecateSimple(
		                    'defineLocaleOverride',
		                    'use moment.updateLocale(localeName, config) to change ' +
		                        'an existing locale. moment.defineLocale(localeName, ' +
		                        'config) should only be used for creating a new locale ' +
		                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
		                );
		                parentConfig = locales[name]._config;
		            } else if (config.parentLocale != null) {
		                if (locales[config.parentLocale] != null) {
		                    parentConfig = locales[config.parentLocale]._config;
		                } else {
		                    locale = loadLocale(config.parentLocale);
		                    if (locale != null) {
		                        parentConfig = locale._config;
		                    } else {
		                        if (!localeFamilies[config.parentLocale]) {
		                            localeFamilies[config.parentLocale] = [];
		                        }
		                        localeFamilies[config.parentLocale].push({
		                            name: name,
		                            config: config,
		                        });
		                        return null;
		                    }
		                }
		            }
		            locales[name] = new Locale(mergeConfigs(parentConfig, config));

		            if (localeFamilies[name]) {
		                localeFamilies[name].forEach(function (x) {
		                    defineLocale(x.name, x.config);
		                });
		            }

		            // backwards compat for now: also set the locale
		            // make sure we set the locale AFTER all child locales have been
		            // created, so we won't end up with the child locale set.
		            getSetGlobalLocale(name);

		            return locales[name];
		        } else {
		            // useful for testing
		            delete locales[name];
		            return null;
		        }
		    }

		    function updateLocale(name, config) {
		        if (config != null) {
		            var locale,
		                tmpLocale,
		                parentConfig = baseConfig;

		            if (locales[name] != null && locales[name].parentLocale != null) {
		                // Update existing child locale in-place to avoid memory-leaks
		                locales[name].set(mergeConfigs(locales[name]._config, config));
		            } else {
		                // MERGE
		                tmpLocale = loadLocale(name);
		                if (tmpLocale != null) {
		                    parentConfig = tmpLocale._config;
		                }
		                config = mergeConfigs(parentConfig, config);
		                if (tmpLocale == null) {
		                    // updateLocale is called for creating a new locale
		                    // Set abbr so it will have a name (getters return
		                    // undefined otherwise).
		                    config.abbr = name;
		                }
		                locale = new Locale(config);
		                locale.parentLocale = locales[name];
		                locales[name] = locale;
		            }

		            // backwards compat for now: also set the locale
		            getSetGlobalLocale(name);
		        } else {
		            // pass null for config to unupdate, useful for tests
		            if (locales[name] != null) {
		                if (locales[name].parentLocale != null) {
		                    locales[name] = locales[name].parentLocale;
		                    if (name === getSetGlobalLocale()) {
		                        getSetGlobalLocale(name);
		                    }
		                } else if (locales[name] != null) {
		                    delete locales[name];
		                }
		            }
		        }
		        return locales[name];
		    }

		    // returns locale data
		    function getLocale(key) {
		        var locale;

		        if (key && key._locale && key._locale._abbr) {
		            key = key._locale._abbr;
		        }

		        if (!key) {
		            return globalLocale;
		        }

		        if (!isArray(key)) {
		            //short-circuit everything else
		            locale = loadLocale(key);
		            if (locale) {
		                return locale;
		            }
		            key = [key];
		        }

		        return chooseLocale(key);
		    }

		    function listLocales() {
		        return keys(locales);
		    }

		    function checkOverflow(m) {
		        var overflow,
		            a = m._a;

		        if (a && getParsingFlags(m).overflow === -2) {
		            overflow =
		                a[MONTH] < 0 || a[MONTH] > 11
		                    ? MONTH
		                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
		                    ? DATE
		                    : a[HOUR] < 0 ||
		                      a[HOUR] > 24 ||
		                      (a[HOUR] === 24 &&
		                          (a[MINUTE] !== 0 ||
		                              a[SECOND] !== 0 ||
		                              a[MILLISECOND] !== 0))
		                    ? HOUR
		                    : a[MINUTE] < 0 || a[MINUTE] > 59
		                    ? MINUTE
		                    : a[SECOND] < 0 || a[SECOND] > 59
		                    ? SECOND
		                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
		                    ? MILLISECOND
		                    : -1;

		            if (
		                getParsingFlags(m)._overflowDayOfYear &&
		                (overflow < YEAR || overflow > DATE)
		            ) {
		                overflow = DATE;
		            }
		            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
		                overflow = WEEK;
		            }
		            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
		                overflow = WEEKDAY;
		            }

		            getParsingFlags(m).overflow = overflow;
		        }

		        return m;
		    }

		    // iso 8601 regex
		    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
		    var extendedIsoRegex =
		            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
		        basicIsoRegex =
		            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
		        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
		        isoDates = [
		            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
		            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
		            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
		            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
		            ['YYYY-DDD', /\d{4}-\d{3}/],
		            ['YYYY-MM', /\d{4}-\d\d/, false],
		            ['YYYYYYMMDD', /[+-]\d{10}/],
		            ['YYYYMMDD', /\d{8}/],
		            ['GGGG[W]WWE', /\d{4}W\d{3}/],
		            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
		            ['YYYYDDD', /\d{7}/],
		            ['YYYYMM', /\d{6}/, false],
		            ['YYYY', /\d{4}/, false],
		        ],
		        // iso time formats and regexes
		        isoTimes = [
		            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
		            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
		            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
		            ['HH:mm', /\d\d:\d\d/],
		            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
		            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
		            ['HHmmss', /\d\d\d\d\d\d/],
		            ['HHmm', /\d\d\d\d/],
		            ['HH', /\d\d/],
		        ],
		        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
		        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
		        rfc2822 =
		            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
		        obsOffsets = {
		            UT: 0,
		            GMT: 0,
		            EDT: -4 * 60,
		            EST: -5 * 60,
		            CDT: -5 * 60,
		            CST: -6 * 60,
		            MDT: -6 * 60,
		            MST: -7 * 60,
		            PDT: -7 * 60,
		            PST: -8 * 60,
		        };

		    // date from iso format
		    function configFromISO(config) {
		        var i,
		            l,
		            string = config._i,
		            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
		            allowTime,
		            dateFormat,
		            timeFormat,
		            tzFormat,
		            isoDatesLen = isoDates.length,
		            isoTimesLen = isoTimes.length;

		        if (match) {
		            getParsingFlags(config).iso = true;
		            for (i = 0, l = isoDatesLen; i < l; i++) {
		                if (isoDates[i][1].exec(match[1])) {
		                    dateFormat = isoDates[i][0];
		                    allowTime = isoDates[i][2] !== false;
		                    break;
		                }
		            }
		            if (dateFormat == null) {
		                config._isValid = false;
		                return;
		            }
		            if (match[3]) {
		                for (i = 0, l = isoTimesLen; i < l; i++) {
		                    if (isoTimes[i][1].exec(match[3])) {
		                        // match[2] should be 'T' or space
		                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
		                        break;
		                    }
		                }
		                if (timeFormat == null) {
		                    config._isValid = false;
		                    return;
		                }
		            }
		            if (!allowTime && timeFormat != null) {
		                config._isValid = false;
		                return;
		            }
		            if (match[4]) {
		                if (tzRegex.exec(match[4])) {
		                    tzFormat = 'Z';
		                } else {
		                    config._isValid = false;
		                    return;
		                }
		            }
		            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
		            configFromStringAndFormat(config);
		        } else {
		            config._isValid = false;
		        }
		    }

		    function extractFromRFC2822Strings(
		        yearStr,
		        monthStr,
		        dayStr,
		        hourStr,
		        minuteStr,
		        secondStr
		    ) {
		        var result = [
		            untruncateYear(yearStr),
		            defaultLocaleMonthsShort.indexOf(monthStr),
		            parseInt(dayStr, 10),
		            parseInt(hourStr, 10),
		            parseInt(minuteStr, 10),
		        ];

		        if (secondStr) {
		            result.push(parseInt(secondStr, 10));
		        }

		        return result;
		    }

		    function untruncateYear(yearStr) {
		        var year = parseInt(yearStr, 10);
		        if (year <= 49) {
		            return 2000 + year;
		        } else if (year <= 999) {
		            return 1900 + year;
		        }
		        return year;
		    }

		    function preprocessRFC2822(s) {
		        // Remove comments and folding whitespace and replace multiple-spaces with a single space
		        return s
		            .replace(/\([^()]*\)|[\n\t]/g, ' ')
		            .replace(/(\s\s+)/g, ' ')
		            .replace(/^\s\s*/, '')
		            .replace(/\s\s*$/, '');
		    }

		    function checkWeekday(weekdayStr, parsedInput, config) {
		        if (weekdayStr) {
		            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
		            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
		                weekdayActual = new Date(
		                    parsedInput[0],
		                    parsedInput[1],
		                    parsedInput[2]
		                ).getDay();
		            if (weekdayProvided !== weekdayActual) {
		                getParsingFlags(config).weekdayMismatch = true;
		                config._isValid = false;
		                return false;
		            }
		        }
		        return true;
		    }

		    function calculateOffset(obsOffset, militaryOffset, numOffset) {
		        if (obsOffset) {
		            return obsOffsets[obsOffset];
		        } else if (militaryOffset) {
		            // the only allowed military tz is Z
		            return 0;
		        } else {
		            var hm = parseInt(numOffset, 10),
		                m = hm % 100,
		                h = (hm - m) / 100;
		            return h * 60 + m;
		        }
		    }

		    // date and time from ref 2822 format
		    function configFromRFC2822(config) {
		        var match = rfc2822.exec(preprocessRFC2822(config._i)),
		            parsedArray;
		        if (match) {
		            parsedArray = extractFromRFC2822Strings(
		                match[4],
		                match[3],
		                match[2],
		                match[5],
		                match[6],
		                match[7]
		            );
		            if (!checkWeekday(match[1], parsedArray, config)) {
		                return;
		            }

		            config._a = parsedArray;
		            config._tzm = calculateOffset(match[8], match[9], match[10]);

		            config._d = createUTCDate.apply(null, config._a);
		            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

		            getParsingFlags(config).rfc2822 = true;
		        } else {
		            config._isValid = false;
		        }
		    }

		    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
		    function configFromString(config) {
		        var matched = aspNetJsonRegex.exec(config._i);
		        if (matched !== null) {
		            config._d = new Date(+matched[1]);
		            return;
		        }

		        configFromISO(config);
		        if (config._isValid === false) {
		            delete config._isValid;
		        } else {
		            return;
		        }

		        configFromRFC2822(config);
		        if (config._isValid === false) {
		            delete config._isValid;
		        } else {
		            return;
		        }

		        if (config._strict) {
		            config._isValid = false;
		        } else {
		            // Final attempt, use Input Fallback
		            hooks.createFromInputFallback(config);
		        }
		    }

		    hooks.createFromInputFallback = deprecate(
		        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
		            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
		            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
		        function (config) {
		            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
		        }
		    );

		    // Pick the first defined of two or three arguments.
		    function defaults(a, b, c) {
		        if (a != null) {
		            return a;
		        }
		        if (b != null) {
		            return b;
		        }
		        return c;
		    }

		    function currentDateArray(config) {
		        // hooks is actually the exported moment object
		        var nowValue = new Date(hooks.now());
		        if (config._useUTC) {
		            return [
		                nowValue.getUTCFullYear(),
		                nowValue.getUTCMonth(),
		                nowValue.getUTCDate(),
		            ];
		        }
		        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
		    }

		    // convert an array to a date.
		    // the array should mirror the parameters below
		    // note: all values past the year are optional and will default to the lowest possible value.
		    // [year, month, day , hour, minute, second, millisecond]
		    function configFromArray(config) {
		        var i,
		            date,
		            input = [],
		            currentDate,
		            expectedWeekday,
		            yearToUse;

		        if (config._d) {
		            return;
		        }

		        currentDate = currentDateArray(config);

		        //compute day of the year from weeks and weekdays
		        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
		            dayOfYearFromWeekInfo(config);
		        }

		        //if the day of the year is set, figure out what it is
		        if (config._dayOfYear != null) {
		            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

		            if (
		                config._dayOfYear > daysInYear(yearToUse) ||
		                config._dayOfYear === 0
		            ) {
		                getParsingFlags(config)._overflowDayOfYear = true;
		            }

		            date = createUTCDate(yearToUse, 0, config._dayOfYear);
		            config._a[MONTH] = date.getUTCMonth();
		            config._a[DATE] = date.getUTCDate();
		        }

		        // Default to current date.
		        // * if no year, month, day of month are given, default to today
		        // * if day of month is given, default month and year
		        // * if month is given, default only year
		        // * if year is given, don't default anything
		        for (i = 0; i < 3 && config._a[i] == null; ++i) {
		            config._a[i] = input[i] = currentDate[i];
		        }

		        // Zero out whatever was not defaulted, including time
		        for (; i < 7; i++) {
		            config._a[i] = input[i] =
		                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
		        }

		        // Check for 24:00:00.000
		        if (
		            config._a[HOUR] === 24 &&
		            config._a[MINUTE] === 0 &&
		            config._a[SECOND] === 0 &&
		            config._a[MILLISECOND] === 0
		        ) {
		            config._nextDay = true;
		            config._a[HOUR] = 0;
		        }

		        config._d = (config._useUTC ? createUTCDate : createDate).apply(
		            null,
		            input
		        );
		        expectedWeekday = config._useUTC
		            ? config._d.getUTCDay()
		            : config._d.getDay();

		        // Apply timezone offset from input. The actual utcOffset can be changed
		        // with parseZone.
		        if (config._tzm != null) {
		            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
		        }

		        if (config._nextDay) {
		            config._a[HOUR] = 24;
		        }

		        // check for mismatching day of week
		        if (
		            config._w &&
		            typeof config._w.d !== 'undefined' &&
		            config._w.d !== expectedWeekday
		        ) {
		            getParsingFlags(config).weekdayMismatch = true;
		        }
		    }

		    function dayOfYearFromWeekInfo(config) {
		        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

		        w = config._w;
		        if (w.GG != null || w.W != null || w.E != null) {
		            dow = 1;
		            doy = 4;

		            // TODO: We need to take the current isoWeekYear, but that depends on
		            // how we interpret now (local, utc, fixed offset). So create
		            // a now version of current config (take local/utc/offset flags, and
		            // create now).
		            weekYear = defaults(
		                w.GG,
		                config._a[YEAR],
		                weekOfYear(createLocal(), 1, 4).year
		            );
		            week = defaults(w.W, 1);
		            weekday = defaults(w.E, 1);
		            if (weekday < 1 || weekday > 7) {
		                weekdayOverflow = true;
		            }
		        } else {
		            dow = config._locale._week.dow;
		            doy = config._locale._week.doy;

		            curWeek = weekOfYear(createLocal(), dow, doy);

		            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

		            // Default to current week.
		            week = defaults(w.w, curWeek.week);

		            if (w.d != null) {
		                // weekday -- low day numbers are considered next week
		                weekday = w.d;
		                if (weekday < 0 || weekday > 6) {
		                    weekdayOverflow = true;
		                }
		            } else if (w.e != null) {
		                // local weekday -- counting starts from beginning of week
		                weekday = w.e + dow;
		                if (w.e < 0 || w.e > 6) {
		                    weekdayOverflow = true;
		                }
		            } else {
		                // default to beginning of week
		                weekday = dow;
		            }
		        }
		        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
		            getParsingFlags(config)._overflowWeeks = true;
		        } else if (weekdayOverflow != null) {
		            getParsingFlags(config)._overflowWeekday = true;
		        } else {
		            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
		            config._a[YEAR] = temp.year;
		            config._dayOfYear = temp.dayOfYear;
		        }
		    }

		    // constant that refers to the ISO standard
		    hooks.ISO_8601 = function () {};

		    // constant that refers to the RFC 2822 form
		    hooks.RFC_2822 = function () {};

		    // date from string and format string
		    function configFromStringAndFormat(config) {
		        // TODO: Move this to another part of the creation flow to prevent circular deps
		        if (config._f === hooks.ISO_8601) {
		            configFromISO(config);
		            return;
		        }
		        if (config._f === hooks.RFC_2822) {
		            configFromRFC2822(config);
		            return;
		        }
		        config._a = [];
		        getParsingFlags(config).empty = true;

		        // This array is used to make a Date, either with `new Date` or `Date.UTC`
		        var string = '' + config._i,
		            i,
		            parsedInput,
		            tokens,
		            token,
		            skipped,
		            stringLength = string.length,
		            totalParsedInputLength = 0,
		            era,
		            tokenLen;

		        tokens =
		            expandFormat(config._f, config._locale).match(formattingTokens) || [];
		        tokenLen = tokens.length;
		        for (i = 0; i < tokenLen; i++) {
		            token = tokens[i];
		            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
		                [])[0];
		            if (parsedInput) {
		                skipped = string.substr(0, string.indexOf(parsedInput));
		                if (skipped.length > 0) {
		                    getParsingFlags(config).unusedInput.push(skipped);
		                }
		                string = string.slice(
		                    string.indexOf(parsedInput) + parsedInput.length
		                );
		                totalParsedInputLength += parsedInput.length;
		            }
		            // don't parse if it's not a known token
		            if (formatTokenFunctions[token]) {
		                if (parsedInput) {
		                    getParsingFlags(config).empty = false;
		                } else {
		                    getParsingFlags(config).unusedTokens.push(token);
		                }
		                addTimeToArrayFromToken(token, parsedInput, config);
		            } else if (config._strict && !parsedInput) {
		                getParsingFlags(config).unusedTokens.push(token);
		            }
		        }

		        // add remaining unparsed input length to the string
		        getParsingFlags(config).charsLeftOver =
		            stringLength - totalParsedInputLength;
		        if (string.length > 0) {
		            getParsingFlags(config).unusedInput.push(string);
		        }

		        // clear _12h flag if hour is <= 12
		        if (
		            config._a[HOUR] <= 12 &&
		            getParsingFlags(config).bigHour === true &&
		            config._a[HOUR] > 0
		        ) {
		            getParsingFlags(config).bigHour = undefined;
		        }

		        getParsingFlags(config).parsedDateParts = config._a.slice(0);
		        getParsingFlags(config).meridiem = config._meridiem;
		        // handle meridiem
		        config._a[HOUR] = meridiemFixWrap(
		            config._locale,
		            config._a[HOUR],
		            config._meridiem
		        );

		        // handle era
		        era = getParsingFlags(config).era;
		        if (era !== null) {
		            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
		        }

		        configFromArray(config);
		        checkOverflow(config);
		    }

		    function meridiemFixWrap(locale, hour, meridiem) {
		        var isPm;

		        if (meridiem == null) {
		            // nothing to do
		            return hour;
		        }
		        if (locale.meridiemHour != null) {
		            return locale.meridiemHour(hour, meridiem);
		        } else if (locale.isPM != null) {
		            // Fallback
		            isPm = locale.isPM(meridiem);
		            if (isPm && hour < 12) {
		                hour += 12;
		            }
		            if (!isPm && hour === 12) {
		                hour = 0;
		            }
		            return hour;
		        } else {
		            // this is not supposed to happen
		            return hour;
		        }
		    }

		    // date from string and array of format strings
		    function configFromStringAndArray(config) {
		        var tempConfig,
		            bestMoment,
		            scoreToBeat,
		            i,
		            currentScore,
		            validFormatFound,
		            bestFormatIsValid = false,
		            configfLen = config._f.length;

		        if (configfLen === 0) {
		            getParsingFlags(config).invalidFormat = true;
		            config._d = new Date(NaN);
		            return;
		        }

		        for (i = 0; i < configfLen; i++) {
		            currentScore = 0;
		            validFormatFound = false;
		            tempConfig = copyConfig({}, config);
		            if (config._useUTC != null) {
		                tempConfig._useUTC = config._useUTC;
		            }
		            tempConfig._f = config._f[i];
		            configFromStringAndFormat(tempConfig);

		            if (isValid(tempConfig)) {
		                validFormatFound = true;
		            }

		            // if there is any input that was not parsed add a penalty for that format
		            currentScore += getParsingFlags(tempConfig).charsLeftOver;

		            //or tokens
		            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

		            getParsingFlags(tempConfig).score = currentScore;

		            if (!bestFormatIsValid) {
		                if (
		                    scoreToBeat == null ||
		                    currentScore < scoreToBeat ||
		                    validFormatFound
		                ) {
		                    scoreToBeat = currentScore;
		                    bestMoment = tempConfig;
		                    if (validFormatFound) {
		                        bestFormatIsValid = true;
		                    }
		                }
		            } else {
		                if (currentScore < scoreToBeat) {
		                    scoreToBeat = currentScore;
		                    bestMoment = tempConfig;
		                }
		            }
		        }

		        extend(config, bestMoment || tempConfig);
		    }

		    function configFromObject(config) {
		        if (config._d) {
		            return;
		        }

		        var i = normalizeObjectUnits(config._i),
		            dayOrDate = i.day === undefined ? i.date : i.day;
		        config._a = map(
		            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
		            function (obj) {
		                return obj && parseInt(obj, 10);
		            }
		        );

		        configFromArray(config);
		    }

		    function createFromConfig(config) {
		        var res = new Moment(checkOverflow(prepareConfig(config)));
		        if (res._nextDay) {
		            // Adding is smart enough around DST
		            res.add(1, 'd');
		            res._nextDay = undefined;
		        }

		        return res;
		    }

		    function prepareConfig(config) {
		        var input = config._i,
		            format = config._f;

		        config._locale = config._locale || getLocale(config._l);

		        if (input === null || (format === undefined && input === '')) {
		            return createInvalid({ nullInput: true });
		        }

		        if (typeof input === 'string') {
		            config._i = input = config._locale.preparse(input);
		        }

		        if (isMoment(input)) {
		            return new Moment(checkOverflow(input));
		        } else if (isDate(input)) {
		            config._d = input;
		        } else if (isArray(format)) {
		            configFromStringAndArray(config);
		        } else if (format) {
		            configFromStringAndFormat(config);
		        } else {
		            configFromInput(config);
		        }

		        if (!isValid(config)) {
		            config._d = null;
		        }

		        return config;
		    }

		    function configFromInput(config) {
		        var input = config._i;
		        if (isUndefined(input)) {
		            config._d = new Date(hooks.now());
		        } else if (isDate(input)) {
		            config._d = new Date(input.valueOf());
		        } else if (typeof input === 'string') {
		            configFromString(config);
		        } else if (isArray(input)) {
		            config._a = map(input.slice(0), function (obj) {
		                return parseInt(obj, 10);
		            });
		            configFromArray(config);
		        } else if (isObject(input)) {
		            configFromObject(config);
		        } else if (isNumber(input)) {
		            // from milliseconds
		            config._d = new Date(input);
		        } else {
		            hooks.createFromInputFallback(config);
		        }
		    }

		    function createLocalOrUTC(input, format, locale, strict, isUTC) {
		        var c = {};

		        if (format === true || format === false) {
		            strict = format;
		            format = undefined;
		        }

		        if (locale === true || locale === false) {
		            strict = locale;
		            locale = undefined;
		        }

		        if (
		            (isObject(input) && isObjectEmpty(input)) ||
		            (isArray(input) && input.length === 0)
		        ) {
		            input = undefined;
		        }
		        // object construction must be done this way.
		        // https://github.com/moment/moment/issues/1423
		        c._isAMomentObject = true;
		        c._useUTC = c._isUTC = isUTC;
		        c._l = locale;
		        c._i = input;
		        c._f = format;
		        c._strict = strict;

		        return createFromConfig(c);
		    }

		    function createLocal(input, format, locale, strict) {
		        return createLocalOrUTC(input, format, locale, strict, false);
		    }

		    var prototypeMin = deprecate(
		            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
		            function () {
		                var other = createLocal.apply(null, arguments);
		                if (this.isValid() && other.isValid()) {
		                    return other < this ? this : other;
		                } else {
		                    return createInvalid();
		                }
		            }
		        ),
		        prototypeMax = deprecate(
		            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
		            function () {
		                var other = createLocal.apply(null, arguments);
		                if (this.isValid() && other.isValid()) {
		                    return other > this ? this : other;
		                } else {
		                    return createInvalid();
		                }
		            }
		        );

		    // Pick a moment m from moments so that m[fn](other) is true for all
		    // other. This relies on the function fn to be transitive.
		    //
		    // moments should either be an array of moment objects or an array, whose
		    // first element is an array of moment objects.
		    function pickBy(fn, moments) {
		        var res, i;
		        if (moments.length === 1 && isArray(moments[0])) {
		            moments = moments[0];
		        }
		        if (!moments.length) {
		            return createLocal();
		        }
		        res = moments[0];
		        for (i = 1; i < moments.length; ++i) {
		            if (!moments[i].isValid() || moments[i][fn](res)) {
		                res = moments[i];
		            }
		        }
		        return res;
		    }

		    // TODO: Use [].sort instead?
		    function min() {
		        var args = [].slice.call(arguments, 0);

		        return pickBy('isBefore', args);
		    }

		    function max() {
		        var args = [].slice.call(arguments, 0);

		        return pickBy('isAfter', args);
		    }

		    var now = function () {
		        return Date.now ? Date.now() : +new Date();
		    };

		    var ordering = [
		        'year',
		        'quarter',
		        'month',
		        'week',
		        'day',
		        'hour',
		        'minute',
		        'second',
		        'millisecond',
		    ];

		    function isDurationValid(m) {
		        var key,
		            unitHasDecimal = false,
		            i,
		            orderLen = ordering.length;
		        for (key in m) {
		            if (
		                hasOwnProp(m, key) &&
		                !(
		                    indexOf.call(ordering, key) !== -1 &&
		                    (m[key] == null || !isNaN(m[key]))
		                )
		            ) {
		                return false;
		            }
		        }

		        for (i = 0; i < orderLen; ++i) {
		            if (m[ordering[i]]) {
		                if (unitHasDecimal) {
		                    return false; // only allow non-integers for smallest unit
		                }
		                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
		                    unitHasDecimal = true;
		                }
		            }
		        }

		        return true;
		    }

		    function isValid$1() {
		        return this._isValid;
		    }

		    function createInvalid$1() {
		        return createDuration(NaN);
		    }

		    function Duration(duration) {
		        var normalizedInput = normalizeObjectUnits(duration),
		            years = normalizedInput.year || 0,
		            quarters = normalizedInput.quarter || 0,
		            months = normalizedInput.month || 0,
		            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
		            days = normalizedInput.day || 0,
		            hours = normalizedInput.hour || 0,
		            minutes = normalizedInput.minute || 0,
		            seconds = normalizedInput.second || 0,
		            milliseconds = normalizedInput.millisecond || 0;

		        this._isValid = isDurationValid(normalizedInput);

		        // representation for dateAddRemove
		        this._milliseconds =
		            +milliseconds +
		            seconds * 1e3 + // 1000
		            minutes * 6e4 + // 1000 * 60
		            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
		        // Because of dateAddRemove treats 24 hours as different from a
		        // day when working around DST, we need to store them separately
		        this._days = +days + weeks * 7;
		        // It is impossible to translate months into days without knowing
		        // which months you are are talking about, so we have to store
		        // it separately.
		        this._months = +months + quarters * 3 + years * 12;

		        this._data = {};

		        this._locale = getLocale();

		        this._bubble();
		    }

		    function isDuration(obj) {
		        return obj instanceof Duration;
		    }

		    function absRound(number) {
		        if (number < 0) {
		            return Math.round(-1 * number) * -1;
		        } else {
		            return Math.round(number);
		        }
		    }

		    // compare two arrays, return the number of differences
		    function compareArrays(array1, array2, dontConvert) {
		        var len = Math.min(array1.length, array2.length),
		            lengthDiff = Math.abs(array1.length - array2.length),
		            diffs = 0,
		            i;
		        for (i = 0; i < len; i++) {
		            if (
		                (dontConvert && array1[i] !== array2[i]) ||
		                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
		            ) {
		                diffs++;
		            }
		        }
		        return diffs + lengthDiff;
		    }

		    // FORMATTING

		    function offset(token, separator) {
		        addFormatToken(token, 0, 0, function () {
		            var offset = this.utcOffset(),
		                sign = '+';
		            if (offset < 0) {
		                offset = -offset;
		                sign = '-';
		            }
		            return (
		                sign +
		                zeroFill(~~(offset / 60), 2) +
		                separator +
		                zeroFill(~~offset % 60, 2)
		            );
		        });
		    }

		    offset('Z', ':');
		    offset('ZZ', '');

		    // PARSING

		    addRegexToken('Z', matchShortOffset);
		    addRegexToken('ZZ', matchShortOffset);
		    addParseToken(['Z', 'ZZ'], function (input, array, config) {
		        config._useUTC = true;
		        config._tzm = offsetFromString(matchShortOffset, input);
		    });

		    // HELPERS

		    // timezone chunker
		    // '+10:00' > ['10',  '00']
		    // '-1530'  > ['-15', '30']
		    var chunkOffset = /([\+\-]|\d\d)/gi;

		    function offsetFromString(matcher, string) {
		        var matches = (string || '').match(matcher),
		            chunk,
		            parts,
		            minutes;

		        if (matches === null) {
		            return null;
		        }

		        chunk = matches[matches.length - 1] || [];
		        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
		        minutes = +(parts[1] * 60) + toInt(parts[2]);

		        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
		    }

		    // Return a moment from input, that is local/utc/zone equivalent to model.
		    function cloneWithOffset(input, model) {
		        var res, diff;
		        if (model._isUTC) {
		            res = model.clone();
		            diff =
		                (isMoment(input) || isDate(input)
		                    ? input.valueOf()
		                    : createLocal(input).valueOf()) - res.valueOf();
		            // Use low-level api, because this fn is low-level api.
		            res._d.setTime(res._d.valueOf() + diff);
		            hooks.updateOffset(res, false);
		            return res;
		        } else {
		            return createLocal(input).local();
		        }
		    }

		    function getDateOffset(m) {
		        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
		        // https://github.com/moment/moment/pull/1871
		        return -Math.round(m._d.getTimezoneOffset());
		    }

		    // HOOKS

		    // This function will be called whenever a moment is mutated.
		    // It is intended to keep the offset in sync with the timezone.
		    hooks.updateOffset = function () {};

		    // MOMENTS

		    // keepLocalTime = true means only change the timezone, without
		    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
		    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
		    // +0200, so we adjust the time as needed, to be valid.
		    //
		    // Keeping the time actually adds/subtracts (one hour)
		    // from the actual represented time. That is why we call updateOffset
		    // a second time. In case it wants us to change the offset again
		    // _changeInProgress == true case, then we have to adjust, because
		    // there is no such time in the given timezone.
		    function getSetOffset(input, keepLocalTime, keepMinutes) {
		        var offset = this._offset || 0,
		            localAdjust;
		        if (!this.isValid()) {
		            return input != null ? this : NaN;
		        }
		        if (input != null) {
		            if (typeof input === 'string') {
		                input = offsetFromString(matchShortOffset, input);
		                if (input === null) {
		                    return this;
		                }
		            } else if (Math.abs(input) < 16 && !keepMinutes) {
		                input = input * 60;
		            }
		            if (!this._isUTC && keepLocalTime) {
		                localAdjust = getDateOffset(this);
		            }
		            this._offset = input;
		            this._isUTC = true;
		            if (localAdjust != null) {
		                this.add(localAdjust, 'm');
		            }
		            if (offset !== input) {
		                if (!keepLocalTime || this._changeInProgress) {
		                    addSubtract(
		                        this,
		                        createDuration(input - offset, 'm'),
		                        1,
		                        false
		                    );
		                } else if (!this._changeInProgress) {
		                    this._changeInProgress = true;
		                    hooks.updateOffset(this, true);
		                    this._changeInProgress = null;
		                }
		            }
		            return this;
		        } else {
		            return this._isUTC ? offset : getDateOffset(this);
		        }
		    }

		    function getSetZone(input, keepLocalTime) {
		        if (input != null) {
		            if (typeof input !== 'string') {
		                input = -input;
		            }

		            this.utcOffset(input, keepLocalTime);

		            return this;
		        } else {
		            return -this.utcOffset();
		        }
		    }

		    function setOffsetToUTC(keepLocalTime) {
		        return this.utcOffset(0, keepLocalTime);
		    }

		    function setOffsetToLocal(keepLocalTime) {
		        if (this._isUTC) {
		            this.utcOffset(0, keepLocalTime);
		            this._isUTC = false;

		            if (keepLocalTime) {
		                this.subtract(getDateOffset(this), 'm');
		            }
		        }
		        return this;
		    }

		    function setOffsetToParsedOffset() {
		        if (this._tzm != null) {
		            this.utcOffset(this._tzm, false, true);
		        } else if (typeof this._i === 'string') {
		            var tZone = offsetFromString(matchOffset, this._i);
		            if (tZone != null) {
		                this.utcOffset(tZone);
		            } else {
		                this.utcOffset(0, true);
		            }
		        }
		        return this;
		    }

		    function hasAlignedHourOffset(input) {
		        if (!this.isValid()) {
		            return false;
		        }
		        input = input ? createLocal(input).utcOffset() : 0;

		        return (this.utcOffset() - input) % 60 === 0;
		    }

		    function isDaylightSavingTime() {
		        return (
		            this.utcOffset() > this.clone().month(0).utcOffset() ||
		            this.utcOffset() > this.clone().month(5).utcOffset()
		        );
		    }

		    function isDaylightSavingTimeShifted() {
		        if (!isUndefined(this._isDSTShifted)) {
		            return this._isDSTShifted;
		        }

		        var c = {},
		            other;

		        copyConfig(c, this);
		        c = prepareConfig(c);

		        if (c._a) {
		            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
		            this._isDSTShifted =
		                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
		        } else {
		            this._isDSTShifted = false;
		        }

		        return this._isDSTShifted;
		    }

		    function isLocal() {
		        return this.isValid() ? !this._isUTC : false;
		    }

		    function isUtcOffset() {
		        return this.isValid() ? this._isUTC : false;
		    }

		    function isUtc() {
		        return this.isValid() ? this._isUTC && this._offset === 0 : false;
		    }

		    // ASP.NET json date format regex
		    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
		        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
		        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
		        // and further modified to allow for strings containing both week and day
		        isoRegex =
		            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

		    function createDuration(input, key) {
		        var duration = input,
		            // matching against regexp is expensive, do it on demand
		            match = null,
		            sign,
		            ret,
		            diffRes;

		        if (isDuration(input)) {
		            duration = {
		                ms: input._milliseconds,
		                d: input._days,
		                M: input._months,
		            };
		        } else if (isNumber(input) || !isNaN(+input)) {
		            duration = {};
		            if (key) {
		                duration[key] = +input;
		            } else {
		                duration.milliseconds = +input;
		            }
		        } else if ((match = aspNetRegex.exec(input))) {
		            sign = match[1] === '-' ? -1 : 1;
		            duration = {
		                y: 0,
		                d: toInt(match[DATE]) * sign,
		                h: toInt(match[HOUR]) * sign,
		                m: toInt(match[MINUTE]) * sign,
		                s: toInt(match[SECOND]) * sign,
		                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
		            };
		        } else if ((match = isoRegex.exec(input))) {
		            sign = match[1] === '-' ? -1 : 1;
		            duration = {
		                y: parseIso(match[2], sign),
		                M: parseIso(match[3], sign),
		                w: parseIso(match[4], sign),
		                d: parseIso(match[5], sign),
		                h: parseIso(match[6], sign),
		                m: parseIso(match[7], sign),
		                s: parseIso(match[8], sign),
		            };
		        } else if (duration == null) {
		            // checks for null or undefined
		            duration = {};
		        } else if (
		            typeof duration === 'object' &&
		            ('from' in duration || 'to' in duration)
		        ) {
		            diffRes = momentsDifference(
		                createLocal(duration.from),
		                createLocal(duration.to)
		            );

		            duration = {};
		            duration.ms = diffRes.milliseconds;
		            duration.M = diffRes.months;
		        }

		        ret = new Duration(duration);

		        if (isDuration(input) && hasOwnProp(input, '_locale')) {
		            ret._locale = input._locale;
		        }

		        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
		            ret._isValid = input._isValid;
		        }

		        return ret;
		    }

		    createDuration.fn = Duration.prototype;
		    createDuration.invalid = createInvalid$1;

		    function parseIso(inp, sign) {
		        // We'd normally use ~~inp for this, but unfortunately it also
		        // converts floats to ints.
		        // inp may be undefined, so careful calling replace on it.
		        var res = inp && parseFloat(inp.replace(',', '.'));
		        // apply sign while we're at it
		        return (isNaN(res) ? 0 : res) * sign;
		    }

		    function positiveMomentsDifference(base, other) {
		        var res = {};

		        res.months =
		            other.month() - base.month() + (other.year() - base.year()) * 12;
		        if (base.clone().add(res.months, 'M').isAfter(other)) {
		            --res.months;
		        }

		        res.milliseconds = +other - +base.clone().add(res.months, 'M');

		        return res;
		    }

		    function momentsDifference(base, other) {
		        var res;
		        if (!(base.isValid() && other.isValid())) {
		            return { milliseconds: 0, months: 0 };
		        }

		        other = cloneWithOffset(other, base);
		        if (base.isBefore(other)) {
		            res = positiveMomentsDifference(base, other);
		        } else {
		            res = positiveMomentsDifference(other, base);
		            res.milliseconds = -res.milliseconds;
		            res.months = -res.months;
		        }

		        return res;
		    }

		    // TODO: remove 'name' arg after deprecation is removed
		    function createAdder(direction, name) {
		        return function (val, period) {
		            var dur, tmp;
		            //invert the arguments, but complain about it
		            if (period !== null && !isNaN(+period)) {
		                deprecateSimple(
		                    name,
		                    'moment().' +
		                        name +
		                        '(period, number) is deprecated. Please use moment().' +
		                        name +
		                        '(number, period). ' +
		                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
		                );
		                tmp = val;
		                val = period;
		                period = tmp;
		            }

		            dur = createDuration(val, period);
		            addSubtract(this, dur, direction);
		            return this;
		        };
		    }

		    function addSubtract(mom, duration, isAdding, updateOffset) {
		        var milliseconds = duration._milliseconds,
		            days = absRound(duration._days),
		            months = absRound(duration._months);

		        if (!mom.isValid()) {
		            // No op
		            return;
		        }

		        updateOffset = updateOffset == null ? true : updateOffset;

		        if (months) {
		            setMonth(mom, get(mom, 'Month') + months * isAdding);
		        }
		        if (days) {
		            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
		        }
		        if (milliseconds) {
		            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
		        }
		        if (updateOffset) {
		            hooks.updateOffset(mom, days || months);
		        }
		    }

		    var add = createAdder(1, 'add'),
		        subtract = createAdder(-1, 'subtract');

		    function isString(input) {
		        return typeof input === 'string' || input instanceof String;
		    }

		    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
		    function isMomentInput(input) {
		        return (
		            isMoment(input) ||
		            isDate(input) ||
		            isString(input) ||
		            isNumber(input) ||
		            isNumberOrStringArray(input) ||
		            isMomentInputObject(input) ||
		            input === null ||
		            input === undefined
		        );
		    }

		    function isMomentInputObject(input) {
		        var objectTest = isObject(input) && !isObjectEmpty(input),
		            propertyTest = false,
		            properties = [
		                'years',
		                'year',
		                'y',
		                'months',
		                'month',
		                'M',
		                'days',
		                'day',
		                'd',
		                'dates',
		                'date',
		                'D',
		                'hours',
		                'hour',
		                'h',
		                'minutes',
		                'minute',
		                'm',
		                'seconds',
		                'second',
		                's',
		                'milliseconds',
		                'millisecond',
		                'ms',
		            ],
		            i,
		            property,
		            propertyLen = properties.length;

		        for (i = 0; i < propertyLen; i += 1) {
		            property = properties[i];
		            propertyTest = propertyTest || hasOwnProp(input, property);
		        }

		        return objectTest && propertyTest;
		    }

		    function isNumberOrStringArray(input) {
		        var arrayTest = isArray(input),
		            dataTypeTest = false;
		        if (arrayTest) {
		            dataTypeTest =
		                input.filter(function (item) {
		                    return !isNumber(item) && isString(input);
		                }).length === 0;
		        }
		        return arrayTest && dataTypeTest;
		    }

		    function isCalendarSpec(input) {
		        var objectTest = isObject(input) && !isObjectEmpty(input),
		            propertyTest = false,
		            properties = [
		                'sameDay',
		                'nextDay',
		                'lastDay',
		                'nextWeek',
		                'lastWeek',
		                'sameElse',
		            ],
		            i,
		            property;

		        for (i = 0; i < properties.length; i += 1) {
		            property = properties[i];
		            propertyTest = propertyTest || hasOwnProp(input, property);
		        }

		        return objectTest && propertyTest;
		    }

		    function getCalendarFormat(myMoment, now) {
		        var diff = myMoment.diff(now, 'days', true);
		        return diff < -6
		            ? 'sameElse'
		            : diff < -1
		            ? 'lastWeek'
		            : diff < 0
		            ? 'lastDay'
		            : diff < 1
		            ? 'sameDay'
		            : diff < 2
		            ? 'nextDay'
		            : diff < 7
		            ? 'nextWeek'
		            : 'sameElse';
		    }

		    function calendar$1(time, formats) {
		        // Support for single parameter, formats only overload to the calendar function
		        if (arguments.length === 1) {
		            if (!arguments[0]) {
		                time = undefined;
		                formats = undefined;
		            } else if (isMomentInput(arguments[0])) {
		                time = arguments[0];
		                formats = undefined;
		            } else if (isCalendarSpec(arguments[0])) {
		                formats = arguments[0];
		                time = undefined;
		            }
		        }
		        // We want to compare the start of today, vs this.
		        // Getting start-of-today depends on whether we're local/utc/offset or not.
		        var now = time || createLocal(),
		            sod = cloneWithOffset(now, this).startOf('day'),
		            format = hooks.calendarFormat(this, sod) || 'sameElse',
		            output =
		                formats &&
		                (isFunction(formats[format])
		                    ? formats[format].call(this, now)
		                    : formats[format]);

		        return this.format(
		            output || this.localeData().calendar(format, this, createLocal(now))
		        );
		    }

		    function clone() {
		        return new Moment(this);
		    }

		    function isAfter(input, units) {
		        var localInput = isMoment(input) ? input : createLocal(input);
		        if (!(this.isValid() && localInput.isValid())) {
		            return false;
		        }
		        units = normalizeUnits(units) || 'millisecond';
		        if (units === 'millisecond') {
		            return this.valueOf() > localInput.valueOf();
		        } else {
		            return localInput.valueOf() < this.clone().startOf(units).valueOf();
		        }
		    }

		    function isBefore(input, units) {
		        var localInput = isMoment(input) ? input : createLocal(input);
		        if (!(this.isValid() && localInput.isValid())) {
		            return false;
		        }
		        units = normalizeUnits(units) || 'millisecond';
		        if (units === 'millisecond') {
		            return this.valueOf() < localInput.valueOf();
		        } else {
		            return this.clone().endOf(units).valueOf() < localInput.valueOf();
		        }
		    }

		    function isBetween(from, to, units, inclusivity) {
		        var localFrom = isMoment(from) ? from : createLocal(from),
		            localTo = isMoment(to) ? to : createLocal(to);
		        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
		            return false;
		        }
		        inclusivity = inclusivity || '()';
		        return (
		            (inclusivity[0] === '('
		                ? this.isAfter(localFrom, units)
		                : !this.isBefore(localFrom, units)) &&
		            (inclusivity[1] === ')'
		                ? this.isBefore(localTo, units)
		                : !this.isAfter(localTo, units))
		        );
		    }

		    function isSame(input, units) {
		        var localInput = isMoment(input) ? input : createLocal(input),
		            inputMs;
		        if (!(this.isValid() && localInput.isValid())) {
		            return false;
		        }
		        units = normalizeUnits(units) || 'millisecond';
		        if (units === 'millisecond') {
		            return this.valueOf() === localInput.valueOf();
		        } else {
		            inputMs = localInput.valueOf();
		            return (
		                this.clone().startOf(units).valueOf() <= inputMs &&
		                inputMs <= this.clone().endOf(units).valueOf()
		            );
		        }
		    }

		    function isSameOrAfter(input, units) {
		        return this.isSame(input, units) || this.isAfter(input, units);
		    }

		    function isSameOrBefore(input, units) {
		        return this.isSame(input, units) || this.isBefore(input, units);
		    }

		    function diff(input, units, asFloat) {
		        var that, zoneDelta, output;

		        if (!this.isValid()) {
		            return NaN;
		        }

		        that = cloneWithOffset(input, this);

		        if (!that.isValid()) {
		            return NaN;
		        }

		        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

		        units = normalizeUnits(units);

		        switch (units) {
		            case 'year':
		                output = monthDiff(this, that) / 12;
		                break;
		            case 'month':
		                output = monthDiff(this, that);
		                break;
		            case 'quarter':
		                output = monthDiff(this, that) / 3;
		                break;
		            case 'second':
		                output = (this - that) / 1e3;
		                break; // 1000
		            case 'minute':
		                output = (this - that) / 6e4;
		                break; // 1000 * 60
		            case 'hour':
		                output = (this - that) / 36e5;
		                break; // 1000 * 60 * 60
		            case 'day':
		                output = (this - that - zoneDelta) / 864e5;
		                break; // 1000 * 60 * 60 * 24, negate dst
		            case 'week':
		                output = (this - that - zoneDelta) / 6048e5;
		                break; // 1000 * 60 * 60 * 24 * 7, negate dst
		            default:
		                output = this - that;
		        }

		        return asFloat ? output : absFloor(output);
		    }

		    function monthDiff(a, b) {
		        if (a.date() < b.date()) {
		            // end-of-month calculations work correct when the start month has more
		            // days than the end month.
		            return -monthDiff(b, a);
		        }
		        // difference in months
		        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
		            // b is in (anchor - 1 month, anchor + 1 month)
		            anchor = a.clone().add(wholeMonthDiff, 'months'),
		            anchor2,
		            adjust;

		        if (b - anchor < 0) {
		            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
		            // linear across the month
		            adjust = (b - anchor) / (anchor - anchor2);
		        } else {
		            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
		            // linear across the month
		            adjust = (b - anchor) / (anchor2 - anchor);
		        }

		        //check for negative zero, return zero if negative zero
		        return -(wholeMonthDiff + adjust) || 0;
		    }

		    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
		    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

		    function toString() {
		        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
		    }

		    function toISOString(keepOffset) {
		        if (!this.isValid()) {
		            return null;
		        }
		        var utc = keepOffset !== true,
		            m = utc ? this.clone().utc() : this;
		        if (m.year() < 0 || m.year() > 9999) {
		            return formatMoment(
		                m,
		                utc
		                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
		                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
		            );
		        }
		        if (isFunction(Date.prototype.toISOString)) {
		            // native implementation is ~50x faster, use it when we can
		            if (utc) {
		                return this.toDate().toISOString();
		            } else {
		                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
		                    .toISOString()
		                    .replace('Z', formatMoment(m, 'Z'));
		            }
		        }
		        return formatMoment(
		            m,
		            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
		        );
		    }

		    /**
		     * Return a human readable representation of a moment that can
		     * also be evaluated to get a new moment which is the same
		     *
		     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
		     */
		    function inspect() {
		        if (!this.isValid()) {
		            return 'moment.invalid(/* ' + this._i + ' */)';
		        }
		        var func = 'moment',
		            zone = '',
		            prefix,
		            year,
		            datetime,
		            suffix;
		        if (!this.isLocal()) {
		            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
		            zone = 'Z';
		        }
		        prefix = '[' + func + '("]';
		        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
		        datetime = '-MM-DD[T]HH:mm:ss.SSS';
		        suffix = zone + '[")]';

		        return this.format(prefix + year + datetime + suffix);
		    }

		    function format(inputString) {
		        if (!inputString) {
		            inputString = this.isUtc()
		                ? hooks.defaultFormatUtc
		                : hooks.defaultFormat;
		        }
		        var output = formatMoment(this, inputString);
		        return this.localeData().postformat(output);
		    }

		    function from(time, withoutSuffix) {
		        if (
		            this.isValid() &&
		            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
		        ) {
		            return createDuration({ to: this, from: time })
		                .locale(this.locale())
		                .humanize(!withoutSuffix);
		        } else {
		            return this.localeData().invalidDate();
		        }
		    }

		    function fromNow(withoutSuffix) {
		        return this.from(createLocal(), withoutSuffix);
		    }

		    function to(time, withoutSuffix) {
		        if (
		            this.isValid() &&
		            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
		        ) {
		            return createDuration({ from: this, to: time })
		                .locale(this.locale())
		                .humanize(!withoutSuffix);
		        } else {
		            return this.localeData().invalidDate();
		        }
		    }

		    function toNow(withoutSuffix) {
		        return this.to(createLocal(), withoutSuffix);
		    }

		    // If passed a locale key, it will set the locale for this
		    // instance.  Otherwise, it will return the locale configuration
		    // variables for this instance.
		    function locale(key) {
		        var newLocaleData;

		        if (key === undefined) {
		            return this._locale._abbr;
		        } else {
		            newLocaleData = getLocale(key);
		            if (newLocaleData != null) {
		                this._locale = newLocaleData;
		            }
		            return this;
		        }
		    }

		    var lang = deprecate(
		        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
		        function (key) {
		            if (key === undefined) {
		                return this.localeData();
		            } else {
		                return this.locale(key);
		            }
		        }
		    );

		    function localeData() {
		        return this._locale;
		    }

		    var MS_PER_SECOND = 1000,
		        MS_PER_MINUTE = 60 * MS_PER_SECOND,
		        MS_PER_HOUR = 60 * MS_PER_MINUTE,
		        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

		    // actual modulo - handles negative numbers (for dates before 1970):
		    function mod$1(dividend, divisor) {
		        return ((dividend % divisor) + divisor) % divisor;
		    }

		    function localStartOfDate(y, m, d) {
		        // the date constructor remaps years 0-99 to 1900-1999
		        if (y < 100 && y >= 0) {
		            // preserve leap years using a full 400 year cycle, then reset
		            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
		        } else {
		            return new Date(y, m, d).valueOf();
		        }
		    }

		    function utcStartOfDate(y, m, d) {
		        // Date.UTC remaps years 0-99 to 1900-1999
		        if (y < 100 && y >= 0) {
		            // preserve leap years using a full 400 year cycle, then reset
		            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
		        } else {
		            return Date.UTC(y, m, d);
		        }
		    }

		    function startOf(units) {
		        var time, startOfDate;
		        units = normalizeUnits(units);
		        if (units === undefined || units === 'millisecond' || !this.isValid()) {
		            return this;
		        }

		        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

		        switch (units) {
		            case 'year':
		                time = startOfDate(this.year(), 0, 1);
		                break;
		            case 'quarter':
		                time = startOfDate(
		                    this.year(),
		                    this.month() - (this.month() % 3),
		                    1
		                );
		                break;
		            case 'month':
		                time = startOfDate(this.year(), this.month(), 1);
		                break;
		            case 'week':
		                time = startOfDate(
		                    this.year(),
		                    this.month(),
		                    this.date() - this.weekday()
		                );
		                break;
		            case 'isoWeek':
		                time = startOfDate(
		                    this.year(),
		                    this.month(),
		                    this.date() - (this.isoWeekday() - 1)
		                );
		                break;
		            case 'day':
		            case 'date':
		                time = startOfDate(this.year(), this.month(), this.date());
		                break;
		            case 'hour':
		                time = this._d.valueOf();
		                time -= mod$1(
		                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
		                    MS_PER_HOUR
		                );
		                break;
		            case 'minute':
		                time = this._d.valueOf();
		                time -= mod$1(time, MS_PER_MINUTE);
		                break;
		            case 'second':
		                time = this._d.valueOf();
		                time -= mod$1(time, MS_PER_SECOND);
		                break;
		        }

		        this._d.setTime(time);
		        hooks.updateOffset(this, true);
		        return this;
		    }

		    function endOf(units) {
		        var time, startOfDate;
		        units = normalizeUnits(units);
		        if (units === undefined || units === 'millisecond' || !this.isValid()) {
		            return this;
		        }

		        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

		        switch (units) {
		            case 'year':
		                time = startOfDate(this.year() + 1, 0, 1) - 1;
		                break;
		            case 'quarter':
		                time =
		                    startOfDate(
		                        this.year(),
		                        this.month() - (this.month() % 3) + 3,
		                        1
		                    ) - 1;
		                break;
		            case 'month':
		                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
		                break;
		            case 'week':
		                time =
		                    startOfDate(
		                        this.year(),
		                        this.month(),
		                        this.date() - this.weekday() + 7
		                    ) - 1;
		                break;
		            case 'isoWeek':
		                time =
		                    startOfDate(
		                        this.year(),
		                        this.month(),
		                        this.date() - (this.isoWeekday() - 1) + 7
		                    ) - 1;
		                break;
		            case 'day':
		            case 'date':
		                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
		                break;
		            case 'hour':
		                time = this._d.valueOf();
		                time +=
		                    MS_PER_HOUR -
		                    mod$1(
		                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
		                        MS_PER_HOUR
		                    ) -
		                    1;
		                break;
		            case 'minute':
		                time = this._d.valueOf();
		                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
		                break;
		            case 'second':
		                time = this._d.valueOf();
		                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
		                break;
		        }

		        this._d.setTime(time);
		        hooks.updateOffset(this, true);
		        return this;
		    }

		    function valueOf() {
		        return this._d.valueOf() - (this._offset || 0) * 60000;
		    }

		    function unix() {
		        return Math.floor(this.valueOf() / 1000);
		    }

		    function toDate() {
		        return new Date(this.valueOf());
		    }

		    function toArray() {
		        var m = this;
		        return [
		            m.year(),
		            m.month(),
		            m.date(),
		            m.hour(),
		            m.minute(),
		            m.second(),
		            m.millisecond(),
		        ];
		    }

		    function toObject() {
		        var m = this;
		        return {
		            years: m.year(),
		            months: m.month(),
		            date: m.date(),
		            hours: m.hours(),
		            minutes: m.minutes(),
		            seconds: m.seconds(),
		            milliseconds: m.milliseconds(),
		        };
		    }

		    function toJSON() {
		        // new Date(NaN).toJSON() === null
		        return this.isValid() ? this.toISOString() : null;
		    }

		    function isValid$2() {
		        return isValid(this);
		    }

		    function parsingFlags() {
		        return extend({}, getParsingFlags(this));
		    }

		    function invalidAt() {
		        return getParsingFlags(this).overflow;
		    }

		    function creationData() {
		        return {
		            input: this._i,
		            format: this._f,
		            locale: this._locale,
		            isUTC: this._isUTC,
		            strict: this._strict,
		        };
		    }

		    addFormatToken('N', 0, 0, 'eraAbbr');
		    addFormatToken('NN', 0, 0, 'eraAbbr');
		    addFormatToken('NNN', 0, 0, 'eraAbbr');
		    addFormatToken('NNNN', 0, 0, 'eraName');
		    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

		    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
		    addFormatToken('y', ['yy', 2], 0, 'eraYear');
		    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
		    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

		    addRegexToken('N', matchEraAbbr);
		    addRegexToken('NN', matchEraAbbr);
		    addRegexToken('NNN', matchEraAbbr);
		    addRegexToken('NNNN', matchEraName);
		    addRegexToken('NNNNN', matchEraNarrow);

		    addParseToken(
		        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
		        function (input, array, config, token) {
		            var era = config._locale.erasParse(input, token, config._strict);
		            if (era) {
		                getParsingFlags(config).era = era;
		            } else {
		                getParsingFlags(config).invalidEra = input;
		            }
		        }
		    );

		    addRegexToken('y', matchUnsigned);
		    addRegexToken('yy', matchUnsigned);
		    addRegexToken('yyy', matchUnsigned);
		    addRegexToken('yyyy', matchUnsigned);
		    addRegexToken('yo', matchEraYearOrdinal);

		    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
		    addParseToken(['yo'], function (input, array, config, token) {
		        var match;
		        if (config._locale._eraYearOrdinalRegex) {
		            match = input.match(config._locale._eraYearOrdinalRegex);
		        }

		        if (config._locale.eraYearOrdinalParse) {
		            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
		        } else {
		            array[YEAR] = parseInt(input, 10);
		        }
		    });

		    function localeEras(m, format) {
		        var i,
		            l,
		            date,
		            eras = this._eras || getLocale('en')._eras;
		        for (i = 0, l = eras.length; i < l; ++i) {
		            switch (typeof eras[i].since) {
		                case 'string':
		                    // truncate time
		                    date = hooks(eras[i].since).startOf('day');
		                    eras[i].since = date.valueOf();
		                    break;
		            }

		            switch (typeof eras[i].until) {
		                case 'undefined':
		                    eras[i].until = +Infinity;
		                    break;
		                case 'string':
		                    // truncate time
		                    date = hooks(eras[i].until).startOf('day').valueOf();
		                    eras[i].until = date.valueOf();
		                    break;
		            }
		        }
		        return eras;
		    }

		    function localeErasParse(eraName, format, strict) {
		        var i,
		            l,
		            eras = this.eras(),
		            name,
		            abbr,
		            narrow;
		        eraName = eraName.toUpperCase();

		        for (i = 0, l = eras.length; i < l; ++i) {
		            name = eras[i].name.toUpperCase();
		            abbr = eras[i].abbr.toUpperCase();
		            narrow = eras[i].narrow.toUpperCase();

		            if (strict) {
		                switch (format) {
		                    case 'N':
		                    case 'NN':
		                    case 'NNN':
		                        if (abbr === eraName) {
		                            return eras[i];
		                        }
		                        break;

		                    case 'NNNN':
		                        if (name === eraName) {
		                            return eras[i];
		                        }
		                        break;

		                    case 'NNNNN':
		                        if (narrow === eraName) {
		                            return eras[i];
		                        }
		                        break;
		                }
		            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
		                return eras[i];
		            }
		        }
		    }

		    function localeErasConvertYear(era, year) {
		        var dir = era.since <= era.until ? +1 : -1;
		        if (year === undefined) {
		            return hooks(era.since).year();
		        } else {
		            return hooks(era.since).year() + (year - era.offset) * dir;
		        }
		    }

		    function getEraName() {
		        var i,
		            l,
		            val,
		            eras = this.localeData().eras();
		        for (i = 0, l = eras.length; i < l; ++i) {
		            // truncate time
		            val = this.clone().startOf('day').valueOf();

		            if (eras[i].since <= val && val <= eras[i].until) {
		                return eras[i].name;
		            }
		            if (eras[i].until <= val && val <= eras[i].since) {
		                return eras[i].name;
		            }
		        }

		        return '';
		    }

		    function getEraNarrow() {
		        var i,
		            l,
		            val,
		            eras = this.localeData().eras();
		        for (i = 0, l = eras.length; i < l; ++i) {
		            // truncate time
		            val = this.clone().startOf('day').valueOf();

		            if (eras[i].since <= val && val <= eras[i].until) {
		                return eras[i].narrow;
		            }
		            if (eras[i].until <= val && val <= eras[i].since) {
		                return eras[i].narrow;
		            }
		        }

		        return '';
		    }

		    function getEraAbbr() {
		        var i,
		            l,
		            val,
		            eras = this.localeData().eras();
		        for (i = 0, l = eras.length; i < l; ++i) {
		            // truncate time
		            val = this.clone().startOf('day').valueOf();

		            if (eras[i].since <= val && val <= eras[i].until) {
		                return eras[i].abbr;
		            }
		            if (eras[i].until <= val && val <= eras[i].since) {
		                return eras[i].abbr;
		            }
		        }

		        return '';
		    }

		    function getEraYear() {
		        var i,
		            l,
		            dir,
		            val,
		            eras = this.localeData().eras();
		        for (i = 0, l = eras.length; i < l; ++i) {
		            dir = eras[i].since <= eras[i].until ? +1 : -1;

		            // truncate time
		            val = this.clone().startOf('day').valueOf();

		            if (
		                (eras[i].since <= val && val <= eras[i].until) ||
		                (eras[i].until <= val && val <= eras[i].since)
		            ) {
		                return (
		                    (this.year() - hooks(eras[i].since).year()) * dir +
		                    eras[i].offset
		                );
		            }
		        }

		        return this.year();
		    }

		    function erasNameRegex(isStrict) {
		        if (!hasOwnProp(this, '_erasNameRegex')) {
		            computeErasParse.call(this);
		        }
		        return isStrict ? this._erasNameRegex : this._erasRegex;
		    }

		    function erasAbbrRegex(isStrict) {
		        if (!hasOwnProp(this, '_erasAbbrRegex')) {
		            computeErasParse.call(this);
		        }
		        return isStrict ? this._erasAbbrRegex : this._erasRegex;
		    }

		    function erasNarrowRegex(isStrict) {
		        if (!hasOwnProp(this, '_erasNarrowRegex')) {
		            computeErasParse.call(this);
		        }
		        return isStrict ? this._erasNarrowRegex : this._erasRegex;
		    }

		    function matchEraAbbr(isStrict, locale) {
		        return locale.erasAbbrRegex(isStrict);
		    }

		    function matchEraName(isStrict, locale) {
		        return locale.erasNameRegex(isStrict);
		    }

		    function matchEraNarrow(isStrict, locale) {
		        return locale.erasNarrowRegex(isStrict);
		    }

		    function matchEraYearOrdinal(isStrict, locale) {
		        return locale._eraYearOrdinalRegex || matchUnsigned;
		    }

		    function computeErasParse() {
		        var abbrPieces = [],
		            namePieces = [],
		            narrowPieces = [],
		            mixedPieces = [],
		            i,
		            l,
		            eras = this.eras();

		        for (i = 0, l = eras.length; i < l; ++i) {
		            namePieces.push(regexEscape(eras[i].name));
		            abbrPieces.push(regexEscape(eras[i].abbr));
		            narrowPieces.push(regexEscape(eras[i].narrow));

		            mixedPieces.push(regexEscape(eras[i].name));
		            mixedPieces.push(regexEscape(eras[i].abbr));
		            mixedPieces.push(regexEscape(eras[i].narrow));
		        }

		        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
		        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
		        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
		        this._erasNarrowRegex = new RegExp(
		            '^(' + narrowPieces.join('|') + ')',
		            'i'
		        );
		    }

		    // FORMATTING

		    addFormatToken(0, ['gg', 2], 0, function () {
		        return this.weekYear() % 100;
		    });

		    addFormatToken(0, ['GG', 2], 0, function () {
		        return this.isoWeekYear() % 100;
		    });

		    function addWeekYearFormatToken(token, getter) {
		        addFormatToken(0, [token, token.length], 0, getter);
		    }

		    addWeekYearFormatToken('gggg', 'weekYear');
		    addWeekYearFormatToken('ggggg', 'weekYear');
		    addWeekYearFormatToken('GGGG', 'isoWeekYear');
		    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

		    // ALIASES

		    addUnitAlias('weekYear', 'gg');
		    addUnitAlias('isoWeekYear', 'GG');

		    // PRIORITY

		    addUnitPriority('weekYear', 1);
		    addUnitPriority('isoWeekYear', 1);

		    // PARSING

		    addRegexToken('G', matchSigned);
		    addRegexToken('g', matchSigned);
		    addRegexToken('GG', match1to2, match2);
		    addRegexToken('gg', match1to2, match2);
		    addRegexToken('GGGG', match1to4, match4);
		    addRegexToken('gggg', match1to4, match4);
		    addRegexToken('GGGGG', match1to6, match6);
		    addRegexToken('ggggg', match1to6, match6);

		    addWeekParseToken(
		        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
		        function (input, week, config, token) {
		            week[token.substr(0, 2)] = toInt(input);
		        }
		    );

		    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
		        week[token] = hooks.parseTwoDigitYear(input);
		    });

		    // MOMENTS

		    function getSetWeekYear(input) {
		        return getSetWeekYearHelper.call(
		            this,
		            input,
		            this.week(),
		            this.weekday(),
		            this.localeData()._week.dow,
		            this.localeData()._week.doy
		        );
		    }

		    function getSetISOWeekYear(input) {
		        return getSetWeekYearHelper.call(
		            this,
		            input,
		            this.isoWeek(),
		            this.isoWeekday(),
		            1,
		            4
		        );
		    }

		    function getISOWeeksInYear() {
		        return weeksInYear(this.year(), 1, 4);
		    }

		    function getISOWeeksInISOWeekYear() {
		        return weeksInYear(this.isoWeekYear(), 1, 4);
		    }

		    function getWeeksInYear() {
		        var weekInfo = this.localeData()._week;
		        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
		    }

		    function getWeeksInWeekYear() {
		        var weekInfo = this.localeData()._week;
		        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
		    }

		    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
		        var weeksTarget;
		        if (input == null) {
		            return weekOfYear(this, dow, doy).year;
		        } else {
		            weeksTarget = weeksInYear(input, dow, doy);
		            if (week > weeksTarget) {
		                week = weeksTarget;
		            }
		            return setWeekAll.call(this, input, week, weekday, dow, doy);
		        }
		    }

		    function setWeekAll(weekYear, week, weekday, dow, doy) {
		        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
		            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

		        this.year(date.getUTCFullYear());
		        this.month(date.getUTCMonth());
		        this.date(date.getUTCDate());
		        return this;
		    }

		    // FORMATTING

		    addFormatToken('Q', 0, 'Qo', 'quarter');

		    // ALIASES

		    addUnitAlias('quarter', 'Q');

		    // PRIORITY

		    addUnitPriority('quarter', 7);

		    // PARSING

		    addRegexToken('Q', match1);
		    addParseToken('Q', function (input, array) {
		        array[MONTH] = (toInt(input) - 1) * 3;
		    });

		    // MOMENTS

		    function getSetQuarter(input) {
		        return input == null
		            ? Math.ceil((this.month() + 1) / 3)
		            : this.month((input - 1) * 3 + (this.month() % 3));
		    }

		    // FORMATTING

		    addFormatToken('D', ['DD', 2], 'Do', 'date');

		    // ALIASES

		    addUnitAlias('date', 'D');

		    // PRIORITY
		    addUnitPriority('date', 9);

		    // PARSING

		    addRegexToken('D', match1to2);
		    addRegexToken('DD', match1to2, match2);
		    addRegexToken('Do', function (isStrict, locale) {
		        // TODO: Remove "ordinalParse" fallback in next major release.
		        return isStrict
		            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
		            : locale._dayOfMonthOrdinalParseLenient;
		    });

		    addParseToken(['D', 'DD'], DATE);
		    addParseToken('Do', function (input, array) {
		        array[DATE] = toInt(input.match(match1to2)[0]);
		    });

		    // MOMENTS

		    var getSetDayOfMonth = makeGetSet('Date', true);

		    // FORMATTING

		    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

		    // ALIASES

		    addUnitAlias('dayOfYear', 'DDD');

		    // PRIORITY
		    addUnitPriority('dayOfYear', 4);

		    // PARSING

		    addRegexToken('DDD', match1to3);
		    addRegexToken('DDDD', match3);
		    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
		        config._dayOfYear = toInt(input);
		    });

		    // HELPERS

		    // MOMENTS

		    function getSetDayOfYear(input) {
		        var dayOfYear =
		            Math.round(
		                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
		            ) + 1;
		        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
		    }

		    // FORMATTING

		    addFormatToken('m', ['mm', 2], 0, 'minute');

		    // ALIASES

		    addUnitAlias('minute', 'm');

		    // PRIORITY

		    addUnitPriority('minute', 14);

		    // PARSING

		    addRegexToken('m', match1to2);
		    addRegexToken('mm', match1to2, match2);
		    addParseToken(['m', 'mm'], MINUTE);

		    // MOMENTS

		    var getSetMinute = makeGetSet('Minutes', false);

		    // FORMATTING

		    addFormatToken('s', ['ss', 2], 0, 'second');

		    // ALIASES

		    addUnitAlias('second', 's');

		    // PRIORITY

		    addUnitPriority('second', 15);

		    // PARSING

		    addRegexToken('s', match1to2);
		    addRegexToken('ss', match1to2, match2);
		    addParseToken(['s', 'ss'], SECOND);

		    // MOMENTS

		    var getSetSecond = makeGetSet('Seconds', false);

		    // FORMATTING

		    addFormatToken('S', 0, 0, function () {
		        return ~~(this.millisecond() / 100);
		    });

		    addFormatToken(0, ['SS', 2], 0, function () {
		        return ~~(this.millisecond() / 10);
		    });

		    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
		    addFormatToken(0, ['SSSS', 4], 0, function () {
		        return this.millisecond() * 10;
		    });
		    addFormatToken(0, ['SSSSS', 5], 0, function () {
		        return this.millisecond() * 100;
		    });
		    addFormatToken(0, ['SSSSSS', 6], 0, function () {
		        return this.millisecond() * 1000;
		    });
		    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
		        return this.millisecond() * 10000;
		    });
		    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
		        return this.millisecond() * 100000;
		    });
		    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
		        return this.millisecond() * 1000000;
		    });

		    // ALIASES

		    addUnitAlias('millisecond', 'ms');

		    // PRIORITY

		    addUnitPriority('millisecond', 16);

		    // PARSING

		    addRegexToken('S', match1to3, match1);
		    addRegexToken('SS', match1to3, match2);
		    addRegexToken('SSS', match1to3, match3);

		    var token, getSetMillisecond;
		    for (token = 'SSSS'; token.length <= 9; token += 'S') {
		        addRegexToken(token, matchUnsigned);
		    }

		    function parseMs(input, array) {
		        array[MILLISECOND] = toInt(('0.' + input) * 1000);
		    }

		    for (token = 'S'; token.length <= 9; token += 'S') {
		        addParseToken(token, parseMs);
		    }

		    getSetMillisecond = makeGetSet('Milliseconds', false);

		    // FORMATTING

		    addFormatToken('z', 0, 0, 'zoneAbbr');
		    addFormatToken('zz', 0, 0, 'zoneName');

		    // MOMENTS

		    function getZoneAbbr() {
		        return this._isUTC ? 'UTC' : '';
		    }

		    function getZoneName() {
		        return this._isUTC ? 'Coordinated Universal Time' : '';
		    }

		    var proto = Moment.prototype;

		    proto.add = add;
		    proto.calendar = calendar$1;
		    proto.clone = clone;
		    proto.diff = diff;
		    proto.endOf = endOf;
		    proto.format = format;
		    proto.from = from;
		    proto.fromNow = fromNow;
		    proto.to = to;
		    proto.toNow = toNow;
		    proto.get = stringGet;
		    proto.invalidAt = invalidAt;
		    proto.isAfter = isAfter;
		    proto.isBefore = isBefore;
		    proto.isBetween = isBetween;
		    proto.isSame = isSame;
		    proto.isSameOrAfter = isSameOrAfter;
		    proto.isSameOrBefore = isSameOrBefore;
		    proto.isValid = isValid$2;
		    proto.lang = lang;
		    proto.locale = locale;
		    proto.localeData = localeData;
		    proto.max = prototypeMax;
		    proto.min = prototypeMin;
		    proto.parsingFlags = parsingFlags;
		    proto.set = stringSet;
		    proto.startOf = startOf;
		    proto.subtract = subtract;
		    proto.toArray = toArray;
		    proto.toObject = toObject;
		    proto.toDate = toDate;
		    proto.toISOString = toISOString;
		    proto.inspect = inspect;
		    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
		        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
		            return 'Moment<' + this.format() + '>';
		        };
		    }
		    proto.toJSON = toJSON;
		    proto.toString = toString;
		    proto.unix = unix;
		    proto.valueOf = valueOf;
		    proto.creationData = creationData;
		    proto.eraName = getEraName;
		    proto.eraNarrow = getEraNarrow;
		    proto.eraAbbr = getEraAbbr;
		    proto.eraYear = getEraYear;
		    proto.year = getSetYear;
		    proto.isLeapYear = getIsLeapYear;
		    proto.weekYear = getSetWeekYear;
		    proto.isoWeekYear = getSetISOWeekYear;
		    proto.quarter = proto.quarters = getSetQuarter;
		    proto.month = getSetMonth;
		    proto.daysInMonth = getDaysInMonth;
		    proto.week = proto.weeks = getSetWeek;
		    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
		    proto.weeksInYear = getWeeksInYear;
		    proto.weeksInWeekYear = getWeeksInWeekYear;
		    proto.isoWeeksInYear = getISOWeeksInYear;
		    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
		    proto.date = getSetDayOfMonth;
		    proto.day = proto.days = getSetDayOfWeek;
		    proto.weekday = getSetLocaleDayOfWeek;
		    proto.isoWeekday = getSetISODayOfWeek;
		    proto.dayOfYear = getSetDayOfYear;
		    proto.hour = proto.hours = getSetHour;
		    proto.minute = proto.minutes = getSetMinute;
		    proto.second = proto.seconds = getSetSecond;
		    proto.millisecond = proto.milliseconds = getSetMillisecond;
		    proto.utcOffset = getSetOffset;
		    proto.utc = setOffsetToUTC;
		    proto.local = setOffsetToLocal;
		    proto.parseZone = setOffsetToParsedOffset;
		    proto.hasAlignedHourOffset = hasAlignedHourOffset;
		    proto.isDST = isDaylightSavingTime;
		    proto.isLocal = isLocal;
		    proto.isUtcOffset = isUtcOffset;
		    proto.isUtc = isUtc;
		    proto.isUTC = isUtc;
		    proto.zoneAbbr = getZoneAbbr;
		    proto.zoneName = getZoneName;
		    proto.dates = deprecate(
		        'dates accessor is deprecated. Use date instead.',
		        getSetDayOfMonth
		    );
		    proto.months = deprecate(
		        'months accessor is deprecated. Use month instead',
		        getSetMonth
		    );
		    proto.years = deprecate(
		        'years accessor is deprecated. Use year instead',
		        getSetYear
		    );
		    proto.zone = deprecate(
		        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
		        getSetZone
		    );
		    proto.isDSTShifted = deprecate(
		        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
		        isDaylightSavingTimeShifted
		    );

		    function createUnix(input) {
		        return createLocal(input * 1000);
		    }

		    function createInZone() {
		        return createLocal.apply(null, arguments).parseZone();
		    }

		    function preParsePostFormat(string) {
		        return string;
		    }

		    var proto$1 = Locale.prototype;

		    proto$1.calendar = calendar;
		    proto$1.longDateFormat = longDateFormat;
		    proto$1.invalidDate = invalidDate;
		    proto$1.ordinal = ordinal;
		    proto$1.preparse = preParsePostFormat;
		    proto$1.postformat = preParsePostFormat;
		    proto$1.relativeTime = relativeTime;
		    proto$1.pastFuture = pastFuture;
		    proto$1.set = set;
		    proto$1.eras = localeEras;
		    proto$1.erasParse = localeErasParse;
		    proto$1.erasConvertYear = localeErasConvertYear;
		    proto$1.erasAbbrRegex = erasAbbrRegex;
		    proto$1.erasNameRegex = erasNameRegex;
		    proto$1.erasNarrowRegex = erasNarrowRegex;

		    proto$1.months = localeMonths;
		    proto$1.monthsShort = localeMonthsShort;
		    proto$1.monthsParse = localeMonthsParse;
		    proto$1.monthsRegex = monthsRegex;
		    proto$1.monthsShortRegex = monthsShortRegex;
		    proto$1.week = localeWeek;
		    proto$1.firstDayOfYear = localeFirstDayOfYear;
		    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

		    proto$1.weekdays = localeWeekdays;
		    proto$1.weekdaysMin = localeWeekdaysMin;
		    proto$1.weekdaysShort = localeWeekdaysShort;
		    proto$1.weekdaysParse = localeWeekdaysParse;

		    proto$1.weekdaysRegex = weekdaysRegex;
		    proto$1.weekdaysShortRegex = weekdaysShortRegex;
		    proto$1.weekdaysMinRegex = weekdaysMinRegex;

		    proto$1.isPM = localeIsPM;
		    proto$1.meridiem = localeMeridiem;

		    function get$1(format, index, field, setter) {
		        var locale = getLocale(),
		            utc = createUTC().set(setter, index);
		        return locale[field](utc, format);
		    }

		    function listMonthsImpl(format, index, field) {
		        if (isNumber(format)) {
		            index = format;
		            format = undefined;
		        }

		        format = format || '';

		        if (index != null) {
		            return get$1(format, index, field, 'month');
		        }

		        var i,
		            out = [];
		        for (i = 0; i < 12; i++) {
		            out[i] = get$1(format, i, field, 'month');
		        }
		        return out;
		    }

		    // ()
		    // (5)
		    // (fmt, 5)
		    // (fmt)
		    // (true)
		    // (true, 5)
		    // (true, fmt, 5)
		    // (true, fmt)
		    function listWeekdaysImpl(localeSorted, format, index, field) {
		        if (typeof localeSorted === 'boolean') {
		            if (isNumber(format)) {
		                index = format;
		                format = undefined;
		            }

		            format = format || '';
		        } else {
		            format = localeSorted;
		            index = format;
		            localeSorted = false;

		            if (isNumber(format)) {
		                index = format;
		                format = undefined;
		            }

		            format = format || '';
		        }

		        var locale = getLocale(),
		            shift = localeSorted ? locale._week.dow : 0,
		            i,
		            out = [];

		        if (index != null) {
		            return get$1(format, (index + shift) % 7, field, 'day');
		        }

		        for (i = 0; i < 7; i++) {
		            out[i] = get$1(format, (i + shift) % 7, field, 'day');
		        }
		        return out;
		    }

		    function listMonths(format, index) {
		        return listMonthsImpl(format, index, 'months');
		    }

		    function listMonthsShort(format, index) {
		        return listMonthsImpl(format, index, 'monthsShort');
		    }

		    function listWeekdays(localeSorted, format, index) {
		        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
		    }

		    function listWeekdaysShort(localeSorted, format, index) {
		        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
		    }

		    function listWeekdaysMin(localeSorted, format, index) {
		        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
		    }

		    getSetGlobalLocale('en', {
		        eras: [
		            {
		                since: '0001-01-01',
		                until: +Infinity,
		                offset: 1,
		                name: 'Anno Domini',
		                narrow: 'AD',
		                abbr: 'AD',
		            },
		            {
		                since: '0000-12-31',
		                until: -Infinity,
		                offset: 1,
		                name: 'Before Christ',
		                narrow: 'BC',
		                abbr: 'BC',
		            },
		        ],
		        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
		        ordinal: function (number) {
		            var b = number % 10,
		                output =
		                    toInt((number % 100) / 10) === 1
		                        ? 'th'
		                        : b === 1
		                        ? 'st'
		                        : b === 2
		                        ? 'nd'
		                        : b === 3
		                        ? 'rd'
		                        : 'th';
		            return number + output;
		        },
		    });

		    // Side effect imports

		    hooks.lang = deprecate(
		        'moment.lang is deprecated. Use moment.locale instead.',
		        getSetGlobalLocale
		    );
		    hooks.langData = deprecate(
		        'moment.langData is deprecated. Use moment.localeData instead.',
		        getLocale
		    );

		    var mathAbs = Math.abs;

		    function abs() {
		        var data = this._data;

		        this._milliseconds = mathAbs(this._milliseconds);
		        this._days = mathAbs(this._days);
		        this._months = mathAbs(this._months);

		        data.milliseconds = mathAbs(data.milliseconds);
		        data.seconds = mathAbs(data.seconds);
		        data.minutes = mathAbs(data.minutes);
		        data.hours = mathAbs(data.hours);
		        data.months = mathAbs(data.months);
		        data.years = mathAbs(data.years);

		        return this;
		    }

		    function addSubtract$1(duration, input, value, direction) {
		        var other = createDuration(input, value);

		        duration._milliseconds += direction * other._milliseconds;
		        duration._days += direction * other._days;
		        duration._months += direction * other._months;

		        return duration._bubble();
		    }

		    // supports only 2.0-style add(1, 's') or add(duration)
		    function add$1(input, value) {
		        return addSubtract$1(this, input, value, 1);
		    }

		    // supports only 2.0-style subtract(1, 's') or subtract(duration)
		    function subtract$1(input, value) {
		        return addSubtract$1(this, input, value, -1);
		    }

		    function absCeil(number) {
		        if (number < 0) {
		            return Math.floor(number);
		        } else {
		            return Math.ceil(number);
		        }
		    }

		    function bubble() {
		        var milliseconds = this._milliseconds,
		            days = this._days,
		            months = this._months,
		            data = this._data,
		            seconds,
		            minutes,
		            hours,
		            years,
		            monthsFromDays;

		        // if we have a mix of positive and negative values, bubble down first
		        // check: https://github.com/moment/moment/issues/2166
		        if (
		            !(
		                (milliseconds >= 0 && days >= 0 && months >= 0) ||
		                (milliseconds <= 0 && days <= 0 && months <= 0)
		            )
		        ) {
		            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
		            days = 0;
		            months = 0;
		        }

		        // The following code bubbles up values, see the tests for
		        // examples of what that means.
		        data.milliseconds = milliseconds % 1000;

		        seconds = absFloor(milliseconds / 1000);
		        data.seconds = seconds % 60;

		        minutes = absFloor(seconds / 60);
		        data.minutes = minutes % 60;

		        hours = absFloor(minutes / 60);
		        data.hours = hours % 24;

		        days += absFloor(hours / 24);

		        // convert days to months
		        monthsFromDays = absFloor(daysToMonths(days));
		        months += monthsFromDays;
		        days -= absCeil(monthsToDays(monthsFromDays));

		        // 12 months -> 1 year
		        years = absFloor(months / 12);
		        months %= 12;

		        data.days = days;
		        data.months = months;
		        data.years = years;

		        return this;
		    }

		    function daysToMonths(days) {
		        // 400 years have 146097 days (taking into account leap year rules)
		        // 400 years have 12 months === 4800
		        return (days * 4800) / 146097;
		    }

		    function monthsToDays(months) {
		        // the reverse of daysToMonths
		        return (months * 146097) / 4800;
		    }

		    function as(units) {
		        if (!this.isValid()) {
		            return NaN;
		        }
		        var days,
		            months,
		            milliseconds = this._milliseconds;

		        units = normalizeUnits(units);

		        if (units === 'month' || units === 'quarter' || units === 'year') {
		            days = this._days + milliseconds / 864e5;
		            months = this._months + daysToMonths(days);
		            switch (units) {
		                case 'month':
		                    return months;
		                case 'quarter':
		                    return months / 3;
		                case 'year':
		                    return months / 12;
		            }
		        } else {
		            // handle milliseconds separately because of floating point math errors (issue #1867)
		            days = this._days + Math.round(monthsToDays(this._months));
		            switch (units) {
		                case 'week':
		                    return days / 7 + milliseconds / 6048e5;
		                case 'day':
		                    return days + milliseconds / 864e5;
		                case 'hour':
		                    return days * 24 + milliseconds / 36e5;
		                case 'minute':
		                    return days * 1440 + milliseconds / 6e4;
		                case 'second':
		                    return days * 86400 + milliseconds / 1000;
		                // Math.floor prevents floating point math errors here
		                case 'millisecond':
		                    return Math.floor(days * 864e5) + milliseconds;
		                default:
		                    throw new Error('Unknown unit ' + units);
		            }
		        }
		    }

		    // TODO: Use this.as('ms')?
		    function valueOf$1() {
		        if (!this.isValid()) {
		            return NaN;
		        }
		        return (
		            this._milliseconds +
		            this._days * 864e5 +
		            (this._months % 12) * 2592e6 +
		            toInt(this._months / 12) * 31536e6
		        );
		    }

		    function makeAs(alias) {
		        return function () {
		            return this.as(alias);
		        };
		    }

		    var asMilliseconds = makeAs('ms'),
		        asSeconds = makeAs('s'),
		        asMinutes = makeAs('m'),
		        asHours = makeAs('h'),
		        asDays = makeAs('d'),
		        asWeeks = makeAs('w'),
		        asMonths = makeAs('M'),
		        asQuarters = makeAs('Q'),
		        asYears = makeAs('y');

		    function clone$1() {
		        return createDuration(this);
		    }

		    function get$2(units) {
		        units = normalizeUnits(units);
		        return this.isValid() ? this[units + 's']() : NaN;
		    }

		    function makeGetter(name) {
		        return function () {
		            return this.isValid() ? this._data[name] : NaN;
		        };
		    }

		    var milliseconds = makeGetter('milliseconds'),
		        seconds = makeGetter('seconds'),
		        minutes = makeGetter('minutes'),
		        hours = makeGetter('hours'),
		        days = makeGetter('days'),
		        months = makeGetter('months'),
		        years = makeGetter('years');

		    function weeks() {
		        return absFloor(this.days() / 7);
		    }

		    var round = Math.round,
		        thresholds = {
		            ss: 44, // a few seconds to seconds
		            s: 45, // seconds to minute
		            m: 45, // minutes to hour
		            h: 22, // hours to day
		            d: 26, // days to month/week
		            w: null, // weeks to month
		            M: 11, // months to year
		        };

		    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
		    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
		        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
		    }

		    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
		        var duration = createDuration(posNegDuration).abs(),
		            seconds = round(duration.as('s')),
		            minutes = round(duration.as('m')),
		            hours = round(duration.as('h')),
		            days = round(duration.as('d')),
		            months = round(duration.as('M')),
		            weeks = round(duration.as('w')),
		            years = round(duration.as('y')),
		            a =
		                (seconds <= thresholds.ss && ['s', seconds]) ||
		                (seconds < thresholds.s && ['ss', seconds]) ||
		                (minutes <= 1 && ['m']) ||
		                (minutes < thresholds.m && ['mm', minutes]) ||
		                (hours <= 1 && ['h']) ||
		                (hours < thresholds.h && ['hh', hours]) ||
		                (days <= 1 && ['d']) ||
		                (days < thresholds.d && ['dd', days]);

		        if (thresholds.w != null) {
		            a =
		                a ||
		                (weeks <= 1 && ['w']) ||
		                (weeks < thresholds.w && ['ww', weeks]);
		        }
		        a = a ||
		            (months <= 1 && ['M']) ||
		            (months < thresholds.M && ['MM', months]) ||
		            (years <= 1 && ['y']) || ['yy', years];

		        a[2] = withoutSuffix;
		        a[3] = +posNegDuration > 0;
		        a[4] = locale;
		        return substituteTimeAgo.apply(null, a);
		    }

		    // This function allows you to set the rounding function for relative time strings
		    function getSetRelativeTimeRounding(roundingFunction) {
		        if (roundingFunction === undefined) {
		            return round;
		        }
		        if (typeof roundingFunction === 'function') {
		            round = roundingFunction;
		            return true;
		        }
		        return false;
		    }

		    // This function allows you to set a threshold for relative time strings
		    function getSetRelativeTimeThreshold(threshold, limit) {
		        if (thresholds[threshold] === undefined) {
		            return false;
		        }
		        if (limit === undefined) {
		            return thresholds[threshold];
		        }
		        thresholds[threshold] = limit;
		        if (threshold === 's') {
		            thresholds.ss = limit - 1;
		        }
		        return true;
		    }

		    function humanize(argWithSuffix, argThresholds) {
		        if (!this.isValid()) {
		            return this.localeData().invalidDate();
		        }

		        var withSuffix = false,
		            th = thresholds,
		            locale,
		            output;

		        if (typeof argWithSuffix === 'object') {
		            argThresholds = argWithSuffix;
		            argWithSuffix = false;
		        }
		        if (typeof argWithSuffix === 'boolean') {
		            withSuffix = argWithSuffix;
		        }
		        if (typeof argThresholds === 'object') {
		            th = Object.assign({}, thresholds, argThresholds);
		            if (argThresholds.s != null && argThresholds.ss == null) {
		                th.ss = argThresholds.s - 1;
		            }
		        }

		        locale = this.localeData();
		        output = relativeTime$1(this, !withSuffix, th, locale);

		        if (withSuffix) {
		            output = locale.pastFuture(+this, output);
		        }

		        return locale.postformat(output);
		    }

		    var abs$1 = Math.abs;

		    function sign(x) {
		        return (x > 0) - (x < 0) || +x;
		    }

		    function toISOString$1() {
		        // for ISO strings we do not use the normal bubbling rules:
		        //  * milliseconds bubble up until they become hours
		        //  * days do not bubble at all
		        //  * months bubble up until they become years
		        // This is because there is no context-free conversion between hours and days
		        // (think of clock changes)
		        // and also not between days and months (28-31 days per month)
		        if (!this.isValid()) {
		            return this.localeData().invalidDate();
		        }

		        var seconds = abs$1(this._milliseconds) / 1000,
		            days = abs$1(this._days),
		            months = abs$1(this._months),
		            minutes,
		            hours,
		            years,
		            s,
		            total = this.asSeconds(),
		            totalSign,
		            ymSign,
		            daysSign,
		            hmsSign;

		        if (!total) {
		            // this is the same as C#'s (Noda) and python (isodate)...
		            // but not other JS (goog.date)
		            return 'P0D';
		        }

		        // 3600 seconds -> 60 minutes -> 1 hour
		        minutes = absFloor(seconds / 60);
		        hours = absFloor(minutes / 60);
		        seconds %= 60;
		        minutes %= 60;

		        // 12 months -> 1 year
		        years = absFloor(months / 12);
		        months %= 12;

		        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
		        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

		        totalSign = total < 0 ? '-' : '';
		        ymSign = sign(this._months) !== sign(total) ? '-' : '';
		        daysSign = sign(this._days) !== sign(total) ? '-' : '';
		        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

		        return (
		            totalSign +
		            'P' +
		            (years ? ymSign + years + 'Y' : '') +
		            (months ? ymSign + months + 'M' : '') +
		            (days ? daysSign + days + 'D' : '') +
		            (hours || minutes || seconds ? 'T' : '') +
		            (hours ? hmsSign + hours + 'H' : '') +
		            (minutes ? hmsSign + minutes + 'M' : '') +
		            (seconds ? hmsSign + s + 'S' : '')
		        );
		    }

		    var proto$2 = Duration.prototype;

		    proto$2.isValid = isValid$1;
		    proto$2.abs = abs;
		    proto$2.add = add$1;
		    proto$2.subtract = subtract$1;
		    proto$2.as = as;
		    proto$2.asMilliseconds = asMilliseconds;
		    proto$2.asSeconds = asSeconds;
		    proto$2.asMinutes = asMinutes;
		    proto$2.asHours = asHours;
		    proto$2.asDays = asDays;
		    proto$2.asWeeks = asWeeks;
		    proto$2.asMonths = asMonths;
		    proto$2.asQuarters = asQuarters;
		    proto$2.asYears = asYears;
		    proto$2.valueOf = valueOf$1;
		    proto$2._bubble = bubble;
		    proto$2.clone = clone$1;
		    proto$2.get = get$2;
		    proto$2.milliseconds = milliseconds;
		    proto$2.seconds = seconds;
		    proto$2.minutes = minutes;
		    proto$2.hours = hours;
		    proto$2.days = days;
		    proto$2.weeks = weeks;
		    proto$2.months = months;
		    proto$2.years = years;
		    proto$2.humanize = humanize;
		    proto$2.toISOString = toISOString$1;
		    proto$2.toString = toISOString$1;
		    proto$2.toJSON = toISOString$1;
		    proto$2.locale = locale;
		    proto$2.localeData = localeData;

		    proto$2.toIsoString = deprecate(
		        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
		        toISOString$1
		    );
		    proto$2.lang = lang;

		    // FORMATTING

		    addFormatToken('X', 0, 0, 'unix');
		    addFormatToken('x', 0, 0, 'valueOf');

		    // PARSING

		    addRegexToken('x', matchSigned);
		    addRegexToken('X', matchTimestamp);
		    addParseToken('X', function (input, array, config) {
		        config._d = new Date(parseFloat(input) * 1000);
		    });
		    addParseToken('x', function (input, array, config) {
		        config._d = new Date(toInt(input));
		    });

		    //! moment.js

		    hooks.version = '2.29.4';

		    setHookCallback(createLocal);

		    hooks.fn = proto;
		    hooks.min = min;
		    hooks.max = max;
		    hooks.now = now;
		    hooks.utc = createUTC;
		    hooks.unix = createUnix;
		    hooks.months = listMonths;
		    hooks.isDate = isDate;
		    hooks.locale = getSetGlobalLocale;
		    hooks.invalid = createInvalid;
		    hooks.duration = createDuration;
		    hooks.isMoment = isMoment;
		    hooks.weekdays = listWeekdays;
		    hooks.parseZone = createInZone;
		    hooks.localeData = getLocale;
		    hooks.isDuration = isDuration;
		    hooks.monthsShort = listMonthsShort;
		    hooks.weekdaysMin = listWeekdaysMin;
		    hooks.defineLocale = defineLocale;
		    hooks.updateLocale = updateLocale;
		    hooks.locales = listLocales;
		    hooks.weekdaysShort = listWeekdaysShort;
		    hooks.normalizeUnits = normalizeUnits;
		    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
		    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
		    hooks.calendarFormat = getCalendarFormat;
		    hooks.prototype = proto;

		    // currently HTML5 input type only supports 24-hour formats
		    hooks.HTML5_FMT = {
		        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
		        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
		        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
		        DATE: 'YYYY-MM-DD', // <input type="date" />
		        TIME: 'HH:mm', // <input type="time" />
		        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
		        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
		        WEEK: 'GGGG-[W]WW', // <input type="week" />
		        MONTH: 'YYYY-MM', // <input type="month" />
		    };

		    return hooks;

		}))); 
	} (moment$2));

	var momentExports = moment$2.exports;
	var moment$1 = /*@__PURE__*/getDefaultExportFromCjs(momentExports);

	(function (module, exports) {
		!function(e,a){"function"==typeof commonjsRequire?a(momentExports):a(e.moment);}(commonjsGlobal,function(e){e.defineLocale("af",{months:"Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"),monthsShort:"Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),weekdays:"Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"),weekdaysShort:"Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),weekdaysMin:"So_Ma_Di_Wo_Do_Vr_Sa".split("_"),meridiemParse:/vm|nm/i,isPM:function(e){return /^nm$/i.test(e)},meridiem:function(e,a,_){return e<12?_?"vm":"VM":_?"nm":"NM"},longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Vandag om] LT",nextDay:"[M\xf4re om] LT",nextWeek:"dddd [om] LT",lastDay:"[Gister om] LT",lastWeek:"[Laas] dddd [om] LT",sameElse:"L"},relativeTime:{future:"oor %s",past:"%s gelede",s:"'n paar sekondes",ss:"%d sekondes",m:"'n minuut",mm:"%d minute",h:"'n uur",hh:"%d ure",d:"'n dag",dd:"%d dae",M:"'n maand",MM:"%d maande",y:"'n jaar",yy:"%d jaar"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||20<=e?"ste":"de")},week:{dow:1,doy:4}});function E(e){return 0===e?0:1===e?1:2===e?2:3<=e%100&&e%100<=10?3:11<=e%100?4:5}function a(n){return function(e,a,_,s){var d=E(e),t=J[n][E(e)];return (t=2===d?t[a?0:1]:t).replace(/%d/i,e)}}function F(e){return 0===e?0:1===e?1:2===e?2:3<=e%100&&e%100<=10?3:11<=e%100?4:5}function _(n){return function(e,a,_,s){var d=F(e),t=N[n][F(e)];return (t=2===d?t[a?0:1]:t).replace(/%d/i,e)}}function z(e){return 0===e?0:1===e?1:2===e?2:3<=e%100&&e%100<=10?3:11<=e%100?4:5}function s(n){return function(e,a,_,s){var d=z(e),t=B[n][z(e)];return (t=2===d?t[a?0:1]:t).replace(/%d/i,e)}}var J={s:["\u0623\u0642\u0644 \u0645\u0646 \u062b\u0627\u0646\u064a\u0629","\u062b\u0627\u0646\u064a\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062b\u0627\u0646\u064a\u062a\u0627\u0646","\u062b\u0627\u0646\u064a\u062a\u064a\u0646"],"%d \u062b\u0648\u0627\u0646","%d \u062b\u0627\u0646\u064a\u0629","%d \u062b\u0627\u0646\u064a\u0629"],m:["\u0623\u0642\u0644 \u0645\u0646 \u062f\u0642\u064a\u0642\u0629","\u062f\u0642\u064a\u0642\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062f\u0642\u064a\u0642\u062a\u0627\u0646","\u062f\u0642\u064a\u0642\u062a\u064a\u0646"],"%d \u062f\u0642\u0627\u0626\u0642","%d \u062f\u0642\u064a\u0642\u0629","%d \u062f\u0642\u064a\u0642\u0629"],h:["\u0623\u0642\u0644 \u0645\u0646 \u0633\u0627\u0639\u0629","\u0633\u0627\u0639\u0629 \u0648\u0627\u062d\u062f\u0629",["\u0633\u0627\u0639\u062a\u0627\u0646","\u0633\u0627\u0639\u062a\u064a\u0646"],"%d \u0633\u0627\u0639\u0627\u062a","%d \u0633\u0627\u0639\u0629","%d \u0633\u0627\u0639\u0629"],d:["\u0623\u0642\u0644 \u0645\u0646 \u064a\u0648\u0645","\u064a\u0648\u0645 \u0648\u0627\u062d\u062f",["\u064a\u0648\u0645\u0627\u0646","\u064a\u0648\u0645\u064a\u0646"],"%d \u0623\u064a\u0627\u0645","%d \u064a\u0648\u0645\u064b\u0627","%d \u064a\u0648\u0645"],M:["\u0623\u0642\u0644 \u0645\u0646 \u0634\u0647\u0631","\u0634\u0647\u0631 \u0648\u0627\u062d\u062f",["\u0634\u0647\u0631\u0627\u0646","\u0634\u0647\u0631\u064a\u0646"],"%d \u0623\u0634\u0647\u0631","%d \u0634\u0647\u0631\u0627","%d \u0634\u0647\u0631"],y:["\u0623\u0642\u0644 \u0645\u0646 \u0639\u0627\u0645","\u0639\u0627\u0645 \u0648\u0627\u062d\u062f",["\u0639\u0627\u0645\u0627\u0646","\u0639\u0627\u0645\u064a\u0646"],"%d \u0623\u0639\u0648\u0627\u0645","%d \u0639\u0627\u0645\u064b\u0627","%d \u0639\u0627\u0645"]},d=["\u062c\u0627\u0646\u0641\u064a","\u0641\u064a\u0641\u0631\u064a","\u0645\u0627\u0631\u0633","\u0623\u0641\u0631\u064a\u0644","\u0645\u0627\u064a","\u062c\u0648\u0627\u0646","\u062c\u0648\u064a\u0644\u064a\u0629","\u0623\u0648\u062a","\u0633\u0628\u062a\u0645\u0628\u0631","\u0623\u0643\u062a\u0648\u0628\u0631","\u0646\u0648\u0641\u0645\u0628\u0631","\u062f\u064a\u0633\u0645\u0628\u0631"],I=(e.defineLocale("ar-dz",{months:d,monthsShort:d,weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"D/\u200fM/\u200fYYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0635|\u0645/,isPM:function(e){return "\u0645"===e},meridiem:function(e,a,_){return e<12?"\u0635":"\u0645"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u064b\u0627 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0628\u0639\u062f %s",past:"\u0645\u0646\u0630 %s",s:a("s"),ss:a("s"),m:a("m"),mm:a("m"),h:a("h"),hh:a("h"),d:a("d"),dd:a("d"),M:a("M"),MM:a("M"),y:a("y"),yy:a("y")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:0,doy:4}}),e.defineLocale("ar-kw",{months:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648\u0632_\u063a\u0634\u062a_\u0634\u062a\u0646\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0646\u0628\u0631_\u062f\u062c\u0646\u0628\u0631".split("_"),monthsShort:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648\u0632_\u063a\u0634\u062a_\u0634\u062a\u0646\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0646\u0628\u0631_\u062f\u062c\u0646\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062a\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0627\u062d\u062f_\u0627\u062a\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},week:{dow:0,doy:12}}),{1:"1",2:"2",3:"3",4:"4",5:"5",6:"6",7:"7",8:"8",9:"9",0:"0"}),N={s:["\u0623\u0642\u0644 \u0645\u0646 \u062b\u0627\u0646\u064a\u0629","\u062b\u0627\u0646\u064a\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062b\u0627\u0646\u064a\u062a\u0627\u0646","\u062b\u0627\u0646\u064a\u062a\u064a\u0646"],"%d \u062b\u0648\u0627\u0646","%d \u062b\u0627\u0646\u064a\u0629","%d \u062b\u0627\u0646\u064a\u0629"],m:["\u0623\u0642\u0644 \u0645\u0646 \u062f\u0642\u064a\u0642\u0629","\u062f\u0642\u064a\u0642\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062f\u0642\u064a\u0642\u062a\u0627\u0646","\u062f\u0642\u064a\u0642\u062a\u064a\u0646"],"%d \u062f\u0642\u0627\u0626\u0642","%d \u062f\u0642\u064a\u0642\u0629","%d \u062f\u0642\u064a\u0642\u0629"],h:["\u0623\u0642\u0644 \u0645\u0646 \u0633\u0627\u0639\u0629","\u0633\u0627\u0639\u0629 \u0648\u0627\u062d\u062f\u0629",["\u0633\u0627\u0639\u062a\u0627\u0646","\u0633\u0627\u0639\u062a\u064a\u0646"],"%d \u0633\u0627\u0639\u0627\u062a","%d \u0633\u0627\u0639\u0629","%d \u0633\u0627\u0639\u0629"],d:["\u0623\u0642\u0644 \u0645\u0646 \u064a\u0648\u0645","\u064a\u0648\u0645 \u0648\u0627\u062d\u062f",["\u064a\u0648\u0645\u0627\u0646","\u064a\u0648\u0645\u064a\u0646"],"%d \u0623\u064a\u0627\u0645","%d \u064a\u0648\u0645\u064b\u0627","%d \u064a\u0648\u0645"],M:["\u0623\u0642\u0644 \u0645\u0646 \u0634\u0647\u0631","\u0634\u0647\u0631 \u0648\u0627\u062d\u062f",["\u0634\u0647\u0631\u0627\u0646","\u0634\u0647\u0631\u064a\u0646"],"%d \u0623\u0634\u0647\u0631","%d \u0634\u0647\u0631\u0627","%d \u0634\u0647\u0631"],y:["\u0623\u0642\u0644 \u0645\u0646 \u0639\u0627\u0645","\u0639\u0627\u0645 \u0648\u0627\u062d\u062f",["\u0639\u0627\u0645\u0627\u0646","\u0639\u0627\u0645\u064a\u0646"],"%d \u0623\u0639\u0648\u0627\u0645","%d \u0639\u0627\u0645\u064b\u0627","%d \u0639\u0627\u0645"]},d=["\u064a\u0646\u0627\u064a\u0631","\u0641\u0628\u0631\u0627\u064a\u0631","\u0645\u0627\u0631\u0633","\u0623\u0628\u0631\u064a\u0644","\u0645\u0627\u064a\u0648","\u064a\u0648\u0646\u064a\u0648","\u064a\u0648\u0644\u064a\u0648","\u0623\u063a\u0633\u0637\u0633","\u0633\u0628\u062a\u0645\u0628\u0631","\u0623\u0643\u062a\u0648\u0628\u0631","\u0646\u0648\u0641\u0645\u0628\u0631","\u062f\u064a\u0633\u0645\u0628\u0631"],R=(e.defineLocale("ar-ly",{months:d,monthsShort:d,weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"D/\u200fM/\u200fYYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0635|\u0645/,isPM:function(e){return "\u0645"===e},meridiem:function(e,a,_){return e<12?"\u0635":"\u0645"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u064b\u0627 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0628\u0639\u062f %s",past:"\u0645\u0646\u0630 %s",s:_("s"),ss:_("s"),m:_("m"),mm:_("m"),h:_("h"),hh:_("h"),d:_("d"),dd:_("d"),M:_("M"),MM:_("M"),y:_("y"),yy:_("y")},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return I[e]}).replace(/,/g,"\u060c")},week:{dow:6,doy:12}}),e.defineLocale("ar-ma",{months:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648\u0632_\u063a\u0634\u062a_\u0634\u062a\u0646\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0646\u0628\u0631_\u062f\u062c\u0646\u0628\u0631".split("_"),monthsShort:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648\u0632_\u063a\u0634\u062a_\u0634\u062a\u0646\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0646\u0628\u0631_\u062f\u062c\u0646\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0627\u062d\u062f_\u0627\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},week:{dow:1,doy:4}}),{1:"\u0661",2:"\u0662",3:"\u0663",4:"\u0664",5:"\u0665",6:"\u0666",7:"\u0667",8:"\u0668",9:"\u0669",0:"\u0660"}),C={"\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u0660":"0"},K=(e.defineLocale("ar-sa",{months:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a\u0648_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648_\u0623\u063a\u0633\u0637\u0633_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),monthsShort:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a\u0648_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648_\u0623\u063a\u0633\u0637\u0633_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0635|\u0645/,isPM:function(e){return "\u0645"===e},meridiem:function(e,a,_){return e<12?"\u0635":"\u0645"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},preparse:function(e){return e.replace(/[\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660]/g,function(e){return C[e]}).replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return R[e]}).replace(/,/g,"\u060c")},week:{dow:0,doy:6}}),e.defineLocale("ar-tn",{months:"\u062c\u0627\u0646\u0641\u064a_\u0641\u064a\u0641\u0631\u064a_\u0645\u0627\u0631\u0633_\u0623\u0641\u0631\u064a\u0644_\u0645\u0627\u064a_\u062c\u0648\u0627\u0646_\u062c\u0648\u064a\u0644\u064a\u0629_\u0623\u0648\u062a_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),monthsShort:"\u062c\u0627\u0646\u0641\u064a_\u0641\u064a\u0641\u0631\u064a_\u0645\u0627\u0631\u0633_\u0623\u0641\u0631\u064a\u0644_\u0645\u0627\u064a_\u062c\u0648\u0627\u0646_\u062c\u0648\u064a\u0644\u064a\u0629_\u0623\u0648\u062a_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},week:{dow:1,doy:4}}),{1:"\u0661",2:"\u0662",3:"\u0663",4:"\u0664",5:"\u0665",6:"\u0666",7:"\u0667",8:"\u0668",9:"\u0669",0:"\u0660"}),G={"\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u0660":"0"},B={s:["\u0623\u0642\u0644 \u0645\u0646 \u062b\u0627\u0646\u064a\u0629","\u062b\u0627\u0646\u064a\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062b\u0627\u0646\u064a\u062a\u0627\u0646","\u062b\u0627\u0646\u064a\u062a\u064a\u0646"],"%d \u062b\u0648\u0627\u0646","%d \u062b\u0627\u0646\u064a\u0629","%d \u062b\u0627\u0646\u064a\u0629"],m:["\u0623\u0642\u0644 \u0645\u0646 \u062f\u0642\u064a\u0642\u0629","\u062f\u0642\u064a\u0642\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062f\u0642\u064a\u0642\u062a\u0627\u0646","\u062f\u0642\u064a\u0642\u062a\u064a\u0646"],"%d \u062f\u0642\u0627\u0626\u0642","%d \u062f\u0642\u064a\u0642\u0629","%d \u062f\u0642\u064a\u0642\u0629"],h:["\u0623\u0642\u0644 \u0645\u0646 \u0633\u0627\u0639\u0629","\u0633\u0627\u0639\u0629 \u0648\u0627\u062d\u062f\u0629",["\u0633\u0627\u0639\u062a\u0627\u0646","\u0633\u0627\u0639\u062a\u064a\u0646"],"%d \u0633\u0627\u0639\u0627\u062a","%d \u0633\u0627\u0639\u0629","%d \u0633\u0627\u0639\u0629"],d:["\u0623\u0642\u0644 \u0645\u0646 \u064a\u0648\u0645","\u064a\u0648\u0645 \u0648\u0627\u062d\u062f",["\u064a\u0648\u0645\u0627\u0646","\u064a\u0648\u0645\u064a\u0646"],"%d \u0623\u064a\u0627\u0645","%d \u064a\u0648\u0645\u064b\u0627","%d \u064a\u0648\u0645"],M:["\u0623\u0642\u0644 \u0645\u0646 \u0634\u0647\u0631","\u0634\u0647\u0631 \u0648\u0627\u062d\u062f",["\u0634\u0647\u0631\u0627\u0646","\u0634\u0647\u0631\u064a\u0646"],"%d \u0623\u0634\u0647\u0631","%d \u0634\u0647\u0631\u0627","%d \u0634\u0647\u0631"],y:["\u0623\u0642\u0644 \u0645\u0646 \u0639\u0627\u0645","\u0639\u0627\u0645 \u0648\u0627\u062d\u062f",["\u0639\u0627\u0645\u0627\u0646","\u0639\u0627\u0645\u064a\u0646"],"%d \u0623\u0639\u0648\u0627\u0645","%d \u0639\u0627\u0645\u064b\u0627","%d \u0639\u0627\u0645"]},d=["\u064a\u0646\u0627\u064a\u0631","\u0641\u0628\u0631\u0627\u064a\u0631","\u0645\u0627\u0631\u0633","\u0623\u0628\u0631\u064a\u0644","\u0645\u0627\u064a\u0648","\u064a\u0648\u0646\u064a\u0648","\u064a\u0648\u0644\u064a\u0648","\u0623\u063a\u0633\u0637\u0633","\u0633\u0628\u062a\u0645\u0628\u0631","\u0623\u0643\u062a\u0648\u0628\u0631","\u0646\u0648\u0641\u0645\u0628\u0631","\u062f\u064a\u0633\u0645\u0628\u0631"],q=(e.defineLocale("ar",{months:d,monthsShort:d,weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"D/\u200fM/\u200fYYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0635|\u0645/,isPM:function(e){return "\u0645"===e},meridiem:function(e,a,_){return e<12?"\u0635":"\u0645"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u064b\u0627 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0628\u0639\u062f %s",past:"\u0645\u0646\u0630 %s",s:s("s"),ss:s("s"),m:s("m"),mm:s("m"),h:s("h"),hh:s("h"),d:s("d"),dd:s("d"),M:s("M"),MM:s("M"),y:s("y"),yy:s("y")},preparse:function(e){return e.replace(/[\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660]/g,function(e){return G[e]}).replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return K[e]}).replace(/,/g,"\u060c")},week:{dow:6,doy:12}}),{1:"-inci",5:"-inci",8:"-inci",70:"-inci",80:"-inci",2:"-nci",7:"-nci",20:"-nci",50:"-nci",3:"-\xfcnc\xfc",4:"-\xfcnc\xfc",100:"-\xfcnc\xfc",6:"-nc\u0131",9:"-uncu",10:"-uncu",30:"-uncu",60:"-\u0131nc\u0131",90:"-\u0131nc\u0131"});function t(e,a,_){return "m"===_?a?"\u0445\u0432\u0456\u043b\u0456\u043d\u0430":"\u0445\u0432\u0456\u043b\u0456\u043d\u0443":"h"===_?a?"\u0433\u0430\u0434\u0437\u0456\u043d\u0430":"\u0433\u0430\u0434\u0437\u0456\u043d\u0443":e+" "+(e=+e,a=(a={ss:a?"\u0441\u0435\u043a\u0443\u043d\u0434\u0430_\u0441\u0435\u043a\u0443\u043d\u0434\u044b_\u0441\u0435\u043a\u0443\u043d\u0434":"\u0441\u0435\u043a\u0443\u043d\u0434\u0443_\u0441\u0435\u043a\u0443\u043d\u0434\u044b_\u0441\u0435\u043a\u0443\u043d\u0434",mm:a?"\u0445\u0432\u0456\u043b\u0456\u043d\u0430_\u0445\u0432\u0456\u043b\u0456\u043d\u044b_\u0445\u0432\u0456\u043b\u0456\u043d":"\u0445\u0432\u0456\u043b\u0456\u043d\u0443_\u0445\u0432\u0456\u043b\u0456\u043d\u044b_\u0445\u0432\u0456\u043b\u0456\u043d",hh:a?"\u0433\u0430\u0434\u0437\u0456\u043d\u0430_\u0433\u0430\u0434\u0437\u0456\u043d\u044b_\u0433\u0430\u0434\u0437\u0456\u043d":"\u0433\u0430\u0434\u0437\u0456\u043d\u0443_\u0433\u0430\u0434\u0437\u0456\u043d\u044b_\u0433\u0430\u0434\u0437\u0456\u043d",dd:"\u0434\u0437\u0435\u043d\u044c_\u0434\u043d\u0456_\u0434\u0437\u0451\u043d",MM:"\u043c\u0435\u0441\u044f\u0446_\u043c\u0435\u0441\u044f\u0446\u044b_\u043c\u0435\u0441\u044f\u0446\u0430\u045e",yy:"\u0433\u043e\u0434_\u0433\u0430\u0434\u044b_\u0433\u0430\u0434\u043e\u045e"}[_]).split("_"),e%10==1&&e%100!=11?a[0]:2<=e%10&&e%10<=4&&(e%100<10||20<=e%100)?a[1]:a[2])}e.defineLocale("az",{months:"yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"),monthsShort:"yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),weekdays:"Bazar_Bazar ert\u0259si_\xc7\u0259r\u015f\u0259nb\u0259 ax\u015fam\u0131_\xc7\u0259r\u015f\u0259nb\u0259_C\xfcm\u0259 ax\u015fam\u0131_C\xfcm\u0259_\u015e\u0259nb\u0259".split("_"),weekdaysShort:"Baz_BzE_\xc7Ax_\xc7\u0259r_CAx_C\xfcm_\u015e\u0259n".split("_"),weekdaysMin:"Bz_BE_\xc7A_\xc7\u0259_CA_C\xfc_\u015e\u0259".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[bug\xfcn saat] LT",nextDay:"[sabah saat] LT",nextWeek:"[g\u0259l\u0259n h\u0259ft\u0259] dddd [saat] LT",lastDay:"[d\xfcn\u0259n] LT",lastWeek:"[ke\xe7\u0259n h\u0259ft\u0259] dddd [saat] LT",sameElse:"L"},relativeTime:{future:"%s sonra",past:"%s \u0259vv\u0259l",s:"bir ne\xe7\u0259 saniy\u0259",ss:"%d saniy\u0259",m:"bir d\u0259qiq\u0259",mm:"%d d\u0259qiq\u0259",h:"bir saat",hh:"%d saat",d:"bir g\xfcn",dd:"%d g\xfcn",M:"bir ay",MM:"%d ay",y:"bir il",yy:"%d il"},meridiemParse:/gec\u0259|s\u0259h\u0259r|g\xfcnd\xfcz|ax\u015fam/,isPM:function(e){return /^(g\xfcnd\xfcz|ax\u015fam)$/.test(e)},meridiem:function(e,a,_){return e<4?"gec\u0259":e<12?"s\u0259h\u0259r":e<17?"g\xfcnd\xfcz":"ax\u015fam"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0131nc\u0131|inci|nci|\xfcnc\xfc|nc\u0131|uncu)/,ordinal:function(e){if(0===e)return e+"-\u0131nc\u0131";var a=e%10;return e+(q[a]||q[e%100-a]||q[100<=e?100:null])},week:{dow:1,doy:7}}),e.defineLocale("be",{months:{format:"\u0441\u0442\u0443\u0434\u0437\u0435\u043d\u044f_\u043b\u044e\u0442\u0430\u0433\u0430_\u0441\u0430\u043a\u0430\u0432\u0456\u043a\u0430_\u043a\u0440\u0430\u0441\u0430\u0432\u0456\u043a\u0430_\u0442\u0440\u0430\u045e\u043d\u044f_\u0447\u044d\u0440\u0432\u0435\u043d\u044f_\u043b\u0456\u043f\u0435\u043d\u044f_\u0436\u043d\u0456\u045e\u043d\u044f_\u0432\u0435\u0440\u0430\u0441\u043d\u044f_\u043a\u0430\u0441\u0442\u0440\u044b\u0447\u043d\u0456\u043a\u0430_\u043b\u0456\u0441\u0442\u0430\u043f\u0430\u0434\u0430_\u0441\u043d\u0435\u0436\u043d\u044f".split("_"),standalone:"\u0441\u0442\u0443\u0434\u0437\u0435\u043d\u044c_\u043b\u044e\u0442\u044b_\u0441\u0430\u043a\u0430\u0432\u0456\u043a_\u043a\u0440\u0430\u0441\u0430\u0432\u0456\u043a_\u0442\u0440\u0430\u0432\u0435\u043d\u044c_\u0447\u044d\u0440\u0432\u0435\u043d\u044c_\u043b\u0456\u043f\u0435\u043d\u044c_\u0436\u043d\u0456\u0432\u0435\u043d\u044c_\u0432\u0435\u0440\u0430\u0441\u0435\u043d\u044c_\u043a\u0430\u0441\u0442\u0440\u044b\u0447\u043d\u0456\u043a_\u043b\u0456\u0441\u0442\u0430\u043f\u0430\u0434_\u0441\u043d\u0435\u0436\u0430\u043d\u044c".split("_")},monthsShort:"\u0441\u0442\u0443\u0434_\u043b\u044e\u0442_\u0441\u0430\u043a_\u043a\u0440\u0430\u0441_\u0442\u0440\u0430\u0432_\u0447\u044d\u0440\u0432_\u043b\u0456\u043f_\u0436\u043d\u0456\u0432_\u0432\u0435\u0440_\u043a\u0430\u0441\u0442_\u043b\u0456\u0441\u0442_\u0441\u043d\u0435\u0436".split("_"),weekdays:{format:"\u043d\u044f\u0434\u0437\u0435\u043b\u044e_\u043f\u0430\u043d\u044f\u0434\u0437\u0435\u043b\u0430\u043a_\u0430\u045e\u0442\u043e\u0440\u0430\u043a_\u0441\u0435\u0440\u0430\u0434\u0443_\u0447\u0430\u0446\u0432\u0435\u0440_\u043f\u044f\u0442\u043d\u0456\u0446\u0443_\u0441\u0443\u0431\u043e\u0442\u0443".split("_"),standalone:"\u043d\u044f\u0434\u0437\u0435\u043b\u044f_\u043f\u0430\u043d\u044f\u0434\u0437\u0435\u043b\u0430\u043a_\u0430\u045e\u0442\u043e\u0440\u0430\u043a_\u0441\u0435\u0440\u0430\u0434\u0430_\u0447\u0430\u0446\u0432\u0435\u0440_\u043f\u044f\u0442\u043d\u0456\u0446\u0430_\u0441\u0443\u0431\u043e\u0442\u0430".split("_"),isFormat:/\[ ?[\u0423\u0443\u045e] ?(?:\u043c\u0456\u043d\u0443\u043b\u0443\u044e|\u043d\u0430\u0441\u0442\u0443\u043f\u043d\u0443\u044e)? ?\] ?dddd/},weekdaysShort:"\u043d\u0434_\u043f\u043d_\u0430\u0442_\u0441\u0440_\u0447\u0446_\u043f\u0442_\u0441\u0431".split("_"),weekdaysMin:"\u043d\u0434_\u043f\u043d_\u0430\u0442_\u0441\u0440_\u0447\u0446_\u043f\u0442_\u0441\u0431".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY \u0433.",LLL:"D MMMM YYYY \u0433., HH:mm",LLLL:"dddd, D MMMM YYYY \u0433., HH:mm"},calendar:{sameDay:"[\u0421\u0451\u043d\u043d\u044f \u045e] LT",nextDay:"[\u0417\u0430\u045e\u0442\u0440\u0430 \u045e] LT",lastDay:"[\u0423\u0447\u043e\u0440\u0430 \u045e] LT",nextWeek:function(){return "[\u0423] dddd [\u045e] LT"},lastWeek:function(){switch(this.day()){case 0:case 3:case 5:case 6:return "[\u0423 \u043c\u0456\u043d\u0443\u043b\u0443\u044e] dddd [\u045e] LT";case 1:case 2:case 4:return "[\u0423 \u043c\u0456\u043d\u0443\u043b\u044b] dddd [\u045e] LT"}},sameElse:"L"},relativeTime:{future:"\u043f\u0440\u0430\u0437 %s",past:"%s \u0442\u0430\u043c\u0443",s:"\u043d\u0435\u043a\u0430\u043b\u044c\u043a\u0456 \u0441\u0435\u043a\u0443\u043d\u0434",m:t,mm:t,h:t,hh:t,d:"\u0434\u0437\u0435\u043d\u044c",dd:t,M:"\u043c\u0435\u0441\u044f\u0446",MM:t,y:"\u0433\u043e\u0434",yy:t},meridiemParse:/\u043d\u043e\u0447\u044b|\u0440\u0430\u043d\u0456\u0446\u044b|\u0434\u043d\u044f|\u0432\u0435\u0447\u0430\u0440\u0430/,isPM:function(e){return /^(\u0434\u043d\u044f|\u0432\u0435\u0447\u0430\u0440\u0430)$/.test(e)},meridiem:function(e,a,_){return e<4?"\u043d\u043e\u0447\u044b":e<12?"\u0440\u0430\u043d\u0456\u0446\u044b":e<17?"\u0434\u043d\u044f":"\u0432\u0435\u0447\u0430\u0440\u0430"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0456|\u044b|\u0433\u0430)/,ordinal:function(e,a){switch(a){case"M":case"d":case"DDD":case"w":case"W":return e%10!=2&&e%10!=3||e%100==12||e%100==13?e+"-\u044b":e+"-\u0456";case"D":return e+"-\u0433\u0430";default:return e}},week:{dow:1,doy:7}}),e.defineLocale("bg",{months:"\u044f\u043d\u0443\u0430\u0440\u0438_\u0444\u0435\u0432\u0440\u0443\u0430\u0440\u0438_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0438\u043b_\u043c\u0430\u0439_\u044e\u043d\u0438_\u044e\u043b\u0438_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043f\u0442\u0435\u043c\u0432\u0440\u0438_\u043e\u043a\u0442\u043e\u043c\u0432\u0440\u0438_\u043d\u043e\u0435\u043c\u0432\u0440\u0438_\u0434\u0435\u043a\u0435\u043c\u0432\u0440\u0438".split("_"),monthsShort:"\u044f\u043d\u0443_\u0444\u0435\u0432_\u043c\u0430\u0440_\u0430\u043f\u0440_\u043c\u0430\u0439_\u044e\u043d\u0438_\u044e\u043b\u0438_\u0430\u0432\u0433_\u0441\u0435\u043f_\u043e\u043a\u0442_\u043d\u043e\u0435_\u0434\u0435\u043a".split("_"),weekdays:"\u043d\u0435\u0434\u0435\u043b\u044f_\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u043d\u0438\u043a_\u0432\u0442\u043e\u0440\u043d\u0438\u043a_\u0441\u0440\u044f\u0434\u0430_\u0447\u0435\u0442\u0432\u044a\u0440\u0442\u044a\u043a_\u043f\u0435\u0442\u044a\u043a_\u0441\u044a\u0431\u043e\u0442\u0430".split("_"),weekdaysShort:"\u043d\u0435\u0434_\u043f\u043e\u043d_\u0432\u0442\u043e_\u0441\u0440\u044f_\u0447\u0435\u0442_\u043f\u0435\u0442_\u0441\u044a\u0431".split("_"),weekdaysMin:"\u043d\u0434_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"D.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY H:mm",LLLL:"dddd, D MMMM YYYY H:mm"},calendar:{sameDay:"[\u0414\u043d\u0435\u0441 \u0432] LT",nextDay:"[\u0423\u0442\u0440\u0435 \u0432] LT",nextWeek:"dddd [\u0432] LT",lastDay:"[\u0412\u0447\u0435\u0440\u0430 \u0432] LT",lastWeek:function(){switch(this.day()){case 0:case 3:case 6:return "[\u041c\u0438\u043d\u0430\u043b\u0430\u0442\u0430] dddd [\u0432] LT";case 1:case 2:case 4:case 5:return "[\u041c\u0438\u043d\u0430\u043b\u0438\u044f] dddd [\u0432] LT"}},sameElse:"L"},relativeTime:{future:"\u0441\u043b\u0435\u0434 %s",past:"\u043f\u0440\u0435\u0434\u0438 %s",s:"\u043d\u044f\u043a\u043e\u043b\u043a\u043e \u0441\u0435\u043a\u0443\u043d\u0434\u0438",ss:"%d \u0441\u0435\u043a\u0443\u043d\u0434\u0438",m:"\u043c\u0438\u043d\u0443\u0442\u0430",mm:"%d \u043c\u0438\u043d\u0443\u0442\u0438",h:"\u0447\u0430\u0441",hh:"%d \u0447\u0430\u0441\u0430",d:"\u0434\u0435\u043d",dd:"%d \u0434\u0435\u043d\u0430",w:"\u0441\u0435\u0434\u043c\u0438\u0446\u0430",ww:"%d \u0441\u0435\u0434\u043c\u0438\u0446\u0438",M:"\u043c\u0435\u0441\u0435\u0446",MM:"%d \u043c\u0435\u0441\u0435\u0446\u0430",y:"\u0433\u043e\u0434\u0438\u043d\u0430",yy:"%d \u0433\u043e\u0434\u0438\u043d\u0438"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0435\u0432|\u0435\u043d|\u0442\u0438|\u0432\u0438|\u0440\u0438|\u043c\u0438)/,ordinal:function(e){var a=e%10,_=e%100;return 0===e?e+"-\u0435\u0432":0==_?e+"-\u0435\u043d":10<_&&_<20?e+"-\u0442\u0438":1==a?e+"-\u0432\u0438":2==a?e+"-\u0440\u0438":7==a||8==a?e+"-\u043c\u0438":e+"-\u0442\u0438"},week:{dow:1,doy:7}}),e.defineLocale("bm",{months:"Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_M\u025bkalo_Zuw\u025bnkalo_Zuluyekalo_Utikalo_S\u025btanburukalo_\u0254kut\u0254burukalo_Nowanburukalo_Desanburukalo".split("_"),monthsShort:"Zan_Few_Mar_Awi_M\u025b_Zuw_Zul_Uti_S\u025bt_\u0254ku_Now_Des".split("_"),weekdays:"Kari_Nt\u025bn\u025bn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"),weekdaysShort:"Kar_Nt\u025b_Tar_Ara_Ala_Jum_Sib".split("_"),weekdaysMin:"Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"MMMM [tile] D [san] YYYY",LLL:"MMMM [tile] D [san] YYYY [l\u025br\u025b] HH:mm",LLLL:"dddd MMMM [tile] D [san] YYYY [l\u025br\u025b] HH:mm"},calendar:{sameDay:"[Bi l\u025br\u025b] LT",nextDay:"[Sini l\u025br\u025b] LT",nextWeek:"dddd [don l\u025br\u025b] LT",lastDay:"[Kunu l\u025br\u025b] LT",lastWeek:"dddd [t\u025bm\u025bnen l\u025br\u025b] LT",sameElse:"L"},relativeTime:{future:"%s k\u0254n\u0254",past:"a b\u025b %s b\u0254",s:"sanga dama dama",ss:"sekondi %d",m:"miniti kelen",mm:"miniti %d",h:"l\u025br\u025b kelen",hh:"l\u025br\u025b %d",d:"tile kelen",dd:"tile %d",M:"kalo kelen",MM:"kalo %d",y:"san kelen",yy:"san %d"},week:{dow:1,doy:4}});var U={1:"\u09e7",2:"\u09e8",3:"\u09e9",4:"\u09ea",5:"\u09eb",6:"\u09ec",7:"\u09ed",8:"\u09ee",9:"\u09ef",0:"\u09e6"},$={"\u09e7":"1","\u09e8":"2","\u09e9":"3","\u09ea":"4","\u09eb":"5","\u09ec":"6","\u09ed":"7","\u09ee":"8","\u09ef":"9","\u09e6":"0"},Q=(e.defineLocale("bn-bd",{months:"\u099c\u09be\u09a8\u09c1\u09df\u09be\u09b0\u09bf_\u09ab\u09c7\u09ac\u09cd\u09b0\u09c1\u09df\u09be\u09b0\u09bf_\u09ae\u09be\u09b0\u09cd\u099a_\u098f\u09aa\u09cd\u09b0\u09bf\u09b2_\u09ae\u09c7_\u099c\u09c1\u09a8_\u099c\u09c1\u09b2\u09be\u0987_\u0986\u0997\u09b8\u09cd\u099f_\u09b8\u09c7\u09aa\u09cd\u099f\u09c7\u09ae\u09cd\u09ac\u09b0_\u0985\u0995\u09cd\u099f\u09cb\u09ac\u09b0_\u09a8\u09ad\u09c7\u09ae\u09cd\u09ac\u09b0_\u09a1\u09bf\u09b8\u09c7\u09ae\u09cd\u09ac\u09b0".split("_"),monthsShort:"\u099c\u09be\u09a8\u09c1_\u09ab\u09c7\u09ac\u09cd\u09b0\u09c1_\u09ae\u09be\u09b0\u09cd\u099a_\u098f\u09aa\u09cd\u09b0\u09bf\u09b2_\u09ae\u09c7_\u099c\u09c1\u09a8_\u099c\u09c1\u09b2\u09be\u0987_\u0986\u0997\u09b8\u09cd\u099f_\u09b8\u09c7\u09aa\u09cd\u099f_\u0985\u0995\u09cd\u099f\u09cb_\u09a8\u09ad\u09c7_\u09a1\u09bf\u09b8\u09c7".split("_"),weekdays:"\u09b0\u09ac\u09bf\u09ac\u09be\u09b0_\u09b8\u09cb\u09ae\u09ac\u09be\u09b0_\u09ae\u0999\u09cd\u0997\u09b2\u09ac\u09be\u09b0_\u09ac\u09c1\u09a7\u09ac\u09be\u09b0_\u09ac\u09c3\u09b9\u09b8\u09cd\u09aa\u09a4\u09bf\u09ac\u09be\u09b0_\u09b6\u09c1\u0995\u09cd\u09b0\u09ac\u09be\u09b0_\u09b6\u09a8\u09bf\u09ac\u09be\u09b0".split("_"),weekdaysShort:"\u09b0\u09ac\u09bf_\u09b8\u09cb\u09ae_\u09ae\u0999\u09cd\u0997\u09b2_\u09ac\u09c1\u09a7_\u09ac\u09c3\u09b9\u09b8\u09cd\u09aa\u09a4\u09bf_\u09b6\u09c1\u0995\u09cd\u09b0_\u09b6\u09a8\u09bf".split("_"),weekdaysMin:"\u09b0\u09ac\u09bf_\u09b8\u09cb\u09ae_\u09ae\u0999\u09cd\u0997\u09b2_\u09ac\u09c1\u09a7_\u09ac\u09c3\u09b9_\u09b6\u09c1\u0995\u09cd\u09b0_\u09b6\u09a8\u09bf".split("_"),longDateFormat:{LT:"A h:mm \u09b8\u09ae\u09df",LTS:"A h:mm:ss \u09b8\u09ae\u09df",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u09b8\u09ae\u09df",LLLL:"dddd, D MMMM YYYY, A h:mm \u09b8\u09ae\u09df"},calendar:{sameDay:"[\u0986\u099c] LT",nextDay:"[\u0986\u0997\u09be\u09ae\u09c0\u0995\u09be\u09b2] LT",nextWeek:"dddd, LT",lastDay:"[\u0997\u09a4\u0995\u09be\u09b2] LT",lastWeek:"[\u0997\u09a4] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u09aa\u09b0\u09c7",past:"%s \u0986\u0997\u09c7",s:"\u0995\u09df\u09c7\u0995 \u09b8\u09c7\u0995\u09c7\u09a8\u09cd\u09a1",ss:"%d \u09b8\u09c7\u0995\u09c7\u09a8\u09cd\u09a1",m:"\u098f\u0995 \u09ae\u09bf\u09a8\u09bf\u099f",mm:"%d \u09ae\u09bf\u09a8\u09bf\u099f",h:"\u098f\u0995 \u0998\u09a8\u09cd\u099f\u09be",hh:"%d \u0998\u09a8\u09cd\u099f\u09be",d:"\u098f\u0995 \u09a6\u09bf\u09a8",dd:"%d \u09a6\u09bf\u09a8",M:"\u098f\u0995 \u09ae\u09be\u09b8",MM:"%d \u09ae\u09be\u09b8",y:"\u098f\u0995 \u09ac\u099b\u09b0",yy:"%d \u09ac\u099b\u09b0"},preparse:function(e){return e.replace(/[\u09e7\u09e8\u09e9\u09ea\u09eb\u09ec\u09ed\u09ee\u09ef\u09e6]/g,function(e){return $[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return U[e]})},meridiemParse:/\u09b0\u09be\u09a4|\u09ad\u09cb\u09b0|\u09b8\u0995\u09be\u09b2|\u09a6\u09c1\u09aa\u09c1\u09b0|\u09ac\u09bf\u0995\u09be\u09b2|\u09b8\u09a8\u09cd\u09a7\u09cd\u09af\u09be|\u09b0\u09be\u09a4/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u09b0\u09be\u09a4"===a?e<4?e:e+12:"\u09ad\u09cb\u09b0"===a||"\u09b8\u0995\u09be\u09b2"===a?e:"\u09a6\u09c1\u09aa\u09c1\u09b0"===a?3<=e?e:e+12:"\u09ac\u09bf\u0995\u09be\u09b2"===a||"\u09b8\u09a8\u09cd\u09a7\u09cd\u09af\u09be"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u09b0\u09be\u09a4":e<6?"\u09ad\u09cb\u09b0":e<12?"\u09b8\u0995\u09be\u09b2":e<15?"\u09a6\u09c1\u09aa\u09c1\u09b0":e<18?"\u09ac\u09bf\u0995\u09be\u09b2":e<20?"\u09b8\u09a8\u09cd\u09a7\u09cd\u09af\u09be":"\u09b0\u09be\u09a4"},week:{dow:0,doy:6}}),{1:"\u09e7",2:"\u09e8",3:"\u09e9",4:"\u09ea",5:"\u09eb",6:"\u09ec",7:"\u09ed",8:"\u09ee",9:"\u09ef",0:"\u09e6"}),V={"\u09e7":"1","\u09e8":"2","\u09e9":"3","\u09ea":"4","\u09eb":"5","\u09ec":"6","\u09ed":"7","\u09ee":"8","\u09ef":"9","\u09e6":"0"},Z=(e.defineLocale("bn",{months:"\u099c\u09be\u09a8\u09c1\u09df\u09be\u09b0\u09bf_\u09ab\u09c7\u09ac\u09cd\u09b0\u09c1\u09df\u09be\u09b0\u09bf_\u09ae\u09be\u09b0\u09cd\u099a_\u098f\u09aa\u09cd\u09b0\u09bf\u09b2_\u09ae\u09c7_\u099c\u09c1\u09a8_\u099c\u09c1\u09b2\u09be\u0987_\u0986\u0997\u09b8\u09cd\u099f_\u09b8\u09c7\u09aa\u09cd\u099f\u09c7\u09ae\u09cd\u09ac\u09b0_\u0985\u0995\u09cd\u099f\u09cb\u09ac\u09b0_\u09a8\u09ad\u09c7\u09ae\u09cd\u09ac\u09b0_\u09a1\u09bf\u09b8\u09c7\u09ae\u09cd\u09ac\u09b0".split("_"),monthsShort:"\u099c\u09be\u09a8\u09c1_\u09ab\u09c7\u09ac\u09cd\u09b0\u09c1_\u09ae\u09be\u09b0\u09cd\u099a_\u098f\u09aa\u09cd\u09b0\u09bf\u09b2_\u09ae\u09c7_\u099c\u09c1\u09a8_\u099c\u09c1\u09b2\u09be\u0987_\u0986\u0997\u09b8\u09cd\u099f_\u09b8\u09c7\u09aa\u09cd\u099f_\u0985\u0995\u09cd\u099f\u09cb_\u09a8\u09ad\u09c7_\u09a1\u09bf\u09b8\u09c7".split("_"),weekdays:"\u09b0\u09ac\u09bf\u09ac\u09be\u09b0_\u09b8\u09cb\u09ae\u09ac\u09be\u09b0_\u09ae\u0999\u09cd\u0997\u09b2\u09ac\u09be\u09b0_\u09ac\u09c1\u09a7\u09ac\u09be\u09b0_\u09ac\u09c3\u09b9\u09b8\u09cd\u09aa\u09a4\u09bf\u09ac\u09be\u09b0_\u09b6\u09c1\u0995\u09cd\u09b0\u09ac\u09be\u09b0_\u09b6\u09a8\u09bf\u09ac\u09be\u09b0".split("_"),weekdaysShort:"\u09b0\u09ac\u09bf_\u09b8\u09cb\u09ae_\u09ae\u0999\u09cd\u0997\u09b2_\u09ac\u09c1\u09a7_\u09ac\u09c3\u09b9\u09b8\u09cd\u09aa\u09a4\u09bf_\u09b6\u09c1\u0995\u09cd\u09b0_\u09b6\u09a8\u09bf".split("_"),weekdaysMin:"\u09b0\u09ac\u09bf_\u09b8\u09cb\u09ae_\u09ae\u0999\u09cd\u0997\u09b2_\u09ac\u09c1\u09a7_\u09ac\u09c3\u09b9_\u09b6\u09c1\u0995\u09cd\u09b0_\u09b6\u09a8\u09bf".split("_"),longDateFormat:{LT:"A h:mm \u09b8\u09ae\u09df",LTS:"A h:mm:ss \u09b8\u09ae\u09df",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u09b8\u09ae\u09df",LLLL:"dddd, D MMMM YYYY, A h:mm \u09b8\u09ae\u09df"},calendar:{sameDay:"[\u0986\u099c] LT",nextDay:"[\u0986\u0997\u09be\u09ae\u09c0\u0995\u09be\u09b2] LT",nextWeek:"dddd, LT",lastDay:"[\u0997\u09a4\u0995\u09be\u09b2] LT",lastWeek:"[\u0997\u09a4] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u09aa\u09b0\u09c7",past:"%s \u0986\u0997\u09c7",s:"\u0995\u09df\u09c7\u0995 \u09b8\u09c7\u0995\u09c7\u09a8\u09cd\u09a1",ss:"%d \u09b8\u09c7\u0995\u09c7\u09a8\u09cd\u09a1",m:"\u098f\u0995 \u09ae\u09bf\u09a8\u09bf\u099f",mm:"%d \u09ae\u09bf\u09a8\u09bf\u099f",h:"\u098f\u0995 \u0998\u09a8\u09cd\u099f\u09be",hh:"%d \u0998\u09a8\u09cd\u099f\u09be",d:"\u098f\u0995 \u09a6\u09bf\u09a8",dd:"%d \u09a6\u09bf\u09a8",M:"\u098f\u0995 \u09ae\u09be\u09b8",MM:"%d \u09ae\u09be\u09b8",y:"\u098f\u0995 \u09ac\u099b\u09b0",yy:"%d \u09ac\u099b\u09b0"},preparse:function(e){return e.replace(/[\u09e7\u09e8\u09e9\u09ea\u09eb\u09ec\u09ed\u09ee\u09ef\u09e6]/g,function(e){return V[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Q[e]})},meridiemParse:/\u09b0\u09be\u09a4|\u09b8\u0995\u09be\u09b2|\u09a6\u09c1\u09aa\u09c1\u09b0|\u09ac\u09bf\u0995\u09be\u09b2|\u09b0\u09be\u09a4/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u09b0\u09be\u09a4"===a&&4<=e||"\u09a6\u09c1\u09aa\u09c1\u09b0"===a&&e<5||"\u09ac\u09bf\u0995\u09be\u09b2"===a?e+12:e},meridiem:function(e,a,_){return e<4?"\u09b0\u09be\u09a4":e<10?"\u09b8\u0995\u09be\u09b2":e<17?"\u09a6\u09c1\u09aa\u09c1\u09b0":e<20?"\u09ac\u09bf\u0995\u09be\u09b2":"\u09b0\u09be\u09a4"},week:{dow:0,doy:6}}),{1:"\u0f21",2:"\u0f22",3:"\u0f23",4:"\u0f24",5:"\u0f25",6:"\u0f26",7:"\u0f27",8:"\u0f28",9:"\u0f29",0:"\u0f20"}),X={"\u0f21":"1","\u0f22":"2","\u0f23":"3","\u0f24":"4","\u0f25":"5","\u0f26":"6","\u0f27":"7","\u0f28":"8","\u0f29":"9","\u0f20":"0"};function ee(e,a,_){return e+" "+(_={mm:"munutenn",MM:"miz",dd:"devezh"}[_],2!==(e=e)?_:void 0!==(e={m:"v",b:"v",d:"z"})[(_=_).charAt(0)]?e[_.charAt(0)]+_.substring(1):_)}e.defineLocale("bo",{months:"\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0f44\u0f0b\u0f54\u0f7c_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f66\u0f74\u0f58\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f5e\u0f72\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f63\u0f94\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0fb2\u0f74\u0f42\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f51\u0f74\u0f53\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f62\u0f92\u0fb1\u0f51\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0f42\u0f74\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f42\u0f45\u0f72\u0f42\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f54".split("_"),monthsShort:"\u0f5f\u0fb3\u0f0b1_\u0f5f\u0fb3\u0f0b2_\u0f5f\u0fb3\u0f0b3_\u0f5f\u0fb3\u0f0b4_\u0f5f\u0fb3\u0f0b5_\u0f5f\u0fb3\u0f0b6_\u0f5f\u0fb3\u0f0b7_\u0f5f\u0fb3\u0f0b8_\u0f5f\u0fb3\u0f0b9_\u0f5f\u0fb3\u0f0b10_\u0f5f\u0fb3\u0f0b11_\u0f5f\u0fb3\u0f0b12".split("_"),monthsShortRegex:/^(\u0f5f\u0fb3\u0f0b\d{1,2})/,monthsParseExact:!0,weekdays:"\u0f42\u0f5f\u0f60\u0f0b\u0f49\u0f72\u0f0b\u0f58\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f5f\u0fb3\u0f0b\u0f56\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f58\u0f72\u0f42\u0f0b\u0f51\u0f58\u0f62\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f63\u0fb7\u0f42\u0f0b\u0f54\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f55\u0f74\u0f62\u0f0b\u0f56\u0f74_\u0f42\u0f5f\u0f60\u0f0b\u0f54\u0f0b\u0f66\u0f44\u0f66\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f66\u0fa4\u0f7a\u0f53\u0f0b\u0f54\u0f0b".split("_"),weekdaysShort:"\u0f49\u0f72\u0f0b\u0f58\u0f0b_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b_\u0f58\u0f72\u0f42\u0f0b\u0f51\u0f58\u0f62\u0f0b_\u0f63\u0fb7\u0f42\u0f0b\u0f54\u0f0b_\u0f55\u0f74\u0f62\u0f0b\u0f56\u0f74_\u0f54\u0f0b\u0f66\u0f44\u0f66\u0f0b_\u0f66\u0fa4\u0f7a\u0f53\u0f0b\u0f54\u0f0b".split("_"),weekdaysMin:"\u0f49\u0f72_\u0f5f\u0fb3_\u0f58\u0f72\u0f42_\u0f63\u0fb7\u0f42_\u0f55\u0f74\u0f62_\u0f66\u0f44\u0f66_\u0f66\u0fa4\u0f7a\u0f53".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm",LLLL:"dddd, D MMMM YYYY, A h:mm"},calendar:{sameDay:"[\u0f51\u0f72\u0f0b\u0f62\u0f72\u0f44] LT",nextDay:"[\u0f66\u0f44\u0f0b\u0f49\u0f72\u0f53] LT",nextWeek:"[\u0f56\u0f51\u0f74\u0f53\u0f0b\u0f55\u0fb2\u0f42\u0f0b\u0f62\u0f97\u0f7a\u0f66\u0f0b\u0f58], LT",lastDay:"[\u0f41\u0f0b\u0f66\u0f44] LT",lastWeek:"[\u0f56\u0f51\u0f74\u0f53\u0f0b\u0f55\u0fb2\u0f42\u0f0b\u0f58\u0f50\u0f60\u0f0b\u0f58] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0f63\u0f0b",past:"%s \u0f66\u0f94\u0f53\u0f0b\u0f63",s:"\u0f63\u0f58\u0f0b\u0f66\u0f44",ss:"%d \u0f66\u0f90\u0f62\u0f0b\u0f46\u0f0d",m:"\u0f66\u0f90\u0f62\u0f0b\u0f58\u0f0b\u0f42\u0f45\u0f72\u0f42",mm:"%d \u0f66\u0f90\u0f62\u0f0b\u0f58",h:"\u0f46\u0f74\u0f0b\u0f5a\u0f7c\u0f51\u0f0b\u0f42\u0f45\u0f72\u0f42",hh:"%d \u0f46\u0f74\u0f0b\u0f5a\u0f7c\u0f51",d:"\u0f49\u0f72\u0f53\u0f0b\u0f42\u0f45\u0f72\u0f42",dd:"%d \u0f49\u0f72\u0f53\u0f0b",M:"\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f45\u0f72\u0f42",MM:"%d \u0f5f\u0fb3\u0f0b\u0f56",y:"\u0f63\u0f7c\u0f0b\u0f42\u0f45\u0f72\u0f42",yy:"%d \u0f63\u0f7c"},preparse:function(e){return e.replace(/[\u0f21\u0f22\u0f23\u0f24\u0f25\u0f26\u0f27\u0f28\u0f29\u0f20]/g,function(e){return X[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Z[e]})},meridiemParse:/\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c|\u0f5e\u0f7c\u0f42\u0f66\u0f0b\u0f40\u0f66|\u0f49\u0f72\u0f53\u0f0b\u0f42\u0f74\u0f44|\u0f51\u0f42\u0f7c\u0f44\u0f0b\u0f51\u0f42|\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c"===a&&4<=e||"\u0f49\u0f72\u0f53\u0f0b\u0f42\u0f74\u0f44"===a&&e<5||"\u0f51\u0f42\u0f7c\u0f44\u0f0b\u0f51\u0f42"===a?e+12:e},meridiem:function(e,a,_){return e<4?"\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c":e<10?"\u0f5e\u0f7c\u0f42\u0f66\u0f0b\u0f40\u0f66":e<17?"\u0f49\u0f72\u0f53\u0f0b\u0f42\u0f74\u0f44":e<20?"\u0f51\u0f42\u0f7c\u0f44\u0f0b\u0f51\u0f42":"\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c"},week:{dow:0,doy:6}});var d=[/^gen/i,/^c[\u02bc\']hwe/i,/^meu/i,/^ebr/i,/^mae/i,/^(mez|eve)/i,/^gou/i,/^eos/i,/^gwe/i,/^her/i,/^du/i,/^ker/i],n=/^(genver|c[\u02bc\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[\u02bc\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,r=[/^Su/i,/^Lu/i,/^Me([^r]|$)/i,/^Mer/i,/^Ya/i,/^Gw/i,/^Sa/i];function i(e,a,_){var s=e+" ";switch(_){case"ss":return s+=1===e?"sekunda":2===e||3===e||4===e?"sekunde":"sekundi";case"m":return a?"jedna minuta":"jedne minute";case"mm":return s+=1!==e&&(2===e||3===e||4===e)?"minute":"minuta";case"h":return a?"jedan sat":"jednog sata";case"hh":return s+=1===e?"sat":2===e||3===e||4===e?"sata":"sati";case"dd":return s+=1===e?"dan":"dana";case"MM":return s+=1===e?"mjesec":2===e||3===e||4===e?"mjeseca":"mjeseci";case"yy":return s+=1!==e&&(2===e||3===e||4===e)?"godine":"godina"}}e.defineLocale("br",{months:"Genver_C\u02bchwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),monthsShort:"Gen_C\u02bchwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),weekdays:"Sul_Lun_Meurzh_Merc\u02bcher_Yaou_Gwener_Sadorn".split("_"),weekdaysShort:"Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),weekdaysMin:"Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),weekdaysParse:r,fullWeekdaysParse:[/^sul/i,/^lun/i,/^meurzh/i,/^merc[\u02bc\']her/i,/^yaou/i,/^gwener/i,/^sadorn/i],shortWeekdaysParse:[/^Sul/i,/^Lun/i,/^Meu/i,/^Mer/i,/^Yao/i,/^Gwe/i,/^Sad/i],minWeekdaysParse:r,monthsRegex:n,monthsShortRegex:n,monthsStrictRegex:/^(genver|c[\u02bc\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i,monthsShortStrictRegex:/^(gen|c[\u02bc\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,monthsParse:d,longMonthsParse:d,shortMonthsParse:d,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [a viz] MMMM YYYY",LLL:"D [a viz] MMMM YYYY HH:mm",LLLL:"dddd, D [a viz] MMMM YYYY HH:mm"},calendar:{sameDay:"[Hiziv da] LT",nextDay:"[Warc\u02bchoazh da] LT",nextWeek:"dddd [da] LT",lastDay:"[Dec\u02bch da] LT",lastWeek:"dddd [paset da] LT",sameElse:"L"},relativeTime:{future:"a-benn %s",past:"%s \u02bczo",s:"un nebeud segondenno\xf9",ss:"%d eilenn",m:"ur vunutenn",mm:ee,h:"un eur",hh:"%d eur",d:"un devezh",dd:ee,M:"ur miz",MM:ee,y:"ur bloaz",yy:function(e){switch(function e(a){if(9<a)return e(a%10);return a}(e)){case 1:case 3:case 4:case 5:case 9:return e+" bloaz";default:return e+" vloaz"}}},dayOfMonthOrdinalParse:/\d{1,2}(a\xf1|vet)/,ordinal:function(e){return e+(1===e?"a\xf1":"vet")},week:{dow:1,doy:4},meridiemParse:/a.m.|g.m./,isPM:function(e){return "g.m."===e},meridiem:function(e,a,_){return e<12?"a.m.":"g.m."}}),e.defineLocale("bs",{months:"januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"),monthsShort:"jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"nedjelja_ponedjeljak_utorak_srijeda_\u010detvrtak_petak_subota".split("_"),weekdaysShort:"ned._pon._uto._sri._\u010det._pet._sub.".split("_"),weekdaysMin:"ne_po_ut_sr_\u010de_pe_su".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danas u] LT",nextDay:"[sutra u] LT",nextWeek:function(){switch(this.day()){case 0:return "[u] [nedjelju] [u] LT";case 3:return "[u] [srijedu] [u] LT";case 6:return "[u] [subotu] [u] LT";case 1:case 2:case 4:case 5:return "[u] dddd [u] LT"}},lastDay:"[ju\u010der u] LT",lastWeek:function(){switch(this.day()){case 0:case 3:return "[pro\u0161lu] dddd [u] LT";case 6:return "[pro\u0161le] [subote] [u] LT";case 1:case 2:case 4:case 5:return "[pro\u0161li] dddd [u] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"prije %s",s:"par sekundi",ss:i,m:i,mm:i,h:i,hh:i,d:"dan",dd:i,M:"mjesec",MM:i,y:"godinu",yy:i},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),e.defineLocale("ca",{months:{standalone:"gener_febrer_mar\xe7_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"),format:"de gener_de febrer_de mar\xe7_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"),isFormat:/D[oD]?(\s)+MMMM/},monthsShort:"gen._febr._mar\xe7_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"),monthsParseExact:!0,weekdays:"diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"),weekdaysShort:"dg._dl._dt._dc._dj._dv._ds.".split("_"),weekdaysMin:"dg_dl_dt_dc_dj_dv_ds".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM [de] YYYY",ll:"D MMM YYYY",LLL:"D MMMM [de] YYYY [a les] H:mm",lll:"D MMM YYYY, H:mm",LLLL:"dddd D MMMM [de] YYYY [a les] H:mm",llll:"ddd D MMM YYYY, H:mm"},calendar:{sameDay:function(){return "[avui a "+(1!==this.hours()?"les":"la")+"] LT"},nextDay:function(){return "[dem\xe0 a "+(1!==this.hours()?"les":"la")+"] LT"},nextWeek:function(){return "dddd [a "+(1!==this.hours()?"les":"la")+"] LT"},lastDay:function(){return "[ahir a "+(1!==this.hours()?"les":"la")+"] LT"},lastWeek:function(){return "[el] dddd [passat a "+(1!==this.hours()?"les":"la")+"] LT"},sameElse:"L"},relativeTime:{future:"d'aqu\xed %s",past:"fa %s",s:"uns segons",ss:"%d segons",m:"un minut",mm:"%d minuts",h:"una hora",hh:"%d hores",d:"un dia",dd:"%d dies",M:"un mes",MM:"%d mesos",y:"un any",yy:"%d anys"},dayOfMonthOrdinalParse:/\d{1,2}(r|n|t|\xe8|a)/,ordinal:function(e,a){return e+("w"!==a&&"W"!==a?1===e?"r":2===e?"n":3===e?"r":4===e?"t":"\xe8":"a")},week:{dow:1,doy:4}});var r={format:"leden_\xfanor_b\u0159ezen_duben_kv\u011bten_\u010derven_\u010dervenec_srpen_z\xe1\u0159\xed_\u0159\xedjen_listopad_prosinec".split("_"),standalone:"ledna_\xfanora_b\u0159ezna_dubna_kv\u011btna_\u010dervna_\u010dervence_srpna_z\xe1\u0159\xed_\u0159\xedjna_listopadu_prosince".split("_")},n="led_\xfano_b\u0159e_dub_kv\u011b_\u010dvn_\u010dvc_srp_z\xe1\u0159_\u0159\xedj_lis_pro".split("_"),d=[/^led/i,/^\xfano/i,/^b\u0159e/i,/^dub/i,/^kv\u011b/i,/^(\u010dvn|\u010derven$|\u010dervna)/i,/^(\u010dvc|\u010dervenec|\u010dervence)/i,/^srp/i,/^z\xe1\u0159/i,/^\u0159\xedj/i,/^lis/i,/^pro/i],m=/^(leden|\xfanor|b\u0159ezen|duben|kv\u011bten|\u010dervenec|\u010dervence|\u010derven|\u010dervna|srpen|z\xe1\u0159\xed|\u0159\xedjen|listopad|prosinec|led|\xfano|b\u0159e|dub|kv\u011b|\u010dvn|\u010dvc|srp|z\xe1\u0159|\u0159\xedj|lis|pro)/i;function o(e){return 1<e&&e<5&&1!=~~(e/10)}function u(e,a,_,s){var d=e+" ";switch(_){case"s":return a||s?"p\xe1r sekund":"p\xe1r sekundami";case"ss":return a||s?d+(o(e)?"sekundy":"sekund"):d+"sekundami";case"m":return a?"minuta":s?"minutu":"minutou";case"mm":return a||s?d+(o(e)?"minuty":"minut"):d+"minutami";case"h":return a?"hodina":s?"hodinu":"hodinou";case"hh":return a||s?d+(o(e)?"hodiny":"hodin"):d+"hodinami";case"d":return a||s?"den":"dnem";case"dd":return a||s?d+(o(e)?"dny":"dn\xed"):d+"dny";case"M":return a||s?"m\u011bs\xedc":"m\u011bs\xedcem";case"MM":return a||s?d+(o(e)?"m\u011bs\xedce":"m\u011bs\xedc\u016f"):d+"m\u011bs\xedci";case"y":return a||s?"rok":"rokem";case"yy":return a||s?d+(o(e)?"roky":"let"):d+"lety"}}function l(e,a,_,s){e={m:["eine Minute","einer Minute"],h:["eine Stunde","einer Stunde"],d:["ein Tag","einem Tag"],dd:[e+" Tage",e+" Tagen"],w:["eine Woche","einer Woche"],M:["ein Monat","einem Monat"],MM:[e+" Monate",e+" Monaten"],y:["ein Jahr","einem Jahr"],yy:[e+" Jahre",e+" Jahren"]};return a?e[_][0]:e[_][1]}function M(e,a,_,s){e={m:["eine Minute","einer Minute"],h:["eine Stunde","einer Stunde"],d:["ein Tag","einem Tag"],dd:[e+" Tage",e+" Tagen"],w:["eine Woche","einer Woche"],M:["ein Monat","einem Monat"],MM:[e+" Monate",e+" Monaten"],y:["ein Jahr","einem Jahr"],yy:[e+" Jahre",e+" Jahren"]};return a?e[_][0]:e[_][1]}function L(e,a,_,s){e={m:["eine Minute","einer Minute"],h:["eine Stunde","einer Stunde"],d:["ein Tag","einem Tag"],dd:[e+" Tage",e+" Tagen"],w:["eine Woche","einer Woche"],M:["ein Monat","einem Monat"],MM:[e+" Monate",e+" Monaten"],y:["ein Jahr","einem Jahr"],yy:[e+" Jahre",e+" Jahren"]};return a?e[_][0]:e[_][1]}e.defineLocale("cs",{months:r,monthsShort:n,monthsRegex:m,monthsShortRegex:m,monthsStrictRegex:/^(leden|ledna|\xfanora|\xfanor|b\u0159ezen|b\u0159ezna|duben|dubna|kv\u011bten|kv\u011btna|\u010dervenec|\u010dervence|\u010derven|\u010dervna|srpen|srpna|z\xe1\u0159\xed|\u0159\xedjen|\u0159\xedjna|listopadu|listopad|prosinec|prosince)/i,monthsShortStrictRegex:/^(led|\xfano|b\u0159e|dub|kv\u011b|\u010dvn|\u010dvc|srp|z\xe1\u0159|\u0159\xedj|lis|pro)/i,monthsParse:d,longMonthsParse:d,shortMonthsParse:d,weekdays:"ned\u011ble_pond\u011bl\xed_\xfater\xfd_st\u0159eda_\u010dtvrtek_p\xe1tek_sobota".split("_"),weekdaysShort:"ne_po_\xfat_st_\u010dt_p\xe1_so".split("_"),weekdaysMin:"ne_po_\xfat_st_\u010dt_p\xe1_so".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd D. MMMM YYYY H:mm",l:"D. M. YYYY"},calendar:{sameDay:"[dnes v] LT",nextDay:"[z\xedtra v] LT",nextWeek:function(){switch(this.day()){case 0:return "[v ned\u011bli v] LT";case 1:case 2:return "[v] dddd [v] LT";case 3:return "[ve st\u0159edu v] LT";case 4:return "[ve \u010dtvrtek v] LT";case 5:return "[v p\xe1tek v] LT";case 6:return "[v sobotu v] LT"}},lastDay:"[v\u010dera v] LT",lastWeek:function(){switch(this.day()){case 0:return "[minulou ned\u011bli v] LT";case 1:case 2:return "[minul\xe9] dddd [v] LT";case 3:return "[minulou st\u0159edu v] LT";case 4:case 5:return "[minul\xfd] dddd [v] LT";case 6:return "[minulou sobotu v] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"p\u0159ed %s",s:u,ss:u,m:u,mm:u,h:u,hh:u,d:u,dd:u,M:u,MM:u,y:u,yy:u},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("cv",{months:"\u043a\u04d1\u0440\u043b\u0430\u0447_\u043d\u0430\u0440\u04d1\u0441_\u043f\u0443\u0448_\u0430\u043a\u0430_\u043c\u0430\u0439_\u04ab\u04d7\u0440\u0442\u043c\u0435_\u0443\u0442\u04d1_\u04ab\u0443\u0440\u043b\u0430_\u0430\u0432\u04d1\u043d_\u044e\u043f\u0430_\u0447\u04f3\u043a_\u0440\u0430\u0448\u0442\u0430\u0432".split("_"),monthsShort:"\u043a\u04d1\u0440_\u043d\u0430\u0440_\u043f\u0443\u0448_\u0430\u043a\u0430_\u043c\u0430\u0439_\u04ab\u04d7\u0440_\u0443\u0442\u04d1_\u04ab\u0443\u0440_\u0430\u0432\u043d_\u044e\u043f\u0430_\u0447\u04f3\u043a_\u0440\u0430\u0448".split("_"),weekdays:"\u0432\u044b\u0440\u0441\u0430\u0440\u043d\u0438\u043a\u0443\u043d_\u0442\u0443\u043d\u0442\u0438\u043a\u0443\u043d_\u044b\u0442\u043b\u0430\u0440\u0438\u043a\u0443\u043d_\u044e\u043d\u043a\u0443\u043d_\u043a\u04d7\u04ab\u043d\u0435\u0440\u043d\u0438\u043a\u0443\u043d_\u044d\u0440\u043d\u0435\u043a\u0443\u043d_\u0448\u04d1\u043c\u0430\u0442\u043a\u0443\u043d".split("_"),weekdaysShort:"\u0432\u044b\u0440_\u0442\u0443\u043d_\u044b\u0442\u043b_\u044e\u043d_\u043a\u04d7\u04ab_\u044d\u0440\u043d_\u0448\u04d1\u043c".split("_"),weekdaysMin:"\u0432\u0440_\u0442\u043d_\u044b\u0442_\u044e\u043d_\u043a\u04ab_\u044d\u0440_\u0448\u043c".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"YYYY [\u04ab\u0443\u043b\u0445\u0438] MMMM [\u0443\u0439\u04d1\u0445\u04d7\u043d] D[-\u043c\u04d7\u0448\u04d7]",LLL:"YYYY [\u04ab\u0443\u043b\u0445\u0438] MMMM [\u0443\u0439\u04d1\u0445\u04d7\u043d] D[-\u043c\u04d7\u0448\u04d7], HH:mm",LLLL:"dddd, YYYY [\u04ab\u0443\u043b\u0445\u0438] MMMM [\u0443\u0439\u04d1\u0445\u04d7\u043d] D[-\u043c\u04d7\u0448\u04d7], HH:mm"},calendar:{sameDay:"[\u041f\u0430\u044f\u043d] LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",nextDay:"[\u042b\u0440\u0430\u043d] LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",lastDay:"[\u04d6\u043d\u0435\u0440] LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",nextWeek:"[\u04aa\u0438\u0442\u0435\u0441] dddd LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",lastWeek:"[\u0418\u0440\u0442\u043d\u04d7] dddd LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",sameElse:"L"},relativeTime:{future:function(e){return e+(/\u0441\u0435\u0445\u0435\u0442$/i.exec(e)?"\u0440\u0435\u043d":/\u04ab\u0443\u043b$/i.exec(e)?"\u0442\u0430\u043d":"\u0440\u0430\u043d")},past:"%s \u043a\u0430\u044f\u043b\u043b\u0430",s:"\u043f\u04d7\u0440-\u0438\u043a \u04ab\u0435\u043a\u043a\u0443\u043d\u0442",ss:"%d \u04ab\u0435\u043a\u043a\u0443\u043d\u0442",m:"\u043f\u04d7\u0440 \u043c\u0438\u043d\u0443\u0442",mm:"%d \u043c\u0438\u043d\u0443\u0442",h:"\u043f\u04d7\u0440 \u0441\u0435\u0445\u0435\u0442",hh:"%d \u0441\u0435\u0445\u0435\u0442",d:"\u043f\u04d7\u0440 \u043a\u0443\u043d",dd:"%d \u043a\u0443\u043d",M:"\u043f\u04d7\u0440 \u0443\u0439\u04d1\u0445",MM:"%d \u0443\u0439\u04d1\u0445",y:"\u043f\u04d7\u0440 \u04ab\u0443\u043b",yy:"%d \u04ab\u0443\u043b"},dayOfMonthOrdinalParse:/\d{1,2}-\u043c\u04d7\u0448/,ordinal:"%d-\u043c\u04d7\u0448",week:{dow:1,doy:7}}),e.defineLocale("cy",{months:"Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),monthsShort:"Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),weekdays:"Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),weekdaysShort:"Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),weekdaysMin:"Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Heddiw am] LT",nextDay:"[Yfory am] LT",nextWeek:"dddd [am] LT",lastDay:"[Ddoe am] LT",lastWeek:"dddd [diwethaf am] LT",sameElse:"L"},relativeTime:{future:"mewn %s",past:"%s yn \xf4l",s:"ychydig eiliadau",ss:"%d eiliad",m:"munud",mm:"%d munud",h:"awr",hh:"%d awr",d:"diwrnod",dd:"%d diwrnod",M:"mis",MM:"%d mis",y:"blwyddyn",yy:"%d flynedd"},dayOfMonthOrdinalParse:/\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,ordinal:function(e){var a="";return 20<e?a=40===e||50===e||60===e||80===e||100===e?"fed":"ain":0<e&&(a=["","af","il","ydd","ydd","ed","ed","ed","fed","fed","fed","eg","fed","eg","eg","fed","eg","eg","fed","eg","fed"][e]),e+a},week:{dow:1,doy:4}}),e.defineLocale("da",{months:"januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),monthsShort:"jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),weekdays:"s\xf8ndag_mandag_tirsdag_onsdag_torsdag_fredag_l\xf8rdag".split("_"),weekdaysShort:"s\xf8n_man_tir_ons_tor_fre_l\xf8r".split("_"),weekdaysMin:"s\xf8_ma_ti_on_to_fr_l\xf8".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd [d.] D. MMMM YYYY [kl.] HH:mm"},calendar:{sameDay:"[i dag kl.] LT",nextDay:"[i morgen kl.] LT",nextWeek:"p\xe5 dddd [kl.] LT",lastDay:"[i g\xe5r kl.] LT",lastWeek:"[i] dddd[s kl.] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"%s siden",s:"f\xe5 sekunder",ss:"%d sekunder",m:"et minut",mm:"%d minutter",h:"en time",hh:"%d timer",d:"en dag",dd:"%d dage",M:"en m\xe5ned",MM:"%d m\xe5neder",y:"et \xe5r",yy:"%d \xe5r"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("de-at",{months:"J\xe4nner_Februar_M\xe4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"J\xe4n._Feb._M\xe4rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},calendar:{sameDay:"[heute um] LT [Uhr]",sameElse:"L",nextDay:"[morgen um] LT [Uhr]",nextWeek:"dddd [um] LT [Uhr]",lastDay:"[gestern um] LT [Uhr]",lastWeek:"[letzten] dddd [um] LT [Uhr]"},relativeTime:{future:"in %s",past:"vor %s",s:"ein paar Sekunden",ss:"%d Sekunden",m:l,mm:"%d Minuten",h:l,hh:"%d Stunden",d:l,dd:l,w:l,ww:"%d Wochen",M:l,MM:l,y:l,yy:l},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("de-ch",{months:"Januar_Februar_M\xe4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan._Feb._M\xe4rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},calendar:{sameDay:"[heute um] LT [Uhr]",sameElse:"L",nextDay:"[morgen um] LT [Uhr]",nextWeek:"dddd [um] LT [Uhr]",lastDay:"[gestern um] LT [Uhr]",lastWeek:"[letzten] dddd [um] LT [Uhr]"},relativeTime:{future:"in %s",past:"vor %s",s:"ein paar Sekunden",ss:"%d Sekunden",m:M,mm:"%d Minuten",h:M,hh:"%d Stunden",d:M,dd:M,w:M,ww:"%d Wochen",M:M,MM:M,y:M,yy:M},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("de",{months:"Januar_Februar_M\xe4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan._Feb._M\xe4rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},calendar:{sameDay:"[heute um] LT [Uhr]",sameElse:"L",nextDay:"[morgen um] LT [Uhr]",nextWeek:"dddd [um] LT [Uhr]",lastDay:"[gestern um] LT [Uhr]",lastWeek:"[letzten] dddd [um] LT [Uhr]"},relativeTime:{future:"in %s",past:"vor %s",s:"ein paar Sekunden",ss:"%d Sekunden",m:L,mm:"%d Minuten",h:L,hh:"%d Stunden",d:L,dd:L,w:L,ww:"%d Wochen",M:L,MM:L,y:L,yy:L},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});r=["\u0796\u07ac\u0782\u07aa\u0787\u07a6\u0783\u07a9","\u078a\u07ac\u0784\u07b0\u0783\u07aa\u0787\u07a6\u0783\u07a9","\u0789\u07a7\u0783\u07a8\u0797\u07aa","\u0787\u07ad\u0795\u07b0\u0783\u07a9\u078d\u07aa","\u0789\u07ad","\u0796\u07ab\u0782\u07b0","\u0796\u07aa\u078d\u07a6\u0787\u07a8","\u0787\u07af\u078e\u07a6\u0790\u07b0\u0793\u07aa","\u0790\u07ac\u0795\u07b0\u0793\u07ac\u0789\u07b0\u0784\u07a6\u0783\u07aa","\u0787\u07ae\u0786\u07b0\u0793\u07af\u0784\u07a6\u0783\u07aa","\u0782\u07ae\u0788\u07ac\u0789\u07b0\u0784\u07a6\u0783\u07aa","\u0791\u07a8\u0790\u07ac\u0789\u07b0\u0784\u07a6\u0783\u07aa"],n=["\u0787\u07a7\u078b\u07a8\u0787\u07b0\u078c\u07a6","\u0780\u07af\u0789\u07a6","\u0787\u07a6\u0782\u07b0\u078e\u07a7\u0783\u07a6","\u0784\u07aa\u078b\u07a6","\u0784\u07aa\u0783\u07a7\u0790\u07b0\u078a\u07a6\u078c\u07a8","\u0780\u07aa\u0786\u07aa\u0783\u07aa","\u0780\u07ae\u0782\u07a8\u0780\u07a8\u0783\u07aa"];e.defineLocale("dv",{months:r,monthsShort:r,weekdays:n,weekdaysShort:n,weekdaysMin:"\u0787\u07a7\u078b\u07a8_\u0780\u07af\u0789\u07a6_\u0787\u07a6\u0782\u07b0_\u0784\u07aa\u078b\u07a6_\u0784\u07aa\u0783\u07a7_\u0780\u07aa\u0786\u07aa_\u0780\u07ae\u0782\u07a8".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"D/M/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0789\u0786|\u0789\u078a/,isPM:function(e){return "\u0789\u078a"===e},meridiem:function(e,a,_){return e<12?"\u0789\u0786":"\u0789\u078a"},calendar:{sameDay:"[\u0789\u07a8\u0787\u07a6\u078b\u07aa] LT",nextDay:"[\u0789\u07a7\u078b\u07a6\u0789\u07a7] LT",nextWeek:"dddd LT",lastDay:"[\u0787\u07a8\u0787\u07b0\u0794\u07ac] LT",lastWeek:"[\u078a\u07a7\u0787\u07a8\u078c\u07aa\u0788\u07a8] dddd LT",sameElse:"L"},relativeTime:{future:"\u078c\u07ac\u0783\u07ad\u078e\u07a6\u0787\u07a8 %s",past:"\u0786\u07aa\u0783\u07a8\u0782\u07b0 %s",s:"\u0790\u07a8\u0786\u07aa\u0782\u07b0\u078c\u07aa\u0786\u07ae\u0785\u07ac\u0787\u07b0",ss:"d% \u0790\u07a8\u0786\u07aa\u0782\u07b0\u078c\u07aa",m:"\u0789\u07a8\u0782\u07a8\u0793\u07ac\u0787\u07b0",mm:"\u0789\u07a8\u0782\u07a8\u0793\u07aa %d",h:"\u078e\u07a6\u0791\u07a8\u0787\u07a8\u0783\u07ac\u0787\u07b0",hh:"\u078e\u07a6\u0791\u07a8\u0787\u07a8\u0783\u07aa %d",d:"\u078b\u07aa\u0788\u07a6\u0780\u07ac\u0787\u07b0",dd:"\u078b\u07aa\u0788\u07a6\u0790\u07b0 %d",M:"\u0789\u07a6\u0780\u07ac\u0787\u07b0",MM:"\u0789\u07a6\u0790\u07b0 %d",y:"\u0787\u07a6\u0780\u07a6\u0783\u07ac\u0787\u07b0",yy:"\u0787\u07a6\u0780\u07a6\u0783\u07aa %d"},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:7,doy:12}}),e.defineLocale("el",{monthsNominativeEl:"\u0399\u03b1\u03bd\u03bf\u03c5\u03ac\u03c1\u03b9\u03bf\u03c2_\u03a6\u03b5\u03b2\u03c1\u03bf\u03c5\u03ac\u03c1\u03b9\u03bf\u03c2_\u039c\u03ac\u03c1\u03c4\u03b9\u03bf\u03c2_\u0391\u03c0\u03c1\u03af\u03bb\u03b9\u03bf\u03c2_\u039c\u03ac\u03b9\u03bf\u03c2_\u0399\u03bf\u03cd\u03bd\u03b9\u03bf\u03c2_\u0399\u03bf\u03cd\u03bb\u03b9\u03bf\u03c2_\u0391\u03cd\u03b3\u03bf\u03c5\u03c3\u03c4\u03bf\u03c2_\u03a3\u03b5\u03c0\u03c4\u03ad\u03bc\u03b2\u03c1\u03b9\u03bf\u03c2_\u039f\u03ba\u03c4\u03ce\u03b2\u03c1\u03b9\u03bf\u03c2_\u039d\u03bf\u03ad\u03bc\u03b2\u03c1\u03b9\u03bf\u03c2_\u0394\u03b5\u03ba\u03ad\u03bc\u03b2\u03c1\u03b9\u03bf\u03c2".split("_"),monthsGenitiveEl:"\u0399\u03b1\u03bd\u03bf\u03c5\u03b1\u03c1\u03af\u03bf\u03c5_\u03a6\u03b5\u03b2\u03c1\u03bf\u03c5\u03b1\u03c1\u03af\u03bf\u03c5_\u039c\u03b1\u03c1\u03c4\u03af\u03bf\u03c5_\u0391\u03c0\u03c1\u03b9\u03bb\u03af\u03bf\u03c5_\u039c\u03b1\u0390\u03bf\u03c5_\u0399\u03bf\u03c5\u03bd\u03af\u03bf\u03c5_\u0399\u03bf\u03c5\u03bb\u03af\u03bf\u03c5_\u0391\u03c5\u03b3\u03bf\u03cd\u03c3\u03c4\u03bf\u03c5_\u03a3\u03b5\u03c0\u03c4\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5_\u039f\u03ba\u03c4\u03c9\u03b2\u03c1\u03af\u03bf\u03c5_\u039d\u03bf\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5_\u0394\u03b5\u03ba\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5".split("_"),months:function(e,a){return e?("string"==typeof a&&/D/.test(a.substring(0,a.indexOf("MMMM")))?this._monthsGenitiveEl:this._monthsNominativeEl)[e.month()]:this._monthsNominativeEl},monthsShort:"\u0399\u03b1\u03bd_\u03a6\u03b5\u03b2_\u039c\u03b1\u03c1_\u0391\u03c0\u03c1_\u039c\u03b1\u03ca_\u0399\u03bf\u03c5\u03bd_\u0399\u03bf\u03c5\u03bb_\u0391\u03c5\u03b3_\u03a3\u03b5\u03c0_\u039f\u03ba\u03c4_\u039d\u03bf\u03b5_\u0394\u03b5\u03ba".split("_"),weekdays:"\u039a\u03c5\u03c1\u03b9\u03b1\u03ba\u03ae_\u0394\u03b5\u03c5\u03c4\u03ad\u03c1\u03b1_\u03a4\u03c1\u03af\u03c4\u03b7_\u03a4\u03b5\u03c4\u03ac\u03c1\u03c4\u03b7_\u03a0\u03ad\u03bc\u03c0\u03c4\u03b7_\u03a0\u03b1\u03c1\u03b1\u03c3\u03ba\u03b5\u03c5\u03ae_\u03a3\u03ac\u03b2\u03b2\u03b1\u03c4\u03bf".split("_"),weekdaysShort:"\u039a\u03c5\u03c1_\u0394\u03b5\u03c5_\u03a4\u03c1\u03b9_\u03a4\u03b5\u03c4_\u03a0\u03b5\u03bc_\u03a0\u03b1\u03c1_\u03a3\u03b1\u03b2".split("_"),weekdaysMin:"\u039a\u03c5_\u0394\u03b5_\u03a4\u03c1_\u03a4\u03b5_\u03a0\u03b5_\u03a0\u03b1_\u03a3\u03b1".split("_"),meridiem:function(e,a,_){return 11<e?_?"\u03bc\u03bc":"\u039c\u039c":_?"\u03c0\u03bc":"\u03a0\u039c"},isPM:function(e){return "\u03bc"===(e+"").toLowerCase()[0]},meridiemParse:/[\u03a0\u039c]\.?\u039c?\.?/i,longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendarEl:{sameDay:"[\u03a3\u03ae\u03bc\u03b5\u03c1\u03b1 {}] LT",nextDay:"[\u0391\u03cd\u03c1\u03b9\u03bf {}] LT",nextWeek:"dddd [{}] LT",lastDay:"[\u03a7\u03b8\u03b5\u03c2 {}] LT",lastWeek:function(){switch(this.day()){case 6:return "[\u03c4\u03bf \u03c0\u03c1\u03bf\u03b7\u03b3\u03bf\u03cd\u03bc\u03b5\u03bd\u03bf] dddd [{}] LT";default:return "[\u03c4\u03b7\u03bd \u03c0\u03c1\u03bf\u03b7\u03b3\u03bf\u03cd\u03bc\u03b5\u03bd\u03b7] dddd [{}] LT"}},sameElse:"L"},calendar:function(e,a){var _,e=this._calendarEl[e],s=a&&a.hours();return _=e,(e="undefined"!=typeof Function&&_ instanceof Function||"[object Function]"===Object.prototype.toString.call(_)?e.apply(a):e).replace("{}",s%12==1?"\u03c3\u03c4\u03b7":"\u03c3\u03c4\u03b9\u03c2")},relativeTime:{future:"\u03c3\u03b5 %s",past:"%s \u03c0\u03c1\u03b9\u03bd",s:"\u03bb\u03af\u03b3\u03b1 \u03b4\u03b5\u03c5\u03c4\u03b5\u03c1\u03cc\u03bb\u03b5\u03c0\u03c4\u03b1",ss:"%d \u03b4\u03b5\u03c5\u03c4\u03b5\u03c1\u03cc\u03bb\u03b5\u03c0\u03c4\u03b1",m:"\u03ad\u03bd\u03b1 \u03bb\u03b5\u03c0\u03c4\u03cc",mm:"%d \u03bb\u03b5\u03c0\u03c4\u03ac",h:"\u03bc\u03af\u03b1 \u03ce\u03c1\u03b1",hh:"%d \u03ce\u03c1\u03b5\u03c2",d:"\u03bc\u03af\u03b1 \u03bc\u03ad\u03c1\u03b1",dd:"%d \u03bc\u03ad\u03c1\u03b5\u03c2",M:"\u03ad\u03bd\u03b1\u03c2 \u03bc\u03ae\u03bd\u03b1\u03c2",MM:"%d \u03bc\u03ae\u03bd\u03b5\u03c2",y:"\u03ad\u03bd\u03b1\u03c2 \u03c7\u03c1\u03cc\u03bd\u03bf\u03c2",yy:"%d \u03c7\u03c1\u03cc\u03bd\u03b9\u03b1"},dayOfMonthOrdinalParse:/\d{1,2}\u03b7/,ordinal:"%d\u03b7",week:{dow:1,doy:4}}),e.defineLocale("en-au",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1==a?"st":2==a?"nd":3==a?"rd":"th")},week:{dow:0,doy:4}}),e.defineLocale("en-ca",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"YYYY-MM-DD",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1==a?"st":2==a?"nd":3==a?"rd":"th")}}),e.defineLocale("en-gb",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1==a?"st":2==a?"nd":3==a?"rd":"th")},week:{dow:1,doy:4}}),e.defineLocale("en-ie",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1==a?"st":2==a?"nd":3==a?"rd":"th")},week:{dow:1,doy:4}}),e.defineLocale("en-il",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1==a?"st":2==a?"nd":3==a?"rd":"th")}}),e.defineLocale("en-in",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1==a?"st":2==a?"nd":3==a?"rd":"th")},week:{dow:0,doy:6}}),e.defineLocale("en-nz",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1==a?"st":2==a?"nd":3==a?"rd":"th")},week:{dow:1,doy:4}}),e.defineLocale("en-sg",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1==a?"st":2==a?"nd":3==a?"rd":"th")},week:{dow:1,doy:4}}),e.defineLocale("eo",{months:"januaro_februaro_marto_aprilo_majo_junio_julio_a\u016dgusto_septembro_oktobro_novembro_decembro".split("_"),monthsShort:"jan_feb_mart_apr_maj_jun_jul_a\u016dg_sept_okt_nov_dec".split("_"),weekdays:"diman\u0109o_lundo_mardo_merkredo_\u0135a\u016ddo_vendredo_sabato".split("_"),weekdaysShort:"dim_lun_mard_merk_\u0135a\u016d_ven_sab".split("_"),weekdaysMin:"di_lu_ma_me_\u0135a_ve_sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"[la] D[-an de] MMMM, YYYY",LLL:"[la] D[-an de] MMMM, YYYY HH:mm",LLLL:"dddd[n], [la] D[-an de] MMMM, YYYY HH:mm",llll:"ddd, [la] D[-an de] MMM, YYYY HH:mm"},meridiemParse:/[ap]\.t\.m/i,isPM:function(e){return "p"===e.charAt(0).toLowerCase()},meridiem:function(e,a,_){return 11<e?_?"p.t.m.":"P.T.M.":_?"a.t.m.":"A.T.M."},calendar:{sameDay:"[Hodia\u016d je] LT",nextDay:"[Morga\u016d je] LT",nextWeek:"dddd[n je] LT",lastDay:"[Hiera\u016d je] LT",lastWeek:"[pasintan] dddd[n je] LT",sameElse:"L"},relativeTime:{future:"post %s",past:"anta\u016d %s",s:"kelkaj sekundoj",ss:"%d sekundoj",m:"unu minuto",mm:"%d minutoj",h:"unu horo",hh:"%d horoj",d:"unu tago",dd:"%d tagoj",M:"unu monato",MM:"%d monatoj",y:"unu jaro",yy:"%d jaroj"},dayOfMonthOrdinalParse:/\d{1,2}a/,ordinal:"%da",week:{dow:1,doy:7}});var ae="ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),_e="ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),m=[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],d=/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,se=(e.defineLocale("es-do",{months:"enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),monthsShort:function(e,a){return e?(/-MMM-/.test(a)?_e:ae)[e.month()]:ae},monthsRegex:d,monthsShortRegex:d,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:m,longMonthsParse:m,shortMonthsParse:m,weekdays:"domingo_lunes_martes_mi\xe9rcoles_jueves_viernes_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._mi\xe9._jue._vie._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY h:mm A",LLLL:"dddd, D [de] MMMM [de] YYYY h:mm A"},calendar:{sameDay:function(){return "[hoy a la"+(1!==this.hours()?"s":"")+"] LT"},nextDay:function(){return "[ma\xf1ana a la"+(1!==this.hours()?"s":"")+"] LT"},nextWeek:function(){return "dddd [a la"+(1!==this.hours()?"s":"")+"] LT"},lastDay:function(){return "[ayer a la"+(1!==this.hours()?"s":"")+"] LT"},lastWeek:function(){return "[el] dddd [pasado a la"+(1!==this.hours()?"s":"")+"] LT"},sameElse:"L"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",w:"una semana",ww:"%d semanas",M:"un mes",MM:"%d meses",y:"un a\xf1o",yy:"%d a\xf1os"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),"ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_")),de="ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),r=[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],n=/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,te=(e.defineLocale("es-mx",{months:"enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),monthsShort:function(e,a){return e?(/-MMM-/.test(a)?de:se)[e.month()]:se},monthsRegex:n,monthsShortRegex:n,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:r,longMonthsParse:r,shortMonthsParse:r,weekdays:"domingo_lunes_martes_mi\xe9rcoles_jueves_viernes_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._mi\xe9._jue._vie._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY H:mm",LLLL:"dddd, D [de] MMMM [de] YYYY H:mm"},calendar:{sameDay:function(){return "[hoy a la"+(1!==this.hours()?"s":"")+"] LT"},nextDay:function(){return "[ma\xf1ana a la"+(1!==this.hours()?"s":"")+"] LT"},nextWeek:function(){return "dddd [a la"+(1!==this.hours()?"s":"")+"] LT"},lastDay:function(){return "[ayer a la"+(1!==this.hours()?"s":"")+"] LT"},lastWeek:function(){return "[el] dddd [pasado a la"+(1!==this.hours()?"s":"")+"] LT"},sameElse:"L"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",w:"una semana",ww:"%d semanas",M:"un mes",MM:"%d meses",y:"un a\xf1o",yy:"%d a\xf1os"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:0,doy:4},invalidDate:"Fecha inv\xe1lida"}),"ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_")),ne="ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),d=[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],m=/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,re=(e.defineLocale("es-us",{months:"enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),monthsShort:function(e,a){return e?(/-MMM-/.test(a)?ne:te)[e.month()]:te},monthsRegex:m,monthsShortRegex:m,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:d,longMonthsParse:d,shortMonthsParse:d,weekdays:"domingo_lunes_martes_mi\xe9rcoles_jueves_viernes_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._mi\xe9._jue._vie._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"MM/DD/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY h:mm A",LLLL:"dddd, D [de] MMMM [de] YYYY h:mm A"},calendar:{sameDay:function(){return "[hoy a la"+(1!==this.hours()?"s":"")+"] LT"},nextDay:function(){return "[ma\xf1ana a la"+(1!==this.hours()?"s":"")+"] LT"},nextWeek:function(){return "dddd [a la"+(1!==this.hours()?"s":"")+"] LT"},lastDay:function(){return "[ayer a la"+(1!==this.hours()?"s":"")+"] LT"},lastWeek:function(){return "[el] dddd [pasado a la"+(1!==this.hours()?"s":"")+"] LT"},sameElse:"L"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",w:"una semana",ww:"%d semanas",M:"un mes",MM:"%d meses",y:"un a\xf1o",yy:"%d a\xf1os"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:0,doy:6}}),"ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_")),ie="ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),n=[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],r=/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;function Y(e,a,_,s){e={s:["m\xf5ne sekundi","m\xf5ni sekund","paar sekundit"],ss:[e+"sekundi",e+"sekundit"],m:["\xfche minuti","\xfcks minut"],mm:[e+" minuti",e+" minutit"],h:["\xfche tunni","tund aega","\xfcks tund"],hh:[e+" tunni",e+" tundi"],d:["\xfche p\xe4eva","\xfcks p\xe4ev"],M:["kuu aja","kuu aega","\xfcks kuu"],MM:[e+" kuu",e+" kuud"],y:["\xfche aasta","aasta","\xfcks aasta"],yy:[e+" aasta",e+" aastat"]};return a?e[_][2]||e[_][1]:s?e[_][0]:e[_][1]}e.defineLocale("es",{months:"enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),monthsShort:function(e,a){return e?(/-MMM-/.test(a)?ie:re)[e.month()]:re},monthsRegex:r,monthsShortRegex:r,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:n,longMonthsParse:n,shortMonthsParse:n,weekdays:"domingo_lunes_martes_mi\xe9rcoles_jueves_viernes_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._mi\xe9._jue._vie._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY H:mm",LLLL:"dddd, D [de] MMMM [de] YYYY H:mm"},calendar:{sameDay:function(){return "[hoy a la"+(1!==this.hours()?"s":"")+"] LT"},nextDay:function(){return "[ma\xf1ana a la"+(1!==this.hours()?"s":"")+"] LT"},nextWeek:function(){return "dddd [a la"+(1!==this.hours()?"s":"")+"] LT"},lastDay:function(){return "[ayer a la"+(1!==this.hours()?"s":"")+"] LT"},lastWeek:function(){return "[el] dddd [pasado a la"+(1!==this.hours()?"s":"")+"] LT"},sameElse:"L"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",w:"una semana",ww:"%d semanas",M:"un mes",MM:"%d meses",y:"un a\xf1o",yy:"%d a\xf1os"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4},invalidDate:"Fecha inv\xe1lida"}),e.defineLocale("et",{months:"jaanuar_veebruar_m\xe4rts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),monthsShort:"jaan_veebr_m\xe4rts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),weekdays:"p\xfchap\xe4ev_esmasp\xe4ev_teisip\xe4ev_kolmap\xe4ev_neljap\xe4ev_reede_laup\xe4ev".split("_"),weekdaysShort:"P_E_T_K_N_R_L".split("_"),weekdaysMin:"P_E_T_K_N_R_L".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[T\xe4na,] LT",nextDay:"[Homme,] LT",nextWeek:"[J\xe4rgmine] dddd LT",lastDay:"[Eile,] LT",lastWeek:"[Eelmine] dddd LT",sameElse:"L"},relativeTime:{future:"%s p\xe4rast",past:"%s tagasi",s:Y,ss:Y,m:Y,mm:Y,h:Y,hh:Y,d:Y,dd:"%d p\xe4eva",M:Y,MM:Y,y:Y,yy:Y},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("eu",{months:"urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),monthsShort:"urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),monthsParseExact:!0,weekdays:"igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),weekdaysShort:"ig._al._ar._az._og._ol._lr.".split("_"),weekdaysMin:"ig_al_ar_az_og_ol_lr".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY[ko] MMMM[ren] D[a]",LLL:"YYYY[ko] MMMM[ren] D[a] HH:mm",LLLL:"dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",l:"YYYY-M-D",ll:"YYYY[ko] MMM D[a]",lll:"YYYY[ko] MMM D[a] HH:mm",llll:"ddd, YYYY[ko] MMM D[a] HH:mm"},calendar:{sameDay:"[gaur] LT[etan]",nextDay:"[bihar] LT[etan]",nextWeek:"dddd LT[etan]",lastDay:"[atzo] LT[etan]",lastWeek:"[aurreko] dddd LT[etan]",sameElse:"L"},relativeTime:{future:"%s barru",past:"duela %s",s:"segundo batzuk",ss:"%d segundo",m:"minutu bat",mm:"%d minutu",h:"ordu bat",hh:"%d ordu",d:"egun bat",dd:"%d egun",M:"hilabete bat",MM:"%d hilabete",y:"urte bat",yy:"%d urte"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}});var me={1:"\u06f1",2:"\u06f2",3:"\u06f3",4:"\u06f4",5:"\u06f5",6:"\u06f6",7:"\u06f7",8:"\u06f8",9:"\u06f9",0:"\u06f0"},oe={"\u06f1":"1","\u06f2":"2","\u06f3":"3","\u06f4":"4","\u06f5":"5","\u06f6":"6","\u06f7":"7","\u06f8":"8","\u06f9":"9","\u06f0":"0"},ue=(e.defineLocale("fa",{months:"\u0698\u0627\u0646\u0648\u06cc\u0647_\u0641\u0648\u0631\u06cc\u0647_\u0645\u0627\u0631\u0633_\u0622\u0648\u0631\u06cc\u0644_\u0645\u0647_\u0698\u0648\u0626\u0646_\u0698\u0648\u0626\u06cc\u0647_\u0627\u0648\u062a_\u0633\u067e\u062a\u0627\u0645\u0628\u0631_\u0627\u06a9\u062a\u0628\u0631_\u0646\u0648\u0627\u0645\u0628\u0631_\u062f\u0633\u0627\u0645\u0628\u0631".split("_"),monthsShort:"\u0698\u0627\u0646\u0648\u06cc\u0647_\u0641\u0648\u0631\u06cc\u0647_\u0645\u0627\u0631\u0633_\u0622\u0648\u0631\u06cc\u0644_\u0645\u0647_\u0698\u0648\u0626\u0646_\u0698\u0648\u0626\u06cc\u0647_\u0627\u0648\u062a_\u0633\u067e\u062a\u0627\u0645\u0628\u0631_\u0627\u06a9\u062a\u0628\u0631_\u0646\u0648\u0627\u0645\u0628\u0631_\u062f\u0633\u0627\u0645\u0628\u0631".split("_"),weekdays:"\u06cc\u06a9\u200c\u0634\u0646\u0628\u0647_\u062f\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200c\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067e\u0646\u062c\u200c\u0634\u0646\u0628\u0647_\u062c\u0645\u0639\u0647_\u0634\u0646\u0628\u0647".split("_"),weekdaysShort:"\u06cc\u06a9\u200c\u0634\u0646\u0628\u0647_\u062f\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200c\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067e\u0646\u062c\u200c\u0634\u0646\u0628\u0647_\u062c\u0645\u0639\u0647_\u0634\u0646\u0628\u0647".split("_"),weekdaysMin:"\u06cc_\u062f_\u0633_\u0686_\u067e_\u062c_\u0634".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},meridiemParse:/\u0642\u0628\u0644 \u0627\u0632 \u0638\u0647\u0631|\u0628\u0639\u062f \u0627\u0632 \u0638\u0647\u0631/,isPM:function(e){return /\u0628\u0639\u062f \u0627\u0632 \u0638\u0647\u0631/.test(e)},meridiem:function(e,a,_){return e<12?"\u0642\u0628\u0644 \u0627\u0632 \u0638\u0647\u0631":"\u0628\u0639\u062f \u0627\u0632 \u0638\u0647\u0631"},calendar:{sameDay:"[\u0627\u0645\u0631\u0648\u0632 \u0633\u0627\u0639\u062a] LT",nextDay:"[\u0641\u0631\u062f\u0627 \u0633\u0627\u0639\u062a] LT",nextWeek:"dddd [\u0633\u0627\u0639\u062a] LT",lastDay:"[\u062f\u06cc\u0631\u0648\u0632 \u0633\u0627\u0639\u062a] LT",lastWeek:"dddd [\u067e\u06cc\u0634] [\u0633\u0627\u0639\u062a] LT",sameElse:"L"},relativeTime:{future:"\u062f\u0631 %s",past:"%s \u067e\u06cc\u0634",s:"\u0686\u0646\u062f \u062b\u0627\u0646\u06cc\u0647",ss:"%d \u062b\u0627\u0646\u06cc\u0647",m:"\u06cc\u06a9 \u062f\u0642\u06cc\u0642\u0647",mm:"%d \u062f\u0642\u06cc\u0642\u0647",h:"\u06cc\u06a9 \u0633\u0627\u0639\u062a",hh:"%d \u0633\u0627\u0639\u062a",d:"\u06cc\u06a9 \u0631\u0648\u0632",dd:"%d \u0631\u0648\u0632",M:"\u06cc\u06a9 \u0645\u0627\u0647",MM:"%d \u0645\u0627\u0647",y:"\u06cc\u06a9 \u0633\u0627\u0644",yy:"%d \u0633\u0627\u0644"},preparse:function(e){return e.replace(/[\u06f0-\u06f9]/g,function(e){return oe[e]}).replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return me[e]}).replace(/,/g,"\u060c")},dayOfMonthOrdinalParse:/\d{1,2}\u0645/,ordinal:"%d\u0645",week:{dow:6,doy:12}}),"nolla yksi kaksi kolme nelj\xe4 viisi kuusi seitsem\xe4n kahdeksan yhdeks\xe4n".split(" ")),le=["nolla","yhden","kahden","kolmen","nelj\xe4n","viiden","kuuden",ue[7],ue[8],ue[9]];function h(e,a,_,s){var d="";switch(_){case"s":return s?"muutaman sekunnin":"muutama sekunti";case"ss":d=s?"sekunnin":"sekuntia";break;case"m":return s?"minuutin":"minuutti";case"mm":d=s?"minuutin":"minuuttia";break;case"h":return s?"tunnin":"tunti";case"hh":d=s?"tunnin":"tuntia";break;case"d":return s?"p\xe4iv\xe4n":"p\xe4iv\xe4";case"dd":d=s?"p\xe4iv\xe4n":"p\xe4iv\xe4\xe4";break;case"M":return s?"kuukauden":"kuukausi";case"MM":d=s?"kuukauden":"kuukautta";break;case"y":return s?"vuoden":"vuosi";case"yy":d=s?"vuoden":"vuotta";break}return _=s,d=((e=e)<10?(_?le:ue)[e]:e)+" "+d}e.defineLocale("fi",{months:"tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kes\xe4kuu_hein\xe4kuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),monthsShort:"tammi_helmi_maalis_huhti_touko_kes\xe4_hein\xe4_elo_syys_loka_marras_joulu".split("_"),weekdays:"sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),weekdaysShort:"su_ma_ti_ke_to_pe_la".split("_"),weekdaysMin:"su_ma_ti_ke_to_pe_la".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD.MM.YYYY",LL:"Do MMMM[ta] YYYY",LLL:"Do MMMM[ta] YYYY, [klo] HH.mm",LLLL:"dddd, Do MMMM[ta] YYYY, [klo] HH.mm",l:"D.M.YYYY",ll:"Do MMM YYYY",lll:"Do MMM YYYY, [klo] HH.mm",llll:"ddd, Do MMM YYYY, [klo] HH.mm"},calendar:{sameDay:"[t\xe4n\xe4\xe4n] [klo] LT",nextDay:"[huomenna] [klo] LT",nextWeek:"dddd [klo] LT",lastDay:"[eilen] [klo] LT",lastWeek:"[viime] dddd[na] [klo] LT",sameElse:"L"},relativeTime:{future:"%s p\xe4\xe4st\xe4",past:"%s sitten",s:h,ss:h,m:h,mm:h,h:h,hh:h,d:h,dd:h,M:h,MM:h,y:h,yy:h},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("fil",{months:"Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),monthsShort:"Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),weekdays:"Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),weekdaysShort:"Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),weekdaysMin:"Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"MM/D/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY HH:mm",LLLL:"dddd, MMMM DD, YYYY HH:mm"},calendar:{sameDay:"LT [ngayong araw]",nextDay:"[Bukas ng] LT",nextWeek:"LT [sa susunod na] dddd",lastDay:"LT [kahapon]",lastWeek:"LT [noong nakaraang] dddd",sameElse:"L"},relativeTime:{future:"sa loob ng %s",past:"%s ang nakalipas",s:"ilang segundo",ss:"%d segundo",m:"isang minuto",mm:"%d minuto",h:"isang oras",hh:"%d oras",d:"isang araw",dd:"%d araw",M:"isang buwan",MM:"%d buwan",y:"isang taon",yy:"%d taon"},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:function(e){return e},week:{dow:1,doy:4}}),e.defineLocale("fo",{months:"januar_februar_mars_apr\xedl_mai_juni_juli_august_september_oktober_november_desember".split("_"),monthsShort:"jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),weekdays:"sunnudagur_m\xe1nadagur_t\xfdsdagur_mikudagur_h\xf3sdagur_fr\xedggjadagur_leygardagur".split("_"),weekdaysShort:"sun_m\xe1n_t\xfds_mik_h\xf3s_fr\xed_ley".split("_"),weekdaysMin:"su_m\xe1_t\xfd_mi_h\xf3_fr_le".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D. MMMM, YYYY HH:mm"},calendar:{sameDay:"[\xcd dag kl.] LT",nextDay:"[\xcd morgin kl.] LT",nextWeek:"dddd [kl.] LT",lastDay:"[\xcd gj\xe1r kl.] LT",lastWeek:"[s\xed\xf0stu] dddd [kl] LT",sameElse:"L"},relativeTime:{future:"um %s",past:"%s s\xed\xf0ani",s:"f\xe1 sekund",ss:"%d sekundir",m:"ein minuttur",mm:"%d minuttir",h:"ein t\xedmi",hh:"%d t\xedmar",d:"ein dagur",dd:"%d dagar",M:"ein m\xe1na\xf0ur",MM:"%d m\xe1na\xf0ir",y:"eitt \xe1r",yy:"%d \xe1r"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("fr-ca",{months:"janvier_f\xe9vrier_mars_avril_mai_juin_juillet_ao\xfbt_septembre_octobre_novembre_d\xe9cembre".split("_"),monthsShort:"janv._f\xe9vr._mars_avr._mai_juin_juil._ao\xfbt_sept._oct._nov._d\xe9c.".split("_"),monthsParseExact:!0,weekdays:"dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),weekdaysShort:"dim._lun._mar._mer._jeu._ven._sam.".split("_"),weekdaysMin:"di_lu_ma_me_je_ve_sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Aujourd\u2019hui \xe0] LT",nextDay:"[Demain \xe0] LT",nextWeek:"dddd [\xe0] LT",lastDay:"[Hier \xe0] LT",lastWeek:"dddd [dernier \xe0] LT",sameElse:"L"},relativeTime:{future:"dans %s",past:"il y a %s",s:"quelques secondes",ss:"%d secondes",m:"une minute",mm:"%d minutes",h:"une heure",hh:"%d heures",d:"un jour",dd:"%d jours",M:"un mois",MM:"%d mois",y:"un an",yy:"%d ans"},dayOfMonthOrdinalParse:/\d{1,2}(er|e)/,ordinal:function(e,a){switch(a){default:case"M":case"Q":case"D":case"DDD":case"d":return e+(1===e?"er":"e");case"w":case"W":return e+(1===e?"re":"e")}}}),e.defineLocale("fr-ch",{months:"janvier_f\xe9vrier_mars_avril_mai_juin_juillet_ao\xfbt_septembre_octobre_novembre_d\xe9cembre".split("_"),monthsShort:"janv._f\xe9vr._mars_avr._mai_juin_juil._ao\xfbt_sept._oct._nov._d\xe9c.".split("_"),monthsParseExact:!0,weekdays:"dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),weekdaysShort:"dim._lun._mar._mer._jeu._ven._sam.".split("_"),weekdaysMin:"di_lu_ma_me_je_ve_sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Aujourd\u2019hui \xe0] LT",nextDay:"[Demain \xe0] LT",nextWeek:"dddd [\xe0] LT",lastDay:"[Hier \xe0] LT",lastWeek:"dddd [dernier \xe0] LT",sameElse:"L"},relativeTime:{future:"dans %s",past:"il y a %s",s:"quelques secondes",ss:"%d secondes",m:"une minute",mm:"%d minutes",h:"une heure",hh:"%d heures",d:"un jour",dd:"%d jours",M:"un mois",MM:"%d mois",y:"un an",yy:"%d ans"},dayOfMonthOrdinalParse:/\d{1,2}(er|e)/,ordinal:function(e,a){switch(a){default:case"M":case"Q":case"D":case"DDD":case"d":return e+(1===e?"er":"e");case"w":case"W":return e+(1===e?"re":"e")}},week:{dow:1,doy:4}});var m=/(janv\.?|f\xe9vr\.?|mars|avr\.?|mai|juin|juil\.?|ao\xfbt|sept\.?|oct\.?|nov\.?|d\xe9c\.?|janvier|f\xe9vrier|mars|avril|mai|juin|juillet|ao\xfbt|septembre|octobre|novembre|d\xe9cembre)/i,d=[/^janv/i,/^f\xe9vr/i,/^mars/i,/^avr/i,/^mai/i,/^juin/i,/^juil/i,/^ao\xfbt/i,/^sept/i,/^oct/i,/^nov/i,/^d\xe9c/i],Me=(e.defineLocale("fr",{months:"janvier_f\xe9vrier_mars_avril_mai_juin_juillet_ao\xfbt_septembre_octobre_novembre_d\xe9cembre".split("_"),monthsShort:"janv._f\xe9vr._mars_avr._mai_juin_juil._ao\xfbt_sept._oct._nov._d\xe9c.".split("_"),monthsRegex:m,monthsShortRegex:m,monthsStrictRegex:/^(janvier|f\xe9vrier|mars|avril|mai|juin|juillet|ao\xfbt|septembre|octobre|novembre|d\xe9cembre)/i,monthsShortStrictRegex:/(janv\.?|f\xe9vr\.?|mars|avr\.?|mai|juin|juil\.?|ao\xfbt|sept\.?|oct\.?|nov\.?|d\xe9c\.?)/i,monthsParse:d,longMonthsParse:d,shortMonthsParse:d,weekdays:"dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),weekdaysShort:"dim._lun._mar._mer._jeu._ven._sam.".split("_"),weekdaysMin:"di_lu_ma_me_je_ve_sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Aujourd\u2019hui \xe0] LT",nextDay:"[Demain \xe0] LT",nextWeek:"dddd [\xe0] LT",lastDay:"[Hier \xe0] LT",lastWeek:"dddd [dernier \xe0] LT",sameElse:"L"},relativeTime:{future:"dans %s",past:"il y a %s",s:"quelques secondes",ss:"%d secondes",m:"une minute",mm:"%d minutes",h:"une heure",hh:"%d heures",d:"un jour",dd:"%d jours",w:"une semaine",ww:"%d semaines",M:"un mois",MM:"%d mois",y:"un an",yy:"%d ans"},dayOfMonthOrdinalParse:/\d{1,2}(er|)/,ordinal:function(e,a){switch(a){case"D":return e+(1===e?"er":"");default:case"M":case"Q":case"DDD":case"d":return e+(1===e?"er":"e");case"w":case"W":return e+(1===e?"re":"e")}},week:{dow:1,doy:4}}),"jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_")),Le="jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");e.defineLocale("fy",{months:"jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"),monthsShort:function(e,a){return e?(/-MMM-/.test(a)?Le:Me)[e.month()]:Me},monthsParseExact:!0,weekdays:"snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"),weekdaysShort:"si._mo._ti._wo._to._fr._so.".split("_"),weekdaysMin:"Si_Mo_Ti_Wo_To_Fr_So".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[hjoed om] LT",nextDay:"[moarn om] LT",nextWeek:"dddd [om] LT",lastDay:"[juster om] LT",lastWeek:"[\xf4fr\xfbne] dddd [om] LT",sameElse:"L"},relativeTime:{future:"oer %s",past:"%s lyn",s:"in pear sekonden",ss:"%d sekonden",m:"ien min\xfat",mm:"%d minuten",h:"ien oere",hh:"%d oeren",d:"ien dei",dd:"%d dagen",M:"ien moanne",MM:"%d moannen",y:"ien jier",yy:"%d jierren"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||20<=e?"ste":"de")},week:{dow:1,doy:4}}),e.defineLocale("ga",{months:["Ean\xe1ir","Feabhra","M\xe1rta","Aibre\xe1n","Bealtaine","Meitheamh","I\xfail","L\xfanasa","Me\xe1n F\xf3mhair","Deireadh F\xf3mhair","Samhain","Nollaig"],monthsShort:["Ean","Feabh","M\xe1rt","Aib","Beal","Meith","I\xfail","L\xfan","M.F.","D.F.","Samh","Noll"],monthsParseExact:!0,weekdays:["D\xe9 Domhnaigh","D\xe9 Luain","D\xe9 M\xe1irt","D\xe9 C\xe9adaoin","D\xe9ardaoin","D\xe9 hAoine","D\xe9 Sathairn"],weekdaysShort:["Domh","Luan","M\xe1irt","C\xe9ad","D\xe9ar","Aoine","Sath"],weekdaysMin:["Do","Lu","M\xe1","C\xe9","D\xe9","A","Sa"],longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Inniu ag] LT",nextDay:"[Am\xe1rach ag] LT",nextWeek:"dddd [ag] LT",lastDay:"[Inn\xe9 ag] LT",lastWeek:"dddd [seo caite] [ag] LT",sameElse:"L"},relativeTime:{future:"i %s",past:"%s \xf3 shin",s:"c\xfapla soicind",ss:"%d soicind",m:"n\xf3im\xe9ad",mm:"%d n\xf3im\xe9ad",h:"uair an chloig",hh:"%d uair an chloig",d:"l\xe1",dd:"%d l\xe1",M:"m\xed",MM:"%d m\xedonna",y:"bliain",yy:"%d bliain"},dayOfMonthOrdinalParse:/\d{1,2}(d|na|mh)/,ordinal:function(e){return e+(1===e?"d":e%10==2?"na":"mh")},week:{dow:1,doy:4}});function y(e,a,_,s){e={s:["\u0925\u094b\u0921\u092f\u093e \u0938\u0945\u0915\u0902\u0921\u093e\u0902\u0928\u0940","\u0925\u094b\u0921\u0947 \u0938\u0945\u0915\u0902\u0921"],ss:[e+" \u0938\u0945\u0915\u0902\u0921\u093e\u0902\u0928\u0940",e+" \u0938\u0945\u0915\u0902\u0921"],m:["\u090f\u0915\u093e \u092e\u093f\u0923\u091f\u093e\u0928","\u090f\u0915 \u092e\u093f\u0928\u0942\u091f"],mm:[e+" \u092e\u093f\u0923\u091f\u093e\u0902\u0928\u0940",e+" \u092e\u093f\u0923\u091f\u093e\u0902"],h:["\u090f\u0915\u093e \u0935\u0930\u093e\u0928","\u090f\u0915 \u0935\u0930"],hh:[e+" \u0935\u0930\u093e\u0902\u0928\u0940",e+" \u0935\u0930\u093e\u0902"],d:["\u090f\u0915\u093e \u0926\u093f\u0938\u093e\u0928","\u090f\u0915 \u0926\u0940\u0938"],dd:[e+" \u0926\u093f\u0938\u093e\u0902\u0928\u0940",e+" \u0926\u0940\u0938"],M:["\u090f\u0915\u093e \u092e\u094d\u0939\u092f\u0928\u094d\u092f\u093e\u0928","\u090f\u0915 \u092e\u094d\u0939\u092f\u0928\u094b"],MM:[e+" \u092e\u094d\u0939\u092f\u0928\u094d\u092f\u093e\u0928\u0940",e+" \u092e\u094d\u0939\u092f\u0928\u0947"],y:["\u090f\u0915\u093e \u0935\u0930\u094d\u0938\u093e\u0928","\u090f\u0915 \u0935\u0930\u094d\u0938"],yy:[e+" \u0935\u0930\u094d\u0938\u093e\u0902\u0928\u0940",e+" \u0935\u0930\u094d\u0938\u093e\u0902"]};return s?e[_][0]:e[_][1]}function c(e,a,_,s){e={s:["thoddea sekondamni","thodde sekond"],ss:[e+" sekondamni",e+" sekond"],m:["eka mintan","ek minut"],mm:[e+" mintamni",e+" mintam"],h:["eka voran","ek vor"],hh:[e+" voramni",e+" voram"],d:["eka disan","ek dis"],dd:[e+" disamni",e+" dis"],M:["eka mhoinean","ek mhoino"],MM:[e+" mhoineamni",e+" mhoine"],y:["eka vorsan","ek voros"],yy:[e+" vorsamni",e+" vorsam"]};return s?e[_][0]:e[_][1]}e.defineLocale("gd",{months:["Am Faoilleach","An Gearran","Am M\xe0rt","An Giblean","An C\xe8itean","An t-\xd2gmhios","An t-Iuchar","An L\xf9nastal","An t-Sultain","An D\xe0mhair","An t-Samhain","An D\xf9bhlachd"],monthsShort:["Faoi","Gear","M\xe0rt","Gibl","C\xe8it","\xd2gmh","Iuch","L\xf9n","Sult","D\xe0mh","Samh","D\xf9bh"],monthsParseExact:!0,weekdays:["Did\xf2mhnaich","Diluain","Dim\xe0irt","Diciadain","Diardaoin","Dihaoine","Disathairne"],weekdaysShort:["Did","Dil","Dim","Dic","Dia","Dih","Dis"],weekdaysMin:["D\xf2","Lu","M\xe0","Ci","Ar","Ha","Sa"],longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[An-diugh aig] LT",nextDay:"[A-m\xe0ireach aig] LT",nextWeek:"dddd [aig] LT",lastDay:"[An-d\xe8 aig] LT",lastWeek:"dddd [seo chaidh] [aig] LT",sameElse:"L"},relativeTime:{future:"ann an %s",past:"bho chionn %s",s:"beagan diogan",ss:"%d diogan",m:"mionaid",mm:"%d mionaidean",h:"uair",hh:"%d uairean",d:"latha",dd:"%d latha",M:"m\xecos",MM:"%d m\xecosan",y:"bliadhna",yy:"%d bliadhna"},dayOfMonthOrdinalParse:/\d{1,2}(d|na|mh)/,ordinal:function(e){return e+(1===e?"d":e%10==2?"na":"mh")},week:{dow:1,doy:4}}),e.defineLocale("gl",{months:"xaneiro_febreiro_marzo_abril_maio_xu\xf1o_xullo_agosto_setembro_outubro_novembro_decembro".split("_"),monthsShort:"xan._feb._mar._abr._mai._xu\xf1._xul._ago._set._out._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"domingo_luns_martes_m\xe9rcores_xoves_venres_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._m\xe9r._xov._ven._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_m\xe9_xo_ve_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY H:mm",LLLL:"dddd, D [de] MMMM [de] YYYY H:mm"},calendar:{sameDay:function(){return "[hoxe "+(1!==this.hours()?"\xe1s":"\xe1")+"] LT"},nextDay:function(){return "[ma\xf1\xe1 "+(1!==this.hours()?"\xe1s":"\xe1")+"] LT"},nextWeek:function(){return "dddd ["+(1!==this.hours()?"\xe1s":"a")+"] LT"},lastDay:function(){return "[onte "+(1!==this.hours()?"\xe1":"a")+"] LT"},lastWeek:function(){return "[o] dddd [pasado "+(1!==this.hours()?"\xe1s":"a")+"] LT"},sameElse:"L"},relativeTime:{future:function(e){return 0===e.indexOf("un")?"n"+e:"en "+e},past:"hai %s",s:"uns segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"unha hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",M:"un mes",MM:"%d meses",y:"un ano",yy:"%d anos"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),e.defineLocale("gom-deva",{months:{standalone:"\u091c\u093e\u0928\u0947\u0935\u093e\u0930\u0940_\u092b\u0947\u092c\u094d\u0930\u0941\u0935\u093e\u0930\u0940_\u092e\u093e\u0930\u094d\u091a_\u090f\u092a\u094d\u0930\u0940\u0932_\u092e\u0947_\u091c\u0942\u0928_\u091c\u0941\u0932\u092f_\u0911\u0917\u0938\u094d\u091f_\u0938\u092a\u094d\u091f\u0947\u0902\u092c\u0930_\u0911\u0915\u094d\u091f\u094b\u092c\u0930_\u0928\u094b\u0935\u094d\u0939\u0947\u0902\u092c\u0930_\u0921\u093f\u0938\u0947\u0902\u092c\u0930".split("_"),format:"\u091c\u093e\u0928\u0947\u0935\u093e\u0930\u0940\u091a\u094d\u092f\u093e_\u092b\u0947\u092c\u094d\u0930\u0941\u0935\u093e\u0930\u0940\u091a\u094d\u092f\u093e_\u092e\u093e\u0930\u094d\u091a\u093e\u091a\u094d\u092f\u093e_\u090f\u092a\u094d\u0930\u0940\u0932\u093e\u091a\u094d\u092f\u093e_\u092e\u0947\u092f\u093e\u091a\u094d\u092f\u093e_\u091c\u0942\u0928\u093e\u091a\u094d\u092f\u093e_\u091c\u0941\u0932\u092f\u093e\u091a\u094d\u092f\u093e_\u0911\u0917\u0938\u094d\u091f\u093e\u091a\u094d\u092f\u093e_\u0938\u092a\u094d\u091f\u0947\u0902\u092c\u0930\u093e\u091a\u094d\u092f\u093e_\u0911\u0915\u094d\u091f\u094b\u092c\u0930\u093e\u091a\u094d\u092f\u093e_\u0928\u094b\u0935\u094d\u0939\u0947\u0902\u092c\u0930\u093e\u091a\u094d\u092f\u093e_\u0921\u093f\u0938\u0947\u0902\u092c\u0930\u093e\u091a\u094d\u092f\u093e".split("_"),isFormat:/MMMM(\s)+D[oD]?/},monthsShort:"\u091c\u093e\u0928\u0947._\u092b\u0947\u092c\u094d\u0930\u0941._\u092e\u093e\u0930\u094d\u091a_\u090f\u092a\u094d\u0930\u0940._\u092e\u0947_\u091c\u0942\u0928_\u091c\u0941\u0932._\u0911\u0917._\u0938\u092a\u094d\u091f\u0947\u0902._\u0911\u0915\u094d\u091f\u094b._\u0928\u094b\u0935\u094d\u0939\u0947\u0902._\u0921\u093f\u0938\u0947\u0902.".split("_"),monthsParseExact:!0,weekdays:"\u0906\u092f\u0924\u093e\u0930_\u0938\u094b\u092e\u093e\u0930_\u092e\u0902\u0917\u0933\u093e\u0930_\u092c\u0941\u0927\u0935\u093e\u0930_\u092c\u093f\u0930\u0947\u0938\u094d\u0924\u093e\u0930_\u0938\u0941\u0915\u094d\u0930\u093e\u0930_\u0936\u0947\u0928\u0935\u093e\u0930".split("_"),weekdaysShort:"\u0906\u092f\u0924._\u0938\u094b\u092e._\u092e\u0902\u0917\u0933._\u092c\u0941\u0927._\u092c\u094d\u0930\u0947\u0938\u094d\u0924._\u0938\u0941\u0915\u094d\u0930._\u0936\u0947\u0928.".split("_"),weekdaysMin:"\u0906_\u0938\u094b_\u092e\u0902_\u092c\u0941_\u092c\u094d\u0930\u0947_\u0938\u0941_\u0936\u0947".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"A h:mm [\u0935\u093e\u091c\u0924\u093e\u0902]",LTS:"A h:mm:ss [\u0935\u093e\u091c\u0924\u093e\u0902]",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY A h:mm [\u0935\u093e\u091c\u0924\u093e\u0902]",LLLL:"dddd, MMMM Do, YYYY, A h:mm [\u0935\u093e\u091c\u0924\u093e\u0902]",llll:"ddd, D MMM YYYY, A h:mm [\u0935\u093e\u091c\u0924\u093e\u0902]"},calendar:{sameDay:"[\u0906\u092f\u091c] LT",nextDay:"[\u092b\u093e\u0932\u094d\u092f\u093e\u0902] LT",nextWeek:"[\u092b\u0941\u0921\u0932\u094b] dddd[,] LT",lastDay:"[\u0915\u093e\u0932] LT",lastWeek:"[\u092b\u093e\u091f\u0932\u094b] dddd[,] LT",sameElse:"L"},relativeTime:{future:"%s",past:"%s \u0906\u0926\u0940\u0902",s:y,ss:y,m:y,mm:y,h:y,hh:y,d:y,dd:y,M:y,MM:y,y:y,yy:y},dayOfMonthOrdinalParse:/\d{1,2}(\u0935\u0947\u0930)/,ordinal:function(e,a){switch(a){case"D":return e+"\u0935\u0947\u0930";default:case"M":case"Q":case"DDD":case"d":case"w":case"W":return e}},week:{dow:0,doy:3},meridiemParse:/\u0930\u093e\u0924\u0940|\u0938\u0915\u093e\u0933\u0940\u0902|\u0926\u0928\u092a\u093e\u0930\u093e\u0902|\u0938\u093e\u0902\u091c\u0947/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0930\u093e\u0924\u0940"===a?e<4?e:e+12:"\u0938\u0915\u093e\u0933\u0940\u0902"===a?e:"\u0926\u0928\u092a\u093e\u0930\u093e\u0902"===a?12<e?e:e+12:"\u0938\u093e\u0902\u091c\u0947"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0930\u093e\u0924\u0940":e<12?"\u0938\u0915\u093e\u0933\u0940\u0902":e<16?"\u0926\u0928\u092a\u093e\u0930\u093e\u0902":e<20?"\u0938\u093e\u0902\u091c\u0947":"\u0930\u093e\u0924\u0940"}}),e.defineLocale("gom-latn",{months:{standalone:"Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"),format:"Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea".split("_"),isFormat:/MMMM(\s)+D[oD]?/},monthsShort:"Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split("_"),weekdaysShort:"Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"),weekdaysMin:"Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"A h:mm [vazta]",LTS:"A h:mm:ss [vazta]",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY A h:mm [vazta]",LLLL:"dddd, MMMM Do, YYYY, A h:mm [vazta]",llll:"ddd, D MMM YYYY, A h:mm [vazta]"},calendar:{sameDay:"[Aiz] LT",nextDay:"[Faleam] LT",nextWeek:"[Fuddlo] dddd[,] LT",lastDay:"[Kal] LT",lastWeek:"[Fattlo] dddd[,] LT",sameElse:"L"},relativeTime:{future:"%s",past:"%s adim",s:c,ss:c,m:c,mm:c,h:c,hh:c,d:c,dd:c,M:c,MM:c,y:c,yy:c},dayOfMonthOrdinalParse:/\d{1,2}(er)/,ordinal:function(e,a){switch(a){case"D":return e+"er";default:case"M":case"Q":case"DDD":case"d":case"w":case"W":return e}},week:{dow:0,doy:3},meridiemParse:/rati|sokallim|donparam|sanje/,meridiemHour:function(e,a){return 12===e&&(e=0),"rati"===a?e<4?e:e+12:"sokallim"===a?e:"donparam"===a?12<e?e:e+12:"sanje"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"rati":e<12?"sokallim":e<16?"donparam":e<20?"sanje":"rati"}});var Ye={1:"\u0ae7",2:"\u0ae8",3:"\u0ae9",4:"\u0aea",5:"\u0aeb",6:"\u0aec",7:"\u0aed",8:"\u0aee",9:"\u0aef",0:"\u0ae6"},he={"\u0ae7":"1","\u0ae8":"2","\u0ae9":"3","\u0aea":"4","\u0aeb":"5","\u0aec":"6","\u0aed":"7","\u0aee":"8","\u0aef":"9","\u0ae6":"0"},ye=(e.defineLocale("gu",{months:"\u0a9c\u0abe\u0aa8\u0acd\u0aaf\u0ac1\u0a86\u0ab0\u0ac0_\u0aab\u0ac7\u0aac\u0acd\u0ab0\u0ac1\u0a86\u0ab0\u0ac0_\u0aae\u0abe\u0ab0\u0acd\u0a9a_\u0a8f\u0aaa\u0acd\u0ab0\u0abf\u0ab2_\u0aae\u0ac7_\u0a9c\u0ac2\u0aa8_\u0a9c\u0ac1\u0ab2\u0abe\u0a88_\u0a91\u0a97\u0ab8\u0acd\u0a9f_\u0ab8\u0aaa\u0acd\u0a9f\u0ac7\u0aae\u0acd\u0aac\u0ab0_\u0a91\u0a95\u0acd\u0a9f\u0acd\u0aac\u0ab0_\u0aa8\u0ab5\u0ac7\u0aae\u0acd\u0aac\u0ab0_\u0aa1\u0abf\u0ab8\u0ac7\u0aae\u0acd\u0aac\u0ab0".split("_"),monthsShort:"\u0a9c\u0abe\u0aa8\u0acd\u0aaf\u0ac1._\u0aab\u0ac7\u0aac\u0acd\u0ab0\u0ac1._\u0aae\u0abe\u0ab0\u0acd\u0a9a_\u0a8f\u0aaa\u0acd\u0ab0\u0abf._\u0aae\u0ac7_\u0a9c\u0ac2\u0aa8_\u0a9c\u0ac1\u0ab2\u0abe._\u0a91\u0a97._\u0ab8\u0aaa\u0acd\u0a9f\u0ac7._\u0a91\u0a95\u0acd\u0a9f\u0acd._\u0aa8\u0ab5\u0ac7._\u0aa1\u0abf\u0ab8\u0ac7.".split("_"),monthsParseExact:!0,weekdays:"\u0ab0\u0ab5\u0abf\u0ab5\u0abe\u0ab0_\u0ab8\u0acb\u0aae\u0ab5\u0abe\u0ab0_\u0aae\u0a82\u0a97\u0ab3\u0ab5\u0abe\u0ab0_\u0aac\u0ac1\u0aa7\u0acd\u0ab5\u0abe\u0ab0_\u0a97\u0ac1\u0ab0\u0ac1\u0ab5\u0abe\u0ab0_\u0ab6\u0ac1\u0a95\u0acd\u0ab0\u0ab5\u0abe\u0ab0_\u0ab6\u0aa8\u0abf\u0ab5\u0abe\u0ab0".split("_"),weekdaysShort:"\u0ab0\u0ab5\u0abf_\u0ab8\u0acb\u0aae_\u0aae\u0a82\u0a97\u0ab3_\u0aac\u0ac1\u0aa7\u0acd_\u0a97\u0ac1\u0ab0\u0ac1_\u0ab6\u0ac1\u0a95\u0acd\u0ab0_\u0ab6\u0aa8\u0abf".split("_"),weekdaysMin:"\u0ab0_\u0ab8\u0acb_\u0aae\u0a82_\u0aac\u0ac1_\u0a97\u0ac1_\u0ab6\u0ac1_\u0ab6".split("_"),longDateFormat:{LT:"A h:mm \u0ab5\u0abe\u0a97\u0acd\u0aaf\u0ac7",LTS:"A h:mm:ss \u0ab5\u0abe\u0a97\u0acd\u0aaf\u0ac7",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u0ab5\u0abe\u0a97\u0acd\u0aaf\u0ac7",LLLL:"dddd, D MMMM YYYY, A h:mm \u0ab5\u0abe\u0a97\u0acd\u0aaf\u0ac7"},calendar:{sameDay:"[\u0a86\u0a9c] LT",nextDay:"[\u0a95\u0abe\u0ab2\u0ac7] LT",nextWeek:"dddd, LT",lastDay:"[\u0a97\u0a87\u0a95\u0abe\u0ab2\u0ac7] LT",lastWeek:"[\u0aaa\u0abe\u0a9b\u0ab2\u0abe] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0aae\u0abe",past:"%s \u0aaa\u0ab9\u0ac7\u0ab2\u0abe",s:"\u0a85\u0aae\u0ac1\u0a95 \u0aaa\u0ab3\u0acb",ss:"%d \u0ab8\u0ac7\u0a95\u0a82\u0aa1",m:"\u0a8f\u0a95 \u0aae\u0abf\u0aa8\u0abf\u0a9f",mm:"%d \u0aae\u0abf\u0aa8\u0abf\u0a9f",h:"\u0a8f\u0a95 \u0a95\u0ab2\u0abe\u0a95",hh:"%d \u0a95\u0ab2\u0abe\u0a95",d:"\u0a8f\u0a95 \u0aa6\u0abf\u0ab5\u0ab8",dd:"%d \u0aa6\u0abf\u0ab5\u0ab8",M:"\u0a8f\u0a95 \u0aae\u0ab9\u0abf\u0aa8\u0acb",MM:"%d \u0aae\u0ab9\u0abf\u0aa8\u0acb",y:"\u0a8f\u0a95 \u0ab5\u0ab0\u0acd\u0ab7",yy:"%d \u0ab5\u0ab0\u0acd\u0ab7"},preparse:function(e){return e.replace(/[\u0ae7\u0ae8\u0ae9\u0aea\u0aeb\u0aec\u0aed\u0aee\u0aef\u0ae6]/g,function(e){return he[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Ye[e]})},meridiemParse:/\u0ab0\u0abe\u0aa4|\u0aac\u0aaa\u0acb\u0ab0|\u0ab8\u0ab5\u0abe\u0ab0|\u0ab8\u0abe\u0a82\u0a9c/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0ab0\u0abe\u0aa4"===a?e<4?e:e+12:"\u0ab8\u0ab5\u0abe\u0ab0"===a?e:"\u0aac\u0aaa\u0acb\u0ab0"===a?10<=e?e:e+12:"\u0ab8\u0abe\u0a82\u0a9c"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0ab0\u0abe\u0aa4":e<10?"\u0ab8\u0ab5\u0abe\u0ab0":e<17?"\u0aac\u0aaa\u0acb\u0ab0":e<20?"\u0ab8\u0abe\u0a82\u0a9c":"\u0ab0\u0abe\u0aa4"},week:{dow:0,doy:6}}),e.defineLocale("he",{months:"\u05d9\u05e0\u05d5\u05d0\u05e8_\u05e4\u05d1\u05e8\u05d5\u05d0\u05e8_\u05de\u05e8\u05e5_\u05d0\u05e4\u05e8\u05d9\u05dc_\u05de\u05d0\u05d9_\u05d9\u05d5\u05e0\u05d9_\u05d9\u05d5\u05dc\u05d9_\u05d0\u05d5\u05d2\u05d5\u05e1\u05d8_\u05e1\u05e4\u05d8\u05de\u05d1\u05e8_\u05d0\u05d5\u05e7\u05d8\u05d5\u05d1\u05e8_\u05e0\u05d5\u05d1\u05de\u05d1\u05e8_\u05d3\u05e6\u05de\u05d1\u05e8".split("_"),monthsShort:"\u05d9\u05e0\u05d5\u05f3_\u05e4\u05d1\u05e8\u05f3_\u05de\u05e8\u05e5_\u05d0\u05e4\u05e8\u05f3_\u05de\u05d0\u05d9_\u05d9\u05d5\u05e0\u05d9_\u05d9\u05d5\u05dc\u05d9_\u05d0\u05d5\u05d2\u05f3_\u05e1\u05e4\u05d8\u05f3_\u05d0\u05d5\u05e7\u05f3_\u05e0\u05d5\u05d1\u05f3_\u05d3\u05e6\u05de\u05f3".split("_"),weekdays:"\u05e8\u05d0\u05e9\u05d5\u05df_\u05e9\u05e0\u05d9_\u05e9\u05dc\u05d9\u05e9\u05d9_\u05e8\u05d1\u05d9\u05e2\u05d9_\u05d7\u05de\u05d9\u05e9\u05d9_\u05e9\u05d9\u05e9\u05d9_\u05e9\u05d1\u05ea".split("_"),weekdaysShort:"\u05d0\u05f3_\u05d1\u05f3_\u05d2\u05f3_\u05d3\u05f3_\u05d4\u05f3_\u05d5\u05f3_\u05e9\u05f3".split("_"),weekdaysMin:"\u05d0_\u05d1_\u05d2_\u05d3_\u05d4_\u05d5_\u05e9".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [\u05d1]MMMM YYYY",LLL:"D [\u05d1]MMMM YYYY HH:mm",LLLL:"dddd, D [\u05d1]MMMM YYYY HH:mm",l:"D/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"},calendar:{sameDay:"[\u05d4\u05d9\u05d5\u05dd \u05d1\u05be]LT",nextDay:"[\u05de\u05d7\u05e8 \u05d1\u05be]LT",nextWeek:"dddd [\u05d1\u05e9\u05e2\u05d4] LT",lastDay:"[\u05d0\u05ea\u05de\u05d5\u05dc \u05d1\u05be]LT",lastWeek:"[\u05d1\u05d9\u05d5\u05dd] dddd [\u05d4\u05d0\u05d7\u05e8\u05d5\u05df \u05d1\u05e9\u05e2\u05d4] LT",sameElse:"L"},relativeTime:{future:"\u05d1\u05e2\u05d5\u05d3 %s",past:"\u05dc\u05e4\u05e0\u05d9 %s",s:"\u05de\u05e1\u05e4\u05e8 \u05e9\u05e0\u05d9\u05d5\u05ea",ss:"%d \u05e9\u05e0\u05d9\u05d5\u05ea",m:"\u05d3\u05e7\u05d4",mm:"%d \u05d3\u05e7\u05d5\u05ea",h:"\u05e9\u05e2\u05d4",hh:function(e){return 2===e?"\u05e9\u05e2\u05ea\u05d9\u05d9\u05dd":e+" \u05e9\u05e2\u05d5\u05ea"},d:"\u05d9\u05d5\u05dd",dd:function(e){return 2===e?"\u05d9\u05d5\u05de\u05d9\u05d9\u05dd":e+" \u05d9\u05de\u05d9\u05dd"},M:"\u05d7\u05d5\u05d3\u05e9",MM:function(e){return 2===e?"\u05d7\u05d5\u05d3\u05e9\u05d9\u05d9\u05dd":e+" \u05d7\u05d5\u05d3\u05e9\u05d9\u05dd"},y:"\u05e9\u05e0\u05d4",yy:function(e){return 2===e?"\u05e9\u05e0\u05ea\u05d9\u05d9\u05dd":e%10==0&&10!==e?e+" \u05e9\u05e0\u05d4":e+" \u05e9\u05e0\u05d9\u05dd"}},meridiemParse:/\u05d0\u05d7\u05d4"\u05e6|\u05dc\u05e4\u05e0\u05d4"\u05e6|\u05d0\u05d7\u05e8\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd|\u05dc\u05e4\u05e0\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd|\u05dc\u05e4\u05e0\u05d5\u05ea \u05d1\u05d5\u05e7\u05e8|\u05d1\u05d1\u05d5\u05e7\u05e8|\u05d1\u05e2\u05e8\u05d1/i,isPM:function(e){return /^(\u05d0\u05d7\u05d4"\u05e6|\u05d0\u05d7\u05e8\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd|\u05d1\u05e2\u05e8\u05d1)$/.test(e)},meridiem:function(e,a,_){return e<5?"\u05dc\u05e4\u05e0\u05d5\u05ea \u05d1\u05d5\u05e7\u05e8":e<10?"\u05d1\u05d1\u05d5\u05e7\u05e8":e<12?_?'\u05dc\u05e4\u05e0\u05d4"\u05e6':"\u05dc\u05e4\u05e0\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd":e<18?_?'\u05d0\u05d7\u05d4"\u05e6':"\u05d0\u05d7\u05e8\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd":"\u05d1\u05e2\u05e8\u05d1"}}),{1:"\u0967",2:"\u0968",3:"\u0969",4:"\u096a",5:"\u096b",6:"\u096c",7:"\u096d",8:"\u096e",9:"\u096f",0:"\u0966"}),ce={"\u0967":"1","\u0968":"2","\u0969":"3","\u096a":"4","\u096b":"5","\u096c":"6","\u096d":"7","\u096e":"8","\u096f":"9","\u0966":"0"},r=[/^\u091c\u0928/i,/^\u092b\u093c\u0930|\u092b\u0930/i,/^\u092e\u093e\u0930\u094d\u091a/i,/^\u0905\u092a\u094d\u0930\u0948/i,/^\u092e\u0908/i,/^\u091c\u0942\u0928/i,/^\u091c\u0941\u0932/i,/^\u0905\u0917/i,/^\u0938\u093f\u0924\u0902|\u0938\u093f\u0924/i,/^\u0905\u0915\u094d\u091f\u0942/i,/^\u0928\u0935|\u0928\u0935\u0902/i,/^\u0926\u093f\u0938\u0902|\u0926\u093f\u0938/i];function k(e,a,_){var s=e+" ";switch(_){case"ss":return s+=1===e?"sekunda":2===e||3===e||4===e?"sekunde":"sekundi";case"m":return a?"jedna minuta":"jedne minute";case"mm":return s+=1!==e&&(2===e||3===e||4===e)?"minute":"minuta";case"h":return a?"jedan sat":"jednog sata";case"hh":return s+=1===e?"sat":2===e||3===e||4===e?"sata":"sati";case"dd":return s+=1===e?"dan":"dana";case"MM":return s+=1===e?"mjesec":2===e||3===e||4===e?"mjeseca":"mjeseci";case"yy":return s+=1!==e&&(2===e||3===e||4===e)?"godine":"godina"}}e.defineLocale("hi",{months:{format:"\u091c\u0928\u0935\u0930\u0940_\u092b\u093c\u0930\u0935\u0930\u0940_\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u0948\u0932_\u092e\u0908_\u091c\u0942\u0928_\u091c\u0941\u0932\u093e\u0908_\u0905\u0917\u0938\u094d\u0924_\u0938\u093f\u0924\u092e\u094d\u092c\u0930_\u0905\u0915\u094d\u091f\u0942\u092c\u0930_\u0928\u0935\u092e\u094d\u092c\u0930_\u0926\u093f\u0938\u092e\u094d\u092c\u0930".split("_"),standalone:"\u091c\u0928\u0935\u0930\u0940_\u092b\u0930\u0935\u0930\u0940_\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u0948\u0932_\u092e\u0908_\u091c\u0942\u0928_\u091c\u0941\u0932\u093e\u0908_\u0905\u0917\u0938\u094d\u0924_\u0938\u093f\u0924\u0902\u092c\u0930_\u0905\u0915\u094d\u091f\u0942\u092c\u0930_\u0928\u0935\u0902\u092c\u0930_\u0926\u093f\u0938\u0902\u092c\u0930".split("_")},monthsShort:"\u091c\u0928._\u092b\u093c\u0930._\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u0948._\u092e\u0908_\u091c\u0942\u0928_\u091c\u0941\u0932._\u0905\u0917._\u0938\u093f\u0924._\u0905\u0915\u094d\u091f\u0942._\u0928\u0935._\u0926\u093f\u0938.".split("_"),weekdays:"\u0930\u0935\u093f\u0935\u093e\u0930_\u0938\u094b\u092e\u0935\u093e\u0930_\u092e\u0902\u0917\u0932\u0935\u093e\u0930_\u092c\u0941\u0927\u0935\u093e\u0930_\u0917\u0941\u0930\u0942\u0935\u093e\u0930_\u0936\u0941\u0915\u094d\u0930\u0935\u093e\u0930_\u0936\u0928\u093f\u0935\u093e\u0930".split("_"),weekdaysShort:"\u0930\u0935\u093f_\u0938\u094b\u092e_\u092e\u0902\u0917\u0932_\u092c\u0941\u0927_\u0917\u0941\u0930\u0942_\u0936\u0941\u0915\u094d\u0930_\u0936\u0928\u093f".split("_"),weekdaysMin:"\u0930_\u0938\u094b_\u092e\u0902_\u092c\u0941_\u0917\u0941_\u0936\u0941_\u0936".split("_"),longDateFormat:{LT:"A h:mm \u092c\u091c\u0947",LTS:"A h:mm:ss \u092c\u091c\u0947",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u092c\u091c\u0947",LLLL:"dddd, D MMMM YYYY, A h:mm \u092c\u091c\u0947"},monthsParse:r,longMonthsParse:r,shortMonthsParse:[/^\u091c\u0928/i,/^\u092b\u093c\u0930/i,/^\u092e\u093e\u0930\u094d\u091a/i,/^\u0905\u092a\u094d\u0930\u0948/i,/^\u092e\u0908/i,/^\u091c\u0942\u0928/i,/^\u091c\u0941\u0932/i,/^\u0905\u0917/i,/^\u0938\u093f\u0924/i,/^\u0905\u0915\u094d\u091f\u0942/i,/^\u0928\u0935/i,/^\u0926\u093f\u0938/i],monthsRegex:/^(\u091c\u0928\u0935\u0930\u0940|\u091c\u0928\.?|\u092b\u093c\u0930\u0935\u0930\u0940|\u092b\u0930\u0935\u0930\u0940|\u092b\u093c\u0930\.?|\u092e\u093e\u0930\u094d\u091a?|\u0905\u092a\u094d\u0930\u0948\u0932|\u0905\u092a\u094d\u0930\u0948\.?|\u092e\u0908?|\u091c\u0942\u0928?|\u091c\u0941\u0932\u093e\u0908|\u091c\u0941\u0932\.?|\u0905\u0917\u0938\u094d\u0924|\u0905\u0917\.?|\u0938\u093f\u0924\u092e\u094d\u092c\u0930|\u0938\u093f\u0924\u0902\u092c\u0930|\u0938\u093f\u0924\.?|\u0905\u0915\u094d\u091f\u0942\u092c\u0930|\u0905\u0915\u094d\u091f\u0942\.?|\u0928\u0935\u092e\u094d\u092c\u0930|\u0928\u0935\u0902\u092c\u0930|\u0928\u0935\.?|\u0926\u093f\u0938\u092e\u094d\u092c\u0930|\u0926\u093f\u0938\u0902\u092c\u0930|\u0926\u093f\u0938\.?)/i,monthsShortRegex:/^(\u091c\u0928\u0935\u0930\u0940|\u091c\u0928\.?|\u092b\u093c\u0930\u0935\u0930\u0940|\u092b\u0930\u0935\u0930\u0940|\u092b\u093c\u0930\.?|\u092e\u093e\u0930\u094d\u091a?|\u0905\u092a\u094d\u0930\u0948\u0932|\u0905\u092a\u094d\u0930\u0948\.?|\u092e\u0908?|\u091c\u0942\u0928?|\u091c\u0941\u0932\u093e\u0908|\u091c\u0941\u0932\.?|\u0905\u0917\u0938\u094d\u0924|\u0905\u0917\.?|\u0938\u093f\u0924\u092e\u094d\u092c\u0930|\u0938\u093f\u0924\u0902\u092c\u0930|\u0938\u093f\u0924\.?|\u0905\u0915\u094d\u091f\u0942\u092c\u0930|\u0905\u0915\u094d\u091f\u0942\.?|\u0928\u0935\u092e\u094d\u092c\u0930|\u0928\u0935\u0902\u092c\u0930|\u0928\u0935\.?|\u0926\u093f\u0938\u092e\u094d\u092c\u0930|\u0926\u093f\u0938\u0902\u092c\u0930|\u0926\u093f\u0938\.?)/i,monthsStrictRegex:/^(\u091c\u0928\u0935\u0930\u0940?|\u092b\u093c\u0930\u0935\u0930\u0940|\u092b\u0930\u0935\u0930\u0940?|\u092e\u093e\u0930\u094d\u091a?|\u0905\u092a\u094d\u0930\u0948\u0932?|\u092e\u0908?|\u091c\u0942\u0928?|\u091c\u0941\u0932\u093e\u0908?|\u0905\u0917\u0938\u094d\u0924?|\u0938\u093f\u0924\u092e\u094d\u092c\u0930|\u0938\u093f\u0924\u0902\u092c\u0930|\u0938\u093f\u0924?\.?|\u0905\u0915\u094d\u091f\u0942\u092c\u0930|\u0905\u0915\u094d\u091f\u0942\.?|\u0928\u0935\u092e\u094d\u092c\u0930|\u0928\u0935\u0902\u092c\u0930?|\u0926\u093f\u0938\u092e\u094d\u092c\u0930|\u0926\u093f\u0938\u0902\u092c\u0930?)/i,monthsShortStrictRegex:/^(\u091c\u0928\.?|\u092b\u093c\u0930\.?|\u092e\u093e\u0930\u094d\u091a?|\u0905\u092a\u094d\u0930\u0948\.?|\u092e\u0908?|\u091c\u0942\u0928?|\u091c\u0941\u0932\.?|\u0905\u0917\.?|\u0938\u093f\u0924\.?|\u0905\u0915\u094d\u091f\u0942\.?|\u0928\u0935\.?|\u0926\u093f\u0938\.?)/i,calendar:{sameDay:"[\u0906\u091c] LT",nextDay:"[\u0915\u0932] LT",nextWeek:"dddd, LT",lastDay:"[\u0915\u0932] LT",lastWeek:"[\u092a\u093f\u091b\u0932\u0947] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u092e\u0947\u0902",past:"%s \u092a\u0939\u0932\u0947",s:"\u0915\u0941\u091b \u0939\u0940 \u0915\u094d\u0937\u0923",ss:"%d \u0938\u0947\u0915\u0902\u0921",m:"\u090f\u0915 \u092e\u093f\u0928\u091f",mm:"%d \u092e\u093f\u0928\u091f",h:"\u090f\u0915 \u0918\u0902\u091f\u093e",hh:"%d \u0918\u0902\u091f\u0947",d:"\u090f\u0915 \u0926\u093f\u0928",dd:"%d \u0926\u093f\u0928",M:"\u090f\u0915 \u092e\u0939\u0940\u0928\u0947",MM:"%d \u092e\u0939\u0940\u0928\u0947",y:"\u090f\u0915 \u0935\u0930\u094d\u0937",yy:"%d \u0935\u0930\u094d\u0937"},preparse:function(e){return e.replace(/[\u0967\u0968\u0969\u096a\u096b\u096c\u096d\u096e\u096f\u0966]/g,function(e){return ce[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return ye[e]})},meridiemParse:/\u0930\u093e\u0924|\u0938\u0941\u092c\u0939|\u0926\u094b\u092a\u0939\u0930|\u0936\u093e\u092e/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0930\u093e\u0924"===a?e<4?e:e+12:"\u0938\u0941\u092c\u0939"===a?e:"\u0926\u094b\u092a\u0939\u0930"===a?10<=e?e:e+12:"\u0936\u093e\u092e"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0930\u093e\u0924":e<10?"\u0938\u0941\u092c\u0939":e<17?"\u0926\u094b\u092a\u0939\u0930":e<20?"\u0936\u093e\u092e":"\u0930\u093e\u0924"},week:{dow:0,doy:6}}),e.defineLocale("hr",{months:{format:"sije\u010dnja_velja\u010de_o\u017eujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"),standalone:"sije\u010danj_velja\u010da_o\u017eujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_")},monthsShort:"sij._velj._o\u017eu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),monthsParseExact:!0,weekdays:"nedjelja_ponedjeljak_utorak_srijeda_\u010detvrtak_petak_subota".split("_"),weekdaysShort:"ned._pon._uto._sri._\u010det._pet._sub.".split("_"),weekdaysMin:"ne_po_ut_sr_\u010de_pe_su".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"Do MMMM YYYY",LLL:"Do MMMM YYYY H:mm",LLLL:"dddd, Do MMMM YYYY H:mm"},calendar:{sameDay:"[danas u] LT",nextDay:"[sutra u] LT",nextWeek:function(){switch(this.day()){case 0:return "[u] [nedjelju] [u] LT";case 3:return "[u] [srijedu] [u] LT";case 6:return "[u] [subotu] [u] LT";case 1:case 2:case 4:case 5:return "[u] dddd [u] LT"}},lastDay:"[ju\u010der u] LT",lastWeek:function(){switch(this.day()){case 0:return "[pro\u0161lu] [nedjelju] [u] LT";case 3:return "[pro\u0161lu] [srijedu] [u] LT";case 6:return "[pro\u0161le] [subote] [u] LT";case 1:case 2:case 4:case 5:return "[pro\u0161li] dddd [u] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"prije %s",s:"par sekundi",ss:k,m:k,mm:k,h:k,hh:k,d:"dan",dd:k,M:"mjesec",MM:k,y:"godinu",yy:k},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}});var ke="vas\xe1rnap h\xe9tf\u0151n kedden szerd\xe1n cs\xfct\xf6rt\xf6k\xf6n p\xe9nteken szombaton".split(" ");function D(e,a,_,s){var d=e;switch(_){case"s":return s||a?"n\xe9h\xe1ny m\xe1sodperc":"n\xe9h\xe1ny m\xe1sodperce";case"ss":return d+(s||a)?" m\xe1sodperc":" m\xe1sodperce";case"m":return "egy"+(s||a?" perc":" perce");case"mm":return d+(s||a?" perc":" perce");case"h":return "egy"+(s||a?" \xf3ra":" \xf3r\xe1ja");case"hh":return d+(s||a?" \xf3ra":" \xf3r\xe1ja");case"d":return "egy"+(s||a?" nap":" napja");case"dd":return d+(s||a?" nap":" napja");case"M":return "egy"+(s||a?" h\xf3nap":" h\xf3napja");case"MM":return d+(s||a?" h\xf3nap":" h\xf3napja");case"y":return "egy"+(s||a?" \xe9v":" \xe9ve");case"yy":return d+(s||a?" \xe9v":" \xe9ve")}return ""}function De(e){return (e?"":"[m\xfalt] ")+"["+ke[this.day()]+"] LT[-kor]"}function p(e){return e%100==11||e%10!=1}function T(e,a,_,s){var d=e+" ";switch(_){case"s":return a||s?"nokkrar sek\xfandur":"nokkrum sek\xfandum";case"ss":return p(e)?d+(a||s?"sek\xfandur":"sek\xfandum"):d+"sek\xfanda";case"m":return a?"m\xedn\xfata":"m\xedn\xfatu";case"mm":return p(e)?d+(a||s?"m\xedn\xfatur":"m\xedn\xfatum"):a?d+"m\xedn\xfata":d+"m\xedn\xfatu";case"hh":return p(e)?d+(a||s?"klukkustundir":"klukkustundum"):d+"klukkustund";case"d":return a?"dagur":s?"dag":"degi";case"dd":return p(e)?a?d+"dagar":d+(s?"daga":"d\xf6gum"):a?d+"dagur":d+(s?"dag":"degi");case"M":return a?"m\xe1nu\xf0ur":s?"m\xe1nu\xf0":"m\xe1nu\xf0i";case"MM":return p(e)?a?d+"m\xe1nu\xf0ir":d+(s?"m\xe1nu\xf0i":"m\xe1nu\xf0um"):a?d+"m\xe1nu\xf0ur":d+(s?"m\xe1nu\xf0":"m\xe1nu\xf0i");case"y":return a||s?"\xe1r":"\xe1ri";case"yy":return p(e)?d+(a||s?"\xe1r":"\xe1rum"):d+(a||s?"\xe1r":"\xe1ri")}}e.defineLocale("hu",{months:"janu\xe1r_febru\xe1r_m\xe1rcius_\xe1prilis_m\xe1jus_j\xfanius_j\xfalius_augusztus_szeptember_okt\xf3ber_november_december".split("_"),monthsShort:"jan._feb._m\xe1rc._\xe1pr._m\xe1j._j\xfan._j\xfal._aug._szept._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"vas\xe1rnap_h\xe9tf\u0151_kedd_szerda_cs\xfct\xf6rt\xf6k_p\xe9ntek_szombat".split("_"),weekdaysShort:"vas_h\xe9t_kedd_sze_cs\xfct_p\xe9n_szo".split("_"),weekdaysMin:"v_h_k_sze_cs_p_szo".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"YYYY.MM.DD.",LL:"YYYY. MMMM D.",LLL:"YYYY. MMMM D. H:mm",LLLL:"YYYY. MMMM D., dddd H:mm"},meridiemParse:/de|du/i,isPM:function(e){return "u"===e.charAt(1).toLowerCase()},meridiem:function(e,a,_){return e<12?!0===_?"de":"DE":!0===_?"du":"DU"},calendar:{sameDay:"[ma] LT[-kor]",nextDay:"[holnap] LT[-kor]",nextWeek:function(){return De.call(this,!0)},lastDay:"[tegnap] LT[-kor]",lastWeek:function(){return De.call(this,!1)},sameElse:"L"},relativeTime:{future:"%s m\xfalva",past:"%s",s:D,ss:D,m:D,mm:D,h:D,hh:D,d:D,dd:D,M:D,MM:D,y:D,yy:D},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("hy-am",{months:{format:"\u0570\u0578\u0582\u0576\u057e\u0561\u0580\u056b_\u0583\u0565\u057f\u0580\u057e\u0561\u0580\u056b_\u0574\u0561\u0580\u057f\u056b_\u0561\u057a\u0580\u056b\u056c\u056b_\u0574\u0561\u0575\u056b\u057d\u056b_\u0570\u0578\u0582\u0576\u056b\u057d\u056b_\u0570\u0578\u0582\u056c\u056b\u057d\u056b_\u0585\u0563\u0578\u057d\u057f\u0578\u057d\u056b_\u057d\u0565\u057a\u057f\u0565\u0574\u0562\u0565\u0580\u056b_\u0570\u0578\u056f\u057f\u0565\u0574\u0562\u0565\u0580\u056b_\u0576\u0578\u0575\u0565\u0574\u0562\u0565\u0580\u056b_\u0564\u0565\u056f\u057f\u0565\u0574\u0562\u0565\u0580\u056b".split("_"),standalone:"\u0570\u0578\u0582\u0576\u057e\u0561\u0580_\u0583\u0565\u057f\u0580\u057e\u0561\u0580_\u0574\u0561\u0580\u057f_\u0561\u057a\u0580\u056b\u056c_\u0574\u0561\u0575\u056b\u057d_\u0570\u0578\u0582\u0576\u056b\u057d_\u0570\u0578\u0582\u056c\u056b\u057d_\u0585\u0563\u0578\u057d\u057f\u0578\u057d_\u057d\u0565\u057a\u057f\u0565\u0574\u0562\u0565\u0580_\u0570\u0578\u056f\u057f\u0565\u0574\u0562\u0565\u0580_\u0576\u0578\u0575\u0565\u0574\u0562\u0565\u0580_\u0564\u0565\u056f\u057f\u0565\u0574\u0562\u0565\u0580".split("_")},monthsShort:"\u0570\u0576\u057e_\u0583\u057f\u0580_\u0574\u0580\u057f_\u0561\u057a\u0580_\u0574\u0575\u057d_\u0570\u0576\u057d_\u0570\u056c\u057d_\u0585\u0563\u057d_\u057d\u057a\u057f_\u0570\u056f\u057f_\u0576\u0574\u0562_\u0564\u056f\u057f".split("_"),weekdays:"\u056f\u056b\u0580\u0561\u056f\u056b_\u0565\u0580\u056f\u0578\u0582\u0577\u0561\u0562\u0569\u056b_\u0565\u0580\u0565\u0584\u0577\u0561\u0562\u0569\u056b_\u0579\u0578\u0580\u0565\u0584\u0577\u0561\u0562\u0569\u056b_\u0570\u056b\u0576\u0563\u0577\u0561\u0562\u0569\u056b_\u0578\u0582\u0580\u0562\u0561\u0569_\u0577\u0561\u0562\u0561\u0569".split("_"),weekdaysShort:"\u056f\u0580\u056f_\u0565\u0580\u056f_\u0565\u0580\u0584_\u0579\u0580\u0584_\u0570\u0576\u0563_\u0578\u0582\u0580\u0562_\u0577\u0562\u0569".split("_"),weekdaysMin:"\u056f\u0580\u056f_\u0565\u0580\u056f_\u0565\u0580\u0584_\u0579\u0580\u0584_\u0570\u0576\u0563_\u0578\u0582\u0580\u0562_\u0577\u0562\u0569".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY \u0569.",LLL:"D MMMM YYYY \u0569., HH:mm",LLLL:"dddd, D MMMM YYYY \u0569., HH:mm"},calendar:{sameDay:"[\u0561\u0575\u057d\u0585\u0580] LT",nextDay:"[\u057e\u0561\u0572\u0568] LT",lastDay:"[\u0565\u0580\u0565\u056f] LT",nextWeek:function(){return "dddd [\u0585\u0580\u0568 \u056a\u0561\u0574\u0568] LT"},lastWeek:function(){return "[\u0561\u0576\u0581\u0561\u056e] dddd [\u0585\u0580\u0568 \u056a\u0561\u0574\u0568] LT"},sameElse:"L"},relativeTime:{future:"%s \u0570\u0565\u057f\u0578",past:"%s \u0561\u057c\u0561\u057b",s:"\u0574\u056b \u0584\u0561\u0576\u056b \u057e\u0561\u0575\u0580\u056f\u0575\u0561\u0576",ss:"%d \u057e\u0561\u0575\u0580\u056f\u0575\u0561\u0576",m:"\u0580\u0578\u057a\u0565",mm:"%d \u0580\u0578\u057a\u0565",h:"\u056a\u0561\u0574",hh:"%d \u056a\u0561\u0574",d:"\u0585\u0580",dd:"%d \u0585\u0580",M:"\u0561\u0574\u056b\u057d",MM:"%d \u0561\u0574\u056b\u057d",y:"\u057f\u0561\u0580\u056b",yy:"%d \u057f\u0561\u0580\u056b"},meridiemParse:/\u0563\u056b\u0577\u0565\u0580\u057e\u0561|\u0561\u057c\u0561\u057e\u0578\u057f\u057e\u0561|\u0581\u0565\u0580\u0565\u056f\u057e\u0561|\u0565\u0580\u0565\u056f\u0578\u0575\u0561\u0576/,isPM:function(e){return /^(\u0581\u0565\u0580\u0565\u056f\u057e\u0561|\u0565\u0580\u0565\u056f\u0578\u0575\u0561\u0576)$/.test(e)},meridiem:function(e){return e<4?"\u0563\u056b\u0577\u0565\u0580\u057e\u0561":e<12?"\u0561\u057c\u0561\u057e\u0578\u057f\u057e\u0561":e<17?"\u0581\u0565\u0580\u0565\u056f\u057e\u0561":"\u0565\u0580\u0565\u056f\u0578\u0575\u0561\u0576"},dayOfMonthOrdinalParse:/\d{1,2}|\d{1,2}-(\u056b\u0576|\u0580\u0564)/,ordinal:function(e,a){switch(a){case"DDD":case"w":case"W":case"DDDo":return 1===e?e+"-\u056b\u0576":e+"-\u0580\u0564";default:return e}},week:{dow:1,doy:7}}),e.defineLocale("id",{months:"Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),monthsShort:"Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"),weekdays:"Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),weekdaysShort:"Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),weekdaysMin:"Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [pukul] HH.mm",LLLL:"dddd, D MMMM YYYY [pukul] HH.mm"},meridiemParse:/pagi|siang|sore|malam/,meridiemHour:function(e,a){return 12===e&&(e=0),"pagi"===a?e:"siang"===a?11<=e?e:e+12:"sore"===a||"malam"===a?e+12:void 0},meridiem:function(e,a,_){return e<11?"pagi":e<15?"siang":e<19?"sore":"malam"},calendar:{sameDay:"[Hari ini pukul] LT",nextDay:"[Besok pukul] LT",nextWeek:"dddd [pukul] LT",lastDay:"[Kemarin pukul] LT",lastWeek:"dddd [lalu pukul] LT",sameElse:"L"},relativeTime:{future:"dalam %s",past:"%s yang lalu",s:"beberapa detik",ss:"%d detik",m:"semenit",mm:"%d menit",h:"sejam",hh:"%d jam",d:"sehari",dd:"%d hari",M:"sebulan",MM:"%d bulan",y:"setahun",yy:"%d tahun"},week:{dow:0,doy:6}}),e.defineLocale("is",{months:"jan\xfaar_febr\xfaar_mars_apr\xedl_ma\xed_j\xfan\xed_j\xfal\xed_\xe1g\xfast_september_okt\xf3ber_n\xf3vember_desember".split("_"),monthsShort:"jan_feb_mar_apr_ma\xed_j\xfan_j\xfal_\xe1g\xfa_sep_okt_n\xf3v_des".split("_"),weekdays:"sunnudagur_m\xe1nudagur_\xferi\xf0judagur_mi\xf0vikudagur_fimmtudagur_f\xf6studagur_laugardagur".split("_"),weekdaysShort:"sun_m\xe1n_\xferi_mi\xf0_fim_f\xf6s_lau".split("_"),weekdaysMin:"Su_M\xe1_\xder_Mi_Fi_F\xf6_La".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY [kl.] H:mm",LLLL:"dddd, D. MMMM YYYY [kl.] H:mm"},calendar:{sameDay:"[\xed dag kl.] LT",nextDay:"[\xe1 morgun kl.] LT",nextWeek:"dddd [kl.] LT",lastDay:"[\xed g\xe6r kl.] LT",lastWeek:"[s\xed\xf0asta] dddd [kl.] LT",sameElse:"L"},relativeTime:{future:"eftir %s",past:"fyrir %s s\xed\xf0an",s:T,ss:T,m:T,mm:T,h:"klukkustund",hh:T,d:T,dd:T,M:T,MM:T,y:T,yy:T},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("it-ch",{months:"gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),monthsShort:"gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),weekdays:"domenica_luned\xec_marted\xec_mercoled\xec_gioved\xec_venerd\xec_sabato".split("_"),weekdaysShort:"dom_lun_mar_mer_gio_ven_sab".split("_"),weekdaysMin:"do_lu_ma_me_gi_ve_sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Oggi alle] LT",nextDay:"[Domani alle] LT",nextWeek:"dddd [alle] LT",lastDay:"[Ieri alle] LT",lastWeek:function(){switch(this.day()){case 0:return "[la scorsa] dddd [alle] LT";default:return "[lo scorso] dddd [alle] LT"}},sameElse:"L"},relativeTime:{future:function(e){return (/^[0-9].+$/.test(e)?"tra":"in")+" "+e},past:"%s fa",s:"alcuni secondi",ss:"%d secondi",m:"un minuto",mm:"%d minuti",h:"un'ora",hh:"%d ore",d:"un giorno",dd:"%d giorni",M:"un mese",MM:"%d mesi",y:"un anno",yy:"%d anni"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),e.defineLocale("it",{months:"gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),monthsShort:"gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),weekdays:"domenica_luned\xec_marted\xec_mercoled\xec_gioved\xec_venerd\xec_sabato".split("_"),weekdaysShort:"dom_lun_mar_mer_gio_ven_sab".split("_"),weekdaysMin:"do_lu_ma_me_gi_ve_sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:function(){return "[Oggi a"+(1<this.hours()?"lle ":0===this.hours()?" ":"ll'")+"]LT"},nextDay:function(){return "[Domani a"+(1<this.hours()?"lle ":0===this.hours()?" ":"ll'")+"]LT"},nextWeek:function(){return "dddd [a"+(1<this.hours()?"lle ":0===this.hours()?" ":"ll'")+"]LT"},lastDay:function(){return "[Ieri a"+(1<this.hours()?"lle ":0===this.hours()?" ":"ll'")+"]LT"},lastWeek:function(){switch(this.day()){case 0:return "[La scorsa] dddd [a"+(1<this.hours()?"lle ":0===this.hours()?" ":"ll'")+"]LT";default:return "[Lo scorso] dddd [a"+(1<this.hours()?"lle ":0===this.hours()?" ":"ll'")+"]LT"}},sameElse:"L"},relativeTime:{future:"tra %s",past:"%s fa",s:"alcuni secondi",ss:"%d secondi",m:"un minuto",mm:"%d minuti",h:"un'ora",hh:"%d ore",d:"un giorno",dd:"%d giorni",w:"una settimana",ww:"%d settimane",M:"un mese",MM:"%d mesi",y:"un anno",yy:"%d anni"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),e.defineLocale("ja",{eras:[{since:"2019-05-01",offset:1,name:"\u4ee4\u548c",narrow:"\u32ff",abbr:"R"},{since:"1989-01-08",until:"2019-04-30",offset:1,name:"\u5e73\u6210",narrow:"\u337b",abbr:"H"},{since:"1926-12-25",until:"1989-01-07",offset:1,name:"\u662d\u548c",narrow:"\u337c",abbr:"S"},{since:"1912-07-30",until:"1926-12-24",offset:1,name:"\u5927\u6b63",narrow:"\u337d",abbr:"T"},{since:"1873-01-01",until:"1912-07-29",offset:6,name:"\u660e\u6cbb",narrow:"\u337e",abbr:"M"},{since:"0001-01-01",until:"1873-12-31",offset:1,name:"\u897f\u66a6",narrow:"AD",abbr:"AD"},{since:"0000-12-31",until:-1/0,offset:1,name:"\u7d00\u5143\u524d",narrow:"BC",abbr:"BC"}],eraYearOrdinalRegex:/(\u5143|\d+)\u5e74/,eraYearOrdinalParse:function(e,a){return "\u5143"===a[1]?1:parseInt(a[1]||e,10)},months:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u65e5\u66dc\u65e5_\u6708\u66dc\u65e5_\u706b\u66dc\u65e5_\u6c34\u66dc\u65e5_\u6728\u66dc\u65e5_\u91d1\u66dc\u65e5_\u571f\u66dc\u65e5".split("_"),weekdaysShort:"\u65e5_\u6708_\u706b_\u6c34_\u6728_\u91d1_\u571f".split("_"),weekdaysMin:"\u65e5_\u6708_\u706b_\u6c34_\u6728_\u91d1_\u571f".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5 HH:mm",LLLL:"YYYY\u5e74M\u6708D\u65e5 dddd HH:mm",l:"YYYY/MM/DD",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5(ddd) HH:mm"},meridiemParse:/\u5348\u524d|\u5348\u5f8c/i,isPM:function(e){return "\u5348\u5f8c"===e},meridiem:function(e,a,_){return e<12?"\u5348\u524d":"\u5348\u5f8c"},calendar:{sameDay:"[\u4eca\u65e5] LT",nextDay:"[\u660e\u65e5] LT",nextWeek:function(e){return e.week()!==this.week()?"[\u6765\u9031]dddd LT":"dddd LT"},lastDay:"[\u6628\u65e5] LT",lastWeek:function(e){return this.week()!==e.week()?"[\u5148\u9031]dddd LT":"dddd LT"},sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}\u65e5/,ordinal:function(e,a){switch(a){case"y":return 1===e?"\u5143\u5e74":e+"\u5e74";case"d":case"D":case"DDD":return e+"\u65e5";default:return e}},relativeTime:{future:"%s\u5f8c",past:"%s\u524d",s:"\u6570\u79d2",ss:"%d\u79d2",m:"1\u5206",mm:"%d\u5206",h:"1\u6642\u9593",hh:"%d\u6642\u9593",d:"1\u65e5",dd:"%d\u65e5",M:"1\u30f6\u6708",MM:"%d\u30f6\u6708",y:"1\u5e74",yy:"%d\u5e74"}}),e.defineLocale("jv",{months:"Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"),monthsShort:"Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),weekdays:"Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),weekdaysShort:"Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),weekdaysMin:"Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [pukul] HH.mm",LLLL:"dddd, D MMMM YYYY [pukul] HH.mm"},meridiemParse:/enjing|siyang|sonten|ndalu/,meridiemHour:function(e,a){return 12===e&&(e=0),"enjing"===a?e:"siyang"===a?11<=e?e:e+12:"sonten"===a||"ndalu"===a?e+12:void 0},meridiem:function(e,a,_){return e<11?"enjing":e<15?"siyang":e<19?"sonten":"ndalu"},calendar:{sameDay:"[Dinten puniko pukul] LT",nextDay:"[Mbenjang pukul] LT",nextWeek:"dddd [pukul] LT",lastDay:"[Kala wingi pukul] LT",lastWeek:"dddd [kepengker pukul] LT",sameElse:"L"},relativeTime:{future:"wonten ing %s",past:"%s ingkang kepengker",s:"sawetawis detik",ss:"%d detik",m:"setunggal menit",mm:"%d menit",h:"setunggal jam",hh:"%d jam",d:"sedinten",dd:"%d dinten",M:"sewulan",MM:"%d wulan",y:"setaun",yy:"%d taun"},week:{dow:1,doy:7}}),e.defineLocale("ka",{months:"\u10d8\u10d0\u10dc\u10d5\u10d0\u10e0\u10d8_\u10d7\u10d4\u10d1\u10d4\u10e0\u10d5\u10d0\u10da\u10d8_\u10db\u10d0\u10e0\u10e2\u10d8_\u10d0\u10de\u10e0\u10d8\u10da\u10d8_\u10db\u10d0\u10d8\u10e1\u10d8_\u10d8\u10d5\u10dc\u10d8\u10e1\u10d8_\u10d8\u10d5\u10da\u10d8\u10e1\u10d8_\u10d0\u10d2\u10d5\u10d8\u10e1\u10e2\u10dd_\u10e1\u10d4\u10e5\u10e2\u10d4\u10db\u10d1\u10d4\u10e0\u10d8_\u10dd\u10e5\u10e2\u10dd\u10db\u10d1\u10d4\u10e0\u10d8_\u10dc\u10dd\u10d4\u10db\u10d1\u10d4\u10e0\u10d8_\u10d3\u10d4\u10d9\u10d4\u10db\u10d1\u10d4\u10e0\u10d8".split("_"),monthsShort:"\u10d8\u10d0\u10dc_\u10d7\u10d4\u10d1_\u10db\u10d0\u10e0_\u10d0\u10de\u10e0_\u10db\u10d0\u10d8_\u10d8\u10d5\u10dc_\u10d8\u10d5\u10da_\u10d0\u10d2\u10d5_\u10e1\u10d4\u10e5_\u10dd\u10e5\u10e2_\u10dc\u10dd\u10d4_\u10d3\u10d4\u10d9".split("_"),weekdays:{standalone:"\u10d9\u10d5\u10d8\u10e0\u10d0_\u10dd\u10e0\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8_\u10e1\u10d0\u10db\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8_\u10dd\u10d7\u10ee\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8_\u10ee\u10e3\u10d7\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8_\u10de\u10d0\u10e0\u10d0\u10e1\u10d9\u10d4\u10d5\u10d8_\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8".split("_"),format:"\u10d9\u10d5\u10d8\u10e0\u10d0\u10e1_\u10dd\u10e0\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1_\u10e1\u10d0\u10db\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1_\u10dd\u10d7\u10ee\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1_\u10ee\u10e3\u10d7\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1_\u10de\u10d0\u10e0\u10d0\u10e1\u10d9\u10d4\u10d5\u10e1_\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1".split("_"),isFormat:/(\u10ec\u10d8\u10dc\u10d0|\u10e8\u10d4\u10db\u10d3\u10d4\u10d2)/},weekdaysShort:"\u10d9\u10d5\u10d8_\u10dd\u10e0\u10e8_\u10e1\u10d0\u10db_\u10dd\u10d7\u10ee_\u10ee\u10e3\u10d7_\u10de\u10d0\u10e0_\u10e8\u10d0\u10d1".split("_"),weekdaysMin:"\u10d9\u10d5_\u10dd\u10e0_\u10e1\u10d0_\u10dd\u10d7_\u10ee\u10e3_\u10de\u10d0_\u10e8\u10d0".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u10d3\u10e6\u10d4\u10e1] LT[-\u10d6\u10d4]",nextDay:"[\u10ee\u10d5\u10d0\u10da] LT[-\u10d6\u10d4]",lastDay:"[\u10d2\u10e3\u10e8\u10d8\u10dc] LT[-\u10d6\u10d4]",nextWeek:"[\u10e8\u10d4\u10db\u10d3\u10d4\u10d2] dddd LT[-\u10d6\u10d4]",lastWeek:"[\u10ec\u10d8\u10dc\u10d0] dddd LT-\u10d6\u10d4",sameElse:"L"},relativeTime:{future:function(e){return e.replace(/(\u10ec\u10d0\u10db|\u10ec\u10e3\u10d7|\u10e1\u10d0\u10d0\u10d7|\u10ec\u10d4\u10da|\u10d3\u10e6|\u10d7\u10d5)(\u10d8|\u10d4)/,function(e,a,_){return "\u10d8"===_?a+"\u10e8\u10d8":a+_+"\u10e8\u10d8"})},past:function(e){return /(\u10ec\u10d0\u10db\u10d8|\u10ec\u10e3\u10d7\u10d8|\u10e1\u10d0\u10d0\u10d7\u10d8|\u10d3\u10e6\u10d4|\u10d7\u10d5\u10d4)/.test(e)?e.replace(/(\u10d8|\u10d4)$/,"\u10d8\u10e1 \u10ec\u10d8\u10dc"):/\u10ec\u10d4\u10da\u10d8/.test(e)?e.replace(/\u10ec\u10d4\u10da\u10d8$/,"\u10ec\u10da\u10d8\u10e1 \u10ec\u10d8\u10dc"):e},s:"\u10e0\u10d0\u10db\u10d3\u10d4\u10dc\u10d8\u10db\u10d4 \u10ec\u10d0\u10db\u10d8",ss:"%d \u10ec\u10d0\u10db\u10d8",m:"\u10ec\u10e3\u10d7\u10d8",mm:"%d \u10ec\u10e3\u10d7\u10d8",h:"\u10e1\u10d0\u10d0\u10d7\u10d8",hh:"%d \u10e1\u10d0\u10d0\u10d7\u10d8",d:"\u10d3\u10e6\u10d4",dd:"%d \u10d3\u10e6\u10d4",M:"\u10d7\u10d5\u10d4",MM:"%d \u10d7\u10d5\u10d4",y:"\u10ec\u10d4\u10da\u10d8",yy:"%d \u10ec\u10d4\u10da\u10d8"},dayOfMonthOrdinalParse:/0|1-\u10da\u10d8|\u10db\u10d4-\d{1,2}|\d{1,2}-\u10d4/,ordinal:function(e){return 0===e?e:1===e?e+"-\u10da\u10d8":e<20||e<=100&&e%20==0||e%100==0?"\u10db\u10d4-"+e:e+"-\u10d4"},week:{dow:1,doy:7}});var pe={0:"-\u0448\u0456",1:"-\u0448\u0456",2:"-\u0448\u0456",3:"-\u0448\u0456",4:"-\u0448\u0456",5:"-\u0448\u0456",6:"-\u0448\u044b",7:"-\u0448\u0456",8:"-\u0448\u0456",9:"-\u0448\u044b",10:"-\u0448\u044b",20:"-\u0448\u044b",30:"-\u0448\u044b",40:"-\u0448\u044b",50:"-\u0448\u0456",60:"-\u0448\u044b",70:"-\u0448\u0456",80:"-\u0448\u0456",90:"-\u0448\u044b",100:"-\u0448\u0456"},Te=(e.defineLocale("kk",{months:"\u049b\u0430\u04a3\u0442\u0430\u0440_\u0430\u049b\u043f\u0430\u043d_\u043d\u0430\u0443\u0440\u044b\u0437_\u0441\u04d9\u0443\u0456\u0440_\u043c\u0430\u043c\u044b\u0440_\u043c\u0430\u0443\u0441\u044b\u043c_\u0448\u0456\u043b\u0434\u0435_\u0442\u0430\u043c\u044b\u0437_\u049b\u044b\u0440\u043a\u04af\u0439\u0435\u043a_\u049b\u0430\u0437\u0430\u043d_\u049b\u0430\u0440\u0430\u0448\u0430_\u0436\u0435\u043b\u0442\u043e\u049b\u0441\u0430\u043d".split("_"),monthsShort:"\u049b\u0430\u04a3_\u0430\u049b\u043f_\u043d\u0430\u0443_\u0441\u04d9\u0443_\u043c\u0430\u043c_\u043c\u0430\u0443_\u0448\u0456\u043b_\u0442\u0430\u043c_\u049b\u044b\u0440_\u049b\u0430\u0437_\u049b\u0430\u0440_\u0436\u0435\u043b".split("_"),weekdays:"\u0436\u0435\u043a\u0441\u0435\u043d\u0431\u0456_\u0434\u04af\u0439\u0441\u0435\u043d\u0431\u0456_\u0441\u0435\u0439\u0441\u0435\u043d\u0431\u0456_\u0441\u04d9\u0440\u0441\u0435\u043d\u0431\u0456_\u0431\u0435\u0439\u0441\u0435\u043d\u0431\u0456_\u0436\u04b1\u043c\u0430_\u0441\u0435\u043d\u0431\u0456".split("_"),weekdaysShort:"\u0436\u0435\u043a_\u0434\u04af\u0439_\u0441\u0435\u0439_\u0441\u04d9\u0440_\u0431\u0435\u0439_\u0436\u04b1\u043c_\u0441\u0435\u043d".split("_"),weekdaysMin:"\u0436\u043a_\u0434\u0439_\u0441\u0439_\u0441\u0440_\u0431\u0439_\u0436\u043c_\u0441\u043d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0411\u04af\u0433\u0456\u043d \u0441\u0430\u0493\u0430\u0442] LT",nextDay:"[\u0415\u0440\u0442\u0435\u04a3 \u0441\u0430\u0493\u0430\u0442] LT",nextWeek:"dddd [\u0441\u0430\u0493\u0430\u0442] LT",lastDay:"[\u041a\u0435\u0448\u0435 \u0441\u0430\u0493\u0430\u0442] LT",lastWeek:"[\u04e8\u0442\u043a\u0435\u043d \u0430\u043f\u0442\u0430\u043d\u044b\u04a3] dddd [\u0441\u0430\u0493\u0430\u0442] LT",sameElse:"L"},relativeTime:{future:"%s \u0456\u0448\u0456\u043d\u0434\u0435",past:"%s \u0431\u04b1\u0440\u044b\u043d",s:"\u0431\u0456\u0440\u043d\u0435\u0448\u0435 \u0441\u0435\u043a\u0443\u043d\u0434",ss:"%d \u0441\u0435\u043a\u0443\u043d\u0434",m:"\u0431\u0456\u0440 \u043c\u0438\u043d\u0443\u0442",mm:"%d \u043c\u0438\u043d\u0443\u0442",h:"\u0431\u0456\u0440 \u0441\u0430\u0493\u0430\u0442",hh:"%d \u0441\u0430\u0493\u0430\u0442",d:"\u0431\u0456\u0440 \u043a\u04af\u043d",dd:"%d \u043a\u04af\u043d",M:"\u0431\u0456\u0440 \u0430\u0439",MM:"%d \u0430\u0439",y:"\u0431\u0456\u0440 \u0436\u044b\u043b",yy:"%d \u0436\u044b\u043b"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0448\u0456|\u0448\u044b)/,ordinal:function(e){return e+(pe[e]||pe[e%10]||pe[100<=e?100:null])},week:{dow:1,doy:7}}),{1:"\u17e1",2:"\u17e2",3:"\u17e3",4:"\u17e4",5:"\u17e5",6:"\u17e6",7:"\u17e7",8:"\u17e8",9:"\u17e9",0:"\u17e0"}),fe={"\u17e1":"1","\u17e2":"2","\u17e3":"3","\u17e4":"4","\u17e5":"5","\u17e6":"6","\u17e7":"7","\u17e8":"8","\u17e9":"9","\u17e0":"0"},we=(e.defineLocale("km",{months:"\u1798\u1780\u179a\u17b6_\u1780\u17bb\u1798\u17d2\u1797\u17c8_\u1798\u17b8\u1793\u17b6_\u1798\u17c1\u179f\u17b6_\u17a7\u179f\u1797\u17b6_\u1798\u17b7\u1790\u17bb\u1793\u17b6_\u1780\u1780\u17d2\u1780\u178a\u17b6_\u179f\u17b8\u17a0\u17b6_\u1780\u1789\u17d2\u1789\u17b6_\u178f\u17bb\u179b\u17b6_\u179c\u17b7\u1785\u17d2\u1786\u17b7\u1780\u17b6_\u1792\u17d2\u1793\u17bc".split("_"),monthsShort:"\u1798\u1780\u179a\u17b6_\u1780\u17bb\u1798\u17d2\u1797\u17c8_\u1798\u17b8\u1793\u17b6_\u1798\u17c1\u179f\u17b6_\u17a7\u179f\u1797\u17b6_\u1798\u17b7\u1790\u17bb\u1793\u17b6_\u1780\u1780\u17d2\u1780\u178a\u17b6_\u179f\u17b8\u17a0\u17b6_\u1780\u1789\u17d2\u1789\u17b6_\u178f\u17bb\u179b\u17b6_\u179c\u17b7\u1785\u17d2\u1786\u17b7\u1780\u17b6_\u1792\u17d2\u1793\u17bc".split("_"),weekdays:"\u17a2\u17b6\u1791\u17b7\u178f\u17d2\u1799_\u1785\u17d0\u1793\u17d2\u1791_\u17a2\u1784\u17d2\u1782\u17b6\u179a_\u1796\u17bb\u1792_\u1796\u17d2\u179a\u17a0\u179f\u17d2\u1794\u178f\u17b7\u17cd_\u179f\u17bb\u1780\u17d2\u179a_\u179f\u17c5\u179a\u17cd".split("_"),weekdaysShort:"\u17a2\u17b6_\u1785_\u17a2_\u1796_\u1796\u17d2\u179a_\u179f\u17bb_\u179f".split("_"),weekdaysMin:"\u17a2\u17b6_\u1785_\u17a2_\u1796_\u1796\u17d2\u179a_\u179f\u17bb_\u179f".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},meridiemParse:/\u1796\u17d2\u179a\u17b9\u1780|\u179b\u17d2\u1784\u17b6\u1785/,isPM:function(e){return "\u179b\u17d2\u1784\u17b6\u1785"===e},meridiem:function(e,a,_){return e<12?"\u1796\u17d2\u179a\u17b9\u1780":"\u179b\u17d2\u1784\u17b6\u1785"},calendar:{sameDay:"[\u1790\u17d2\u1784\u17c3\u1793\u17c1\u17c7 \u1798\u17c9\u17c4\u1784] LT",nextDay:"[\u179f\u17d2\u17a2\u17c2\u1780 \u1798\u17c9\u17c4\u1784] LT",nextWeek:"dddd [\u1798\u17c9\u17c4\u1784] LT",lastDay:"[\u1798\u17d2\u179f\u17b7\u179b\u1798\u17b7\u1789 \u1798\u17c9\u17c4\u1784] LT",lastWeek:"dddd [\u179f\u1794\u17d2\u178f\u17b6\u17a0\u17cd\u1798\u17bb\u1793] [\u1798\u17c9\u17c4\u1784] LT",sameElse:"L"},relativeTime:{future:"%s\u1791\u17c0\u178f",past:"%s\u1798\u17bb\u1793",s:"\u1794\u17c9\u17bb\u1793\u17d2\u1798\u17b6\u1793\u179c\u17b7\u1793\u17b6\u1791\u17b8",ss:"%d \u179c\u17b7\u1793\u17b6\u1791\u17b8",m:"\u1798\u17bd\u1799\u1793\u17b6\u1791\u17b8",mm:"%d \u1793\u17b6\u1791\u17b8",h:"\u1798\u17bd\u1799\u1798\u17c9\u17c4\u1784",hh:"%d \u1798\u17c9\u17c4\u1784",d:"\u1798\u17bd\u1799\u1790\u17d2\u1784\u17c3",dd:"%d \u1790\u17d2\u1784\u17c3",M:"\u1798\u17bd\u1799\u1781\u17c2",MM:"%d \u1781\u17c2",y:"\u1798\u17bd\u1799\u1786\u17d2\u1793\u17b6\u17c6",yy:"%d \u1786\u17d2\u1793\u17b6\u17c6"},dayOfMonthOrdinalParse:/\u1791\u17b8\d{1,2}/,ordinal:"\u1791\u17b8%d",preparse:function(e){return e.replace(/[\u17e1\u17e2\u17e3\u17e4\u17e5\u17e6\u17e7\u17e8\u17e9\u17e0]/g,function(e){return fe[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Te[e]})},week:{dow:1,doy:4}}),{1:"\u0ce7",2:"\u0ce8",3:"\u0ce9",4:"\u0cea",5:"\u0ceb",6:"\u0cec",7:"\u0ced",8:"\u0cee",9:"\u0cef",0:"\u0ce6"}),ge={"\u0ce7":"1","\u0ce8":"2","\u0ce9":"3","\u0cea":"4","\u0ceb":"5","\u0cec":"6","\u0ced":"7","\u0cee":"8","\u0cef":"9","\u0ce6":"0"},He=(e.defineLocale("kn",{months:"\u0c9c\u0ca8\u0cb5\u0cb0\u0cbf_\u0cab\u0cc6\u0cac\u0ccd\u0cb0\u0cb5\u0cb0\u0cbf_\u0cae\u0cbe\u0cb0\u0ccd\u0c9a\u0ccd_\u0c8f\u0caa\u0ccd\u0cb0\u0cbf\u0cb2\u0ccd_\u0cae\u0cc6\u0cd5_\u0c9c\u0cc2\u0ca8\u0ccd_\u0c9c\u0cc1\u0cb2\u0cc6\u0cd6_\u0c86\u0c97\u0cb8\u0ccd\u0c9f\u0ccd_\u0cb8\u0cc6\u0caa\u0ccd\u0c9f\u0cc6\u0c82\u0cac\u0cb0\u0ccd_\u0c85\u0c95\u0ccd\u0c9f\u0cc6\u0cc2\u0cd5\u0cac\u0cb0\u0ccd_\u0ca8\u0cb5\u0cc6\u0c82\u0cac\u0cb0\u0ccd_\u0ca1\u0cbf\u0cb8\u0cc6\u0c82\u0cac\u0cb0\u0ccd".split("_"),monthsShort:"\u0c9c\u0ca8_\u0cab\u0cc6\u0cac\u0ccd\u0cb0_\u0cae\u0cbe\u0cb0\u0ccd\u0c9a\u0ccd_\u0c8f\u0caa\u0ccd\u0cb0\u0cbf\u0cb2\u0ccd_\u0cae\u0cc6\u0cd5_\u0c9c\u0cc2\u0ca8\u0ccd_\u0c9c\u0cc1\u0cb2\u0cc6\u0cd6_\u0c86\u0c97\u0cb8\u0ccd\u0c9f\u0ccd_\u0cb8\u0cc6\u0caa\u0ccd\u0c9f\u0cc6\u0c82_\u0c85\u0c95\u0ccd\u0c9f\u0cc6\u0cc2\u0cd5_\u0ca8\u0cb5\u0cc6\u0c82_\u0ca1\u0cbf\u0cb8\u0cc6\u0c82".split("_"),monthsParseExact:!0,weekdays:"\u0cad\u0cbe\u0ca8\u0cc1\u0cb5\u0cbe\u0cb0_\u0cb8\u0cc6\u0cc2\u0cd5\u0cae\u0cb5\u0cbe\u0cb0_\u0cae\u0c82\u0c97\u0cb3\u0cb5\u0cbe\u0cb0_\u0cac\u0cc1\u0ca7\u0cb5\u0cbe\u0cb0_\u0c97\u0cc1\u0cb0\u0cc1\u0cb5\u0cbe\u0cb0_\u0cb6\u0cc1\u0c95\u0ccd\u0cb0\u0cb5\u0cbe\u0cb0_\u0cb6\u0ca8\u0cbf\u0cb5\u0cbe\u0cb0".split("_"),weekdaysShort:"\u0cad\u0cbe\u0ca8\u0cc1_\u0cb8\u0cc6\u0cc2\u0cd5\u0cae_\u0cae\u0c82\u0c97\u0cb3_\u0cac\u0cc1\u0ca7_\u0c97\u0cc1\u0cb0\u0cc1_\u0cb6\u0cc1\u0c95\u0ccd\u0cb0_\u0cb6\u0ca8\u0cbf".split("_"),weekdaysMin:"\u0cad\u0cbe_\u0cb8\u0cc6\u0cc2\u0cd5_\u0cae\u0c82_\u0cac\u0cc1_\u0c97\u0cc1_\u0cb6\u0cc1_\u0cb6".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm",LLLL:"dddd, D MMMM YYYY, A h:mm"},calendar:{sameDay:"[\u0c87\u0c82\u0ca6\u0cc1] LT",nextDay:"[\u0ca8\u0cbe\u0cb3\u0cc6] LT",nextWeek:"dddd, LT",lastDay:"[\u0ca8\u0cbf\u0ca8\u0ccd\u0ca8\u0cc6] LT",lastWeek:"[\u0c95\u0cc6\u0cc2\u0ca8\u0cc6\u0caf] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0ca8\u0c82\u0ca4\u0cb0",past:"%s \u0cb9\u0cbf\u0c82\u0ca6\u0cc6",s:"\u0c95\u0cc6\u0cb2\u0cb5\u0cc1 \u0c95\u0ccd\u0cb7\u0ca3\u0c97\u0cb3\u0cc1",ss:"%d \u0cb8\u0cc6\u0c95\u0cc6\u0c82\u0ca1\u0cc1\u0c97\u0cb3\u0cc1",m:"\u0c92\u0c82\u0ca6\u0cc1 \u0ca8\u0cbf\u0cae\u0cbf\u0cb7",mm:"%d \u0ca8\u0cbf\u0cae\u0cbf\u0cb7",h:"\u0c92\u0c82\u0ca6\u0cc1 \u0c97\u0c82\u0c9f\u0cc6",hh:"%d \u0c97\u0c82\u0c9f\u0cc6",d:"\u0c92\u0c82\u0ca6\u0cc1 \u0ca6\u0cbf\u0ca8",dd:"%d \u0ca6\u0cbf\u0ca8",M:"\u0c92\u0c82\u0ca6\u0cc1 \u0ca4\u0cbf\u0c82\u0c97\u0cb3\u0cc1",MM:"%d \u0ca4\u0cbf\u0c82\u0c97\u0cb3\u0cc1",y:"\u0c92\u0c82\u0ca6\u0cc1 \u0cb5\u0cb0\u0ccd\u0cb7",yy:"%d \u0cb5\u0cb0\u0ccd\u0cb7"},preparse:function(e){return e.replace(/[\u0ce7\u0ce8\u0ce9\u0cea\u0ceb\u0cec\u0ced\u0cee\u0cef\u0ce6]/g,function(e){return ge[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return we[e]})},meridiemParse:/\u0cb0\u0cbe\u0ca4\u0ccd\u0cb0\u0cbf|\u0cac\u0cc6\u0cb3\u0cbf\u0c97\u0ccd\u0c97\u0cc6|\u0cae\u0ca7\u0ccd\u0caf\u0cbe\u0cb9\u0ccd\u0ca8|\u0cb8\u0c82\u0c9c\u0cc6/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0cb0\u0cbe\u0ca4\u0ccd\u0cb0\u0cbf"===a?e<4?e:e+12:"\u0cac\u0cc6\u0cb3\u0cbf\u0c97\u0ccd\u0c97\u0cc6"===a?e:"\u0cae\u0ca7\u0ccd\u0caf\u0cbe\u0cb9\u0ccd\u0ca8"===a?10<=e?e:e+12:"\u0cb8\u0c82\u0c9c\u0cc6"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0cb0\u0cbe\u0ca4\u0ccd\u0cb0\u0cbf":e<10?"\u0cac\u0cc6\u0cb3\u0cbf\u0c97\u0ccd\u0c97\u0cc6":e<17?"\u0cae\u0ca7\u0ccd\u0caf\u0cbe\u0cb9\u0ccd\u0ca8":e<20?"\u0cb8\u0c82\u0c9c\u0cc6":"\u0cb0\u0cbe\u0ca4\u0ccd\u0cb0\u0cbf"},dayOfMonthOrdinalParse:/\d{1,2}(\u0ca8\u0cc6\u0cd5)/,ordinal:function(e){return e+"\u0ca8\u0cc6\u0cd5"},week:{dow:0,doy:6}}),e.defineLocale("ko",{months:"1\uc6d4_2\uc6d4_3\uc6d4_4\uc6d4_5\uc6d4_6\uc6d4_7\uc6d4_8\uc6d4_9\uc6d4_10\uc6d4_11\uc6d4_12\uc6d4".split("_"),monthsShort:"1\uc6d4_2\uc6d4_3\uc6d4_4\uc6d4_5\uc6d4_6\uc6d4_7\uc6d4_8\uc6d4_9\uc6d4_10\uc6d4_11\uc6d4_12\uc6d4".split("_"),weekdays:"\uc77c\uc694\uc77c_\uc6d4\uc694\uc77c_\ud654\uc694\uc77c_\uc218\uc694\uc77c_\ubaa9\uc694\uc77c_\uae08\uc694\uc77c_\ud1a0\uc694\uc77c".split("_"),weekdaysShort:"\uc77c_\uc6d4_\ud654_\uc218_\ubaa9_\uae08_\ud1a0".split("_"),weekdaysMin:"\uc77c_\uc6d4_\ud654_\uc218_\ubaa9_\uae08_\ud1a0".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"YYYY.MM.DD.",LL:"YYYY\ub144 MMMM D\uc77c",LLL:"YYYY\ub144 MMMM D\uc77c A h:mm",LLLL:"YYYY\ub144 MMMM D\uc77c dddd A h:mm",l:"YYYY.MM.DD.",ll:"YYYY\ub144 MMMM D\uc77c",lll:"YYYY\ub144 MMMM D\uc77c A h:mm",llll:"YYYY\ub144 MMMM D\uc77c dddd A h:mm"},calendar:{sameDay:"\uc624\ub298 LT",nextDay:"\ub0b4\uc77c LT",nextWeek:"dddd LT",lastDay:"\uc5b4\uc81c LT",lastWeek:"\uc9c0\ub09c\uc8fc dddd LT",sameElse:"L"},relativeTime:{future:"%s \ud6c4",past:"%s \uc804",s:"\uba87 \ucd08",ss:"%d\ucd08",m:"1\ubd84",mm:"%d\ubd84",h:"\ud55c \uc2dc\uac04",hh:"%d\uc2dc\uac04",d:"\ud558\ub8e8",dd:"%d\uc77c",M:"\ud55c \ub2ec",MM:"%d\ub2ec",y:"\uc77c \ub144",yy:"%d\ub144"},dayOfMonthOrdinalParse:/\d{1,2}(\uc77c|\uc6d4|\uc8fc)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\uc77c";case"M":return e+"\uc6d4";case"w":case"W":return e+"\uc8fc";default:return e}},meridiemParse:/\uc624\uc804|\uc624\ud6c4/,isPM:function(e){return "\uc624\ud6c4"===e},meridiem:function(e,a,_){return e<12?"\uc624\uc804":"\uc624\ud6c4"}}),{1:"\u0661",2:"\u0662",3:"\u0663",4:"\u0664",5:"\u0665",6:"\u0666",7:"\u0667",8:"\u0668",9:"\u0669",0:"\u0660"}),be={"\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u0660":"0"},n=["\u06a9\u0627\u0646\u0648\u0646\u06cc \u062f\u0648\u0648\u06d5\u0645","\u0634\u0648\u0628\u0627\u062a","\u0626\u0627\u0632\u0627\u0631","\u0646\u06cc\u0633\u0627\u0646","\u0626\u0627\u06cc\u0627\u0631","\u062d\u0648\u0632\u06d5\u06cc\u0631\u0627\u0646","\u062a\u06d5\u0645\u0645\u0648\u0632","\u0626\u0627\u0628","\u0626\u06d5\u06cc\u0644\u0648\u0648\u0644","\u062a\u0634\u0631\u06cc\u0646\u06cc \u06cc\u06d5\u0643\u06d5\u0645","\u062a\u0634\u0631\u06cc\u0646\u06cc \u062f\u0648\u0648\u06d5\u0645","\u0643\u0627\u0646\u0648\u0646\u06cc \u06cc\u06d5\u06a9\u06d5\u0645"],Se=(e.defineLocale("ku",{months:n,monthsShort:n,weekdays:"\u06cc\u0647\u200c\u0643\u0634\u0647\u200c\u0645\u0645\u0647\u200c_\u062f\u0648\u0648\u0634\u0647\u200c\u0645\u0645\u0647\u200c_\u0633\u06ce\u0634\u0647\u200c\u0645\u0645\u0647\u200c_\u0686\u0648\u0627\u0631\u0634\u0647\u200c\u0645\u0645\u0647\u200c_\u067e\u06ce\u0646\u062c\u0634\u0647\u200c\u0645\u0645\u0647\u200c_\u0647\u0647\u200c\u06cc\u0646\u06cc_\u0634\u0647\u200c\u0645\u0645\u0647\u200c".split("_"),weekdaysShort:"\u06cc\u0647\u200c\u0643\u0634\u0647\u200c\u0645_\u062f\u0648\u0648\u0634\u0647\u200c\u0645_\u0633\u06ce\u0634\u0647\u200c\u0645_\u0686\u0648\u0627\u0631\u0634\u0647\u200c\u0645_\u067e\u06ce\u0646\u062c\u0634\u0647\u200c\u0645_\u0647\u0647\u200c\u06cc\u0646\u06cc_\u0634\u0647\u200c\u0645\u0645\u0647\u200c".split("_"),weekdaysMin:"\u06cc_\u062f_\u0633_\u0686_\u067e_\u0647_\u0634".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},meridiemParse:/\u0626\u06ce\u0648\u0627\u0631\u0647\u200c|\u0628\u0647\u200c\u06cc\u0627\u0646\u06cc/,isPM:function(e){return /\u0626\u06ce\u0648\u0627\u0631\u0647\u200c/.test(e)},meridiem:function(e,a,_){return e<12?"\u0628\u0647\u200c\u06cc\u0627\u0646\u06cc":"\u0626\u06ce\u0648\u0627\u0631\u0647\u200c"},calendar:{sameDay:"[\u0626\u0647\u200c\u0645\u0631\u06c6 \u0643\u0627\u062a\u0698\u0645\u06ce\u0631] LT",nextDay:"[\u0628\u0647\u200c\u06cc\u0627\u0646\u06cc \u0643\u0627\u062a\u0698\u0645\u06ce\u0631] LT",nextWeek:"dddd [\u0643\u0627\u062a\u0698\u0645\u06ce\u0631] LT",lastDay:"[\u062f\u0648\u06ce\u0646\u06ce \u0643\u0627\u062a\u0698\u0645\u06ce\u0631] LT",lastWeek:"dddd [\u0643\u0627\u062a\u0698\u0645\u06ce\u0631] LT",sameElse:"L"},relativeTime:{future:"\u0644\u0647\u200c %s",past:"%s",s:"\u0686\u0647\u200c\u0646\u062f \u0686\u0631\u0643\u0647\u200c\u06cc\u0647\u200c\u0643",ss:"\u0686\u0631\u0643\u0647\u200c %d",m:"\u06cc\u0647\u200c\u0643 \u062e\u0648\u0644\u0647\u200c\u0643",mm:"%d \u062e\u0648\u0644\u0647\u200c\u0643",h:"\u06cc\u0647\u200c\u0643 \u0643\u0627\u062a\u0698\u0645\u06ce\u0631",hh:"%d \u0643\u0627\u062a\u0698\u0645\u06ce\u0631",d:"\u06cc\u0647\u200c\u0643 \u0695\u06c6\u0698",dd:"%d \u0695\u06c6\u0698",M:"\u06cc\u0647\u200c\u0643 \u0645\u0627\u0646\u06af",MM:"%d \u0645\u0627\u0646\u06af",y:"\u06cc\u0647\u200c\u0643 \u0633\u0627\u06b5",yy:"%d \u0633\u0627\u06b5"},preparse:function(e){return e.replace(/[\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660]/g,function(e){return be[e]}).replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return He[e]}).replace(/,/g,"\u060c")},week:{dow:6,doy:12}}),{0:"-\u0447\u04af",1:"-\u0447\u0438",2:"-\u0447\u0438",3:"-\u0447\u04af",4:"-\u0447\u04af",5:"-\u0447\u0438",6:"-\u0447\u044b",7:"-\u0447\u0438",8:"-\u0447\u0438",9:"-\u0447\u0443",10:"-\u0447\u0443",20:"-\u0447\u044b",30:"-\u0447\u0443",40:"-\u0447\u044b",50:"-\u0447\u04af",60:"-\u0447\u044b",70:"-\u0447\u0438",80:"-\u0447\u0438",90:"-\u0447\u0443",100:"-\u0447\u04af"});function ve(e,a,_,s){var d={m:["eng Minutt","enger Minutt"],h:["eng Stonn","enger Stonn"],d:["een Dag","engem Dag"],M:["ee Mount","engem Mount"],y:["ee Joer","engem Joer"]};return a?d[_][0]:d[_][1]}function je(e){if(e=parseInt(e,10),isNaN(e))return !1;if(e<0)return !0;if(e<10)return 4<=e&&e<=7;var a;if(e<100)return je(0==(a=e%10)?e/10:a);if(e<1e4){for(;10<=e;)e/=10;return je(e)}return je(e/=1e3)}e.defineLocale("ky",{months:"\u044f\u043d\u0432\u0430\u0440\u044c_\u0444\u0435\u0432\u0440\u0430\u043b\u044c_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0435\u043b\u044c_\u043c\u0430\u0439_\u0438\u044e\u043d\u044c_\u0438\u044e\u043b\u044c_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043d\u0442\u044f\u0431\u0440\u044c_\u043e\u043a\u0442\u044f\u0431\u0440\u044c_\u043d\u043e\u044f\u0431\u0440\u044c_\u0434\u0435\u043a\u0430\u0431\u0440\u044c".split("_"),monthsShort:"\u044f\u043d\u0432_\u0444\u0435\u0432_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440_\u043c\u0430\u0439_\u0438\u044e\u043d\u044c_\u0438\u044e\u043b\u044c_\u0430\u0432\u0433_\u0441\u0435\u043d_\u043e\u043a\u0442_\u043d\u043e\u044f_\u0434\u0435\u043a".split("_"),weekdays:"\u0416\u0435\u043a\u0448\u0435\u043c\u0431\u0438_\u0414\u04af\u0439\u0448\u04e9\u043c\u0431\u04af_\u0428\u0435\u0439\u0448\u0435\u043c\u0431\u0438_\u0428\u0430\u0440\u0448\u0435\u043c\u0431\u0438_\u0411\u0435\u0439\u0448\u0435\u043c\u0431\u0438_\u0416\u0443\u043c\u0430_\u0418\u0448\u0435\u043c\u0431\u0438".split("_"),weekdaysShort:"\u0416\u0435\u043a_\u0414\u04af\u0439_\u0428\u0435\u0439_\u0428\u0430\u0440_\u0411\u0435\u0439_\u0416\u0443\u043c_\u0418\u0448\u0435".split("_"),weekdaysMin:"\u0416\u043a_\u0414\u0439_\u0428\u0439_\u0428\u0440_\u0411\u0439_\u0416\u043c_\u0418\u0448".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0411\u04af\u0433\u04af\u043d \u0441\u0430\u0430\u0442] LT",nextDay:"[\u042d\u0440\u0442\u0435\u04a3 \u0441\u0430\u0430\u0442] LT",nextWeek:"dddd [\u0441\u0430\u0430\u0442] LT",lastDay:"[\u041a\u0435\u0447\u044d\u044d \u0441\u0430\u0430\u0442] LT",lastWeek:"[\u04e8\u0442\u043a\u04e9\u043d \u0430\u043f\u0442\u0430\u043d\u044b\u043d] dddd [\u043a\u04af\u043d\u04af] [\u0441\u0430\u0430\u0442] LT",sameElse:"L"},relativeTime:{future:"%s \u0438\u0447\u0438\u043d\u0434\u0435",past:"%s \u043c\u0443\u0440\u0443\u043d",s:"\u0431\u0438\u0440\u043d\u0435\u0447\u0435 \u0441\u0435\u043a\u0443\u043d\u0434",ss:"%d \u0441\u0435\u043a\u0443\u043d\u0434",m:"\u0431\u0438\u0440 \u043c\u04af\u043d\u04e9\u0442",mm:"%d \u043c\u04af\u043d\u04e9\u0442",h:"\u0431\u0438\u0440 \u0441\u0430\u0430\u0442",hh:"%d \u0441\u0430\u0430\u0442",d:"\u0431\u0438\u0440 \u043a\u04af\u043d",dd:"%d \u043a\u04af\u043d",M:"\u0431\u0438\u0440 \u0430\u0439",MM:"%d \u0430\u0439",y:"\u0431\u0438\u0440 \u0436\u044b\u043b",yy:"%d \u0436\u044b\u043b"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0447\u0438|\u0447\u044b|\u0447\u04af|\u0447\u0443)/,ordinal:function(e){return e+(Se[e]||Se[e%10]||Se[100<=e?100:null])},week:{dow:1,doy:7}}),e.defineLocale("lb",{months:"Januar_Februar_M\xe4erz_Abr\xebll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonndeg_M\xe9indeg_D\xebnschdeg_M\xebttwoch_Donneschdeg_Freideg_Samschdeg".split("_"),weekdaysShort:"So._M\xe9._D\xeb._M\xeb._Do._Fr._Sa.".split("_"),weekdaysMin:"So_M\xe9_D\xeb_M\xeb_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm [Auer]",LTS:"H:mm:ss [Auer]",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm [Auer]",LLLL:"dddd, D. MMMM YYYY H:mm [Auer]"},calendar:{sameDay:"[Haut um] LT",sameElse:"L",nextDay:"[Muer um] LT",nextWeek:"dddd [um] LT",lastDay:"[G\xebschter um] LT",lastWeek:function(){switch(this.day()){case 2:case 4:return "[Leschten] dddd [um] LT";default:return "[Leschte] dddd [um] LT"}}},relativeTime:{future:function(e){return je(e.substr(0,e.indexOf(" ")))?"a "+e:"an "+e},past:function(e){return je(e.substr(0,e.indexOf(" ")))?"viru "+e:"virun "+e},s:"e puer Sekonnen",ss:"%d Sekonnen",m:ve,mm:"%d Minutten",h:ve,hh:"%d Stonnen",d:ve,dd:"%d Deeg",M:ve,MM:"%d M\xe9int",y:ve,yy:"%d Joer"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("lo",{months:"\u0ea1\u0eb1\u0e87\u0e81\u0ead\u0e99_\u0e81\u0eb8\u0ea1\u0e9e\u0eb2_\u0ea1\u0eb5\u0e99\u0eb2_\u0ec0\u0ea1\u0eaa\u0eb2_\u0e9e\u0eb6\u0e94\u0eaa\u0eb0\u0e9e\u0eb2_\u0ea1\u0eb4\u0e96\u0eb8\u0e99\u0eb2_\u0e81\u0ecd\u0ea5\u0eb0\u0e81\u0ebb\u0e94_\u0eaa\u0eb4\u0e87\u0eab\u0eb2_\u0e81\u0eb1\u0e99\u0e8d\u0eb2_\u0e95\u0eb8\u0ea5\u0eb2_\u0e9e\u0eb0\u0e88\u0eb4\u0e81_\u0e97\u0eb1\u0e99\u0ea7\u0eb2".split("_"),monthsShort:"\u0ea1\u0eb1\u0e87\u0e81\u0ead\u0e99_\u0e81\u0eb8\u0ea1\u0e9e\u0eb2_\u0ea1\u0eb5\u0e99\u0eb2_\u0ec0\u0ea1\u0eaa\u0eb2_\u0e9e\u0eb6\u0e94\u0eaa\u0eb0\u0e9e\u0eb2_\u0ea1\u0eb4\u0e96\u0eb8\u0e99\u0eb2_\u0e81\u0ecd\u0ea5\u0eb0\u0e81\u0ebb\u0e94_\u0eaa\u0eb4\u0e87\u0eab\u0eb2_\u0e81\u0eb1\u0e99\u0e8d\u0eb2_\u0e95\u0eb8\u0ea5\u0eb2_\u0e9e\u0eb0\u0e88\u0eb4\u0e81_\u0e97\u0eb1\u0e99\u0ea7\u0eb2".split("_"),weekdays:"\u0ead\u0eb2\u0e97\u0eb4\u0e94_\u0e88\u0eb1\u0e99_\u0ead\u0eb1\u0e87\u0e84\u0eb2\u0e99_\u0e9e\u0eb8\u0e94_\u0e9e\u0eb0\u0eab\u0eb1\u0e94_\u0eaa\u0eb8\u0e81_\u0ec0\u0eaa\u0ebb\u0eb2".split("_"),weekdaysShort:"\u0e97\u0eb4\u0e94_\u0e88\u0eb1\u0e99_\u0ead\u0eb1\u0e87\u0e84\u0eb2\u0e99_\u0e9e\u0eb8\u0e94_\u0e9e\u0eb0\u0eab\u0eb1\u0e94_\u0eaa\u0eb8\u0e81_\u0ec0\u0eaa\u0ebb\u0eb2".split("_"),weekdaysMin:"\u0e97_\u0e88_\u0ead\u0e84_\u0e9e_\u0e9e\u0eab_\u0eaa\u0e81_\u0eaa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"\u0ea7\u0eb1\u0e99dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0e95\u0ead\u0e99\u0ec0\u0e8a\u0ebb\u0ec9\u0eb2|\u0e95\u0ead\u0e99\u0ec1\u0ea5\u0e87/,isPM:function(e){return "\u0e95\u0ead\u0e99\u0ec1\u0ea5\u0e87"===e},meridiem:function(e,a,_){return e<12?"\u0e95\u0ead\u0e99\u0ec0\u0e8a\u0ebb\u0ec9\u0eb2":"\u0e95\u0ead\u0e99\u0ec1\u0ea5\u0e87"},calendar:{sameDay:"[\u0ea1\u0eb7\u0ec9\u0e99\u0eb5\u0ec9\u0ec0\u0ea7\u0ea5\u0eb2] LT",nextDay:"[\u0ea1\u0eb7\u0ec9\u0ead\u0eb7\u0ec8\u0e99\u0ec0\u0ea7\u0ea5\u0eb2] LT",nextWeek:"[\u0ea7\u0eb1\u0e99]dddd[\u0edc\u0ec9\u0eb2\u0ec0\u0ea7\u0ea5\u0eb2] LT",lastDay:"[\u0ea1\u0eb7\u0ec9\u0ea7\u0eb2\u0e99\u0e99\u0eb5\u0ec9\u0ec0\u0ea7\u0ea5\u0eb2] LT",lastWeek:"[\u0ea7\u0eb1\u0e99]dddd[\u0ec1\u0ea5\u0ec9\u0ea7\u0e99\u0eb5\u0ec9\u0ec0\u0ea7\u0ea5\u0eb2] LT",sameElse:"L"},relativeTime:{future:"\u0ead\u0eb5\u0e81 %s",past:"%s\u0e9c\u0ec8\u0eb2\u0e99\u0ea1\u0eb2",s:"\u0e9a\u0ecd\u0ec8\u0ec0\u0e97\u0ebb\u0ec8\u0eb2\u0ec3\u0e94\u0ea7\u0eb4\u0e99\u0eb2\u0e97\u0eb5",ss:"%d \u0ea7\u0eb4\u0e99\u0eb2\u0e97\u0eb5",m:"1 \u0e99\u0eb2\u0e97\u0eb5",mm:"%d \u0e99\u0eb2\u0e97\u0eb5",h:"1 \u0e8a\u0ebb\u0ec8\u0ea7\u0ec2\u0ea1\u0e87",hh:"%d \u0e8a\u0ebb\u0ec8\u0ea7\u0ec2\u0ea1\u0e87",d:"1 \u0ea1\u0eb7\u0ec9",dd:"%d \u0ea1\u0eb7\u0ec9",M:"1 \u0ec0\u0e94\u0eb7\u0ead\u0e99",MM:"%d \u0ec0\u0e94\u0eb7\u0ead\u0e99",y:"1 \u0e9b\u0eb5",yy:"%d \u0e9b\u0eb5"},dayOfMonthOrdinalParse:/(\u0e97\u0eb5\u0ec8)\d{1,2}/,ordinal:function(e){return "\u0e97\u0eb5\u0ec8"+e}});var xe={ss:"sekund\u0117_sekund\u017ei\u0173_sekundes",m:"minut\u0117_minut\u0117s_minut\u0119",mm:"minut\u0117s_minu\u010di\u0173_minutes",h:"valanda_valandos_valand\u0105",hh:"valandos_valand\u0173_valandas",d:"diena_dienos_dien\u0105",dd:"dienos_dien\u0173_dienas",M:"m\u0117nuo_m\u0117nesio_m\u0117nes\u012f",MM:"m\u0117nesiai_m\u0117nesi\u0173_m\u0117nesius",y:"metai_met\u0173_metus",yy:"metai_met\u0173_metus"};function Pe(e,a,_,s){return a?f(_)[0]:s?f(_)[1]:f(_)[2]}function We(e){return e%10==0||10<e&&e<20}function f(e){return xe[e].split("_")}function Ae(e,a,_,s){var d=e+" ";return 1===e?d+Pe(0,a,_[0],s):a?d+(We(e)?f(_)[1]:f(_)[0]):s?d+f(_)[1]:d+(We(e)?f(_)[1]:f(_)[2])}e.defineLocale("lt",{months:{format:"sausio_vasario_kovo_baland\u017eio_gegu\u017e\u0117s_bir\u017eelio_liepos_rugpj\u016b\u010dio_rugs\u0117jo_spalio_lapkri\u010dio_gruod\u017eio".split("_"),standalone:"sausis_vasaris_kovas_balandis_gegu\u017e\u0117_bir\u017eelis_liepa_rugpj\u016btis_rugs\u0117jis_spalis_lapkritis_gruodis".split("_"),isFormat:/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/},monthsShort:"sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),weekdays:{format:"sekmadien\u012f_pirmadien\u012f_antradien\u012f_tre\u010diadien\u012f_ketvirtadien\u012f_penktadien\u012f_\u0161e\u0161tadien\u012f".split("_"),standalone:"sekmadienis_pirmadienis_antradienis_tre\u010diadienis_ketvirtadienis_penktadienis_\u0161e\u0161tadienis".split("_"),isFormat:/dddd HH:mm/},weekdaysShort:"Sek_Pir_Ant_Tre_Ket_Pen_\u0160e\u0161".split("_"),weekdaysMin:"S_P_A_T_K_Pn_\u0160".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY [m.] MMMM D [d.]",LLL:"YYYY [m.] MMMM D [d.], HH:mm [val.]",LLLL:"YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",l:"YYYY-MM-DD",ll:"YYYY [m.] MMMM D [d.]",lll:"YYYY [m.] MMMM D [d.], HH:mm [val.]",llll:"YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]"},calendar:{sameDay:"[\u0160iandien] LT",nextDay:"[Rytoj] LT",nextWeek:"dddd LT",lastDay:"[Vakar] LT",lastWeek:"[Pra\u0117jus\u012f] dddd LT",sameElse:"L"},relativeTime:{future:"po %s",past:"prie\u0161 %s",s:function(e,a,_,s){return a?"kelios sekund\u0117s":s?"keli\u0173 sekund\u017ei\u0173":"kelias sekundes"},ss:Ae,m:Pe,mm:Ae,h:Pe,hh:Ae,d:Pe,dd:Ae,M:Pe,MM:Ae,y:Pe,yy:Ae},dayOfMonthOrdinalParse:/\d{1,2}-oji/,ordinal:function(e){return e+"-oji"},week:{dow:1,doy:4}});var Oe={ss:"sekundes_sekund\u0113m_sekunde_sekundes".split("_"),m:"min\u016btes_min\u016bt\u0113m_min\u016bte_min\u016btes".split("_"),mm:"min\u016btes_min\u016bt\u0113m_min\u016bte_min\u016btes".split("_"),h:"stundas_stund\u0101m_stunda_stundas".split("_"),hh:"stundas_stund\u0101m_stunda_stundas".split("_"),d:"dienas_dien\u0101m_diena_dienas".split("_"),dd:"dienas_dien\u0101m_diena_dienas".split("_"),M:"m\u0113ne\u0161a_m\u0113ne\u0161iem_m\u0113nesis_m\u0113ne\u0161i".split("_"),MM:"m\u0113ne\u0161a_m\u0113ne\u0161iem_m\u0113nesis_m\u0113ne\u0161i".split("_"),y:"gada_gadiem_gads_gadi".split("_"),yy:"gada_gadiem_gads_gadi".split("_")};function Ee(e,a,_){return _?a%10==1&&a%100!=11?e[2]:e[3]:a%10==1&&a%100!=11?e[0]:e[1]}function Fe(e,a,_){return e+" "+Ee(Oe[_],e,a)}function ze(e,a,_){return Ee(Oe[_],e,a)}e.defineLocale("lv",{months:"janv\u0101ris_febru\u0101ris_marts_apr\u012blis_maijs_j\u016bnijs_j\u016blijs_augusts_septembris_oktobris_novembris_decembris".split("_"),monthsShort:"jan_feb_mar_apr_mai_j\u016bn_j\u016bl_aug_sep_okt_nov_dec".split("_"),weekdays:"sv\u0113tdiena_pirmdiena_otrdiena_tre\u0161diena_ceturtdiena_piektdiena_sestdiena".split("_"),weekdaysShort:"Sv_P_O_T_C_Pk_S".split("_"),weekdaysMin:"Sv_P_O_T_C_Pk_S".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY.",LL:"YYYY. [gada] D. MMMM",LLL:"YYYY. [gada] D. MMMM, HH:mm",LLLL:"YYYY. [gada] D. MMMM, dddd, HH:mm"},calendar:{sameDay:"[\u0160odien pulksten] LT",nextDay:"[R\u012bt pulksten] LT",nextWeek:"dddd [pulksten] LT",lastDay:"[Vakar pulksten] LT",lastWeek:"[Pag\u0101ju\u0161\u0101] dddd [pulksten] LT",sameElse:"L"},relativeTime:{future:"p\u0113c %s",past:"pirms %s",s:function(e,a){return a?"da\u017eas sekundes":"da\u017e\u0101m sekund\u0113m"},ss:Fe,m:ze,mm:Fe,h:ze,hh:Fe,d:ze,dd:Fe,M:ze,MM:Fe,y:ze,yy:Fe},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var w={words:{ss:["sekund","sekunda","sekundi"],m:["jedan minut","jednog minuta"],mm:["minut","minuta","minuta"],h:["jedan sat","jednog sata"],hh:["sat","sata","sati"],dd:["dan","dana","dana"],MM:["mjesec","mjeseca","mjeseci"],yy:["godina","godine","godina"]},correctGrammaticalCase:function(e,a){return 1===e?a[0]:2<=e&&e<=4?a[1]:a[2]},translate:function(e,a,_){var s=w.words[_];return 1===_.length?a?s[0]:s[1]:e+" "+w.correctGrammaticalCase(e,s)}};function g(e,a,_,s){switch(_){case"s":return a?"\u0445\u044d\u0434\u0445\u044d\u043d \u0441\u0435\u043a\u0443\u043d\u0434":"\u0445\u044d\u0434\u0445\u044d\u043d \u0441\u0435\u043a\u0443\u043d\u0434\u044b\u043d";case"ss":return e+(a?" \u0441\u0435\u043a\u0443\u043d\u0434":" \u0441\u0435\u043a\u0443\u043d\u0434\u044b\u043d");case"m":case"mm":return e+(a?" \u043c\u0438\u043d\u0443\u0442":" \u043c\u0438\u043d\u0443\u0442\u044b\u043d");case"h":case"hh":return e+(a?" \u0446\u0430\u0433":" \u0446\u0430\u0433\u0438\u0439\u043d");case"d":case"dd":return e+(a?" \u04e9\u0434\u04e9\u0440":" \u04e9\u0434\u0440\u0438\u0439\u043d");case"M":case"MM":return e+(a?" \u0441\u0430\u0440":" \u0441\u0430\u0440\u044b\u043d");case"y":case"yy":return e+(a?" \u0436\u0438\u043b":" \u0436\u0438\u043b\u0438\u0439\u043d");default:return e}}e.defineLocale("me",{months:"januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),monthsShort:"jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"nedjelja_ponedjeljak_utorak_srijeda_\u010detvrtak_petak_subota".split("_"),weekdaysShort:"ned._pon._uto._sri._\u010det._pet._sub.".split("_"),weekdaysMin:"ne_po_ut_sr_\u010de_pe_su".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danas u] LT",nextDay:"[sjutra u] LT",nextWeek:function(){switch(this.day()){case 0:return "[u] [nedjelju] [u] LT";case 3:return "[u] [srijedu] [u] LT";case 6:return "[u] [subotu] [u] LT";case 1:case 2:case 4:case 5:return "[u] dddd [u] LT"}},lastDay:"[ju\u010de u] LT",lastWeek:function(){return ["[pro\u0161le] [nedjelje] [u] LT","[pro\u0161log] [ponedjeljka] [u] LT","[pro\u0161log] [utorka] [u] LT","[pro\u0161le] [srijede] [u] LT","[pro\u0161log] [\u010detvrtka] [u] LT","[pro\u0161log] [petka] [u] LT","[pro\u0161le] [subote] [u] LT"][this.day()]},sameElse:"L"},relativeTime:{future:"za %s",past:"prije %s",s:"nekoliko sekundi",ss:w.translate,m:w.translate,mm:w.translate,h:w.translate,hh:w.translate,d:"dan",dd:w.translate,M:"mjesec",MM:w.translate,y:"godinu",yy:w.translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),e.defineLocale("mi",{months:"Kohi-t\u0101te_Hui-tanguru_Pout\u016b-te-rangi_Paenga-wh\u0101wh\u0101_Haratua_Pipiri_H\u014dngoingoi_Here-turi-k\u014dk\u0101_Mahuru_Whiringa-\u0101-nuku_Whiringa-\u0101-rangi_Hakihea".split("_"),monthsShort:"Kohi_Hui_Pou_Pae_Hara_Pipi_H\u014dngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"),monthsRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,monthsStrictRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,monthsShortRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,monthsShortStrictRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,weekdays:"R\u0101tapu_Mane_T\u016brei_Wenerei_T\u0101ite_Paraire_H\u0101tarei".split("_"),weekdaysShort:"Ta_Ma_T\u016b_We_T\u0101i_Pa_H\u0101".split("_"),weekdaysMin:"Ta_Ma_T\u016b_We_T\u0101i_Pa_H\u0101".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [i] HH:mm",LLLL:"dddd, D MMMM YYYY [i] HH:mm"},calendar:{sameDay:"[i teie mahana, i] LT",nextDay:"[apopo i] LT",nextWeek:"dddd [i] LT",lastDay:"[inanahi i] LT",lastWeek:"dddd [whakamutunga i] LT",sameElse:"L"},relativeTime:{future:"i roto i %s",past:"%s i mua",s:"te h\u0113kona ruarua",ss:"%d h\u0113kona",m:"he meneti",mm:"%d meneti",h:"te haora",hh:"%d haora",d:"he ra",dd:"%d ra",M:"he marama",MM:"%d marama",y:"he tau",yy:"%d tau"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),e.defineLocale("mk",{months:"\u0458\u0430\u043d\u0443\u0430\u0440\u0438_\u0444\u0435\u0432\u0440\u0443\u0430\u0440\u0438_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0438\u043b_\u043c\u0430\u0458_\u0458\u0443\u043d\u0438_\u0458\u0443\u043b\u0438_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043f\u0442\u0435\u043c\u0432\u0440\u0438_\u043e\u043a\u0442\u043e\u043c\u0432\u0440\u0438_\u043d\u043e\u0435\u043c\u0432\u0440\u0438_\u0434\u0435\u043a\u0435\u043c\u0432\u0440\u0438".split("_"),monthsShort:"\u0458\u0430\u043d_\u0444\u0435\u0432_\u043c\u0430\u0440_\u0430\u043f\u0440_\u043c\u0430\u0458_\u0458\u0443\u043d_\u0458\u0443\u043b_\u0430\u0432\u0433_\u0441\u0435\u043f_\u043e\u043a\u0442_\u043d\u043e\u0435_\u0434\u0435\u043a".split("_"),weekdays:"\u043d\u0435\u0434\u0435\u043b\u0430_\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u043d\u0438\u043a_\u0432\u0442\u043e\u0440\u043d\u0438\u043a_\u0441\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0440\u0442\u043e\u043a_\u043f\u0435\u0442\u043e\u043a_\u0441\u0430\u0431\u043e\u0442\u0430".split("_"),weekdaysShort:"\u043d\u0435\u0434_\u043f\u043e\u043d_\u0432\u0442\u043e_\u0441\u0440\u0435_\u0447\u0435\u0442_\u043f\u0435\u0442_\u0441\u0430\u0431".split("_"),weekdaysMin:"\u043de_\u043fo_\u0432\u0442_\u0441\u0440_\u0447\u0435_\u043f\u0435_\u0441a".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"D.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY H:mm",LLLL:"dddd, D MMMM YYYY H:mm"},calendar:{sameDay:"[\u0414\u0435\u043d\u0435\u0441 \u0432\u043e] LT",nextDay:"[\u0423\u0442\u0440\u0435 \u0432\u043e] LT",nextWeek:"[\u0412\u043e] dddd [\u0432\u043e] LT",lastDay:"[\u0412\u0447\u0435\u0440\u0430 \u0432\u043e] LT",lastWeek:function(){switch(this.day()){case 0:case 3:case 6:return "[\u0418\u0437\u043c\u0438\u043d\u0430\u0442\u0430\u0442\u0430] dddd [\u0432\u043e] LT";case 1:case 2:case 4:case 5:return "[\u0418\u0437\u043c\u0438\u043d\u0430\u0442\u0438\u043e\u0442] dddd [\u0432\u043e] LT"}},sameElse:"L"},relativeTime:{future:"\u0437\u0430 %s",past:"\u043f\u0440\u0435\u0434 %s",s:"\u043d\u0435\u043a\u043e\u043b\u043a\u0443 \u0441\u0435\u043a\u0443\u043d\u0434\u0438",ss:"%d \u0441\u0435\u043a\u0443\u043d\u0434\u0438",m:"\u0435\u0434\u043d\u0430 \u043c\u0438\u043d\u0443\u0442\u0430",mm:"%d \u043c\u0438\u043d\u0443\u0442\u0438",h:"\u0435\u0434\u0435\u043d \u0447\u0430\u0441",hh:"%d \u0447\u0430\u0441\u0430",d:"\u0435\u0434\u0435\u043d \u0434\u0435\u043d",dd:"%d \u0434\u0435\u043d\u0430",M:"\u0435\u0434\u0435\u043d \u043c\u0435\u0441\u0435\u0446",MM:"%d \u043c\u0435\u0441\u0435\u0446\u0438",y:"\u0435\u0434\u043d\u0430 \u0433\u043e\u0434\u0438\u043d\u0430",yy:"%d \u0433\u043e\u0434\u0438\u043d\u0438"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0435\u0432|\u0435\u043d|\u0442\u0438|\u0432\u0438|\u0440\u0438|\u043c\u0438)/,ordinal:function(e){var a=e%10,_=e%100;return 0===e?e+"-\u0435\u0432":0==_?e+"-\u0435\u043d":10<_&&_<20?e+"-\u0442\u0438":1==a?e+"-\u0432\u0438":2==a?e+"-\u0440\u0438":7==a||8==a?e+"-\u043c\u0438":e+"-\u0442\u0438"},week:{dow:1,doy:7}}),e.defineLocale("ml",{months:"\u0d1c\u0d28\u0d41\u0d35\u0d30\u0d3f_\u0d2b\u0d46\u0d2c\u0d4d\u0d30\u0d41\u0d35\u0d30\u0d3f_\u0d2e\u0d3e\u0d7c\u0d1a\u0d4d\u0d1a\u0d4d_\u0d0f\u0d2a\u0d4d\u0d30\u0d3f\u0d7d_\u0d2e\u0d47\u0d2f\u0d4d_\u0d1c\u0d42\u0d7a_\u0d1c\u0d42\u0d32\u0d48_\u0d13\u0d17\u0d38\u0d4d\u0d31\u0d4d\u0d31\u0d4d_\u0d38\u0d46\u0d2a\u0d4d\u0d31\u0d4d\u0d31\u0d02\u0d2c\u0d7c_\u0d12\u0d15\u0d4d\u0d1f\u0d4b\u0d2c\u0d7c_\u0d28\u0d35\u0d02\u0d2c\u0d7c_\u0d21\u0d3f\u0d38\u0d02\u0d2c\u0d7c".split("_"),monthsShort:"\u0d1c\u0d28\u0d41._\u0d2b\u0d46\u0d2c\u0d4d\u0d30\u0d41._\u0d2e\u0d3e\u0d7c._\u0d0f\u0d2a\u0d4d\u0d30\u0d3f._\u0d2e\u0d47\u0d2f\u0d4d_\u0d1c\u0d42\u0d7a_\u0d1c\u0d42\u0d32\u0d48._\u0d13\u0d17._\u0d38\u0d46\u0d2a\u0d4d\u0d31\u0d4d\u0d31._\u0d12\u0d15\u0d4d\u0d1f\u0d4b._\u0d28\u0d35\u0d02._\u0d21\u0d3f\u0d38\u0d02.".split("_"),monthsParseExact:!0,weekdays:"\u0d1e\u0d3e\u0d2f\u0d31\u0d3e\u0d34\u0d4d\u0d1a_\u0d24\u0d3f\u0d19\u0d4d\u0d15\u0d33\u0d3e\u0d34\u0d4d\u0d1a_\u0d1a\u0d4a\u0d35\u0d4d\u0d35\u0d3e\u0d34\u0d4d\u0d1a_\u0d2c\u0d41\u0d27\u0d28\u0d3e\u0d34\u0d4d\u0d1a_\u0d35\u0d4d\u0d2f\u0d3e\u0d34\u0d3e\u0d34\u0d4d\u0d1a_\u0d35\u0d46\u0d33\u0d4d\u0d33\u0d3f\u0d2f\u0d3e\u0d34\u0d4d\u0d1a_\u0d36\u0d28\u0d3f\u0d2f\u0d3e\u0d34\u0d4d\u0d1a".split("_"),weekdaysShort:"\u0d1e\u0d3e\u0d2f\u0d7c_\u0d24\u0d3f\u0d19\u0d4d\u0d15\u0d7e_\u0d1a\u0d4a\u0d35\u0d4d\u0d35_\u0d2c\u0d41\u0d27\u0d7b_\u0d35\u0d4d\u0d2f\u0d3e\u0d34\u0d02_\u0d35\u0d46\u0d33\u0d4d\u0d33\u0d3f_\u0d36\u0d28\u0d3f".split("_"),weekdaysMin:"\u0d1e\u0d3e_\u0d24\u0d3f_\u0d1a\u0d4a_\u0d2c\u0d41_\u0d35\u0d4d\u0d2f\u0d3e_\u0d35\u0d46_\u0d36".split("_"),longDateFormat:{LT:"A h:mm -\u0d28\u0d41",LTS:"A h:mm:ss -\u0d28\u0d41",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm -\u0d28\u0d41",LLLL:"dddd, D MMMM YYYY, A h:mm -\u0d28\u0d41"},calendar:{sameDay:"[\u0d07\u0d28\u0d4d\u0d28\u0d4d] LT",nextDay:"[\u0d28\u0d3e\u0d33\u0d46] LT",nextWeek:"dddd, LT",lastDay:"[\u0d07\u0d28\u0d4d\u0d28\u0d32\u0d46] LT",lastWeek:"[\u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e\u0d4d",past:"%s \u0d2e\u0d41\u0d7b\u0d2a\u0d4d",s:"\u0d05\u0d7d\u0d2a \u0d28\u0d3f\u0d2e\u0d3f\u0d37\u0d19\u0d4d\u0d19\u0d7e",ss:"%d \u0d38\u0d46\u0d15\u0d4d\u0d15\u0d7b\u0d21\u0d4d",m:"\u0d12\u0d30\u0d41 \u0d2e\u0d3f\u0d28\u0d3f\u0d31\u0d4d\u0d31\u0d4d",mm:"%d \u0d2e\u0d3f\u0d28\u0d3f\u0d31\u0d4d\u0d31\u0d4d",h:"\u0d12\u0d30\u0d41 \u0d2e\u0d23\u0d3f\u0d15\u0d4d\u0d15\u0d42\u0d7c",hh:"%d \u0d2e\u0d23\u0d3f\u0d15\u0d4d\u0d15\u0d42\u0d7c",d:"\u0d12\u0d30\u0d41 \u0d26\u0d3f\u0d35\u0d38\u0d02",dd:"%d \u0d26\u0d3f\u0d35\u0d38\u0d02",M:"\u0d12\u0d30\u0d41 \u0d2e\u0d3e\u0d38\u0d02",MM:"%d \u0d2e\u0d3e\u0d38\u0d02",y:"\u0d12\u0d30\u0d41 \u0d35\u0d7c\u0d37\u0d02",yy:"%d \u0d35\u0d7c\u0d37\u0d02"},meridiemParse:/\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f|\u0d30\u0d3e\u0d35\u0d3f\u0d32\u0d46|\u0d09\u0d1a\u0d4d\u0d1a \u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e\u0d4d|\u0d35\u0d48\u0d15\u0d41\u0d28\u0d4d\u0d28\u0d47\u0d30\u0d02|\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f/i,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f"===a&&4<=e||"\u0d09\u0d1a\u0d4d\u0d1a \u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e\u0d4d"===a||"\u0d35\u0d48\u0d15\u0d41\u0d28\u0d4d\u0d28\u0d47\u0d30\u0d02"===a?e+12:e},meridiem:function(e,a,_){return e<4?"\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f":e<12?"\u0d30\u0d3e\u0d35\u0d3f\u0d32\u0d46":e<17?"\u0d09\u0d1a\u0d4d\u0d1a \u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e\u0d4d":e<20?"\u0d35\u0d48\u0d15\u0d41\u0d28\u0d4d\u0d28\u0d47\u0d30\u0d02":"\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f"}}),e.defineLocale("mn",{months:"\u041d\u044d\u0433\u0434\u04af\u0433\u044d\u044d\u0440 \u0441\u0430\u0440_\u0425\u043e\u0451\u0440\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0413\u0443\u0440\u0430\u0432\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0414\u04e9\u0440\u04e9\u0432\u0434\u04af\u0433\u044d\u044d\u0440 \u0441\u0430\u0440_\u0422\u0430\u0432\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0417\u0443\u0440\u0433\u0430\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0414\u043e\u043b\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u041d\u0430\u0439\u043c\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0415\u0441\u0434\u04af\u0433\u044d\u044d\u0440 \u0441\u0430\u0440_\u0410\u0440\u0430\u0432\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0410\u0440\u0432\u0430\u043d \u043d\u044d\u0433\u0434\u04af\u0433\u044d\u044d\u0440 \u0441\u0430\u0440_\u0410\u0440\u0432\u0430\u043d \u0445\u043e\u0451\u0440\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440".split("_"),monthsShort:"1 \u0441\u0430\u0440_2 \u0441\u0430\u0440_3 \u0441\u0430\u0440_4 \u0441\u0430\u0440_5 \u0441\u0430\u0440_6 \u0441\u0430\u0440_7 \u0441\u0430\u0440_8 \u0441\u0430\u0440_9 \u0441\u0430\u0440_10 \u0441\u0430\u0440_11 \u0441\u0430\u0440_12 \u0441\u0430\u0440".split("_"),monthsParseExact:!0,weekdays:"\u041d\u044f\u043c_\u0414\u0430\u0432\u0430\u0430_\u041c\u044f\u0433\u043c\u0430\u0440_\u041b\u0445\u0430\u0433\u0432\u0430_\u041f\u04af\u0440\u044d\u0432_\u0411\u0430\u0430\u0441\u0430\u043d_\u0411\u044f\u043c\u0431\u0430".split("_"),weekdaysShort:"\u041d\u044f\u043c_\u0414\u0430\u0432_\u041c\u044f\u0433_\u041b\u0445\u0430_\u041f\u04af\u0440_\u0411\u0430\u0430_\u0411\u044f\u043c".split("_"),weekdaysMin:"\u041d\u044f_\u0414\u0430_\u041c\u044f_\u041b\u0445_\u041f\u04af_\u0411\u0430_\u0411\u044f".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY \u043e\u043d\u044b MMMM\u044b\u043d D",LLL:"YYYY \u043e\u043d\u044b MMMM\u044b\u043d D HH:mm",LLLL:"dddd, YYYY \u043e\u043d\u044b MMMM\u044b\u043d D HH:mm"},meridiemParse:/\u04ae\u04e8|\u04ae\u0425/i,isPM:function(e){return "\u04ae\u0425"===e},meridiem:function(e,a,_){return e<12?"\u04ae\u04e8":"\u04ae\u0425"},calendar:{sameDay:"[\u04e8\u043d\u04e9\u04e9\u0434\u04e9\u0440] LT",nextDay:"[\u041c\u0430\u0440\u0433\u0430\u0430\u0448] LT",nextWeek:"[\u0418\u0440\u044d\u0445] dddd LT",lastDay:"[\u04e8\u0447\u0438\u0433\u0434\u04e9\u0440] LT",lastWeek:"[\u04e8\u043d\u0433\u04e9\u0440\u0441\u04e9\u043d] dddd LT",sameElse:"L"},relativeTime:{future:"%s \u0434\u0430\u0440\u0430\u0430",past:"%s \u04e9\u043c\u043d\u04e9",s:g,ss:g,m:g,mm:g,h:g,hh:g,d:g,dd:g,M:g,MM:g,y:g,yy:g},dayOfMonthOrdinalParse:/\d{1,2} \u04e9\u0434\u04e9\u0440/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+" \u04e9\u0434\u04e9\u0440";default:return e}}});var Je={1:"\u0967",2:"\u0968",3:"\u0969",4:"\u096a",5:"\u096b",6:"\u096c",7:"\u096d",8:"\u096e",9:"\u096f",0:"\u0966"},Ie={"\u0967":"1","\u0968":"2","\u0969":"3","\u096a":"4","\u096b":"5","\u096c":"6","\u096d":"7","\u096e":"8","\u096f":"9","\u0966":"0"};function H(e,a,_,s){var d="";if(a)switch(_){case"s":d="\u0915\u093e\u0939\u0940 \u0938\u0947\u0915\u0902\u0926";break;case"ss":d="%d \u0938\u0947\u0915\u0902\u0926";break;case"m":d="\u090f\u0915 \u092e\u093f\u0928\u093f\u091f";break;case"mm":d="%d \u092e\u093f\u0928\u093f\u091f\u0947";break;case"h":d="\u090f\u0915 \u0924\u093e\u0938";break;case"hh":d="%d \u0924\u093e\u0938";break;case"d":d="\u090f\u0915 \u0926\u093f\u0935\u0938";break;case"dd":d="%d \u0926\u093f\u0935\u0938";break;case"M":d="\u090f\u0915 \u092e\u0939\u093f\u0928\u093e";break;case"MM":d="%d \u092e\u0939\u093f\u0928\u0947";break;case"y":d="\u090f\u0915 \u0935\u0930\u094d\u0937";break;case"yy":d="%d \u0935\u0930\u094d\u0937\u0947";break}else switch(_){case"s":d="\u0915\u093e\u0939\u0940 \u0938\u0947\u0915\u0902\u0926\u093e\u0902";break;case"ss":d="%d \u0938\u0947\u0915\u0902\u0926\u093e\u0902";break;case"m":d="\u090f\u0915\u093e \u092e\u093f\u0928\u093f\u091f\u093e";break;case"mm":d="%d \u092e\u093f\u0928\u093f\u091f\u093e\u0902";break;case"h":d="\u090f\u0915\u093e \u0924\u093e\u0938\u093e";break;case"hh":d="%d \u0924\u093e\u0938\u093e\u0902";break;case"d":d="\u090f\u0915\u093e \u0926\u093f\u0935\u0938\u093e";break;case"dd":d="%d \u0926\u093f\u0935\u0938\u093e\u0902";break;case"M":d="\u090f\u0915\u093e \u092e\u0939\u093f\u0928\u094d\u092f\u093e";break;case"MM":d="%d \u092e\u0939\u093f\u0928\u094d\u092f\u093e\u0902";break;case"y":d="\u090f\u0915\u093e \u0935\u0930\u094d\u0937\u093e";break;case"yy":d="%d \u0935\u0930\u094d\u0937\u093e\u0902";break}return d.replace(/%d/i,e)}e.defineLocale("mr",{months:"\u091c\u093e\u0928\u0947\u0935\u093e\u0930\u0940_\u092b\u0947\u092c\u094d\u0930\u0941\u0935\u093e\u0930\u0940_\u092e\u093e\u0930\u094d\u091a_\u090f\u092a\u094d\u0930\u093f\u0932_\u092e\u0947_\u091c\u0942\u0928_\u091c\u0941\u0932\u0948_\u0911\u0917\u0938\u094d\u091f_\u0938\u092a\u094d\u091f\u0947\u0902\u092c\u0930_\u0911\u0915\u094d\u091f\u094b\u092c\u0930_\u0928\u094b\u0935\u094d\u0939\u0947\u0902\u092c\u0930_\u0921\u093f\u0938\u0947\u0902\u092c\u0930".split("_"),monthsShort:"\u091c\u093e\u0928\u0947._\u092b\u0947\u092c\u094d\u0930\u0941._\u092e\u093e\u0930\u094d\u091a._\u090f\u092a\u094d\u0930\u093f._\u092e\u0947._\u091c\u0942\u0928._\u091c\u0941\u0932\u0948._\u0911\u0917._\u0938\u092a\u094d\u091f\u0947\u0902._\u0911\u0915\u094d\u091f\u094b._\u0928\u094b\u0935\u094d\u0939\u0947\u0902._\u0921\u093f\u0938\u0947\u0902.".split("_"),monthsParseExact:!0,weekdays:"\u0930\u0935\u093f\u0935\u093e\u0930_\u0938\u094b\u092e\u0935\u093e\u0930_\u092e\u0902\u0917\u0933\u0935\u093e\u0930_\u092c\u0941\u0927\u0935\u093e\u0930_\u0917\u0941\u0930\u0942\u0935\u093e\u0930_\u0936\u0941\u0915\u094d\u0930\u0935\u093e\u0930_\u0936\u0928\u093f\u0935\u093e\u0930".split("_"),weekdaysShort:"\u0930\u0935\u093f_\u0938\u094b\u092e_\u092e\u0902\u0917\u0933_\u092c\u0941\u0927_\u0917\u0941\u0930\u0942_\u0936\u0941\u0915\u094d\u0930_\u0936\u0928\u093f".split("_"),weekdaysMin:"\u0930_\u0938\u094b_\u092e\u0902_\u092c\u0941_\u0917\u0941_\u0936\u0941_\u0936".split("_"),longDateFormat:{LT:"A h:mm \u0935\u093e\u091c\u0924\u093e",LTS:"A h:mm:ss \u0935\u093e\u091c\u0924\u093e",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u0935\u093e\u091c\u0924\u093e",LLLL:"dddd, D MMMM YYYY, A h:mm \u0935\u093e\u091c\u0924\u093e"},calendar:{sameDay:"[\u0906\u091c] LT",nextDay:"[\u0909\u0926\u094d\u092f\u093e] LT",nextWeek:"dddd, LT",lastDay:"[\u0915\u093e\u0932] LT",lastWeek:"[\u092e\u093e\u0917\u0940\u0932] dddd, LT",sameElse:"L"},relativeTime:{future:"%s\u092e\u0927\u094d\u092f\u0947",past:"%s\u092a\u0942\u0930\u094d\u0935\u0940",s:H,ss:H,m:H,mm:H,h:H,hh:H,d:H,dd:H,M:H,MM:H,y:H,yy:H},preparse:function(e){return e.replace(/[\u0967\u0968\u0969\u096a\u096b\u096c\u096d\u096e\u096f\u0966]/g,function(e){return Ie[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Je[e]})},meridiemParse:/\u092a\u0939\u093e\u091f\u0947|\u0938\u0915\u093e\u0933\u0940|\u0926\u0941\u092a\u093e\u0930\u0940|\u0938\u093e\u092f\u0902\u0915\u093e\u0933\u0940|\u0930\u093e\u0924\u094d\u0930\u0940/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u092a\u0939\u093e\u091f\u0947"===a||"\u0938\u0915\u093e\u0933\u0940"===a?e:"\u0926\u0941\u092a\u093e\u0930\u0940"===a||"\u0938\u093e\u092f\u0902\u0915\u093e\u0933\u0940"===a||"\u0930\u093e\u0924\u094d\u0930\u0940"===a?12<=e?e:e+12:void 0},meridiem:function(e,a,_){return 0<=e&&e<6?"\u092a\u0939\u093e\u091f\u0947":e<12?"\u0938\u0915\u093e\u0933\u0940":e<17?"\u0926\u0941\u092a\u093e\u0930\u0940":e<20?"\u0938\u093e\u092f\u0902\u0915\u093e\u0933\u0940":"\u0930\u093e\u0924\u094d\u0930\u0940"},week:{dow:0,doy:6}}),e.defineLocale("ms-my",{months:"Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),monthsShort:"Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),weekdays:"Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),weekdaysShort:"Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),weekdaysMin:"Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [pukul] HH.mm",LLLL:"dddd, D MMMM YYYY [pukul] HH.mm"},meridiemParse:/pagi|tengahari|petang|malam/,meridiemHour:function(e,a){return 12===e&&(e=0),"pagi"===a?e:"tengahari"===a?11<=e?e:e+12:"petang"===a||"malam"===a?e+12:void 0},meridiem:function(e,a,_){return e<11?"pagi":e<15?"tengahari":e<19?"petang":"malam"},calendar:{sameDay:"[Hari ini pukul] LT",nextDay:"[Esok pukul] LT",nextWeek:"dddd [pukul] LT",lastDay:"[Kelmarin pukul] LT",lastWeek:"dddd [lepas pukul] LT",sameElse:"L"},relativeTime:{future:"dalam %s",past:"%s yang lepas",s:"beberapa saat",ss:"%d saat",m:"seminit",mm:"%d minit",h:"sejam",hh:"%d jam",d:"sehari",dd:"%d hari",M:"sebulan",MM:"%d bulan",y:"setahun",yy:"%d tahun"},week:{dow:1,doy:7}}),e.defineLocale("ms",{months:"Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),monthsShort:"Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),weekdays:"Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),weekdaysShort:"Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),weekdaysMin:"Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [pukul] HH.mm",LLLL:"dddd, D MMMM YYYY [pukul] HH.mm"},meridiemParse:/pagi|tengahari|petang|malam/,meridiemHour:function(e,a){return 12===e&&(e=0),"pagi"===a?e:"tengahari"===a?11<=e?e:e+12:"petang"===a||"malam"===a?e+12:void 0},meridiem:function(e,a,_){return e<11?"pagi":e<15?"tengahari":e<19?"petang":"malam"},calendar:{sameDay:"[Hari ini pukul] LT",nextDay:"[Esok pukul] LT",nextWeek:"dddd [pukul] LT",lastDay:"[Kelmarin pukul] LT",lastWeek:"dddd [lepas pukul] LT",sameElse:"L"},relativeTime:{future:"dalam %s",past:"%s yang lepas",s:"beberapa saat",ss:"%d saat",m:"seminit",mm:"%d minit",h:"sejam",hh:"%d jam",d:"sehari",dd:"%d hari",M:"sebulan",MM:"%d bulan",y:"setahun",yy:"%d tahun"},week:{dow:1,doy:7}}),e.defineLocale("mt",{months:"Jannar_Frar_Marzu_April_Mejju_\u0120unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Di\u010bembru".split("_"),monthsShort:"Jan_Fra_Mar_Apr_Mej_\u0120un_Lul_Aww_Set_Ott_Nov_Di\u010b".split("_"),weekdays:"Il-\u0126add_It-Tnejn_It-Tlieta_L-Erbg\u0127a_Il-\u0126amis_Il-\u0120img\u0127a_Is-Sibt".split("_"),weekdaysShort:"\u0126ad_Tne_Tli_Erb_\u0126am_\u0120im_Sib".split("_"),weekdaysMin:"\u0126a_Tn_Tl_Er_\u0126a_\u0120i_Si".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Illum fil-]LT",nextDay:"[G\u0127ada fil-]LT",nextWeek:"dddd [fil-]LT",lastDay:"[Il-biera\u0127 fil-]LT",lastWeek:"dddd [li g\u0127adda] [fil-]LT",sameElse:"L"},relativeTime:{future:"f\u2019 %s",past:"%s ilu",s:"ftit sekondi",ss:"%d sekondi",m:"minuta",mm:"%d minuti",h:"sieg\u0127a",hh:"%d sieg\u0127at",d:"\u0121urnata",dd:"%d \u0121ranet",M:"xahar",MM:"%d xhur",y:"sena",yy:"%d sni"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}});var Ne={1:"\u1041",2:"\u1042",3:"\u1043",4:"\u1044",5:"\u1045",6:"\u1046",7:"\u1047",8:"\u1048",9:"\u1049",0:"\u1040"},Re={"\u1041":"1","\u1042":"2","\u1043":"3","\u1044":"4","\u1045":"5","\u1046":"6","\u1047":"7","\u1048":"8","\u1049":"9","\u1040":"0"},Ce=(e.defineLocale("my",{months:"\u1007\u1014\u103a\u1014\u101d\u102b\u101b\u102e_\u1016\u1031\u1016\u1031\u102c\u103a\u101d\u102b\u101b\u102e_\u1019\u1010\u103a_\u1027\u1015\u103c\u102e_\u1019\u1031_\u1007\u103d\u1014\u103a_\u1007\u1030\u101c\u102d\u102f\u1004\u103a_\u101e\u103c\u1002\u102f\u1010\u103a_\u1005\u1000\u103a\u1010\u1004\u103a\u1018\u102c_\u1021\u1031\u102c\u1000\u103a\u1010\u102d\u102f\u1018\u102c_\u1014\u102d\u102f\u101d\u1004\u103a\u1018\u102c_\u1012\u102e\u1007\u1004\u103a\u1018\u102c".split("_"),monthsShort:"\u1007\u1014\u103a_\u1016\u1031_\u1019\u1010\u103a_\u1015\u103c\u102e_\u1019\u1031_\u1007\u103d\u1014\u103a_\u101c\u102d\u102f\u1004\u103a_\u101e\u103c_\u1005\u1000\u103a_\u1021\u1031\u102c\u1000\u103a_\u1014\u102d\u102f_\u1012\u102e".split("_"),weekdays:"\u1010\u1014\u1004\u103a\u1039\u1002\u1014\u103d\u1031_\u1010\u1014\u1004\u103a\u1039\u101c\u102c_\u1021\u1004\u103a\u1039\u1002\u102b_\u1017\u102f\u1012\u1039\u1013\u101f\u1030\u1038_\u1000\u103c\u102c\u101e\u1015\u1010\u1031\u1038_\u101e\u1031\u102c\u1000\u103c\u102c_\u1005\u1014\u1031".split("_"),weekdaysShort:"\u1014\u103d\u1031_\u101c\u102c_\u1002\u102b_\u101f\u1030\u1038_\u1000\u103c\u102c_\u101e\u1031\u102c_\u1014\u1031".split("_"),weekdaysMin:"\u1014\u103d\u1031_\u101c\u102c_\u1002\u102b_\u101f\u1030\u1038_\u1000\u103c\u102c_\u101e\u1031\u102c_\u1014\u1031".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u101a\u1014\u1031.] LT [\u1019\u103e\u102c]",nextDay:"[\u1019\u1014\u1000\u103a\u1016\u103c\u1014\u103a] LT [\u1019\u103e\u102c]",nextWeek:"dddd LT [\u1019\u103e\u102c]",lastDay:"[\u1019\u1014\u1031.\u1000] LT [\u1019\u103e\u102c]",lastWeek:"[\u1015\u103c\u102e\u1038\u1001\u1032\u1037\u101e\u1031\u102c] dddd LT [\u1019\u103e\u102c]",sameElse:"L"},relativeTime:{future:"\u101c\u102c\u1019\u100a\u103a\u1037 %s \u1019\u103e\u102c",past:"\u101c\u103d\u1014\u103a\u1001\u1032\u1037\u101e\u1031\u102c %s \u1000",s:"\u1005\u1000\u1039\u1000\u1014\u103a.\u1021\u1014\u100a\u103a\u1038\u1004\u101a\u103a",ss:"%d \u1005\u1000\u1039\u1000\u1014\u1037\u103a",m:"\u1010\u1005\u103a\u1019\u102d\u1014\u1005\u103a",mm:"%d \u1019\u102d\u1014\u1005\u103a",h:"\u1010\u1005\u103a\u1014\u102c\u101b\u102e",hh:"%d \u1014\u102c\u101b\u102e",d:"\u1010\u1005\u103a\u101b\u1000\u103a",dd:"%d \u101b\u1000\u103a",M:"\u1010\u1005\u103a\u101c",MM:"%d \u101c",y:"\u1010\u1005\u103a\u1014\u103e\u1005\u103a",yy:"%d \u1014\u103e\u1005\u103a"},preparse:function(e){return e.replace(/[\u1041\u1042\u1043\u1044\u1045\u1046\u1047\u1048\u1049\u1040]/g,function(e){return Re[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Ne[e]})},week:{dow:1,doy:4}}),e.defineLocale("nb",{months:"januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),monthsShort:"jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),monthsParseExact:!0,weekdays:"s\xf8ndag_mandag_tirsdag_onsdag_torsdag_fredag_l\xf8rdag".split("_"),weekdaysShort:"s\xf8._ma._ti._on._to._fr._l\xf8.".split("_"),weekdaysMin:"s\xf8_ma_ti_on_to_fr_l\xf8".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY [kl.] HH:mm",LLLL:"dddd D. MMMM YYYY [kl.] HH:mm"},calendar:{sameDay:"[i dag kl.] LT",nextDay:"[i morgen kl.] LT",nextWeek:"dddd [kl.] LT",lastDay:"[i g\xe5r kl.] LT",lastWeek:"[forrige] dddd [kl.] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"%s siden",s:"noen sekunder",ss:"%d sekunder",m:"ett minutt",mm:"%d minutter",h:"en time",hh:"%d timer",d:"en dag",dd:"%d dager",w:"en uke",ww:"%d uker",M:"en m\xe5ned",MM:"%d m\xe5neder",y:"ett \xe5r",yy:"%d \xe5r"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),{1:"\u0967",2:"\u0968",3:"\u0969",4:"\u096a",5:"\u096b",6:"\u096c",7:"\u096d",8:"\u096e",9:"\u096f",0:"\u0966"}),Ke={"\u0967":"1","\u0968":"2","\u0969":"3","\u096a":"4","\u096b":"5","\u096c":"6","\u096d":"7","\u096e":"8","\u096f":"9","\u0966":"0"},Ge=(e.defineLocale("ne",{months:"\u091c\u0928\u0935\u0930\u0940_\u092b\u0947\u092c\u094d\u0930\u0941\u0935\u0930\u0940_\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u093f\u0932_\u092e\u0908_\u091c\u0941\u0928_\u091c\u0941\u0932\u093e\u0908_\u0905\u0917\u0937\u094d\u091f_\u0938\u0947\u092a\u094d\u091f\u0947\u092e\u094d\u092c\u0930_\u0905\u0915\u094d\u091f\u094b\u092c\u0930_\u0928\u094b\u092d\u0947\u092e\u094d\u092c\u0930_\u0921\u093f\u0938\u0947\u092e\u094d\u092c\u0930".split("_"),monthsShort:"\u091c\u0928._\u092b\u0947\u092c\u094d\u0930\u0941._\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u093f._\u092e\u0908_\u091c\u0941\u0928_\u091c\u0941\u0932\u093e\u0908._\u0905\u0917._\u0938\u0947\u092a\u094d\u091f._\u0905\u0915\u094d\u091f\u094b._\u0928\u094b\u092d\u0947._\u0921\u093f\u0938\u0947.".split("_"),monthsParseExact:!0,weekdays:"\u0906\u0907\u0924\u092c\u093e\u0930_\u0938\u094b\u092e\u092c\u093e\u0930_\u092e\u0919\u094d\u0917\u0932\u092c\u093e\u0930_\u092c\u0941\u0927\u092c\u093e\u0930_\u092c\u093f\u0939\u093f\u092c\u093e\u0930_\u0936\u0941\u0915\u094d\u0930\u092c\u093e\u0930_\u0936\u0928\u093f\u092c\u093e\u0930".split("_"),weekdaysShort:"\u0906\u0907\u0924._\u0938\u094b\u092e._\u092e\u0919\u094d\u0917\u0932._\u092c\u0941\u0927._\u092c\u093f\u0939\u093f._\u0936\u0941\u0915\u094d\u0930._\u0936\u0928\u093f.".split("_"),weekdaysMin:"\u0906._\u0938\u094b._\u092e\u0902._\u092c\u0941._\u092c\u093f._\u0936\u0941._\u0936.".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"A\u0915\u094b h:mm \u092c\u091c\u0947",LTS:"A\u0915\u094b h:mm:ss \u092c\u091c\u0947",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A\u0915\u094b h:mm \u092c\u091c\u0947",LLLL:"dddd, D MMMM YYYY, A\u0915\u094b h:mm \u092c\u091c\u0947"},preparse:function(e){return e.replace(/[\u0967\u0968\u0969\u096a\u096b\u096c\u096d\u096e\u096f\u0966]/g,function(e){return Ke[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Ce[e]})},meridiemParse:/\u0930\u093e\u0924\u093f|\u092c\u093f\u0939\u093e\u0928|\u0926\u093f\u0909\u0901\u0938\u094b|\u0938\u093e\u0901\u091d/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0930\u093e\u0924\u093f"===a?e<4?e:e+12:"\u092c\u093f\u0939\u093e\u0928"===a?e:"\u0926\u093f\u0909\u0901\u0938\u094b"===a?10<=e?e:e+12:"\u0938\u093e\u0901\u091d"===a?e+12:void 0},meridiem:function(e,a,_){return e<3?"\u0930\u093e\u0924\u093f":e<12?"\u092c\u093f\u0939\u093e\u0928":e<16?"\u0926\u093f\u0909\u0901\u0938\u094b":e<20?"\u0938\u093e\u0901\u091d":"\u0930\u093e\u0924\u093f"},calendar:{sameDay:"[\u0906\u091c] LT",nextDay:"[\u092d\u094b\u0932\u093f] LT",nextWeek:"[\u0906\u0909\u0901\u0926\u094b] dddd[,] LT",lastDay:"[\u0939\u093f\u091c\u094b] LT",lastWeek:"[\u0917\u090f\u0915\u094b] dddd[,] LT",sameElse:"L"},relativeTime:{future:"%s\u092e\u093e",past:"%s \u0905\u0917\u093e\u0921\u093f",s:"\u0915\u0947\u0939\u0940 \u0915\u094d\u0937\u0923",ss:"%d \u0938\u0947\u0915\u0947\u0923\u094d\u0921",m:"\u090f\u0915 \u092e\u093f\u0928\u0947\u091f",mm:"%d \u092e\u093f\u0928\u0947\u091f",h:"\u090f\u0915 \u0918\u0923\u094d\u091f\u093e",hh:"%d \u0918\u0923\u094d\u091f\u093e",d:"\u090f\u0915 \u0926\u093f\u0928",dd:"%d \u0926\u093f\u0928",M:"\u090f\u0915 \u092e\u0939\u093f\u0928\u093e",MM:"%d \u092e\u0939\u093f\u0928\u093e",y:"\u090f\u0915 \u092c\u0930\u094d\u0937",yy:"%d \u092c\u0930\u094d\u0937"},week:{dow:0,doy:6}}),"jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_")),Be="jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),m=[/^jan/i,/^feb/i,/^maart|mrt.?$/i,/^apr/i,/^mei$/i,/^jun[i.]?$/i,/^jul[i.]?$/i,/^aug/i,/^sep/i,/^okt/i,/^nov/i,/^dec/i],d=/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,qe=(e.defineLocale("nl-be",{months:"januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),monthsShort:function(e,a){return e?(/-MMM-/.test(a)?Be:Ge)[e.month()]:Ge},monthsRegex:d,monthsShortRegex:d,monthsStrictRegex:/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,monthsShortStrictRegex:/^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,monthsParse:m,longMonthsParse:m,shortMonthsParse:m,weekdays:"zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),weekdaysShort:"zo._ma._di._wo._do._vr._za.".split("_"),weekdaysMin:"zo_ma_di_wo_do_vr_za".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[vandaag om] LT",nextDay:"[morgen om] LT",nextWeek:"dddd [om] LT",lastDay:"[gisteren om] LT",lastWeek:"[afgelopen] dddd [om] LT",sameElse:"L"},relativeTime:{future:"over %s",past:"%s geleden",s:"een paar seconden",ss:"%d seconden",m:"\xe9\xe9n minuut",mm:"%d minuten",h:"\xe9\xe9n uur",hh:"%d uur",d:"\xe9\xe9n dag",dd:"%d dagen",M:"\xe9\xe9n maand",MM:"%d maanden",y:"\xe9\xe9n jaar",yy:"%d jaar"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||20<=e?"ste":"de")},week:{dow:1,doy:4}}),"jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_")),Ue="jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),r=[/^jan/i,/^feb/i,/^maart|mrt.?$/i,/^apr/i,/^mei$/i,/^jun[i.]?$/i,/^jul[i.]?$/i,/^aug/i,/^sep/i,/^okt/i,/^nov/i,/^dec/i],n=/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,$e=(e.defineLocale("nl",{months:"januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),monthsShort:function(e,a){return e?(/-MMM-/.test(a)?Ue:qe)[e.month()]:qe},monthsRegex:n,monthsShortRegex:n,monthsStrictRegex:/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,monthsShortStrictRegex:/^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,monthsParse:r,longMonthsParse:r,shortMonthsParse:r,weekdays:"zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),weekdaysShort:"zo._ma._di._wo._do._vr._za.".split("_"),weekdaysMin:"zo_ma_di_wo_do_vr_za".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[vandaag om] LT",nextDay:"[morgen om] LT",nextWeek:"dddd [om] LT",lastDay:"[gisteren om] LT",lastWeek:"[afgelopen] dddd [om] LT",sameElse:"L"},relativeTime:{future:"over %s",past:"%s geleden",s:"een paar seconden",ss:"%d seconden",m:"\xe9\xe9n minuut",mm:"%d minuten",h:"\xe9\xe9n uur",hh:"%d uur",d:"\xe9\xe9n dag",dd:"%d dagen",w:"\xe9\xe9n week",ww:"%d weken",M:"\xe9\xe9n maand",MM:"%d maanden",y:"\xe9\xe9n jaar",yy:"%d jaar"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||20<=e?"ste":"de")},week:{dow:1,doy:4}}),e.defineLocale("nn",{months:"januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),monthsShort:"jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),monthsParseExact:!0,weekdays:"sundag_m\xe5ndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),weekdaysShort:"su._m\xe5._ty._on._to._fr._lau.".split("_"),weekdaysMin:"su_m\xe5_ty_on_to_fr_la".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY [kl.] H:mm",LLLL:"dddd D. MMMM YYYY [kl.] HH:mm"},calendar:{sameDay:"[I dag klokka] LT",nextDay:"[I morgon klokka] LT",nextWeek:"dddd [klokka] LT",lastDay:"[I g\xe5r klokka] LT",lastWeek:"[F\xf8reg\xe5ande] dddd [klokka] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"%s sidan",s:"nokre sekund",ss:"%d sekund",m:"eit minutt",mm:"%d minutt",h:"ein time",hh:"%d timar",d:"ein dag",dd:"%d dagar",w:"ei veke",ww:"%d veker",M:"ein m\xe5nad",MM:"%d m\xe5nader",y:"eit \xe5r",yy:"%d \xe5r"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("oc-lnc",{months:{standalone:"geni\xe8r_febri\xe8r_mar\xe7_abril_mai_junh_julhet_agost_setembre_oct\xf2bre_novembre_decembre".split("_"),format:"de geni\xe8r_de febri\xe8r_de mar\xe7_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'oct\xf2bre_de novembre_de decembre".split("_"),isFormat:/D[oD]?(\s)+MMMM/},monthsShort:"gen._febr._mar\xe7_abr._mai_junh_julh._ago._set._oct._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"dimenge_diluns_dimars_dim\xe8cres_dij\xf2us_divendres_dissabte".split("_"),weekdaysShort:"dg._dl._dm._dc._dj._dv._ds.".split("_"),weekdaysMin:"dg_dl_dm_dc_dj_dv_ds".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM [de] YYYY",ll:"D MMM YYYY",LLL:"D MMMM [de] YYYY [a] H:mm",lll:"D MMM YYYY, H:mm",LLLL:"dddd D MMMM [de] YYYY [a] H:mm",llll:"ddd D MMM YYYY, H:mm"},calendar:{sameDay:"[u\xe8i a] LT",nextDay:"[deman a] LT",nextWeek:"dddd [a] LT",lastDay:"[i\xe8r a] LT",lastWeek:"dddd [passat a] LT",sameElse:"L"},relativeTime:{future:"d'aqu\xed %s",past:"fa %s",s:"unas segondas",ss:"%d segondas",m:"una minuta",mm:"%d minutas",h:"una ora",hh:"%d oras",d:"un jorn",dd:"%d jorns",M:"un mes",MM:"%d meses",y:"un an",yy:"%d ans"},dayOfMonthOrdinalParse:/\d{1,2}(r|n|t|\xe8|a)/,ordinal:function(e,a){return e+("w"!==a&&"W"!==a?1===e?"r":2===e?"n":3===e?"r":4===e?"t":"\xe8":"a")},week:{dow:1,doy:4}}),{1:"\u0a67",2:"\u0a68",3:"\u0a69",4:"\u0a6a",5:"\u0a6b",6:"\u0a6c",7:"\u0a6d",8:"\u0a6e",9:"\u0a6f",0:"\u0a66"}),Qe={"\u0a67":"1","\u0a68":"2","\u0a69":"3","\u0a6a":"4","\u0a6b":"5","\u0a6c":"6","\u0a6d":"7","\u0a6e":"8","\u0a6f":"9","\u0a66":"0"},Ve=(e.defineLocale("pa-in",{months:"\u0a1c\u0a28\u0a35\u0a30\u0a40_\u0a2b\u0a3c\u0a30\u0a35\u0a30\u0a40_\u0a2e\u0a3e\u0a30\u0a1a_\u0a05\u0a2a\u0a4d\u0a30\u0a48\u0a32_\u0a2e\u0a08_\u0a1c\u0a42\u0a28_\u0a1c\u0a41\u0a32\u0a3e\u0a08_\u0a05\u0a17\u0a38\u0a24_\u0a38\u0a24\u0a70\u0a2c\u0a30_\u0a05\u0a15\u0a24\u0a42\u0a2c\u0a30_\u0a28\u0a35\u0a70\u0a2c\u0a30_\u0a26\u0a38\u0a70\u0a2c\u0a30".split("_"),monthsShort:"\u0a1c\u0a28\u0a35\u0a30\u0a40_\u0a2b\u0a3c\u0a30\u0a35\u0a30\u0a40_\u0a2e\u0a3e\u0a30\u0a1a_\u0a05\u0a2a\u0a4d\u0a30\u0a48\u0a32_\u0a2e\u0a08_\u0a1c\u0a42\u0a28_\u0a1c\u0a41\u0a32\u0a3e\u0a08_\u0a05\u0a17\u0a38\u0a24_\u0a38\u0a24\u0a70\u0a2c\u0a30_\u0a05\u0a15\u0a24\u0a42\u0a2c\u0a30_\u0a28\u0a35\u0a70\u0a2c\u0a30_\u0a26\u0a38\u0a70\u0a2c\u0a30".split("_"),weekdays:"\u0a10\u0a24\u0a35\u0a3e\u0a30_\u0a38\u0a4b\u0a2e\u0a35\u0a3e\u0a30_\u0a2e\u0a70\u0a17\u0a32\u0a35\u0a3e\u0a30_\u0a2c\u0a41\u0a27\u0a35\u0a3e\u0a30_\u0a35\u0a40\u0a30\u0a35\u0a3e\u0a30_\u0a38\u0a3c\u0a41\u0a71\u0a15\u0a30\u0a35\u0a3e\u0a30_\u0a38\u0a3c\u0a28\u0a40\u0a1a\u0a30\u0a35\u0a3e\u0a30".split("_"),weekdaysShort:"\u0a10\u0a24_\u0a38\u0a4b\u0a2e_\u0a2e\u0a70\u0a17\u0a32_\u0a2c\u0a41\u0a27_\u0a35\u0a40\u0a30_\u0a38\u0a3c\u0a41\u0a15\u0a30_\u0a38\u0a3c\u0a28\u0a40".split("_"),weekdaysMin:"\u0a10\u0a24_\u0a38\u0a4b\u0a2e_\u0a2e\u0a70\u0a17\u0a32_\u0a2c\u0a41\u0a27_\u0a35\u0a40\u0a30_\u0a38\u0a3c\u0a41\u0a15\u0a30_\u0a38\u0a3c\u0a28\u0a40".split("_"),longDateFormat:{LT:"A h:mm \u0a35\u0a1c\u0a47",LTS:"A h:mm:ss \u0a35\u0a1c\u0a47",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u0a35\u0a1c\u0a47",LLLL:"dddd, D MMMM YYYY, A h:mm \u0a35\u0a1c\u0a47"},calendar:{sameDay:"[\u0a05\u0a1c] LT",nextDay:"[\u0a15\u0a32] LT",nextWeek:"[\u0a05\u0a17\u0a32\u0a3e] dddd, LT",lastDay:"[\u0a15\u0a32] LT",lastWeek:"[\u0a2a\u0a3f\u0a1b\u0a32\u0a47] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0a35\u0a3f\u0a71\u0a1a",past:"%s \u0a2a\u0a3f\u0a1b\u0a32\u0a47",s:"\u0a15\u0a41\u0a1d \u0a38\u0a15\u0a3f\u0a70\u0a1f",ss:"%d \u0a38\u0a15\u0a3f\u0a70\u0a1f",m:"\u0a07\u0a15 \u0a2e\u0a3f\u0a70\u0a1f",mm:"%d \u0a2e\u0a3f\u0a70\u0a1f",h:"\u0a07\u0a71\u0a15 \u0a18\u0a70\u0a1f\u0a3e",hh:"%d \u0a18\u0a70\u0a1f\u0a47",d:"\u0a07\u0a71\u0a15 \u0a26\u0a3f\u0a28",dd:"%d \u0a26\u0a3f\u0a28",M:"\u0a07\u0a71\u0a15 \u0a2e\u0a39\u0a40\u0a28\u0a3e",MM:"%d \u0a2e\u0a39\u0a40\u0a28\u0a47",y:"\u0a07\u0a71\u0a15 \u0a38\u0a3e\u0a32",yy:"%d \u0a38\u0a3e\u0a32"},preparse:function(e){return e.replace(/[\u0a67\u0a68\u0a69\u0a6a\u0a6b\u0a6c\u0a6d\u0a6e\u0a6f\u0a66]/g,function(e){return Qe[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return $e[e]})},meridiemParse:/\u0a30\u0a3e\u0a24|\u0a38\u0a35\u0a47\u0a30|\u0a26\u0a41\u0a2a\u0a39\u0a3f\u0a30|\u0a38\u0a3c\u0a3e\u0a2e/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0a30\u0a3e\u0a24"===a?e<4?e:e+12:"\u0a38\u0a35\u0a47\u0a30"===a?e:"\u0a26\u0a41\u0a2a\u0a39\u0a3f\u0a30"===a?10<=e?e:e+12:"\u0a38\u0a3c\u0a3e\u0a2e"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0a30\u0a3e\u0a24":e<10?"\u0a38\u0a35\u0a47\u0a30":e<17?"\u0a26\u0a41\u0a2a\u0a39\u0a3f\u0a30":e<20?"\u0a38\u0a3c\u0a3e\u0a2e":"\u0a30\u0a3e\u0a24"},week:{dow:0,doy:6}}),"stycze\u0144_luty_marzec_kwiecie\u0144_maj_czerwiec_lipiec_sierpie\u0144_wrzesie\u0144_pa\u017adziernik_listopad_grudzie\u0144".split("_")),Ze="stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrze\u015bnia_pa\u017adziernika_listopada_grudnia".split("_"),d=[/^sty/i,/^lut/i,/^mar/i,/^kwi/i,/^maj/i,/^cze/i,/^lip/i,/^sie/i,/^wrz/i,/^pa\u017a/i,/^lis/i,/^gru/i];function Xe(e){return e%10<5&&1<e%10&&~~(e/10)%10!=1}function b(e,a,_){var s=e+" ";switch(_){case"ss":return s+(Xe(e)?"sekundy":"sekund");case"m":return a?"minuta":"minut\u0119";case"mm":return s+(Xe(e)?"minuty":"minut");case"h":return a?"godzina":"godzin\u0119";case"hh":return s+(Xe(e)?"godziny":"godzin");case"ww":return s+(Xe(e)?"tygodnie":"tygodni");case"MM":return s+(Xe(e)?"miesi\u0105ce":"miesi\u0119cy");case"yy":return s+(Xe(e)?"lata":"lat")}}function S(e,a,_){return e+(20<=e%100||100<=e&&e%100==0?" de ":" ")+{ss:"secunde",mm:"minute",hh:"ore",dd:"zile",ww:"s\u0103pt\u0103m\xe2ni",MM:"luni",yy:"ani"}[_]}function v(e,a,_){return "m"===_?a?"\u043c\u0438\u043d\u0443\u0442\u0430":"\u043c\u0438\u043d\u0443\u0442\u0443":e+" "+(e=+e,a=(a={ss:a?"\u0441\u0435\u043a\u0443\u043d\u0434\u0430_\u0441\u0435\u043a\u0443\u043d\u0434\u044b_\u0441\u0435\u043a\u0443\u043d\u0434":"\u0441\u0435\u043a\u0443\u043d\u0434\u0443_\u0441\u0435\u043a\u0443\u043d\u0434\u044b_\u0441\u0435\u043a\u0443\u043d\u0434",mm:a?"\u043c\u0438\u043d\u0443\u0442\u0430_\u043c\u0438\u043d\u0443\u0442\u044b_\u043c\u0438\u043d\u0443\u0442":"\u043c\u0438\u043d\u0443\u0442\u0443_\u043c\u0438\u043d\u0443\u0442\u044b_\u043c\u0438\u043d\u0443\u0442",hh:"\u0447\u0430\u0441_\u0447\u0430\u0441\u0430_\u0447\u0430\u0441\u043e\u0432",dd:"\u0434\u0435\u043d\u044c_\u0434\u043d\u044f_\u0434\u043d\u0435\u0439",ww:"\u043d\u0435\u0434\u0435\u043b\u044f_\u043d\u0435\u0434\u0435\u043b\u0438_\u043d\u0435\u0434\u0435\u043b\u044c",MM:"\u043c\u0435\u0441\u044f\u0446_\u043c\u0435\u0441\u044f\u0446\u0430_\u043c\u0435\u0441\u044f\u0446\u0435\u0432",yy:"\u0433\u043e\u0434_\u0433\u043e\u0434\u0430_\u043b\u0435\u0442"}[_]).split("_"),e%10==1&&e%100!=11?a[0]:2<=e%10&&e%10<=4&&(e%100<10||20<=e%100)?a[1]:a[2])}e.defineLocale("pl",{months:function(e,a){return e?(/D MMMM/.test(a)?Ze:Ve)[e.month()]:Ve},monthsShort:"sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa\u017a_lis_gru".split("_"),monthsParse:d,longMonthsParse:d,shortMonthsParse:d,weekdays:"niedziela_poniedzia\u0142ek_wtorek_\u015broda_czwartek_pi\u0105tek_sobota".split("_"),weekdaysShort:"ndz_pon_wt_\u015br_czw_pt_sob".split("_"),weekdaysMin:"Nd_Pn_Wt_\u015ar_Cz_Pt_So".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Dzi\u015b o] LT",nextDay:"[Jutro o] LT",nextWeek:function(){switch(this.day()){case 0:return "[W niedziel\u0119 o] LT";case 2:return "[We wtorek o] LT";case 3:return "[W \u015brod\u0119 o] LT";case 6:return "[W sobot\u0119 o] LT";default:return "[W] dddd [o] LT"}},lastDay:"[Wczoraj o] LT",lastWeek:function(){switch(this.day()){case 0:return "[W zesz\u0142\u0105 niedziel\u0119 o] LT";case 3:return "[W zesz\u0142\u0105 \u015brod\u0119 o] LT";case 6:return "[W zesz\u0142\u0105 sobot\u0119 o] LT";default:return "[W zesz\u0142y] dddd [o] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"%s temu",s:"kilka sekund",ss:b,m:b,mm:b,h:b,hh:b,d:"1 dzie\u0144",dd:"%d dni",w:"tydzie\u0144",ww:b,M:"miesi\u0105c",MM:b,y:"rok",yy:b},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("pt-br",{months:"janeiro_fevereiro_mar\xe7o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),monthsShort:"jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),weekdays:"domingo_segunda-feira_ter\xe7a-feira_quarta-feira_quinta-feira_sexta-feira_s\xe1bado".split("_"),weekdaysShort:"dom_seg_ter_qua_qui_sex_s\xe1b".split("_"),weekdaysMin:"do_2\xaa_3\xaa_4\xaa_5\xaa_6\xaa_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY [\xe0s] HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY [\xe0s] HH:mm"},calendar:{sameDay:"[Hoje \xe0s] LT",nextDay:"[Amanh\xe3 \xe0s] LT",nextWeek:"dddd [\xe0s] LT",lastDay:"[Ontem \xe0s] LT",lastWeek:function(){return 0===this.day()||6===this.day()?"[\xdaltimo] dddd [\xe0s] LT":"[\xdaltima] dddd [\xe0s] LT"},sameElse:"L"},relativeTime:{future:"em %s",past:"h\xe1 %s",s:"poucos segundos",ss:"%d segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um m\xeas",MM:"%d meses",y:"um ano",yy:"%d anos"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",invalidDate:"Data inv\xe1lida"}),e.defineLocale("pt",{months:"janeiro_fevereiro_mar\xe7o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),monthsShort:"jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),weekdays:"Domingo_Segunda-feira_Ter\xe7a-feira_Quarta-feira_Quinta-feira_Sexta-feira_S\xe1bado".split("_"),weekdaysShort:"Dom_Seg_Ter_Qua_Qui_Sex_S\xe1b".split("_"),weekdaysMin:"Do_2\xaa_3\xaa_4\xaa_5\xaa_6\xaa_S\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY HH:mm"},calendar:{sameDay:"[Hoje \xe0s] LT",nextDay:"[Amanh\xe3 \xe0s] LT",nextWeek:"dddd [\xe0s] LT",lastDay:"[Ontem \xe0s] LT",lastWeek:function(){return 0===this.day()||6===this.day()?"[\xdaltimo] dddd [\xe0s] LT":"[\xdaltima] dddd [\xe0s] LT"},sameElse:"L"},relativeTime:{future:"em %s",past:"h\xe1 %s",s:"segundos",ss:"%d segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",w:"uma semana",ww:"%d semanas",M:"um m\xeas",MM:"%d meses",y:"um ano",yy:"%d anos"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),e.defineLocale("ro",{months:"ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),monthsShort:"ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"duminic\u0103_luni_mar\u021bi_miercuri_joi_vineri_s\xe2mb\u0103t\u0103".split("_"),weekdaysShort:"Dum_Lun_Mar_Mie_Joi_Vin_S\xe2m".split("_"),weekdaysMin:"Du_Lu_Ma_Mi_Jo_Vi_S\xe2".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY H:mm",LLLL:"dddd, D MMMM YYYY H:mm"},calendar:{sameDay:"[azi la] LT",nextDay:"[m\xe2ine la] LT",nextWeek:"dddd [la] LT",lastDay:"[ieri la] LT",lastWeek:"[fosta] dddd [la] LT",sameElse:"L"},relativeTime:{future:"peste %s",past:"%s \xeen urm\u0103",s:"c\xe2teva secunde",ss:S,m:"un minut",mm:S,h:"o or\u0103",hh:S,d:"o zi",dd:S,w:"o s\u0103pt\u0103m\xe2n\u0103",ww:S,M:"o lun\u0103",MM:S,y:"un an",yy:S},week:{dow:1,doy:7}});m=[/^\u044f\u043d\u0432/i,/^\u0444\u0435\u0432/i,/^\u043c\u0430\u0440/i,/^\u0430\u043f\u0440/i,/^\u043c\u0430[\u0439\u044f]/i,/^\u0438\u044e\u043d/i,/^\u0438\u044e\u043b/i,/^\u0430\u0432\u0433/i,/^\u0441\u0435\u043d/i,/^\u043e\u043a\u0442/i,/^\u043d\u043e\u044f/i,/^\u0434\u0435\u043a/i],e.defineLocale("ru",{months:{format:"\u044f\u043d\u0432\u0430\u0440\u044f_\u0444\u0435\u0432\u0440\u0430\u043b\u044f_\u043c\u0430\u0440\u0442\u0430_\u0430\u043f\u0440\u0435\u043b\u044f_\u043c\u0430\u044f_\u0438\u044e\u043d\u044f_\u0438\u044e\u043b\u044f_\u0430\u0432\u0433\u0443\u0441\u0442\u0430_\u0441\u0435\u043d\u0442\u044f\u0431\u0440\u044f_\u043e\u043a\u0442\u044f\u0431\u0440\u044f_\u043d\u043e\u044f\u0431\u0440\u044f_\u0434\u0435\u043a\u0430\u0431\u0440\u044f".split("_"),standalone:"\u044f\u043d\u0432\u0430\u0440\u044c_\u0444\u0435\u0432\u0440\u0430\u043b\u044c_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0435\u043b\u044c_\u043c\u0430\u0439_\u0438\u044e\u043d\u044c_\u0438\u044e\u043b\u044c_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043d\u0442\u044f\u0431\u0440\u044c_\u043e\u043a\u0442\u044f\u0431\u0440\u044c_\u043d\u043e\u044f\u0431\u0440\u044c_\u0434\u0435\u043a\u0430\u0431\u0440\u044c".split("_")},monthsShort:{format:"\u044f\u043d\u0432._\u0444\u0435\u0432\u0440._\u043c\u0430\u0440._\u0430\u043f\u0440._\u043c\u0430\u044f_\u0438\u044e\u043d\u044f_\u0438\u044e\u043b\u044f_\u0430\u0432\u0433._\u0441\u0435\u043d\u0442._\u043e\u043a\u0442._\u043d\u043e\u044f\u0431._\u0434\u0435\u043a.".split("_"),standalone:"\u044f\u043d\u0432._\u0444\u0435\u0432\u0440._\u043c\u0430\u0440\u0442_\u0430\u043f\u0440._\u043c\u0430\u0439_\u0438\u044e\u043d\u044c_\u0438\u044e\u043b\u044c_\u0430\u0432\u0433._\u0441\u0435\u043d\u0442._\u043e\u043a\u0442._\u043d\u043e\u044f\u0431._\u0434\u0435\u043a.".split("_")},weekdays:{standalone:"\u0432\u043e\u0441\u043a\u0440\u0435\u0441\u0435\u043d\u044c\u0435_\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a_\u0432\u0442\u043e\u0440\u043d\u0438\u043a_\u0441\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0435\u0440\u0433_\u043f\u044f\u0442\u043d\u0438\u0446\u0430_\u0441\u0443\u0431\u0431\u043e\u0442\u0430".split("_"),format:"\u0432\u043e\u0441\u043a\u0440\u0435\u0441\u0435\u043d\u044c\u0435_\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a_\u0432\u0442\u043e\u0440\u043d\u0438\u043a_\u0441\u0440\u0435\u0434\u0443_\u0447\u0435\u0442\u0432\u0435\u0440\u0433_\u043f\u044f\u0442\u043d\u0438\u0446\u0443_\u0441\u0443\u0431\u0431\u043e\u0442\u0443".split("_"),isFormat:/\[ ?[\u0412\u0432] ?(?:\u043f\u0440\u043e\u0448\u043b\u0443\u044e|\u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0443\u044e|\u044d\u0442\u0443)? ?] ?dddd/},weekdaysShort:"\u0432\u0441_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),weekdaysMin:"\u0432\u0441_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),monthsParse:m,longMonthsParse:m,shortMonthsParse:m,monthsRegex:/^(\u044f\u043d\u0432\u0430\u0440[\u044c\u044f]|\u044f\u043d\u0432\.?|\u0444\u0435\u0432\u0440\u0430\u043b[\u044c\u044f]|\u0444\u0435\u0432\u0440?\.?|\u043c\u0430\u0440\u0442\u0430?|\u043c\u0430\u0440\.?|\u0430\u043f\u0440\u0435\u043b[\u044c\u044f]|\u0430\u043f\u0440\.?|\u043c\u0430[\u0439\u044f]|\u0438\u044e\u043d[\u044c\u044f]|\u0438\u044e\u043d\.?|\u0438\u044e\u043b[\u044c\u044f]|\u0438\u044e\u043b\.?|\u0430\u0432\u0433\u0443\u0441\u0442\u0430?|\u0430\u0432\u0433\.?|\u0441\u0435\u043d\u0442\u044f\u0431\u0440[\u044c\u044f]|\u0441\u0435\u043d\u0442?\.?|\u043e\u043a\u0442\u044f\u0431\u0440[\u044c\u044f]|\u043e\u043a\u0442\.?|\u043d\u043e\u044f\u0431\u0440[\u044c\u044f]|\u043d\u043e\u044f\u0431?\.?|\u0434\u0435\u043a\u0430\u0431\u0440[\u044c\u044f]|\u0434\u0435\u043a\.?)/i,monthsShortRegex:/^(\u044f\u043d\u0432\u0430\u0440[\u044c\u044f]|\u044f\u043d\u0432\.?|\u0444\u0435\u0432\u0440\u0430\u043b[\u044c\u044f]|\u0444\u0435\u0432\u0440?\.?|\u043c\u0430\u0440\u0442\u0430?|\u043c\u0430\u0440\.?|\u0430\u043f\u0440\u0435\u043b[\u044c\u044f]|\u0430\u043f\u0440\.?|\u043c\u0430[\u0439\u044f]|\u0438\u044e\u043d[\u044c\u044f]|\u0438\u044e\u043d\.?|\u0438\u044e\u043b[\u044c\u044f]|\u0438\u044e\u043b\.?|\u0430\u0432\u0433\u0443\u0441\u0442\u0430?|\u0430\u0432\u0433\.?|\u0441\u0435\u043d\u0442\u044f\u0431\u0440[\u044c\u044f]|\u0441\u0435\u043d\u0442?\.?|\u043e\u043a\u0442\u044f\u0431\u0440[\u044c\u044f]|\u043e\u043a\u0442\.?|\u043d\u043e\u044f\u0431\u0440[\u044c\u044f]|\u043d\u043e\u044f\u0431?\.?|\u0434\u0435\u043a\u0430\u0431\u0440[\u044c\u044f]|\u0434\u0435\u043a\.?)/i,monthsStrictRegex:/^(\u044f\u043d\u0432\u0430\u0440[\u044f\u044c]|\u0444\u0435\u0432\u0440\u0430\u043b[\u044f\u044c]|\u043c\u0430\u0440\u0442\u0430?|\u0430\u043f\u0440\u0435\u043b[\u044f\u044c]|\u043c\u0430[\u044f\u0439]|\u0438\u044e\u043d[\u044f\u044c]|\u0438\u044e\u043b[\u044f\u044c]|\u0430\u0432\u0433\u0443\u0441\u0442\u0430?|\u0441\u0435\u043d\u0442\u044f\u0431\u0440[\u044f\u044c]|\u043e\u043a\u0442\u044f\u0431\u0440[\u044f\u044c]|\u043d\u043e\u044f\u0431\u0440[\u044f\u044c]|\u0434\u0435\u043a\u0430\u0431\u0440[\u044f\u044c])/i,monthsShortStrictRegex:/^(\u044f\u043d\u0432\.|\u0444\u0435\u0432\u0440?\.|\u043c\u0430\u0440[\u0442.]|\u0430\u043f\u0440\.|\u043c\u0430[\u044f\u0439]|\u0438\u044e\u043d[\u044c\u044f.]|\u0438\u044e\u043b[\u044c\u044f.]|\u0430\u0432\u0433\.|\u0441\u0435\u043d\u0442?\.|\u043e\u043a\u0442\.|\u043d\u043e\u044f\u0431?\.|\u0434\u0435\u043a\.)/i,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY \u0433.",LLL:"D MMMM YYYY \u0433., H:mm",LLLL:"dddd, D MMMM YYYY \u0433., H:mm"},calendar:{sameDay:"[\u0421\u0435\u0433\u043e\u0434\u043d\u044f, \u0432] LT",nextDay:"[\u0417\u0430\u0432\u0442\u0440\u0430, \u0432] LT",lastDay:"[\u0412\u0447\u0435\u0440\u0430, \u0432] LT",nextWeek:function(e){if(e.week()===this.week())return 2===this.day()?"[\u0412\u043e] dddd, [\u0432] LT":"[\u0412] dddd, [\u0432] LT";switch(this.day()){case 0:return "[\u0412 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0435] dddd, [\u0432] LT";case 1:case 2:case 4:return "[\u0412 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439] dddd, [\u0432] LT";case 3:case 5:case 6:return "[\u0412 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0443\u044e] dddd, [\u0432] LT"}},lastWeek:function(e){if(e.week()===this.week())return 2===this.day()?"[\u0412\u043e] dddd, [\u0432] LT":"[\u0412] dddd, [\u0432] LT";switch(this.day()){case 0:return "[\u0412 \u043f\u0440\u043e\u0448\u043b\u043e\u0435] dddd, [\u0432] LT";case 1:case 2:case 4:return "[\u0412 \u043f\u0440\u043e\u0448\u043b\u044b\u0439] dddd, [\u0432] LT";case 3:case 5:case 6:return "[\u0412 \u043f\u0440\u043e\u0448\u043b\u0443\u044e] dddd, [\u0432] LT"}},sameElse:"L"},relativeTime:{future:"\u0447\u0435\u0440\u0435\u0437 %s",past:"%s \u043d\u0430\u0437\u0430\u0434",s:"\u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0441\u0435\u043a\u0443\u043d\u0434",ss:v,m:v,mm:v,h:"\u0447\u0430\u0441",hh:v,d:"\u0434\u0435\u043d\u044c",dd:v,w:"\u043d\u0435\u0434\u0435\u043b\u044f",ww:v,M:"\u043c\u0435\u0441\u044f\u0446",MM:v,y:"\u0433\u043e\u0434",yy:v},meridiemParse:/\u043d\u043e\u0447\u0438|\u0443\u0442\u0440\u0430|\u0434\u043d\u044f|\u0432\u0435\u0447\u0435\u0440\u0430/i,isPM:function(e){return /^(\u0434\u043d\u044f|\u0432\u0435\u0447\u0435\u0440\u0430)$/.test(e)},meridiem:function(e,a,_){return e<4?"\u043d\u043e\u0447\u0438":e<12?"\u0443\u0442\u0440\u0430":e<17?"\u0434\u043d\u044f":"\u0432\u0435\u0447\u0435\u0440\u0430"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0439|\u0433\u043e|\u044f)/,ordinal:function(e,a){switch(a){case"M":case"d":case"DDD":return e+"-\u0439";case"D":return e+"-\u0433\u043e";case"w":case"W":return e+"-\u044f";default:return e}},week:{dow:1,doy:4}}),n=["\u062c\u0646\u0648\u0631\u064a","\u0641\u064a\u0628\u0631\u0648\u0631\u064a","\u0645\u0627\u0631\u0686","\u0627\u067e\u0631\u064a\u0644","\u0645\u0626\u064a","\u062c\u0648\u0646","\u062c\u0648\u0644\u0627\u0621\u0650","\u0622\u06af\u0633\u067d","\u0633\u064a\u067e\u067d\u0645\u0628\u0631","\u0622\u06aa\u067d\u0648\u0628\u0631","\u0646\u0648\u0645\u0628\u0631","\u068a\u0633\u0645\u0628\u0631"],r=["\u0622\u0686\u0631","\u0633\u0648\u0645\u0631","\u0627\u06b1\u0627\u0631\u0648","\u0627\u0631\u0628\u0639","\u062e\u0645\u064a\u0633","\u062c\u0645\u0639","\u0687\u0646\u0687\u0631"],e.defineLocale("sd",{months:n,monthsShort:n,weekdays:r,weekdaysShort:r,weekdaysMin:r,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd\u060c D MMMM YYYY HH:mm"},meridiemParse:/\u0635\u0628\u062d|\u0634\u0627\u0645/,isPM:function(e){return "\u0634\u0627\u0645"===e},meridiem:function(e,a,_){return e<12?"\u0635\u0628\u062d":"\u0634\u0627\u0645"},calendar:{sameDay:"[\u0627\u0684] LT",nextDay:"[\u0633\u0680\u0627\u06bb\u064a] LT",nextWeek:"dddd [\u0627\u06b3\u064a\u0646 \u0647\u0641\u062a\u064a \u062a\u064a] LT",lastDay:"[\u06aa\u0627\u0644\u0647\u0647] LT",lastWeek:"[\u06af\u0632\u0631\u064a\u0644 \u0647\u0641\u062a\u064a] dddd [\u062a\u064a] LT",sameElse:"L"},relativeTime:{future:"%s \u067e\u0648\u0621",past:"%s \u0627\u06b3",s:"\u0686\u0646\u062f \u0633\u064a\u06aa\u0646\u068a",ss:"%d \u0633\u064a\u06aa\u0646\u068a",m:"\u0647\u06aa \u0645\u0646\u067d",mm:"%d \u0645\u0646\u067d",h:"\u0647\u06aa \u06aa\u0644\u0627\u06aa",hh:"%d \u06aa\u0644\u0627\u06aa",d:"\u0647\u06aa \u068f\u064a\u0646\u0647\u0646",dd:"%d \u068f\u064a\u0646\u0647\u0646",M:"\u0647\u06aa \u0645\u0647\u064a\u0646\u0648",MM:"%d \u0645\u0647\u064a\u0646\u0627",y:"\u0647\u06aa \u0633\u0627\u0644",yy:"%d \u0633\u0627\u0644"},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:1,doy:4}}),e.defineLocale("se",{months:"o\u0111\u0111ajagem\xe1nnu_guovvam\xe1nnu_njuk\u010dam\xe1nnu_cuo\u014bom\xe1nnu_miessem\xe1nnu_geassem\xe1nnu_suoidnem\xe1nnu_borgem\xe1nnu_\u010dak\u010dam\xe1nnu_golggotm\xe1nnu_sk\xe1bmam\xe1nnu_juovlam\xe1nnu".split("_"),monthsShort:"o\u0111\u0111j_guov_njuk_cuo_mies_geas_suoi_borg_\u010dak\u010d_golg_sk\xe1b_juov".split("_"),weekdays:"sotnabeaivi_vuoss\xe1rga_ma\u014b\u014beb\xe1rga_gaskavahkku_duorastat_bearjadat_l\xe1vvardat".split("_"),weekdaysShort:"sotn_vuos_ma\u014b_gask_duor_bear_l\xe1v".split("_"),weekdaysMin:"s_v_m_g_d_b_L".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"MMMM D. [b.] YYYY",LLL:"MMMM D. [b.] YYYY [ti.] HH:mm",LLLL:"dddd, MMMM D. [b.] YYYY [ti.] HH:mm"},calendar:{sameDay:"[otne ti] LT",nextDay:"[ihttin ti] LT",nextWeek:"dddd [ti] LT",lastDay:"[ikte ti] LT",lastWeek:"[ovddit] dddd [ti] LT",sameElse:"L"},relativeTime:{future:"%s gea\u017ees",past:"ma\u014bit %s",s:"moadde sekunddat",ss:"%d sekunddat",m:"okta minuhta",mm:"%d minuhtat",h:"okta diimmu",hh:"%d diimmut",d:"okta beaivi",dd:"%d beaivvit",M:"okta m\xe1nnu",MM:"%d m\xe1nut",y:"okta jahki",yy:"%d jagit"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("si",{months:"\u0da2\u0db1\u0dc0\u0dcf\u0dbb\u0dd2_\u0db4\u0dd9\u0db6\u0dbb\u0dc0\u0dcf\u0dbb\u0dd2_\u0db8\u0dcf\u0dbb\u0dca\u0dad\u0dd4_\u0d85\u0db4\u0dca\u200d\u0dbb\u0dda\u0dbd\u0dca_\u0db8\u0dd0\u0dba\u0dd2_\u0da2\u0dd6\u0db1\u0dd2_\u0da2\u0dd6\u0dbd\u0dd2_\u0d85\u0d9c\u0ddd\u0dc3\u0dca\u0dad\u0dd4_\u0dc3\u0dd0\u0db4\u0dca\u0dad\u0dd0\u0db8\u0dca\u0db6\u0dbb\u0dca_\u0d94\u0d9a\u0dca\u0dad\u0ddd\u0db6\u0dbb\u0dca_\u0db1\u0ddc\u0dc0\u0dd0\u0db8\u0dca\u0db6\u0dbb\u0dca_\u0daf\u0dd9\u0dc3\u0dd0\u0db8\u0dca\u0db6\u0dbb\u0dca".split("_"),monthsShort:"\u0da2\u0db1_\u0db4\u0dd9\u0db6_\u0db8\u0dcf\u0dbb\u0dca_\u0d85\u0db4\u0dca_\u0db8\u0dd0\u0dba\u0dd2_\u0da2\u0dd6\u0db1\u0dd2_\u0da2\u0dd6\u0dbd\u0dd2_\u0d85\u0d9c\u0ddd_\u0dc3\u0dd0\u0db4\u0dca_\u0d94\u0d9a\u0dca_\u0db1\u0ddc\u0dc0\u0dd0_\u0daf\u0dd9\u0dc3\u0dd0".split("_"),weekdays:"\u0d89\u0dbb\u0dd2\u0daf\u0dcf_\u0dc3\u0db3\u0dd4\u0daf\u0dcf_\u0d85\u0d9f\u0dc4\u0dbb\u0dd4\u0dc0\u0dcf\u0daf\u0dcf_\u0db6\u0daf\u0dcf\u0daf\u0dcf_\u0db6\u0dca\u200d\u0dbb\u0dc4\u0dc3\u0dca\u0db4\u0dad\u0dd2\u0db1\u0dca\u0daf\u0dcf_\u0dc3\u0dd2\u0d9a\u0dd4\u0dbb\u0dcf\u0daf\u0dcf_\u0dc3\u0dd9\u0db1\u0dc3\u0dd4\u0dbb\u0dcf\u0daf\u0dcf".split("_"),weekdaysShort:"\u0d89\u0dbb\u0dd2_\u0dc3\u0db3\u0dd4_\u0d85\u0d9f_\u0db6\u0daf\u0dcf_\u0db6\u0dca\u200d\u0dbb\u0dc4_\u0dc3\u0dd2\u0d9a\u0dd4_\u0dc3\u0dd9\u0db1".split("_"),weekdaysMin:"\u0d89_\u0dc3_\u0d85_\u0db6_\u0db6\u0dca\u200d\u0dbb_\u0dc3\u0dd2_\u0dc3\u0dd9".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"a h:mm",LTS:"a h:mm:ss",L:"YYYY/MM/DD",LL:"YYYY MMMM D",LLL:"YYYY MMMM D, a h:mm",LLLL:"YYYY MMMM D [\u0dc0\u0dd0\u0db1\u0dd2] dddd, a h:mm:ss"},calendar:{sameDay:"[\u0d85\u0daf] LT[\u0da7]",nextDay:"[\u0dc4\u0dd9\u0da7] LT[\u0da7]",nextWeek:"dddd LT[\u0da7]",lastDay:"[\u0d8a\u0dba\u0dda] LT[\u0da7]",lastWeek:"[\u0db4\u0dc3\u0dd4\u0d9c\u0dd2\u0dba] dddd LT[\u0da7]",sameElse:"L"},relativeTime:{future:"%s\u0d9a\u0dd2\u0db1\u0dca",past:"%s\u0d9a\u0da7 \u0db4\u0dd9\u0dbb",s:"\u0dad\u0dad\u0dca\u0db4\u0dbb \u0d9a\u0dd2\u0dc4\u0dd2\u0db4\u0dba",ss:"\u0dad\u0dad\u0dca\u0db4\u0dbb %d",m:"\u0db8\u0dd2\u0db1\u0dd2\u0dad\u0dca\u0dad\u0dd4\u0dc0",mm:"\u0db8\u0dd2\u0db1\u0dd2\u0dad\u0dca\u0dad\u0dd4 %d",h:"\u0db4\u0dd0\u0dba",hh:"\u0db4\u0dd0\u0dba %d",d:"\u0daf\u0dd2\u0db1\u0dba",dd:"\u0daf\u0dd2\u0db1 %d",M:"\u0db8\u0dcf\u0dc3\u0dba",MM:"\u0db8\u0dcf\u0dc3 %d",y:"\u0dc0\u0dc3\u0dbb",yy:"\u0dc0\u0dc3\u0dbb %d"},dayOfMonthOrdinalParse:/\d{1,2} \u0dc0\u0dd0\u0db1\u0dd2/,ordinal:function(e){return e+" \u0dc0\u0dd0\u0db1\u0dd2"},meridiemParse:/\u0db4\u0dd9\u0dbb \u0dc0\u0dbb\u0dd4|\u0db4\u0dc3\u0dca \u0dc0\u0dbb\u0dd4|\u0db4\u0dd9.\u0dc0|\u0db4.\u0dc0./,isPM:function(e){return "\u0db4.\u0dc0."===e||"\u0db4\u0dc3\u0dca \u0dc0\u0dbb\u0dd4"===e},meridiem:function(e,a,_){return 11<e?_?"\u0db4.\u0dc0.":"\u0db4\u0dc3\u0dca \u0dc0\u0dbb\u0dd4":_?"\u0db4\u0dd9.\u0dc0.":"\u0db4\u0dd9\u0dbb \u0dc0\u0dbb\u0dd4"}}),d="janu\xe1r_febru\xe1r_marec_apr\xedl_m\xe1j_j\xfan_j\xfal_august_september_okt\xf3ber_november_december".split("_"),m="jan_feb_mar_apr_m\xe1j_j\xfan_j\xfal_aug_sep_okt_nov_dec".split("_");function ea(e){return 1<e&&e<5}function j(e,a,_,s){var d=e+" ";switch(_){case"s":return a||s?"p\xe1r sek\xfand":"p\xe1r sekundami";case"ss":return a||s?d+(ea(e)?"sekundy":"sek\xfand"):d+"sekundami";case"m":return a?"min\xfata":s?"min\xfatu":"min\xfatou";case"mm":return a||s?d+(ea(e)?"min\xfaty":"min\xfat"):d+"min\xfatami";case"h":return a?"hodina":s?"hodinu":"hodinou";case"hh":return a||s?d+(ea(e)?"hodiny":"hod\xedn"):d+"hodinami";case"d":return a||s?"de\u0148":"d\u0148om";case"dd":return a||s?d+(ea(e)?"dni":"dn\xed"):d+"d\u0148ami";case"M":return a||s?"mesiac":"mesiacom";case"MM":return a||s?d+(ea(e)?"mesiace":"mesiacov"):d+"mesiacmi";case"y":return a||s?"rok":"rokom";case"yy":return a||s?d+(ea(e)?"roky":"rokov"):d+"rokmi"}}function x(e,a,_,s){var d=e+" ";switch(_){case"s":return a||s?"nekaj sekund":"nekaj sekundami";case"ss":return d+=1===e?a?"sekundo":"sekundi":2===e?a||s?"sekundi":"sekundah":e<5?a||s?"sekunde":"sekundah":"sekund";case"m":return a?"ena minuta":"eno minuto";case"mm":return d+=1===e?a?"minuta":"minuto":2===e?a||s?"minuti":"minutama":e<5?a||s?"minute":"minutami":a||s?"minut":"minutami";case"h":return a?"ena ura":"eno uro";case"hh":return d+=1===e?a?"ura":"uro":2===e?a||s?"uri":"urama":e<5?a||s?"ure":"urami":a||s?"ur":"urami";case"d":return a||s?"en dan":"enim dnem";case"dd":return d+=1===e?a||s?"dan":"dnem":2===e?a||s?"dni":"dnevoma":a||s?"dni":"dnevi";case"M":return a||s?"en mesec":"enim mesecem";case"MM":return d+=1===e?a||s?"mesec":"mesecem":2===e?a||s?"meseca":"mesecema":e<5?a||s?"mesece":"meseci":a||s?"mesecev":"meseci";case"y":return a||s?"eno leto":"enim letom";case"yy":return d+=1===e?a||s?"leto":"letom":2===e?a||s?"leti":"letoma":e<5?a||s?"leta":"leti":a||s?"let":"leti"}}e.defineLocale("sk",{months:d,monthsShort:m,weekdays:"nede\u013ea_pondelok_utorok_streda_\u0161tvrtok_piatok_sobota".split("_"),weekdaysShort:"ne_po_ut_st_\u0161t_pi_so".split("_"),weekdaysMin:"ne_po_ut_st_\u0161t_pi_so".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd D. MMMM YYYY H:mm"},calendar:{sameDay:"[dnes o] LT",nextDay:"[zajtra o] LT",nextWeek:function(){switch(this.day()){case 0:return "[v nede\u013eu o] LT";case 1:case 2:return "[v] dddd [o] LT";case 3:return "[v stredu o] LT";case 4:return "[vo \u0161tvrtok o] LT";case 5:return "[v piatok o] LT";case 6:return "[v sobotu o] LT"}},lastDay:"[v\u010dera o] LT",lastWeek:function(){switch(this.day()){case 0:return "[minul\xfa nede\u013eu o] LT";case 1:case 2:return "[minul\xfd] dddd [o] LT";case 3:return "[minul\xfa stredu o] LT";case 4:case 5:return "[minul\xfd] dddd [o] LT";case 6:return "[minul\xfa sobotu o] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"pred %s",s:j,ss:j,m:j,mm:j,h:j,hh:j,d:j,dd:j,M:j,MM:j,y:j,yy:j},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("sl",{months:"januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),monthsShort:"jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"nedelja_ponedeljek_torek_sreda_\u010detrtek_petek_sobota".split("_"),weekdaysShort:"ned._pon._tor._sre._\u010det._pet._sob.".split("_"),weekdaysMin:"ne_po_to_sr_\u010de_pe_so".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD. MM. YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danes ob] LT",nextDay:"[jutri ob] LT",nextWeek:function(){switch(this.day()){case 0:return "[v] [nedeljo] [ob] LT";case 3:return "[v] [sredo] [ob] LT";case 6:return "[v] [soboto] [ob] LT";case 1:case 2:case 4:case 5:return "[v] dddd [ob] LT"}},lastDay:"[v\u010deraj ob] LT",lastWeek:function(){switch(this.day()){case 0:return "[prej\u0161njo] [nedeljo] [ob] LT";case 3:return "[prej\u0161njo] [sredo] [ob] LT";case 6:return "[prej\u0161njo] [soboto] [ob] LT";case 1:case 2:case 4:case 5:return "[prej\u0161nji] dddd [ob] LT"}},sameElse:"L"},relativeTime:{future:"\u010dez %s",past:"pred %s",s:x,ss:x,m:x,mm:x,h:x,hh:x,d:x,dd:x,M:x,MM:x,y:x,yy:x},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),e.defineLocale("sq",{months:"Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_N\xebntor_Dhjetor".split("_"),monthsShort:"Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_N\xebn_Dhj".split("_"),weekdays:"E Diel_E H\xebn\xeb_E Mart\xeb_E M\xebrkur\xeb_E Enjte_E Premte_E Shtun\xeb".split("_"),weekdaysShort:"Die_H\xebn_Mar_M\xebr_Enj_Pre_Sht".split("_"),weekdaysMin:"D_H_Ma_M\xeb_E_P_Sh".split("_"),weekdaysParseExact:!0,meridiemParse:/PD|MD/,isPM:function(e){return "M"===e.charAt(0)},meridiem:function(e,a,_){return e<12?"PD":"MD"},longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Sot n\xeb] LT",nextDay:"[Nes\xebr n\xeb] LT",nextWeek:"dddd [n\xeb] LT",lastDay:"[Dje n\xeb] LT",lastWeek:"dddd [e kaluar n\xeb] LT",sameElse:"L"},relativeTime:{future:"n\xeb %s",past:"%s m\xeb par\xeb",s:"disa sekonda",ss:"%d sekonda",m:"nj\xeb minut\xeb",mm:"%d minuta",h:"nj\xeb or\xeb",hh:"%d or\xeb",d:"nj\xeb dit\xeb",dd:"%d dit\xeb",M:"nj\xeb muaj",MM:"%d muaj",y:"nj\xeb vit",yy:"%d vite"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var P={words:{ss:["\u0441\u0435\u043a\u0443\u043d\u0434\u0430","\u0441\u0435\u043a\u0443\u043d\u0434\u0435","\u0441\u0435\u043a\u0443\u043d\u0434\u0438"],m:["\u0458\u0435\u0434\u0430\u043d \u043c\u0438\u043d\u0443\u0442","\u0458\u0435\u0434\u043d\u043e\u0433 \u043c\u0438\u043d\u0443\u0442\u0430"],mm:["\u043c\u0438\u043d\u0443\u0442","\u043c\u0438\u043d\u0443\u0442\u0430","\u043c\u0438\u043d\u0443\u0442\u0430"],h:["\u0458\u0435\u0434\u0430\u043d \u0441\u0430\u0442","\u0458\u0435\u0434\u043d\u043e\u0433 \u0441\u0430\u0442\u0430"],hh:["\u0441\u0430\u0442","\u0441\u0430\u0442\u0430","\u0441\u0430\u0442\u0438"],d:["\u0458\u0435\u0434\u0430\u043d \u0434\u0430\u043d","\u0458\u0435\u0434\u043d\u043e\u0433 \u0434\u0430\u043d\u0430"],dd:["\u0434\u0430\u043d","\u0434\u0430\u043d\u0430","\u0434\u0430\u043d\u0430"],M:["\u0458\u0435\u0434\u0430\u043d \u043c\u0435\u0441\u0435\u0446","\u0458\u0435\u0434\u043d\u043e\u0433 \u043c\u0435\u0441\u0435\u0446\u0430"],MM:["\u043c\u0435\u0441\u0435\u0446","\u043c\u0435\u0441\u0435\u0446\u0430","\u043c\u0435\u0441\u0435\u0446\u0438"],y:["\u0458\u0435\u0434\u043d\u0443 \u0433\u043e\u0434\u0438\u043d\u0443","\u0458\u0435\u0434\u043d\u0435 \u0433\u043e\u0434\u0438\u043d\u0435"],yy:["\u0433\u043e\u0434\u0438\u043d\u0443","\u0433\u043e\u0434\u0438\u043d\u0435","\u0433\u043e\u0434\u0438\u043d\u0430"]},correctGrammaticalCase:function(e,a){return 1<=e%10&&e%10<=4&&(e%100<10||20<=e%100)?e%10==1?a[0]:a[1]:a[2]},translate:function(e,a,_,s){var d=P.words[_];return 1===_.length?"y"===_&&a?"\u0458\u0435\u0434\u043d\u0430 \u0433\u043e\u0434\u0438\u043d\u0430":s||a?d[0]:d[1]:(s=P.correctGrammaticalCase(e,d),"yy"===_&&a&&"\u0433\u043e\u0434\u0438\u043d\u0443"===s?e+" \u0433\u043e\u0434\u0438\u043d\u0430":e+" "+s)}},W=(e.defineLocale("sr-cyrl",{months:"\u0458\u0430\u043d\u0443\u0430\u0440_\u0444\u0435\u0431\u0440\u0443\u0430\u0440_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0438\u043b_\u043c\u0430\u0458_\u0458\u0443\u043d_\u0458\u0443\u043b_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043f\u0442\u0435\u043c\u0431\u0430\u0440_\u043e\u043a\u0442\u043e\u0431\u0430\u0440_\u043d\u043e\u0432\u0435\u043c\u0431\u0430\u0440_\u0434\u0435\u0446\u0435\u043c\u0431\u0430\u0440".split("_"),monthsShort:"\u0458\u0430\u043d._\u0444\u0435\u0431._\u043c\u0430\u0440._\u0430\u043f\u0440._\u043c\u0430\u0458_\u0458\u0443\u043d_\u0458\u0443\u043b_\u0430\u0432\u0433._\u0441\u0435\u043f._\u043e\u043a\u0442._\u043d\u043e\u0432._\u0434\u0435\u0446.".split("_"),monthsParseExact:!0,weekdays:"\u043d\u0435\u0434\u0435\u0459\u0430_\u043f\u043e\u043d\u0435\u0434\u0435\u0459\u0430\u043a_\u0443\u0442\u043e\u0440\u0430\u043a_\u0441\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0440\u0442\u0430\u043a_\u043f\u0435\u0442\u0430\u043a_\u0441\u0443\u0431\u043e\u0442\u0430".split("_"),weekdaysShort:"\u043d\u0435\u0434._\u043f\u043e\u043d._\u0443\u0442\u043e._\u0441\u0440\u0435._\u0447\u0435\u0442._\u043f\u0435\u0442._\u0441\u0443\u0431.".split("_"),weekdaysMin:"\u043d\u0435_\u043f\u043e_\u0443\u0442_\u0441\u0440_\u0447\u0435_\u043f\u0435_\u0441\u0443".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"D. M. YYYY.",LL:"D. MMMM YYYY.",LLL:"D. MMMM YYYY. H:mm",LLLL:"dddd, D. MMMM YYYY. H:mm"},calendar:{sameDay:"[\u0434\u0430\u043d\u0430\u0441 \u0443] LT",nextDay:"[\u0441\u0443\u0442\u0440\u0430 \u0443] LT",nextWeek:function(){switch(this.day()){case 0:return "[\u0443] [\u043d\u0435\u0434\u0435\u0459\u0443] [\u0443] LT";case 3:return "[\u0443] [\u0441\u0440\u0435\u0434\u0443] [\u0443] LT";case 6:return "[\u0443] [\u0441\u0443\u0431\u043e\u0442\u0443] [\u0443] LT";case 1:case 2:case 4:case 5:return "[\u0443] dddd [\u0443] LT"}},lastDay:"[\u0458\u0443\u0447\u0435 \u0443] LT",lastWeek:function(){return ["[\u043f\u0440\u043e\u0448\u043b\u0435] [\u043d\u0435\u0434\u0435\u0459\u0435] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u043e\u0433] [\u043f\u043e\u043d\u0435\u0434\u0435\u0459\u043a\u0430] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u043e\u0433] [\u0443\u0442\u043e\u0440\u043a\u0430] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u0435] [\u0441\u0440\u0435\u0434\u0435] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u043e\u0433] [\u0447\u0435\u0442\u0432\u0440\u0442\u043a\u0430] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u043e\u0433] [\u043f\u0435\u0442\u043a\u0430] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u0435] [\u0441\u0443\u0431\u043e\u0442\u0435] [\u0443] LT"][this.day()]},sameElse:"L"},relativeTime:{future:"\u0437\u0430 %s",past:"\u043f\u0440\u0435 %s",s:"\u043d\u0435\u043a\u043e\u043b\u0438\u043a\u043e \u0441\u0435\u043a\u0443\u043d\u0434\u0438",ss:P.translate,m:P.translate,mm:P.translate,h:P.translate,hh:P.translate,d:P.translate,dd:P.translate,M:P.translate,MM:P.translate,y:P.translate,yy:P.translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),{words:{ss:["sekunda","sekunde","sekundi"],m:["jedan minut","jednog minuta"],mm:["minut","minuta","minuta"],h:["jedan sat","jednog sata"],hh:["sat","sata","sati"],d:["jedan dan","jednog dana"],dd:["dan","dana","dana"],M:["jedan mesec","jednog meseca"],MM:["mesec","meseca","meseci"],y:["jednu godinu","jedne godine"],yy:["godinu","godine","godina"]},correctGrammaticalCase:function(e,a){return 1<=e%10&&e%10<=4&&(e%100<10||20<=e%100)?e%10==1?a[0]:a[1]:a[2]},translate:function(e,a,_,s){var d=W.words[_];return 1===_.length?"y"===_&&a?"jedna godina":s||a?d[0]:d[1]:(s=W.correctGrammaticalCase(e,d),"yy"===_&&a&&"godinu"===s?e+" godina":e+" "+s)}}),aa=(e.defineLocale("sr",{months:"januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),monthsShort:"jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"nedelja_ponedeljak_utorak_sreda_\u010detvrtak_petak_subota".split("_"),weekdaysShort:"ned._pon._uto._sre._\u010det._pet._sub.".split("_"),weekdaysMin:"ne_po_ut_sr_\u010de_pe_su".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"D. M. YYYY.",LL:"D. MMMM YYYY.",LLL:"D. MMMM YYYY. H:mm",LLLL:"dddd, D. MMMM YYYY. H:mm"},calendar:{sameDay:"[danas u] LT",nextDay:"[sutra u] LT",nextWeek:function(){switch(this.day()){case 0:return "[u] [nedelju] [u] LT";case 3:return "[u] [sredu] [u] LT";case 6:return "[u] [subotu] [u] LT";case 1:case 2:case 4:case 5:return "[u] dddd [u] LT"}},lastDay:"[ju\u010de u] LT",lastWeek:function(){return ["[pro\u0161le] [nedelje] [u] LT","[pro\u0161log] [ponedeljka] [u] LT","[pro\u0161log] [utorka] [u] LT","[pro\u0161le] [srede] [u] LT","[pro\u0161log] [\u010detvrtka] [u] LT","[pro\u0161log] [petka] [u] LT","[pro\u0161le] [subote] [u] LT"][this.day()]},sameElse:"L"},relativeTime:{future:"za %s",past:"pre %s",s:"nekoliko sekundi",ss:W.translate,m:W.translate,mm:W.translate,h:W.translate,hh:W.translate,d:W.translate,dd:W.translate,M:W.translate,MM:W.translate,y:W.translate,yy:W.translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),e.defineLocale("ss",{months:"Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"),monthsShort:"Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"),weekdays:"Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"),weekdaysShort:"Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"),weekdaysMin:"Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[Namuhla nga] LT",nextDay:"[Kusasa nga] LT",nextWeek:"dddd [nga] LT",lastDay:"[Itolo nga] LT",lastWeek:"dddd [leliphelile] [nga] LT",sameElse:"L"},relativeTime:{future:"nga %s",past:"wenteka nga %s",s:"emizuzwana lomcane",ss:"%d mzuzwana",m:"umzuzu",mm:"%d emizuzu",h:"lihora",hh:"%d emahora",d:"lilanga",dd:"%d emalanga",M:"inyanga",MM:"%d tinyanga",y:"umnyaka",yy:"%d iminyaka"},meridiemParse:/ekuseni|emini|entsambama|ebusuku/,meridiem:function(e,a,_){return e<11?"ekuseni":e<15?"emini":e<19?"entsambama":"ebusuku"},meridiemHour:function(e,a){return 12===e&&(e=0),"ekuseni"===a?e:"emini"===a?11<=e?e:e+12:"entsambama"===a||"ebusuku"===a?0===e?0:e+12:void 0},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:"%d",week:{dow:1,doy:4}}),e.defineLocale("sv",{months:"januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),monthsShort:"jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),weekdays:"s\xf6ndag_m\xe5ndag_tisdag_onsdag_torsdag_fredag_l\xf6rdag".split("_"),weekdaysShort:"s\xf6n_m\xe5n_tis_ons_tor_fre_l\xf6r".split("_"),weekdaysMin:"s\xf6_m\xe5_ti_on_to_fr_l\xf6".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [kl.] HH:mm",LLLL:"dddd D MMMM YYYY [kl.] HH:mm",lll:"D MMM YYYY HH:mm",llll:"ddd D MMM YYYY HH:mm"},calendar:{sameDay:"[Idag] LT",nextDay:"[Imorgon] LT",lastDay:"[Ig\xe5r] LT",nextWeek:"[P\xe5] dddd LT",lastWeek:"[I] dddd[s] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"f\xf6r %s sedan",s:"n\xe5gra sekunder",ss:"%d sekunder",m:"en minut",mm:"%d minuter",h:"en timme",hh:"%d timmar",d:"en dag",dd:"%d dagar",M:"en m\xe5nad",MM:"%d m\xe5nader",y:"ett \xe5r",yy:"%d \xe5r"},dayOfMonthOrdinalParse:/\d{1,2}(\:e|\:a)/,ordinal:function(e){var a=e%10;return e+(1!=~~(e%100/10)&&(1==a||2==a)?":a":":e")},week:{dow:1,doy:4}}),e.defineLocale("sw",{months:"Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"),monthsShort:"Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"),weekdays:"Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"),weekdaysShort:"Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"),weekdaysMin:"J2_J3_J4_J5_Al_Ij_J1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"hh:mm A",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[leo saa] LT",nextDay:"[kesho saa] LT",nextWeek:"[wiki ijayo] dddd [saat] LT",lastDay:"[jana] LT",lastWeek:"[wiki iliyopita] dddd [saat] LT",sameElse:"L"},relativeTime:{future:"%s baadaye",past:"tokea %s",s:"hivi punde",ss:"sekunde %d",m:"dakika moja",mm:"dakika %d",h:"saa limoja",hh:"masaa %d",d:"siku moja",dd:"siku %d",M:"mwezi mmoja",MM:"miezi %d",y:"mwaka mmoja",yy:"miaka %d"},week:{dow:1,doy:7}}),{1:"\u0be7",2:"\u0be8",3:"\u0be9",4:"\u0bea",5:"\u0beb",6:"\u0bec",7:"\u0bed",8:"\u0bee",9:"\u0bef",0:"\u0be6"}),_a={"\u0be7":"1","\u0be8":"2","\u0be9":"3","\u0bea":"4","\u0beb":"5","\u0bec":"6","\u0bed":"7","\u0bee":"8","\u0bef":"9","\u0be6":"0"},sa=(e.defineLocale("ta",{months:"\u0b9c\u0ba9\u0bb5\u0bb0\u0bbf_\u0baa\u0bbf\u0baa\u0bcd\u0bb0\u0bb5\u0bb0\u0bbf_\u0bae\u0bbe\u0bb0\u0bcd\u0b9a\u0bcd_\u0b8f\u0baa\u0bcd\u0bb0\u0bb2\u0bcd_\u0bae\u0bc7_\u0b9c\u0bc2\u0ba9\u0bcd_\u0b9c\u0bc2\u0bb2\u0bc8_\u0b86\u0b95\u0bb8\u0bcd\u0b9f\u0bcd_\u0b9a\u0bc6\u0baa\u0bcd\u0b9f\u0bc6\u0bae\u0bcd\u0baa\u0bb0\u0bcd_\u0b85\u0b95\u0bcd\u0b9f\u0bc7\u0bbe\u0baa\u0bb0\u0bcd_\u0ba8\u0bb5\u0bae\u0bcd\u0baa\u0bb0\u0bcd_\u0b9f\u0bbf\u0b9a\u0bae\u0bcd\u0baa\u0bb0\u0bcd".split("_"),monthsShort:"\u0b9c\u0ba9\u0bb5\u0bb0\u0bbf_\u0baa\u0bbf\u0baa\u0bcd\u0bb0\u0bb5\u0bb0\u0bbf_\u0bae\u0bbe\u0bb0\u0bcd\u0b9a\u0bcd_\u0b8f\u0baa\u0bcd\u0bb0\u0bb2\u0bcd_\u0bae\u0bc7_\u0b9c\u0bc2\u0ba9\u0bcd_\u0b9c\u0bc2\u0bb2\u0bc8_\u0b86\u0b95\u0bb8\u0bcd\u0b9f\u0bcd_\u0b9a\u0bc6\u0baa\u0bcd\u0b9f\u0bc6\u0bae\u0bcd\u0baa\u0bb0\u0bcd_\u0b85\u0b95\u0bcd\u0b9f\u0bc7\u0bbe\u0baa\u0bb0\u0bcd_\u0ba8\u0bb5\u0bae\u0bcd\u0baa\u0bb0\u0bcd_\u0b9f\u0bbf\u0b9a\u0bae\u0bcd\u0baa\u0bb0\u0bcd".split("_"),weekdays:"\u0b9e\u0bbe\u0baf\u0bbf\u0bb1\u0bcd\u0bb1\u0bc1\u0b95\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0ba4\u0bbf\u0b99\u0bcd\u0b95\u0b9f\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0b9a\u0bc6\u0bb5\u0bcd\u0bb5\u0bbe\u0baf\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0baa\u0bc1\u0ba4\u0ba9\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0bb5\u0bbf\u0baf\u0bbe\u0bb4\u0b95\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0bb5\u0bc6\u0bb3\u0bcd\u0bb3\u0bbf\u0b95\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0b9a\u0ba9\u0bbf\u0b95\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8".split("_"),weekdaysShort:"\u0b9e\u0bbe\u0baf\u0bbf\u0bb1\u0bc1_\u0ba4\u0bbf\u0b99\u0bcd\u0b95\u0bb3\u0bcd_\u0b9a\u0bc6\u0bb5\u0bcd\u0bb5\u0bbe\u0baf\u0bcd_\u0baa\u0bc1\u0ba4\u0ba9\u0bcd_\u0bb5\u0bbf\u0baf\u0bbe\u0bb4\u0ba9\u0bcd_\u0bb5\u0bc6\u0bb3\u0bcd\u0bb3\u0bbf_\u0b9a\u0ba9\u0bbf".split("_"),weekdaysMin:"\u0b9e\u0bbe_\u0ba4\u0bbf_\u0b9a\u0bc6_\u0baa\u0bc1_\u0bb5\u0bbf_\u0bb5\u0bc6_\u0b9a".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, HH:mm",LLLL:"dddd, D MMMM YYYY, HH:mm"},calendar:{sameDay:"[\u0b87\u0ba9\u0bcd\u0bb1\u0bc1] LT",nextDay:"[\u0ba8\u0bbe\u0bb3\u0bc8] LT",nextWeek:"dddd, LT",lastDay:"[\u0ba8\u0bc7\u0bb1\u0bcd\u0bb1\u0bc1] LT",lastWeek:"[\u0b95\u0b9f\u0ba8\u0bcd\u0ba4 \u0bb5\u0bbe\u0bb0\u0bae\u0bcd] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0b87\u0bb2\u0bcd",past:"%s \u0bae\u0bc1\u0ba9\u0bcd",s:"\u0b92\u0bb0\u0bc1 \u0b9a\u0bbf\u0bb2 \u0bb5\u0bbf\u0ba8\u0bbe\u0b9f\u0bbf\u0b95\u0bb3\u0bcd",ss:"%d \u0bb5\u0bbf\u0ba8\u0bbe\u0b9f\u0bbf\u0b95\u0bb3\u0bcd",m:"\u0b92\u0bb0\u0bc1 \u0ba8\u0bbf\u0bae\u0bbf\u0b9f\u0bae\u0bcd",mm:"%d \u0ba8\u0bbf\u0bae\u0bbf\u0b9f\u0b99\u0bcd\u0b95\u0bb3\u0bcd",h:"\u0b92\u0bb0\u0bc1 \u0bae\u0ba3\u0bbf \u0ba8\u0bc7\u0bb0\u0bae\u0bcd",hh:"%d \u0bae\u0ba3\u0bbf \u0ba8\u0bc7\u0bb0\u0bae\u0bcd",d:"\u0b92\u0bb0\u0bc1 \u0ba8\u0bbe\u0bb3\u0bcd",dd:"%d \u0ba8\u0bbe\u0b9f\u0bcd\u0b95\u0bb3\u0bcd",M:"\u0b92\u0bb0\u0bc1 \u0bae\u0bbe\u0ba4\u0bae\u0bcd",MM:"%d \u0bae\u0bbe\u0ba4\u0b99\u0bcd\u0b95\u0bb3\u0bcd",y:"\u0b92\u0bb0\u0bc1 \u0bb5\u0bb0\u0bc1\u0b9f\u0bae\u0bcd",yy:"%d \u0b86\u0ba3\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd"},dayOfMonthOrdinalParse:/\d{1,2}\u0bb5\u0ba4\u0bc1/,ordinal:function(e){return e+"\u0bb5\u0ba4\u0bc1"},preparse:function(e){return e.replace(/[\u0be7\u0be8\u0be9\u0bea\u0beb\u0bec\u0bed\u0bee\u0bef\u0be6]/g,function(e){return _a[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return aa[e]})},meridiemParse:/\u0baf\u0bbe\u0bae\u0bae\u0bcd|\u0bb5\u0bc8\u0b95\u0bb1\u0bc8|\u0b95\u0bbe\u0bb2\u0bc8|\u0ba8\u0ba3\u0bcd\u0baa\u0b95\u0bb2\u0bcd|\u0b8e\u0bb1\u0bcd\u0baa\u0bbe\u0b9f\u0bc1|\u0bae\u0bbe\u0bb2\u0bc8/,meridiem:function(e,a,_){return e<2?" \u0baf\u0bbe\u0bae\u0bae\u0bcd":e<6?" \u0bb5\u0bc8\u0b95\u0bb1\u0bc8":e<10?" \u0b95\u0bbe\u0bb2\u0bc8":e<14?" \u0ba8\u0ba3\u0bcd\u0baa\u0b95\u0bb2\u0bcd":e<18?" \u0b8e\u0bb1\u0bcd\u0baa\u0bbe\u0b9f\u0bc1":e<22?" \u0bae\u0bbe\u0bb2\u0bc8":" \u0baf\u0bbe\u0bae\u0bae\u0bcd"},meridiemHour:function(e,a){return 12===e&&(e=0),"\u0baf\u0bbe\u0bae\u0bae\u0bcd"===a?e<2?e:e+12:"\u0bb5\u0bc8\u0b95\u0bb1\u0bc8"===a||"\u0b95\u0bbe\u0bb2\u0bc8"===a||"\u0ba8\u0ba3\u0bcd\u0baa\u0b95\u0bb2\u0bcd"===a&&10<=e?e:e+12},week:{dow:0,doy:6}}),e.defineLocale("te",{months:"\u0c1c\u0c28\u0c35\u0c30\u0c3f_\u0c2b\u0c3f\u0c2c\u0c4d\u0c30\u0c35\u0c30\u0c3f_\u0c2e\u0c3e\u0c30\u0c4d\u0c1a\u0c3f_\u0c0f\u0c2a\u0c4d\u0c30\u0c3f\u0c32\u0c4d_\u0c2e\u0c47_\u0c1c\u0c42\u0c28\u0c4d_\u0c1c\u0c41\u0c32\u0c48_\u0c06\u0c17\u0c38\u0c4d\u0c1f\u0c41_\u0c38\u0c46\u0c2a\u0c4d\u0c1f\u0c46\u0c02\u0c2c\u0c30\u0c4d_\u0c05\u0c15\u0c4d\u0c1f\u0c4b\u0c2c\u0c30\u0c4d_\u0c28\u0c35\u0c02\u0c2c\u0c30\u0c4d_\u0c21\u0c3f\u0c38\u0c46\u0c02\u0c2c\u0c30\u0c4d".split("_"),monthsShort:"\u0c1c\u0c28._\u0c2b\u0c3f\u0c2c\u0c4d\u0c30._\u0c2e\u0c3e\u0c30\u0c4d\u0c1a\u0c3f_\u0c0f\u0c2a\u0c4d\u0c30\u0c3f._\u0c2e\u0c47_\u0c1c\u0c42\u0c28\u0c4d_\u0c1c\u0c41\u0c32\u0c48_\u0c06\u0c17._\u0c38\u0c46\u0c2a\u0c4d._\u0c05\u0c15\u0c4d\u0c1f\u0c4b._\u0c28\u0c35._\u0c21\u0c3f\u0c38\u0c46.".split("_"),monthsParseExact:!0,weekdays:"\u0c06\u0c26\u0c3f\u0c35\u0c3e\u0c30\u0c02_\u0c38\u0c4b\u0c2e\u0c35\u0c3e\u0c30\u0c02_\u0c2e\u0c02\u0c17\u0c33\u0c35\u0c3e\u0c30\u0c02_\u0c2c\u0c41\u0c27\u0c35\u0c3e\u0c30\u0c02_\u0c17\u0c41\u0c30\u0c41\u0c35\u0c3e\u0c30\u0c02_\u0c36\u0c41\u0c15\u0c4d\u0c30\u0c35\u0c3e\u0c30\u0c02_\u0c36\u0c28\u0c3f\u0c35\u0c3e\u0c30\u0c02".split("_"),weekdaysShort:"\u0c06\u0c26\u0c3f_\u0c38\u0c4b\u0c2e_\u0c2e\u0c02\u0c17\u0c33_\u0c2c\u0c41\u0c27_\u0c17\u0c41\u0c30\u0c41_\u0c36\u0c41\u0c15\u0c4d\u0c30_\u0c36\u0c28\u0c3f".split("_"),weekdaysMin:"\u0c06_\u0c38\u0c4b_\u0c2e\u0c02_\u0c2c\u0c41_\u0c17\u0c41_\u0c36\u0c41_\u0c36".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm",LLLL:"dddd, D MMMM YYYY, A h:mm"},calendar:{sameDay:"[\u0c28\u0c47\u0c21\u0c41] LT",nextDay:"[\u0c30\u0c47\u0c2a\u0c41] LT",nextWeek:"dddd, LT",lastDay:"[\u0c28\u0c3f\u0c28\u0c4d\u0c28] LT",lastWeek:"[\u0c17\u0c24] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0c32\u0c4b",past:"%s \u0c15\u0c4d\u0c30\u0c3f\u0c24\u0c02",s:"\u0c15\u0c4a\u0c28\u0c4d\u0c28\u0c3f \u0c15\u0c4d\u0c37\u0c23\u0c3e\u0c32\u0c41",ss:"%d \u0c38\u0c46\u0c15\u0c28\u0c4d\u0c32\u0c41",m:"\u0c12\u0c15 \u0c28\u0c3f\u0c2e\u0c3f\u0c37\u0c02",mm:"%d \u0c28\u0c3f\u0c2e\u0c3f\u0c37\u0c3e\u0c32\u0c41",h:"\u0c12\u0c15 \u0c17\u0c02\u0c1f",hh:"%d \u0c17\u0c02\u0c1f\u0c32\u0c41",d:"\u0c12\u0c15 \u0c30\u0c4b\u0c1c\u0c41",dd:"%d \u0c30\u0c4b\u0c1c\u0c41\u0c32\u0c41",M:"\u0c12\u0c15 \u0c28\u0c46\u0c32",MM:"%d \u0c28\u0c46\u0c32\u0c32\u0c41",y:"\u0c12\u0c15 \u0c38\u0c02\u0c35\u0c24\u0c4d\u0c38\u0c30\u0c02",yy:"%d \u0c38\u0c02\u0c35\u0c24\u0c4d\u0c38\u0c30\u0c3e\u0c32\u0c41"},dayOfMonthOrdinalParse:/\d{1,2}\u0c35/,ordinal:"%d\u0c35",meridiemParse:/\u0c30\u0c3e\u0c24\u0c4d\u0c30\u0c3f|\u0c09\u0c26\u0c2f\u0c02|\u0c2e\u0c27\u0c4d\u0c2f\u0c3e\u0c39\u0c4d\u0c28\u0c02|\u0c38\u0c3e\u0c2f\u0c02\u0c24\u0c4d\u0c30\u0c02/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0c30\u0c3e\u0c24\u0c4d\u0c30\u0c3f"===a?e<4?e:e+12:"\u0c09\u0c26\u0c2f\u0c02"===a?e:"\u0c2e\u0c27\u0c4d\u0c2f\u0c3e\u0c39\u0c4d\u0c28\u0c02"===a?10<=e?e:e+12:"\u0c38\u0c3e\u0c2f\u0c02\u0c24\u0c4d\u0c30\u0c02"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0c30\u0c3e\u0c24\u0c4d\u0c30\u0c3f":e<10?"\u0c09\u0c26\u0c2f\u0c02":e<17?"\u0c2e\u0c27\u0c4d\u0c2f\u0c3e\u0c39\u0c4d\u0c28\u0c02":e<20?"\u0c38\u0c3e\u0c2f\u0c02\u0c24\u0c4d\u0c30\u0c02":"\u0c30\u0c3e\u0c24\u0c4d\u0c30\u0c3f"},week:{dow:0,doy:6}}),e.defineLocale("tet",{months:"Janeiru_Fevereiru_Marsu_Abril_Maiu_Ju\xf1u_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split("_"),monthsShort:"Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),weekdays:"Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"),weekdaysShort:"Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"),weekdaysMin:"Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Ohin iha] LT",nextDay:"[Aban iha] LT",nextWeek:"dddd [iha] LT",lastDay:"[Horiseik iha] LT",lastWeek:"dddd [semana kotuk] [iha] LT",sameElse:"L"},relativeTime:{future:"iha %s",past:"%s liuba",s:"segundu balun",ss:"segundu %d",m:"minutu ida",mm:"minutu %d",h:"oras ida",hh:"oras %d",d:"loron ida",dd:"loron %d",M:"fulan ida",MM:"fulan %d",y:"tinan ida",yy:"tinan %d"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1==a?"st":2==a?"nd":3==a?"rd":"th")},week:{dow:1,doy:4}}),{0:"-\u0443\u043c",1:"-\u0443\u043c",2:"-\u044e\u043c",3:"-\u044e\u043c",4:"-\u0443\u043c",5:"-\u0443\u043c",6:"-\u0443\u043c",7:"-\u0443\u043c",8:"-\u0443\u043c",9:"-\u0443\u043c",10:"-\u0443\u043c",12:"-\u0443\u043c",13:"-\u0443\u043c",20:"-\u0443\u043c",30:"-\u044e\u043c",40:"-\u0443\u043c",50:"-\u0443\u043c",60:"-\u0443\u043c",70:"-\u0443\u043c",80:"-\u0443\u043c",90:"-\u0443\u043c",100:"-\u0443\u043c"}),da=(e.defineLocale("tg",{months:{format:"\u044f\u043d\u0432\u0430\u0440\u0438_\u0444\u0435\u0432\u0440\u0430\u043b\u0438_\u043c\u0430\u0440\u0442\u0438_\u0430\u043f\u0440\u0435\u043b\u0438_\u043c\u0430\u0439\u0438_\u0438\u044e\u043d\u0438_\u0438\u044e\u043b\u0438_\u0430\u0432\u0433\u0443\u0441\u0442\u0438_\u0441\u0435\u043d\u0442\u044f\u0431\u0440\u0438_\u043e\u043a\u0442\u044f\u0431\u0440\u0438_\u043d\u043e\u044f\u0431\u0440\u0438_\u0434\u0435\u043a\u0430\u0431\u0440\u0438".split("_"),standalone:"\u044f\u043d\u0432\u0430\u0440_\u0444\u0435\u0432\u0440\u0430\u043b_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0435\u043b_\u043c\u0430\u0439_\u0438\u044e\u043d_\u0438\u044e\u043b_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043d\u0442\u044f\u0431\u0440_\u043e\u043a\u0442\u044f\u0431\u0440_\u043d\u043e\u044f\u0431\u0440_\u0434\u0435\u043a\u0430\u0431\u0440".split("_")},monthsShort:"\u044f\u043d\u0432_\u0444\u0435\u0432_\u043c\u0430\u0440_\u0430\u043f\u0440_\u043c\u0430\u0439_\u0438\u044e\u043d_\u0438\u044e\u043b_\u0430\u0432\u0433_\u0441\u0435\u043d_\u043e\u043a\u0442_\u043d\u043e\u044f_\u0434\u0435\u043a".split("_"),weekdays:"\u044f\u043a\u0448\u0430\u043d\u0431\u0435_\u0434\u0443\u0448\u0430\u043d\u0431\u0435_\u0441\u0435\u0448\u0430\u043d\u0431\u0435_\u0447\u043e\u0440\u0448\u0430\u043d\u0431\u0435_\u043f\u0430\u043d\u04b7\u0448\u0430\u043d\u0431\u0435_\u04b7\u0443\u043c\u044a\u0430_\u0448\u0430\u043d\u0431\u0435".split("_"),weekdaysShort:"\u044f\u0448\u0431_\u0434\u0448\u0431_\u0441\u0448\u0431_\u0447\u0448\u0431_\u043f\u0448\u0431_\u04b7\u0443\u043c_\u0448\u043d\u0431".split("_"),weekdaysMin:"\u044f\u0448_\u0434\u0448_\u0441\u0448_\u0447\u0448_\u043f\u0448_\u04b7\u043c_\u0448\u0431".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0418\u043c\u0440\u04ef\u0437 \u0441\u043e\u0430\u0442\u0438] LT",nextDay:"[\u0424\u0430\u0440\u0434\u043e \u0441\u043e\u0430\u0442\u0438] LT",lastDay:"[\u0414\u0438\u0440\u04ef\u0437 \u0441\u043e\u0430\u0442\u0438] LT",nextWeek:"dddd[\u0438] [\u04b3\u0430\u0444\u0442\u0430\u0438 \u043e\u044f\u043d\u0434\u0430 \u0441\u043e\u0430\u0442\u0438] LT",lastWeek:"dddd[\u0438] [\u04b3\u0430\u0444\u0442\u0430\u0438 \u0433\u0443\u0437\u0430\u0448\u0442\u0430 \u0441\u043e\u0430\u0442\u0438] LT",sameElse:"L"},relativeTime:{future:"\u0431\u0430\u044a\u0434\u0438 %s",past:"%s \u043f\u0435\u0448",s:"\u044f\u043a\u0447\u0430\u043d\u0434 \u0441\u043e\u043d\u0438\u044f",m:"\u044f\u043a \u0434\u0430\u049b\u0438\u049b\u0430",mm:"%d \u0434\u0430\u049b\u0438\u049b\u0430",h:"\u044f\u043a \u0441\u043e\u0430\u0442",hh:"%d \u0441\u043e\u0430\u0442",d:"\u044f\u043a \u0440\u04ef\u0437",dd:"%d \u0440\u04ef\u0437",M:"\u044f\u043a \u043c\u043e\u04b3",MM:"%d \u043c\u043e\u04b3",y:"\u044f\u043a \u0441\u043e\u043b",yy:"%d \u0441\u043e\u043b"},meridiemParse:/\u0448\u0430\u0431|\u0441\u0443\u0431\u04b3|\u0440\u04ef\u0437|\u0431\u0435\u0433\u043e\u04b3/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0448\u0430\u0431"===a?e<4?e:e+12:"\u0441\u0443\u0431\u04b3"===a?e:"\u0440\u04ef\u0437"===a?11<=e?e:e+12:"\u0431\u0435\u0433\u043e\u04b3"===a?e+12:void 0},meridiem:function(e,a,_){return e<4?"\u0448\u0430\u0431":e<11?"\u0441\u0443\u0431\u04b3":e<16?"\u0440\u04ef\u0437":e<19?"\u0431\u0435\u0433\u043e\u04b3":"\u0448\u0430\u0431"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0443\u043c|\u044e\u043c)/,ordinal:function(e){return e+(sa[e]||sa[e%10]||sa[100<=e?100:null])},week:{dow:1,doy:7}}),e.defineLocale("th",{months:"\u0e21\u0e01\u0e23\u0e32\u0e04\u0e21_\u0e01\u0e38\u0e21\u0e20\u0e32\u0e1e\u0e31\u0e19\u0e18\u0e4c_\u0e21\u0e35\u0e19\u0e32\u0e04\u0e21_\u0e40\u0e21\u0e29\u0e32\u0e22\u0e19_\u0e1e\u0e24\u0e29\u0e20\u0e32\u0e04\u0e21_\u0e21\u0e34\u0e16\u0e38\u0e19\u0e32\u0e22\u0e19_\u0e01\u0e23\u0e01\u0e0e\u0e32\u0e04\u0e21_\u0e2a\u0e34\u0e07\u0e2b\u0e32\u0e04\u0e21_\u0e01\u0e31\u0e19\u0e22\u0e32\u0e22\u0e19_\u0e15\u0e38\u0e25\u0e32\u0e04\u0e21_\u0e1e\u0e24\u0e28\u0e08\u0e34\u0e01\u0e32\u0e22\u0e19_\u0e18\u0e31\u0e19\u0e27\u0e32\u0e04\u0e21".split("_"),monthsShort:"\u0e21.\u0e04._\u0e01.\u0e1e._\u0e21\u0e35.\u0e04._\u0e40\u0e21.\u0e22._\u0e1e.\u0e04._\u0e21\u0e34.\u0e22._\u0e01.\u0e04._\u0e2a.\u0e04._\u0e01.\u0e22._\u0e15.\u0e04._\u0e1e.\u0e22._\u0e18.\u0e04.".split("_"),monthsParseExact:!0,weekdays:"\u0e2d\u0e32\u0e17\u0e34\u0e15\u0e22\u0e4c_\u0e08\u0e31\u0e19\u0e17\u0e23\u0e4c_\u0e2d\u0e31\u0e07\u0e04\u0e32\u0e23_\u0e1e\u0e38\u0e18_\u0e1e\u0e24\u0e2b\u0e31\u0e2a\u0e1a\u0e14\u0e35_\u0e28\u0e38\u0e01\u0e23\u0e4c_\u0e40\u0e2a\u0e32\u0e23\u0e4c".split("_"),weekdaysShort:"\u0e2d\u0e32\u0e17\u0e34\u0e15\u0e22\u0e4c_\u0e08\u0e31\u0e19\u0e17\u0e23\u0e4c_\u0e2d\u0e31\u0e07\u0e04\u0e32\u0e23_\u0e1e\u0e38\u0e18_\u0e1e\u0e24\u0e2b\u0e31\u0e2a_\u0e28\u0e38\u0e01\u0e23\u0e4c_\u0e40\u0e2a\u0e32\u0e23\u0e4c".split("_"),weekdaysMin:"\u0e2d\u0e32._\u0e08._\u0e2d._\u0e1e._\u0e1e\u0e24._\u0e28._\u0e2a.".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY \u0e40\u0e27\u0e25\u0e32 H:mm",LLLL:"\u0e27\u0e31\u0e19dddd\u0e17\u0e35\u0e48 D MMMM YYYY \u0e40\u0e27\u0e25\u0e32 H:mm"},meridiemParse:/\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07|\u0e2b\u0e25\u0e31\u0e07\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07/,isPM:function(e){return "\u0e2b\u0e25\u0e31\u0e07\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07"===e},meridiem:function(e,a,_){return e<12?"\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07":"\u0e2b\u0e25\u0e31\u0e07\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07"},calendar:{sameDay:"[\u0e27\u0e31\u0e19\u0e19\u0e35\u0e49 \u0e40\u0e27\u0e25\u0e32] LT",nextDay:"[\u0e1e\u0e23\u0e38\u0e48\u0e07\u0e19\u0e35\u0e49 \u0e40\u0e27\u0e25\u0e32] LT",nextWeek:"dddd[\u0e2b\u0e19\u0e49\u0e32 \u0e40\u0e27\u0e25\u0e32] LT",lastDay:"[\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e27\u0e32\u0e19\u0e19\u0e35\u0e49 \u0e40\u0e27\u0e25\u0e32] LT",lastWeek:"[\u0e27\u0e31\u0e19]dddd[\u0e17\u0e35\u0e48\u0e41\u0e25\u0e49\u0e27 \u0e40\u0e27\u0e25\u0e32] LT",sameElse:"L"},relativeTime:{future:"\u0e2d\u0e35\u0e01 %s",past:"%s\u0e17\u0e35\u0e48\u0e41\u0e25\u0e49\u0e27",s:"\u0e44\u0e21\u0e48\u0e01\u0e35\u0e48\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35",ss:"%d \u0e27\u0e34\u0e19\u0e32\u0e17\u0e35",m:"1 \u0e19\u0e32\u0e17\u0e35",mm:"%d \u0e19\u0e32\u0e17\u0e35",h:"1 \u0e0a\u0e31\u0e48\u0e27\u0e42\u0e21\u0e07",hh:"%d \u0e0a\u0e31\u0e48\u0e27\u0e42\u0e21\u0e07",d:"1 \u0e27\u0e31\u0e19",dd:"%d \u0e27\u0e31\u0e19",w:"1 \u0e2a\u0e31\u0e1b\u0e14\u0e32\u0e2b\u0e4c",ww:"%d \u0e2a\u0e31\u0e1b\u0e14\u0e32\u0e2b\u0e4c",M:"1 \u0e40\u0e14\u0e37\u0e2d\u0e19",MM:"%d \u0e40\u0e14\u0e37\u0e2d\u0e19",y:"1 \u0e1b\u0e35",yy:"%d \u0e1b\u0e35"}}),{1:"'inji",5:"'inji",8:"'inji",70:"'inji",80:"'inji",2:"'nji",7:"'nji",20:"'nji",50:"'nji",3:"'\xfcnji",4:"'\xfcnji",100:"'\xfcnji",6:"'njy",9:"'unjy",10:"'unjy",30:"'unjy",60:"'ynjy",90:"'ynjy"}),ta=(e.defineLocale("tk",{months:"\xddanwar_Fewral_Mart_Aprel_Ma\xfd_I\xfdun_I\xfdul_Awgust_Sent\xfdabr_Okt\xfdabr_No\xfdabr_Dekabr".split("_"),monthsShort:"\xddan_Few_Mar_Apr_Ma\xfd_I\xfdn_I\xfdl_Awg_Sen_Okt_No\xfd_Dek".split("_"),weekdays:"\xddek\u015fenbe_Du\u015fenbe_Si\u015fenbe_\xc7ar\u015fenbe_Pen\u015fenbe_Anna_\u015eenbe".split("_"),weekdaysShort:"\xddek_Du\u015f_Si\u015f_\xc7ar_Pen_Ann_\u015een".split("_"),weekdaysMin:"\xddk_D\u015f_S\u015f_\xc7r_Pn_An_\u015en".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[bug\xfcn sagat] LT",nextDay:"[ertir sagat] LT",nextWeek:"[indiki] dddd [sagat] LT",lastDay:"[d\xfc\xfdn] LT",lastWeek:"[ge\xe7en] dddd [sagat] LT",sameElse:"L"},relativeTime:{future:"%s so\u0148",past:"%s \xf6\u0148",s:"birn\xe4\xe7e sekunt",m:"bir minut",mm:"%d minut",h:"bir sagat",hh:"%d sagat",d:"bir g\xfcn",dd:"%d g\xfcn",M:"bir a\xfd",MM:"%d a\xfd",y:"bir \xfdyl",yy:"%d \xfdyl"},ordinal:function(e,a){switch(a){case"d":case"D":case"Do":case"DD":return e;default:if(0===e)return e+"'unjy";var _=e%10;return e+(da[_]||da[e%100-_]||da[100<=e?100:null])}},week:{dow:1,doy:7}}),e.defineLocale("tl-ph",{months:"Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),monthsShort:"Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),weekdays:"Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),weekdaysShort:"Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),weekdaysMin:"Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"MM/D/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY HH:mm",LLLL:"dddd, MMMM DD, YYYY HH:mm"},calendar:{sameDay:"LT [ngayong araw]",nextDay:"[Bukas ng] LT",nextWeek:"LT [sa susunod na] dddd",lastDay:"LT [kahapon]",lastWeek:"LT [noong nakaraang] dddd",sameElse:"L"},relativeTime:{future:"sa loob ng %s",past:"%s ang nakalipas",s:"ilang segundo",ss:"%d segundo",m:"isang minuto",mm:"%d minuto",h:"isang oras",hh:"%d oras",d:"isang araw",dd:"%d araw",M:"isang buwan",MM:"%d buwan",y:"isang taon",yy:"%d taon"},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:function(e){return e},week:{dow:1,doy:4}}),"pagh_wa\u2019_cha\u2019_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_"));function na(e,a,_,s){var d=function(e){var a=Math.floor(e%1e3/100),_=Math.floor(e%100/10),e=e%10,s="";0<a&&(s+=ta[a]+"vatlh");0<_&&(s+=(""!==s?" ":"")+ta[_]+"maH");0<e&&(s+=(""!==s?" ":"")+ta[e]);return ""===s?"pagh":s}(e);switch(_){case"ss":return d+" lup";case"mm":return d+" tup";case"hh":return d+" rep";case"dd":return d+" jaj";case"MM":return d+" jar";case"yy":return d+" DIS"}}e.defineLocale("tlh",{months:"tera\u2019 jar wa\u2019_tera\u2019 jar cha\u2019_tera\u2019 jar wej_tera\u2019 jar loS_tera\u2019 jar vagh_tera\u2019 jar jav_tera\u2019 jar Soch_tera\u2019 jar chorgh_tera\u2019 jar Hut_tera\u2019 jar wa\u2019maH_tera\u2019 jar wa\u2019maH wa\u2019_tera\u2019 jar wa\u2019maH cha\u2019".split("_"),monthsShort:"jar wa\u2019_jar cha\u2019_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa\u2019maH_jar wa\u2019maH wa\u2019_jar wa\u2019maH cha\u2019".split("_"),monthsParseExact:!0,weekdays:"lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),weekdaysShort:"lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),weekdaysMin:"lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[DaHjaj] LT",nextDay:"[wa\u2019leS] LT",nextWeek:"LLL",lastDay:"[wa\u2019Hu\u2019] LT",lastWeek:"LLL",sameElse:"L"},relativeTime:{future:function(e){var a=e;return a=-1!==e.indexOf("jaj")?a.slice(0,-3)+"leS":-1!==e.indexOf("jar")?a.slice(0,-3)+"waQ":-1!==e.indexOf("DIS")?a.slice(0,-3)+"nem":a+" pIq"},past:function(e){var a=e;return a=-1!==e.indexOf("jaj")?a.slice(0,-3)+"Hu\u2019":-1!==e.indexOf("jar")?a.slice(0,-3)+"wen":-1!==e.indexOf("DIS")?a.slice(0,-3)+"ben":a+" ret"},s:"puS lup",ss:na,m:"wa\u2019 tup",mm:na,h:"wa\u2019 rep",hh:na,d:"wa\u2019 jaj",dd:na,M:"wa\u2019 jar",MM:na,y:"wa\u2019 DIS",yy:na},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var ra={1:"'inci",5:"'inci",8:"'inci",70:"'inci",80:"'inci",2:"'nci",7:"'nci",20:"'nci",50:"'nci",3:"'\xfcnc\xfc",4:"'\xfcnc\xfc",100:"'\xfcnc\xfc",6:"'nc\u0131",9:"'uncu",10:"'uncu",30:"'uncu",60:"'\u0131nc\u0131",90:"'\u0131nc\u0131"};function A(e,a,_,s){e={s:["viensas secunds","'iensas secunds"],ss:[e+" secunds",e+" secunds"],m:["'n m\xedut","'iens m\xedut"],mm:[e+" m\xeduts",e+" m\xeduts"],h:["'n \xfeora","'iensa \xfeora"],hh:[e+" \xfeoras",e+" \xfeoras"],d:["'n ziua","'iensa ziua"],dd:[e+" ziuas",e+" ziuas"],M:["'n mes","'iens mes"],MM:[e+" mesen",e+" mesen"],y:["'n ar","'iens ar"],yy:[e+" ars",e+" ars"]};return s||a?e[_][0]:e[_][1]}function O(e,a,_){return "m"===_?a?"\u0445\u0432\u0438\u043b\u0438\u043d\u0430":"\u0445\u0432\u0438\u043b\u0438\u043d\u0443":"h"===_?a?"\u0433\u043e\u0434\u0438\u043d\u0430":"\u0433\u043e\u0434\u0438\u043d\u0443":e+" "+(e=+e,a=(a={ss:a?"\u0441\u0435\u043a\u0443\u043d\u0434\u0430_\u0441\u0435\u043a\u0443\u043d\u0434\u0438_\u0441\u0435\u043a\u0443\u043d\u0434":"\u0441\u0435\u043a\u0443\u043d\u0434\u0443_\u0441\u0435\u043a\u0443\u043d\u0434\u0438_\u0441\u0435\u043a\u0443\u043d\u0434",mm:a?"\u0445\u0432\u0438\u043b\u0438\u043d\u0430_\u0445\u0432\u0438\u043b\u0438\u043d\u0438_\u0445\u0432\u0438\u043b\u0438\u043d":"\u0445\u0432\u0438\u043b\u0438\u043d\u0443_\u0445\u0432\u0438\u043b\u0438\u043d\u0438_\u0445\u0432\u0438\u043b\u0438\u043d",hh:a?"\u0433\u043e\u0434\u0438\u043d\u0430_\u0433\u043e\u0434\u0438\u043d\u0438_\u0433\u043e\u0434\u0438\u043d":"\u0433\u043e\u0434\u0438\u043d\u0443_\u0433\u043e\u0434\u0438\u043d\u0438_\u0433\u043e\u0434\u0438\u043d",dd:"\u0434\u0435\u043d\u044c_\u0434\u043d\u0456_\u0434\u043d\u0456\u0432",MM:"\u043c\u0456\u0441\u044f\u0446\u044c_\u043c\u0456\u0441\u044f\u0446\u0456_\u043c\u0456\u0441\u044f\u0446\u0456\u0432",yy:"\u0440\u0456\u043a_\u0440\u043e\u043a\u0438_\u0440\u043e\u043a\u0456\u0432"}[_]).split("_"),e%10==1&&e%100!=11?a[0]:2<=e%10&&e%10<=4&&(e%100<10||20<=e%100)?a[1]:a[2])}function ia(e){return function(){return e+"\u043e"+(11===this.hours()?"\u0431":"")+"] LT"}}e.defineLocale("tr",{months:"Ocak_\u015eubat_Mart_Nisan_May\u0131s_Haziran_Temmuz_A\u011fustos_Eyl\xfcl_Ekim_Kas\u0131m_Aral\u0131k".split("_"),monthsShort:"Oca_\u015eub_Mar_Nis_May_Haz_Tem_A\u011fu_Eyl_Eki_Kas_Ara".split("_"),weekdays:"Pazar_Pazartesi_Sal\u0131_\xc7ar\u015famba_Per\u015fembe_Cuma_Cumartesi".split("_"),weekdaysShort:"Paz_Pzt_Sal_\xc7ar_Per_Cum_Cmt".split("_"),weekdaysMin:"Pz_Pt_Sa_\xc7a_Pe_Cu_Ct".split("_"),meridiem:function(e,a,_){return e<12?_?"\xf6\xf6":"\xd6\xd6":_?"\xf6s":"\xd6S"},meridiemParse:/\xf6\xf6|\xd6\xd6|\xf6s|\xd6S/,isPM:function(e){return "\xf6s"===e||"\xd6S"===e},longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[bug\xfcn saat] LT",nextDay:"[yar\u0131n saat] LT",nextWeek:"[gelecek] dddd [saat] LT",lastDay:"[d\xfcn] LT",lastWeek:"[ge\xe7en] dddd [saat] LT",sameElse:"L"},relativeTime:{future:"%s sonra",past:"%s \xf6nce",s:"birka\xe7 saniye",ss:"%d saniye",m:"bir dakika",mm:"%d dakika",h:"bir saat",hh:"%d saat",d:"bir g\xfcn",dd:"%d g\xfcn",w:"bir hafta",ww:"%d hafta",M:"bir ay",MM:"%d ay",y:"bir y\u0131l",yy:"%d y\u0131l"},ordinal:function(e,a){switch(a){case"d":case"D":case"Do":case"DD":return e;default:if(0===e)return e+"'\u0131nc\u0131";var _=e%10;return e+(ra[_]||ra[e%100-_]||ra[100<=e?100:null])}},week:{dow:1,doy:7}}),e.defineLocale("tzl",{months:"Januar_Fevraglh_Mar\xe7_Avr\xefu_Mai_G\xfcn_Julia_Guscht_Setemvar_Listop\xe4ts_Noemvar_Zecemvar".split("_"),monthsShort:"Jan_Fev_Mar_Avr_Mai_G\xfcn_Jul_Gus_Set_Lis_Noe_Zec".split("_"),weekdays:"S\xfaladi_L\xfane\xe7i_Maitzi_M\xe1rcuri_Xh\xfaadi_Vi\xe9ner\xe7i_S\xe1turi".split("_"),weekdaysShort:"S\xfal_L\xfan_Mai_M\xe1r_Xh\xfa_Vi\xe9_S\xe1t".split("_"),weekdaysMin:"S\xfa_L\xfa_Ma_M\xe1_Xh_Vi_S\xe1".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD.MM.YYYY",LL:"D. MMMM [dallas] YYYY",LLL:"D. MMMM [dallas] YYYY HH.mm",LLLL:"dddd, [li] D. MMMM [dallas] YYYY HH.mm"},meridiemParse:/d\'o|d\'a/i,isPM:function(e){return "d'o"===e.toLowerCase()},meridiem:function(e,a,_){return 11<e?_?"d'o":"D'O":_?"d'a":"D'A"},calendar:{sameDay:"[oxhi \xe0] LT",nextDay:"[dem\xe0 \xe0] LT",nextWeek:"dddd [\xe0] LT",lastDay:"[ieiri \xe0] LT",lastWeek:"[s\xfcr el] dddd [lasteu \xe0] LT",sameElse:"L"},relativeTime:{future:"osprei %s",past:"ja%s",s:A,ss:A,m:A,mm:A,h:A,hh:A,d:A,dd:A,M:A,MM:A,y:A,yy:A},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),e.defineLocale("tzm-latn",{months:"innayr_br\u02e4ayr\u02e4_mar\u02e4s\u02e4_ibrir_mayyw_ywnyw_ywlywz_\u0263w\u0161t_\u0161wtanbir_kt\u02e4wbr\u02e4_nwwanbir_dwjnbir".split("_"),monthsShort:"innayr_br\u02e4ayr\u02e4_mar\u02e4s\u02e4_ibrir_mayyw_ywnyw_ywlywz_\u0263w\u0161t_\u0161wtanbir_kt\u02e4wbr\u02e4_nwwanbir_dwjnbir".split("_"),weekdays:"asamas_aynas_asinas_akras_akwas_asimwas_asi\u1e0dyas".split("_"),weekdaysShort:"asamas_aynas_asinas_akras_akwas_asimwas_asi\u1e0dyas".split("_"),weekdaysMin:"asamas_aynas_asinas_akras_akwas_asimwas_asi\u1e0dyas".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[asdkh g] LT",nextDay:"[aska g] LT",nextWeek:"dddd [g] LT",lastDay:"[assant g] LT",lastWeek:"dddd [g] LT",sameElse:"L"},relativeTime:{future:"dadkh s yan %s",past:"yan %s",s:"imik",ss:"%d imik",m:"minu\u1e0d",mm:"%d minu\u1e0d",h:"sa\u025ba",hh:"%d tassa\u025bin",d:"ass",dd:"%d ossan",M:"ayowr",MM:"%d iyyirn",y:"asgas",yy:"%d isgasn"},week:{dow:6,doy:12}}),e.defineLocale("tzm",{months:"\u2d49\u2d4f\u2d4f\u2d30\u2d62\u2d54_\u2d31\u2d55\u2d30\u2d62\u2d55_\u2d4e\u2d30\u2d55\u2d5a_\u2d49\u2d31\u2d54\u2d49\u2d54_\u2d4e\u2d30\u2d62\u2d62\u2d53_\u2d62\u2d53\u2d4f\u2d62\u2d53_\u2d62\u2d53\u2d4d\u2d62\u2d53\u2d63_\u2d56\u2d53\u2d5b\u2d5c_\u2d5b\u2d53\u2d5c\u2d30\u2d4f\u2d31\u2d49\u2d54_\u2d3d\u2d5f\u2d53\u2d31\u2d55_\u2d4f\u2d53\u2d61\u2d30\u2d4f\u2d31\u2d49\u2d54_\u2d37\u2d53\u2d4a\u2d4f\u2d31\u2d49\u2d54".split("_"),monthsShort:"\u2d49\u2d4f\u2d4f\u2d30\u2d62\u2d54_\u2d31\u2d55\u2d30\u2d62\u2d55_\u2d4e\u2d30\u2d55\u2d5a_\u2d49\u2d31\u2d54\u2d49\u2d54_\u2d4e\u2d30\u2d62\u2d62\u2d53_\u2d62\u2d53\u2d4f\u2d62\u2d53_\u2d62\u2d53\u2d4d\u2d62\u2d53\u2d63_\u2d56\u2d53\u2d5b\u2d5c_\u2d5b\u2d53\u2d5c\u2d30\u2d4f\u2d31\u2d49\u2d54_\u2d3d\u2d5f\u2d53\u2d31\u2d55_\u2d4f\u2d53\u2d61\u2d30\u2d4f\u2d31\u2d49\u2d54_\u2d37\u2d53\u2d4a\u2d4f\u2d31\u2d49\u2d54".split("_"),weekdays:"\u2d30\u2d59\u2d30\u2d4e\u2d30\u2d59_\u2d30\u2d62\u2d4f\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4f\u2d30\u2d59_\u2d30\u2d3d\u2d54\u2d30\u2d59_\u2d30\u2d3d\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4e\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d39\u2d62\u2d30\u2d59".split("_"),weekdaysShort:"\u2d30\u2d59\u2d30\u2d4e\u2d30\u2d59_\u2d30\u2d62\u2d4f\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4f\u2d30\u2d59_\u2d30\u2d3d\u2d54\u2d30\u2d59_\u2d30\u2d3d\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4e\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d39\u2d62\u2d30\u2d59".split("_"),weekdaysMin:"\u2d30\u2d59\u2d30\u2d4e\u2d30\u2d59_\u2d30\u2d62\u2d4f\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4f\u2d30\u2d59_\u2d30\u2d3d\u2d54\u2d30\u2d59_\u2d30\u2d3d\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4e\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d39\u2d62\u2d30\u2d59".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u2d30\u2d59\u2d37\u2d45 \u2d34] LT",nextDay:"[\u2d30\u2d59\u2d3d\u2d30 \u2d34] LT",nextWeek:"dddd [\u2d34] LT",lastDay:"[\u2d30\u2d5a\u2d30\u2d4f\u2d5c \u2d34] LT",lastWeek:"dddd [\u2d34] LT",sameElse:"L"},relativeTime:{future:"\u2d37\u2d30\u2d37\u2d45 \u2d59 \u2d62\u2d30\u2d4f %s",past:"\u2d62\u2d30\u2d4f %s",s:"\u2d49\u2d4e\u2d49\u2d3d",ss:"%d \u2d49\u2d4e\u2d49\u2d3d",m:"\u2d4e\u2d49\u2d4f\u2d53\u2d3a",mm:"%d \u2d4e\u2d49\u2d4f\u2d53\u2d3a",h:"\u2d59\u2d30\u2d44\u2d30",hh:"%d \u2d5c\u2d30\u2d59\u2d59\u2d30\u2d44\u2d49\u2d4f",d:"\u2d30\u2d59\u2d59",dd:"%d o\u2d59\u2d59\u2d30\u2d4f",M:"\u2d30\u2d62o\u2d53\u2d54",MM:"%d \u2d49\u2d62\u2d62\u2d49\u2d54\u2d4f",y:"\u2d30\u2d59\u2d33\u2d30\u2d59",yy:"%d \u2d49\u2d59\u2d33\u2d30\u2d59\u2d4f"},week:{dow:6,doy:12}}),e.defineLocale("ug-cn",{months:"\u064a\u0627\u0646\u06cb\u0627\u0631_\u0641\u06d0\u06cb\u0631\u0627\u0644_\u0645\u0627\u0631\u062a_\u0626\u0627\u067e\u0631\u06d0\u0644_\u0645\u0627\u064a_\u0626\u0649\u064a\u06c7\u0646_\u0626\u0649\u064a\u06c7\u0644_\u0626\u0627\u06cb\u063a\u06c7\u0633\u062a_\u0633\u06d0\u0646\u062a\u06d5\u0628\u0649\u0631_\u0626\u06c6\u0643\u062a\u06d5\u0628\u0649\u0631_\u0646\u0648\u064a\u0627\u0628\u0649\u0631_\u062f\u06d0\u0643\u0627\u0628\u0649\u0631".split("_"),monthsShort:"\u064a\u0627\u0646\u06cb\u0627\u0631_\u0641\u06d0\u06cb\u0631\u0627\u0644_\u0645\u0627\u0631\u062a_\u0626\u0627\u067e\u0631\u06d0\u0644_\u0645\u0627\u064a_\u0626\u0649\u064a\u06c7\u0646_\u0626\u0649\u064a\u06c7\u0644_\u0626\u0627\u06cb\u063a\u06c7\u0633\u062a_\u0633\u06d0\u0646\u062a\u06d5\u0628\u0649\u0631_\u0626\u06c6\u0643\u062a\u06d5\u0628\u0649\u0631_\u0646\u0648\u064a\u0627\u0628\u0649\u0631_\u062f\u06d0\u0643\u0627\u0628\u0649\u0631".split("_"),weekdays:"\u064a\u06d5\u0643\u0634\u06d5\u0646\u0628\u06d5_\u062f\u06c8\u0634\u06d5\u0646\u0628\u06d5_\u0633\u06d5\u064a\u0634\u06d5\u0646\u0628\u06d5_\u0686\u0627\u0631\u0634\u06d5\u0646\u0628\u06d5_\u067e\u06d5\u064a\u0634\u06d5\u0646\u0628\u06d5_\u062c\u06c8\u0645\u06d5_\u0634\u06d5\u0646\u0628\u06d5".split("_"),weekdaysShort:"\u064a\u06d5_\u062f\u06c8_\u0633\u06d5_\u0686\u0627_\u067e\u06d5_\u062c\u06c8_\u0634\u06d5".split("_"),weekdaysMin:"\u064a\u06d5_\u062f\u06c8_\u0633\u06d5_\u0686\u0627_\u067e\u06d5_\u062c\u06c8_\u0634\u06d5".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY-\u064a\u0649\u0644\u0649M-\u0626\u0627\u064a\u0646\u0649\u06adD-\u0643\u06c8\u0646\u0649",LLL:"YYYY-\u064a\u0649\u0644\u0649M-\u0626\u0627\u064a\u0646\u0649\u06adD-\u0643\u06c8\u0646\u0649\u060c HH:mm",LLLL:"dddd\u060c YYYY-\u064a\u0649\u0644\u0649M-\u0626\u0627\u064a\u0646\u0649\u06adD-\u0643\u06c8\u0646\u0649\u060c HH:mm"},meridiemParse:/\u064a\u06d0\u0631\u0649\u0645 \u0643\u06d0\u0686\u06d5|\u0633\u06d5\u06be\u06d5\u0631|\u0686\u06c8\u0634\u062a\u0649\u0646 \u0628\u06c7\u0631\u06c7\u0646|\u0686\u06c8\u0634|\u0686\u06c8\u0634\u062a\u0649\u0646 \u0643\u06d0\u064a\u0649\u0646|\u0643\u06d5\u0686/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u064a\u06d0\u0631\u0649\u0645 \u0643\u06d0\u0686\u06d5"===a||"\u0633\u06d5\u06be\u06d5\u0631"===a||"\u0686\u06c8\u0634\u062a\u0649\u0646 \u0628\u06c7\u0631\u06c7\u0646"===a||"\u0686\u06c8\u0634\u062a\u0649\u0646 \u0643\u06d0\u064a\u0649\u0646"!==a&&"\u0643\u06d5\u0686"!==a&&11<=e?e:e+12},meridiem:function(e,a,_){e=100*e+a;return e<600?"\u064a\u06d0\u0631\u0649\u0645 \u0643\u06d0\u0686\u06d5":e<900?"\u0633\u06d5\u06be\u06d5\u0631":e<1130?"\u0686\u06c8\u0634\u062a\u0649\u0646 \u0628\u06c7\u0631\u06c7\u0646":e<1230?"\u0686\u06c8\u0634":e<1800?"\u0686\u06c8\u0634\u062a\u0649\u0646 \u0643\u06d0\u064a\u0649\u0646":"\u0643\u06d5\u0686"},calendar:{sameDay:"[\u0628\u06c8\u06af\u06c8\u0646 \u0633\u0627\u0626\u06d5\u062a] LT",nextDay:"[\u0626\u06d5\u062a\u06d5 \u0633\u0627\u0626\u06d5\u062a] LT",nextWeek:"[\u0643\u06d0\u0644\u06d5\u0631\u0643\u0649] dddd [\u0633\u0627\u0626\u06d5\u062a] LT",lastDay:"[\u062a\u06c6\u0646\u06c8\u06af\u06c8\u0646] LT",lastWeek:"[\u0626\u0627\u0644\u062f\u0649\u0646\u0642\u0649] dddd [\u0633\u0627\u0626\u06d5\u062a] LT",sameElse:"L"},relativeTime:{future:"%s \u0643\u06d0\u064a\u0649\u0646",past:"%s \u0628\u06c7\u0631\u06c7\u0646",s:"\u0646\u06d5\u0686\u0686\u06d5 \u0633\u06d0\u0643\u0648\u0646\u062a",ss:"%d \u0633\u06d0\u0643\u0648\u0646\u062a",m:"\u0628\u0649\u0631 \u0645\u0649\u0646\u06c7\u062a",mm:"%d \u0645\u0649\u0646\u06c7\u062a",h:"\u0628\u0649\u0631 \u0633\u0627\u0626\u06d5\u062a",hh:"%d \u0633\u0627\u0626\u06d5\u062a",d:"\u0628\u0649\u0631 \u0643\u06c8\u0646",dd:"%d \u0643\u06c8\u0646",M:"\u0628\u0649\u0631 \u0626\u0627\u064a",MM:"%d \u0626\u0627\u064a",y:"\u0628\u0649\u0631 \u064a\u0649\u0644",yy:"%d \u064a\u0649\u0644"},dayOfMonthOrdinalParse:/\d{1,2}(-\u0643\u06c8\u0646\u0649|-\u0626\u0627\u064a|-\u06be\u06d5\u067e\u062a\u06d5)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"-\u0643\u06c8\u0646\u0649";case"w":case"W":return e+"-\u06be\u06d5\u067e\u062a\u06d5";default:return e}},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:1,doy:7}}),e.defineLocale("uk",{months:{format:"\u0441\u0456\u0447\u043d\u044f_\u043b\u044e\u0442\u043e\u0433\u043e_\u0431\u0435\u0440\u0435\u0437\u043d\u044f_\u043a\u0432\u0456\u0442\u043d\u044f_\u0442\u0440\u0430\u0432\u043d\u044f_\u0447\u0435\u0440\u0432\u043d\u044f_\u043b\u0438\u043f\u043d\u044f_\u0441\u0435\u0440\u043f\u043d\u044f_\u0432\u0435\u0440\u0435\u0441\u043d\u044f_\u0436\u043e\u0432\u0442\u043d\u044f_\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434\u0430_\u0433\u0440\u0443\u0434\u043d\u044f".split("_"),standalone:"\u0441\u0456\u0447\u0435\u043d\u044c_\u043b\u044e\u0442\u0438\u0439_\u0431\u0435\u0440\u0435\u0437\u0435\u043d\u044c_\u043a\u0432\u0456\u0442\u0435\u043d\u044c_\u0442\u0440\u0430\u0432\u0435\u043d\u044c_\u0447\u0435\u0440\u0432\u0435\u043d\u044c_\u043b\u0438\u043f\u0435\u043d\u044c_\u0441\u0435\u0440\u043f\u0435\u043d\u044c_\u0432\u0435\u0440\u0435\u0441\u0435\u043d\u044c_\u0436\u043e\u0432\u0442\u0435\u043d\u044c_\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434_\u0433\u0440\u0443\u0434\u0435\u043d\u044c".split("_")},monthsShort:"\u0441\u0456\u0447_\u043b\u044e\u0442_\u0431\u0435\u0440_\u043a\u0432\u0456\u0442_\u0442\u0440\u0430\u0432_\u0447\u0435\u0440\u0432_\u043b\u0438\u043f_\u0441\u0435\u0440\u043f_\u0432\u0435\u0440_\u0436\u043e\u0432\u0442_\u043b\u0438\u0441\u0442_\u0433\u0440\u0443\u0434".split("_"),weekdays:function(e,a){var _={nominative:"\u043d\u0435\u0434\u0456\u043b\u044f_\u043f\u043e\u043d\u0435\u0434\u0456\u043b\u043e\u043a_\u0432\u0456\u0432\u0442\u043e\u0440\u043e\u043a_\u0441\u0435\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0435\u0440_\u043f\u2019\u044f\u0442\u043d\u0438\u0446\u044f_\u0441\u0443\u0431\u043e\u0442\u0430".split("_"),accusative:"\u043d\u0435\u0434\u0456\u043b\u044e_\u043f\u043e\u043d\u0435\u0434\u0456\u043b\u043e\u043a_\u0432\u0456\u0432\u0442\u043e\u0440\u043e\u043a_\u0441\u0435\u0440\u0435\u0434\u0443_\u0447\u0435\u0442\u0432\u0435\u0440_\u043f\u2019\u044f\u0442\u043d\u0438\u0446\u044e_\u0441\u0443\u0431\u043e\u0442\u0443".split("_"),genitive:"\u043d\u0435\u0434\u0456\u043b\u0456_\u043f\u043e\u043d\u0435\u0434\u0456\u043b\u043a\u0430_\u0432\u0456\u0432\u0442\u043e\u0440\u043a\u0430_\u0441\u0435\u0440\u0435\u0434\u0438_\u0447\u0435\u0442\u0432\u0435\u0440\u0433\u0430_\u043f\u2019\u044f\u0442\u043d\u0438\u0446\u0456_\u0441\u0443\u0431\u043e\u0442\u0438".split("_")};return !0===e?_.nominative.slice(1,7).concat(_.nominative.slice(0,1)):e?_[/(\[[\u0412\u0432\u0423\u0443]\]) ?dddd/.test(a)?"accusative":/\[?(?:\u043c\u0438\u043d\u0443\u043b\u043e\u0457|\u043d\u0430\u0441\u0442\u0443\u043f\u043d\u043e\u0457)? ?\] ?dddd/.test(a)?"genitive":"nominative"][e.day()]:_.nominative},weekdaysShort:"\u043d\u0434_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),weekdaysMin:"\u043d\u0434_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY \u0440.",LLL:"D MMMM YYYY \u0440., HH:mm",LLLL:"dddd, D MMMM YYYY \u0440., HH:mm"},calendar:{sameDay:ia("[\u0421\u044c\u043e\u0433\u043e\u0434\u043d\u0456 "),nextDay:ia("[\u0417\u0430\u0432\u0442\u0440\u0430 "),lastDay:ia("[\u0412\u0447\u043e\u0440\u0430 "),nextWeek:ia("[\u0423] dddd ["),lastWeek:function(){switch(this.day()){case 0:case 3:case 5:case 6:return ia("[\u041c\u0438\u043d\u0443\u043b\u043e\u0457] dddd [").call(this);case 1:case 2:case 4:return ia("[\u041c\u0438\u043d\u0443\u043b\u043e\u0433\u043e] dddd [").call(this)}},sameElse:"L"},relativeTime:{future:"\u0437\u0430 %s",past:"%s \u0442\u043e\u043c\u0443",s:"\u0434\u0435\u043a\u0456\u043b\u044c\u043a\u0430 \u0441\u0435\u043a\u0443\u043d\u0434",ss:O,m:O,mm:O,h:"\u0433\u043e\u0434\u0438\u043d\u0443",hh:O,d:"\u0434\u0435\u043d\u044c",dd:O,M:"\u043c\u0456\u0441\u044f\u0446\u044c",MM:O,y:"\u0440\u0456\u043a",yy:O},meridiemParse:/\u043d\u043e\u0447\u0456|\u0440\u0430\u043d\u043a\u0443|\u0434\u043d\u044f|\u0432\u0435\u0447\u043e\u0440\u0430/,isPM:function(e){return /^(\u0434\u043d\u044f|\u0432\u0435\u0447\u043e\u0440\u0430)$/.test(e)},meridiem:function(e,a,_){return e<4?"\u043d\u043e\u0447\u0456":e<12?"\u0440\u0430\u043d\u043a\u0443":e<17?"\u0434\u043d\u044f":"\u0432\u0435\u0447\u043e\u0440\u0430"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0439|\u0433\u043e)/,ordinal:function(e,a){switch(a){case"M":case"d":case"DDD":case"w":case"W":return e+"-\u0439";case"D":return e+"-\u0433\u043e";default:return e}},week:{dow:1,doy:7}});n=["\u062c\u0646\u0648\u0631\u06cc","\u0641\u0631\u0648\u0631\u06cc","\u0645\u0627\u0631\u0686","\u0627\u067e\u0631\u06cc\u0644","\u0645\u0626\u06cc","\u062c\u0648\u0646","\u062c\u0648\u0644\u0627\u0626\u06cc","\u0627\u06af\u0633\u062a","\u0633\u062a\u0645\u0628\u0631","\u0627\u06a9\u062a\u0648\u0628\u0631","\u0646\u0648\u0645\u0628\u0631","\u062f\u0633\u0645\u0628\u0631"],r=["\u0627\u062a\u0648\u0627\u0631","\u067e\u06cc\u0631","\u0645\u0646\u06af\u0644","\u0628\u062f\u06be","\u062c\u0645\u0639\u0631\u0627\u062a","\u062c\u0645\u0639\u06c1","\u06c1\u0641\u062a\u06c1"];return e.defineLocale("ur",{months:n,monthsShort:n,weekdays:r,weekdaysShort:r,weekdaysMin:r,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd\u060c D MMMM YYYY HH:mm"},meridiemParse:/\u0635\u0628\u062d|\u0634\u0627\u0645/,isPM:function(e){return "\u0634\u0627\u0645"===e},meridiem:function(e,a,_){return e<12?"\u0635\u0628\u062d":"\u0634\u0627\u0645"},calendar:{sameDay:"[\u0622\u062c \u0628\u0648\u0642\u062a] LT",nextDay:"[\u06a9\u0644 \u0628\u0648\u0642\u062a] LT",nextWeek:"dddd [\u0628\u0648\u0642\u062a] LT",lastDay:"[\u06af\u0630\u0634\u062a\u06c1 \u0631\u0648\u0632 \u0628\u0648\u0642\u062a] LT",lastWeek:"[\u06af\u0630\u0634\u062a\u06c1] dddd [\u0628\u0648\u0642\u062a] LT",sameElse:"L"},relativeTime:{future:"%s \u0628\u0639\u062f",past:"%s \u0642\u0628\u0644",s:"\u0686\u0646\u062f \u0633\u06cc\u06a9\u0646\u0688",ss:"%d \u0633\u06cc\u06a9\u0646\u0688",m:"\u0627\u06cc\u06a9 \u0645\u0646\u0679",mm:"%d \u0645\u0646\u0679",h:"\u0627\u06cc\u06a9 \u06af\u06be\u0646\u0679\u06c1",hh:"%d \u06af\u06be\u0646\u0679\u06d2",d:"\u0627\u06cc\u06a9 \u062f\u0646",dd:"%d \u062f\u0646",M:"\u0627\u06cc\u06a9 \u0645\u0627\u06c1",MM:"%d \u0645\u0627\u06c1",y:"\u0627\u06cc\u06a9 \u0633\u0627\u0644",yy:"%d \u0633\u0627\u0644"},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:1,doy:4}}),e.defineLocale("uz-latn",{months:"Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"),monthsShort:"Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"),weekdays:"Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"),weekdaysShort:"Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"),weekdaysMin:"Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"D MMMM YYYY, dddd HH:mm"},calendar:{sameDay:"[Bugun soat] LT [da]",nextDay:"[Ertaga] LT [da]",nextWeek:"dddd [kuni soat] LT [da]",lastDay:"[Kecha soat] LT [da]",lastWeek:"[O'tgan] dddd [kuni soat] LT [da]",sameElse:"L"},relativeTime:{future:"Yaqin %s ichida",past:"Bir necha %s oldin",s:"soniya",ss:"%d soniya",m:"bir daqiqa",mm:"%d daqiqa",h:"bir soat",hh:"%d soat",d:"bir kun",dd:"%d kun",M:"bir oy",MM:"%d oy",y:"bir yil",yy:"%d yil"},week:{dow:1,doy:7}}),e.defineLocale("uz",{months:"\u044f\u043d\u0432\u0430\u0440_\u0444\u0435\u0432\u0440\u0430\u043b_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0435\u043b_\u043c\u0430\u0439_\u0438\u044e\u043d_\u0438\u044e\u043b_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043d\u0442\u044f\u0431\u0440_\u043e\u043a\u0442\u044f\u0431\u0440_\u043d\u043e\u044f\u0431\u0440_\u0434\u0435\u043a\u0430\u0431\u0440".split("_"),monthsShort:"\u044f\u043d\u0432_\u0444\u0435\u0432_\u043c\u0430\u0440_\u0430\u043f\u0440_\u043c\u0430\u0439_\u0438\u044e\u043d_\u0438\u044e\u043b_\u0430\u0432\u0433_\u0441\u0435\u043d_\u043e\u043a\u0442_\u043d\u043e\u044f_\u0434\u0435\u043a".split("_"),weekdays:"\u042f\u043a\u0448\u0430\u043d\u0431\u0430_\u0414\u0443\u0448\u0430\u043d\u0431\u0430_\u0421\u0435\u0448\u0430\u043d\u0431\u0430_\u0427\u043e\u0440\u0448\u0430\u043d\u0431\u0430_\u041f\u0430\u0439\u0448\u0430\u043d\u0431\u0430_\u0416\u0443\u043c\u0430_\u0428\u0430\u043d\u0431\u0430".split("_"),weekdaysShort:"\u042f\u043a\u0448_\u0414\u0443\u0448_\u0421\u0435\u0448_\u0427\u043e\u0440_\u041f\u0430\u0439_\u0416\u0443\u043c_\u0428\u0430\u043d".split("_"),weekdaysMin:"\u042f\u043a_\u0414\u0443_\u0421\u0435_\u0427\u043e_\u041f\u0430_\u0416\u0443_\u0428\u0430".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"D MMMM YYYY, dddd HH:mm"},calendar:{sameDay:"[\u0411\u0443\u0433\u0443\u043d \u0441\u043e\u0430\u0442] LT [\u0434\u0430]",nextDay:"[\u042d\u0440\u0442\u0430\u0433\u0430] LT [\u0434\u0430]",nextWeek:"dddd [\u043a\u0443\u043d\u0438 \u0441\u043e\u0430\u0442] LT [\u0434\u0430]",lastDay:"[\u041a\u0435\u0447\u0430 \u0441\u043e\u0430\u0442] LT [\u0434\u0430]",lastWeek:"[\u0423\u0442\u0433\u0430\u043d] dddd [\u043a\u0443\u043d\u0438 \u0441\u043e\u0430\u0442] LT [\u0434\u0430]",sameElse:"L"},relativeTime:{future:"\u042f\u043a\u0438\u043d %s \u0438\u0447\u0438\u0434\u0430",past:"\u0411\u0438\u0440 \u043d\u0435\u0447\u0430 %s \u043e\u043b\u0434\u0438\u043d",s:"\u0444\u0443\u0440\u0441\u0430\u0442",ss:"%d \u0444\u0443\u0440\u0441\u0430\u0442",m:"\u0431\u0438\u0440 \u0434\u0430\u043a\u0438\u043a\u0430",mm:"%d \u0434\u0430\u043a\u0438\u043a\u0430",h:"\u0431\u0438\u0440 \u0441\u043e\u0430\u0442",hh:"%d \u0441\u043e\u0430\u0442",d:"\u0431\u0438\u0440 \u043a\u0443\u043d",dd:"%d \u043a\u0443\u043d",M:"\u0431\u0438\u0440 \u043e\u0439",MM:"%d \u043e\u0439",y:"\u0431\u0438\u0440 \u0439\u0438\u043b",yy:"%d \u0439\u0438\u043b"},week:{dow:1,doy:7}}),e.defineLocale("vi",{months:"th\xe1ng 1_th\xe1ng 2_th\xe1ng 3_th\xe1ng 4_th\xe1ng 5_th\xe1ng 6_th\xe1ng 7_th\xe1ng 8_th\xe1ng 9_th\xe1ng 10_th\xe1ng 11_th\xe1ng 12".split("_"),monthsShort:"Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12".split("_"),monthsParseExact:!0,weekdays:"ch\u1ee7 nh\u1eadt_th\u1ee9 hai_th\u1ee9 ba_th\u1ee9 t\u01b0_th\u1ee9 n\u0103m_th\u1ee9 s\xe1u_th\u1ee9 b\u1ea3y".split("_"),weekdaysShort:"CN_T2_T3_T4_T5_T6_T7".split("_"),weekdaysMin:"CN_T2_T3_T4_T5_T6_T7".split("_"),weekdaysParseExact:!0,meridiemParse:/sa|ch/i,isPM:function(e){return /^ch$/i.test(e)},meridiem:function(e,a,_){return e<12?_?"sa":"SA":_?"ch":"CH"},longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM [n\u0103m] YYYY",LLL:"D MMMM [n\u0103m] YYYY HH:mm",LLLL:"dddd, D MMMM [n\u0103m] YYYY HH:mm",l:"DD/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"},calendar:{sameDay:"[H\xf4m nay l\xfac] LT",nextDay:"[Ng\xe0y mai l\xfac] LT",nextWeek:"dddd [tu\u1ea7n t\u1edbi l\xfac] LT",lastDay:"[H\xf4m qua l\xfac] LT",lastWeek:"dddd [tu\u1ea7n tr\u01b0\u1edbc l\xfac] LT",sameElse:"L"},relativeTime:{future:"%s t\u1edbi",past:"%s tr\u01b0\u1edbc",s:"v\xe0i gi\xe2y",ss:"%d gi\xe2y",m:"m\u1ed9t ph\xfat",mm:"%d ph\xfat",h:"m\u1ed9t gi\u1edd",hh:"%d gi\u1edd",d:"m\u1ed9t ng\xe0y",dd:"%d ng\xe0y",w:"m\u1ed9t tu\u1ea7n",ww:"%d tu\u1ea7n",M:"m\u1ed9t th\xe1ng",MM:"%d th\xe1ng",y:"m\u1ed9t n\u0103m",yy:"%d n\u0103m"},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:function(e){return e},week:{dow:1,doy:4}}),e.defineLocale("x-pseudo",{months:"J~\xe1\xf1\xfa\xe1~r\xfd_F~\xe9br\xfa~\xe1r\xfd_~M\xe1rc~h_\xc1p~r\xedl_~M\xe1\xfd_~J\xfa\xf1\xe9~_J\xfal~\xfd_\xc1\xfa~g\xfast~_S\xe9p~t\xe9mb~\xe9r_\xd3~ct\xf3b~\xe9r_\xd1~\xf3v\xe9m~b\xe9r_~D\xe9c\xe9~mb\xe9r".split("_"),monthsShort:"J~\xe1\xf1_~F\xe9b_~M\xe1r_~\xc1pr_~M\xe1\xfd_~J\xfa\xf1_~J\xfal_~\xc1\xfag_~S\xe9p_~\xd3ct_~\xd1\xf3v_~D\xe9c".split("_"),monthsParseExact:!0,weekdays:"S~\xfa\xf1d\xe1~\xfd_M\xf3~\xf1d\xe1\xfd~_T\xfa\xe9~sd\xe1\xfd~_W\xe9d~\xf1\xe9sd~\xe1\xfd_T~h\xfars~d\xe1\xfd_~Fr\xedd~\xe1\xfd_S~\xe1t\xfar~d\xe1\xfd".split("_"),weekdaysShort:"S~\xfa\xf1_~M\xf3\xf1_~T\xfa\xe9_~W\xe9d_~Th\xfa_~Fr\xed_~S\xe1t".split("_"),weekdaysMin:"S~\xfa_M\xf3~_T\xfa_~W\xe9_T~h_Fr~_S\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[T~\xf3d\xe1~\xfd \xe1t] LT",nextDay:"[T~\xf3m\xf3~rr\xf3~w \xe1t] LT",nextWeek:"dddd [\xe1t] LT",lastDay:"[\xdd~\xe9st~\xe9rd\xe1~\xfd \xe1t] LT",lastWeek:"[L~\xe1st] dddd [\xe1t] LT",sameElse:"L"},relativeTime:{future:"\xed~\xf1 %s",past:"%s \xe1~g\xf3",s:"\xe1 ~f\xe9w ~s\xe9c\xf3~\xf1ds",ss:"%d s~\xe9c\xf3\xf1~ds",m:"\xe1 ~m\xed\xf1~\xfat\xe9",mm:"%d m~\xed\xf1\xfa~t\xe9s",h:"\xe1~\xf1 h\xf3~\xfar",hh:"%d h~\xf3\xfars",d:"\xe1 ~d\xe1\xfd",dd:"%d d~\xe1\xfds",M:"\xe1 ~m\xf3\xf1~th",MM:"%d m~\xf3\xf1t~hs",y:"\xe1 ~\xfd\xe9\xe1r",yy:"%d \xfd~\xe9\xe1rs"},dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1==a?"st":2==a?"nd":3==a?"rd":"th")},week:{dow:1,doy:4}}),e.defineLocale("yo",{months:"S\u1eb9\u0301r\u1eb9\u0301_E\u0300re\u0300le\u0300_\u1eb8r\u1eb9\u0300na\u0300_I\u0300gbe\u0301_E\u0300bibi_O\u0300ku\u0300du_Ag\u1eb9mo_O\u0300gu\u0301n_Owewe_\u1ecc\u0300wa\u0300ra\u0300_Be\u0301lu\u0301_\u1ecc\u0300p\u1eb9\u0300\u0300".split("_"),monthsShort:"S\u1eb9\u0301r_E\u0300rl_\u1eb8rn_I\u0300gb_E\u0300bi_O\u0300ku\u0300_Ag\u1eb9_O\u0300gu\u0301_Owe_\u1ecc\u0300wa\u0300_Be\u0301l_\u1ecc\u0300p\u1eb9\u0300\u0300".split("_"),weekdays:"A\u0300i\u0300ku\u0301_Aje\u0301_I\u0300s\u1eb9\u0301gun_\u1eccj\u1ecd\u0301ru\u0301_\u1eccj\u1ecd\u0301b\u1ecd_\u1eb8ti\u0300_A\u0300ba\u0301m\u1eb9\u0301ta".split("_"),weekdaysShort:"A\u0300i\u0300k_Aje\u0301_I\u0300s\u1eb9\u0301_\u1eccjr_\u1eccjb_\u1eb8ti\u0300_A\u0300ba\u0301".split("_"),weekdaysMin:"A\u0300i\u0300_Aj_I\u0300s_\u1eccr_\u1eccb_\u1eb8t_A\u0300b".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[O\u0300ni\u0300 ni] LT",nextDay:"[\u1ecc\u0300la ni] LT",nextWeek:"dddd [\u1eccs\u1eb9\u0300 to\u0301n'b\u1ecd] [ni] LT",lastDay:"[A\u0300na ni] LT",lastWeek:"dddd [\u1eccs\u1eb9\u0300 to\u0301l\u1ecd\u0301] [ni] LT",sameElse:"L"},relativeTime:{future:"ni\u0301 %s",past:"%s k\u1ecdja\u0301",s:"i\u0300s\u1eb9ju\u0301 aaya\u0301 die",ss:"aaya\u0301 %d",m:"i\u0300s\u1eb9ju\u0301 kan",mm:"i\u0300s\u1eb9ju\u0301 %d",h:"wa\u0301kati kan",hh:"wa\u0301kati %d",d:"\u1ecdj\u1ecd\u0301 kan",dd:"\u1ecdj\u1ecd\u0301 %d",M:"osu\u0300 kan",MM:"osu\u0300 %d",y:"\u1ecddu\u0301n kan",yy:"\u1ecddu\u0301n %d"},dayOfMonthOrdinalParse:/\u1ecdj\u1ecd\u0301\s\d{1,2}/,ordinal:"\u1ecdj\u1ecd\u0301 %d",week:{dow:1,doy:4}}),e.defineLocale("zh-cn",{months:"\u4e00\u6708_\u4e8c\u6708_\u4e09\u6708_\u56db\u6708_\u4e94\u6708_\u516d\u6708_\u4e03\u6708_\u516b\u6708_\u4e5d\u6708_\u5341\u6708_\u5341\u4e00\u6708_\u5341\u4e8c\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u661f\u671f\u65e5_\u661f\u671f\u4e00_\u661f\u671f\u4e8c_\u661f\u671f\u4e09_\u661f\u671f\u56db_\u661f\u671f\u4e94_\u661f\u671f\u516d".split("_"),weekdaysShort:"\u5468\u65e5_\u5468\u4e00_\u5468\u4e8c_\u5468\u4e09_\u5468\u56db_\u5468\u4e94_\u5468\u516d".split("_"),weekdaysMin:"\u65e5_\u4e00_\u4e8c_\u4e09_\u56db_\u4e94_\u516d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5Ah\u70b9mm\u5206",LLLL:"YYYY\u5e74M\u6708D\u65e5ddddAh\u70b9mm\u5206",l:"YYYY/M/D",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm"},meridiemParse:/\u51cc\u6668|\u65e9\u4e0a|\u4e0a\u5348|\u4e2d\u5348|\u4e0b\u5348|\u665a\u4e0a/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u51cc\u6668"===a||"\u65e9\u4e0a"===a||"\u4e0a\u5348"===a||"\u4e0b\u5348"!==a&&"\u665a\u4e0a"!==a&&11<=e?e:e+12},meridiem:function(e,a,_){e=100*e+a;return e<600?"\u51cc\u6668":e<900?"\u65e9\u4e0a":e<1130?"\u4e0a\u5348":e<1230?"\u4e2d\u5348":e<1800?"\u4e0b\u5348":"\u665a\u4e0a"},calendar:{sameDay:"[\u4eca\u5929]LT",nextDay:"[\u660e\u5929]LT",nextWeek:function(e){return e.week()!==this.week()?"[\u4e0b]dddLT":"[\u672c]dddLT"},lastDay:"[\u6628\u5929]LT",lastWeek:function(e){return this.week()!==e.week()?"[\u4e0a]dddLT":"[\u672c]dddLT"},sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(\u65e5|\u6708|\u5468)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\u65e5";case"M":return e+"\u6708";case"w":case"W":return e+"\u5468";default:return e}},relativeTime:{future:"%s\u540e",past:"%s\u524d",s:"\u51e0\u79d2",ss:"%d \u79d2",m:"1 \u5206\u949f",mm:"%d \u5206\u949f",h:"1 \u5c0f\u65f6",hh:"%d \u5c0f\u65f6",d:"1 \u5929",dd:"%d \u5929",w:"1 \u5468",ww:"%d \u5468",M:"1 \u4e2a\u6708",MM:"%d \u4e2a\u6708",y:"1 \u5e74",yy:"%d \u5e74"},week:{dow:1,doy:4}}),e.defineLocale("zh-hk",{months:"\u4e00\u6708_\u4e8c\u6708_\u4e09\u6708_\u56db\u6708_\u4e94\u6708_\u516d\u6708_\u4e03\u6708_\u516b\u6708_\u4e5d\u6708_\u5341\u6708_\u5341\u4e00\u6708_\u5341\u4e8c\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u661f\u671f\u65e5_\u661f\u671f\u4e00_\u661f\u671f\u4e8c_\u661f\u671f\u4e09_\u661f\u671f\u56db_\u661f\u671f\u4e94_\u661f\u671f\u516d".split("_"),weekdaysShort:"\u9031\u65e5_\u9031\u4e00_\u9031\u4e8c_\u9031\u4e09_\u9031\u56db_\u9031\u4e94_\u9031\u516d".split("_"),weekdaysMin:"\u65e5_\u4e00_\u4e8c_\u4e09_\u56db_\u4e94_\u516d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5 HH:mm",LLLL:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm",l:"YYYY/M/D",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm"},meridiemParse:/\u51cc\u6668|\u65e9\u4e0a|\u4e0a\u5348|\u4e2d\u5348|\u4e0b\u5348|\u665a\u4e0a/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u51cc\u6668"===a||"\u65e9\u4e0a"===a||"\u4e0a\u5348"===a?e:"\u4e2d\u5348"===a?11<=e?e:e+12:"\u4e0b\u5348"===a||"\u665a\u4e0a"===a?e+12:void 0},meridiem:function(e,a,_){e=100*e+a;return e<600?"\u51cc\u6668":e<900?"\u65e9\u4e0a":e<1200?"\u4e0a\u5348":1200===e?"\u4e2d\u5348":e<1800?"\u4e0b\u5348":"\u665a\u4e0a"},calendar:{sameDay:"[\u4eca\u5929]LT",nextDay:"[\u660e\u5929]LT",nextWeek:"[\u4e0b]ddddLT",lastDay:"[\u6628\u5929]LT",lastWeek:"[\u4e0a]ddddLT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(\u65e5|\u6708|\u9031)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\u65e5";case"M":return e+"\u6708";case"w":case"W":return e+"\u9031";default:return e}},relativeTime:{future:"%s\u5f8c",past:"%s\u524d",s:"\u5e7e\u79d2",ss:"%d \u79d2",m:"1 \u5206\u9418",mm:"%d \u5206\u9418",h:"1 \u5c0f\u6642",hh:"%d \u5c0f\u6642",d:"1 \u5929",dd:"%d \u5929",M:"1 \u500b\u6708",MM:"%d \u500b\u6708",y:"1 \u5e74",yy:"%d \u5e74"}}),e.defineLocale("zh-mo",{months:"\u4e00\u6708_\u4e8c\u6708_\u4e09\u6708_\u56db\u6708_\u4e94\u6708_\u516d\u6708_\u4e03\u6708_\u516b\u6708_\u4e5d\u6708_\u5341\u6708_\u5341\u4e00\u6708_\u5341\u4e8c\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u661f\u671f\u65e5_\u661f\u671f\u4e00_\u661f\u671f\u4e8c_\u661f\u671f\u4e09_\u661f\u671f\u56db_\u661f\u671f\u4e94_\u661f\u671f\u516d".split("_"),weekdaysShort:"\u9031\u65e5_\u9031\u4e00_\u9031\u4e8c_\u9031\u4e09_\u9031\u56db_\u9031\u4e94_\u9031\u516d".split("_"),weekdaysMin:"\u65e5_\u4e00_\u4e8c_\u4e09_\u56db_\u4e94_\u516d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5 HH:mm",LLLL:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm",l:"D/M/YYYY",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm"},meridiemParse:/\u51cc\u6668|\u65e9\u4e0a|\u4e0a\u5348|\u4e2d\u5348|\u4e0b\u5348|\u665a\u4e0a/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u51cc\u6668"===a||"\u65e9\u4e0a"===a||"\u4e0a\u5348"===a?e:"\u4e2d\u5348"===a?11<=e?e:e+12:"\u4e0b\u5348"===a||"\u665a\u4e0a"===a?e+12:void 0},meridiem:function(e,a,_){e=100*e+a;return e<600?"\u51cc\u6668":e<900?"\u65e9\u4e0a":e<1130?"\u4e0a\u5348":e<1230?"\u4e2d\u5348":e<1800?"\u4e0b\u5348":"\u665a\u4e0a"},calendar:{sameDay:"[\u4eca\u5929] LT",nextDay:"[\u660e\u5929] LT",nextWeek:"[\u4e0b]dddd LT",lastDay:"[\u6628\u5929] LT",lastWeek:"[\u4e0a]dddd LT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(\u65e5|\u6708|\u9031)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\u65e5";case"M":return e+"\u6708";case"w":case"W":return e+"\u9031";default:return e}},relativeTime:{future:"%s\u5167",past:"%s\u524d",s:"\u5e7e\u79d2",ss:"%d \u79d2",m:"1 \u5206\u9418",mm:"%d \u5206\u9418",h:"1 \u5c0f\u6642",hh:"%d \u5c0f\u6642",d:"1 \u5929",dd:"%d \u5929",M:"1 \u500b\u6708",MM:"%d \u500b\u6708",y:"1 \u5e74",yy:"%d \u5e74"}}),e.defineLocale("zh-tw",{months:"\u4e00\u6708_\u4e8c\u6708_\u4e09\u6708_\u56db\u6708_\u4e94\u6708_\u516d\u6708_\u4e03\u6708_\u516b\u6708_\u4e5d\u6708_\u5341\u6708_\u5341\u4e00\u6708_\u5341\u4e8c\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u661f\u671f\u65e5_\u661f\u671f\u4e00_\u661f\u671f\u4e8c_\u661f\u671f\u4e09_\u661f\u671f\u56db_\u661f\u671f\u4e94_\u661f\u671f\u516d".split("_"),weekdaysShort:"\u9031\u65e5_\u9031\u4e00_\u9031\u4e8c_\u9031\u4e09_\u9031\u56db_\u9031\u4e94_\u9031\u516d".split("_"),weekdaysMin:"\u65e5_\u4e00_\u4e8c_\u4e09_\u56db_\u4e94_\u516d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5 HH:mm",LLLL:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm",l:"YYYY/M/D",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm"},meridiemParse:/\u51cc\u6668|\u65e9\u4e0a|\u4e0a\u5348|\u4e2d\u5348|\u4e0b\u5348|\u665a\u4e0a/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u51cc\u6668"===a||"\u65e9\u4e0a"===a||"\u4e0a\u5348"===a?e:"\u4e2d\u5348"===a?11<=e?e:e+12:"\u4e0b\u5348"===a||"\u665a\u4e0a"===a?e+12:void 0},meridiem:function(e,a,_){e=100*e+a;return e<600?"\u51cc\u6668":e<900?"\u65e9\u4e0a":e<1130?"\u4e0a\u5348":e<1230?"\u4e2d\u5348":e<1800?"\u4e0b\u5348":"\u665a\u4e0a"},calendar:{sameDay:"[\u4eca\u5929] LT",nextDay:"[\u660e\u5929] LT",nextWeek:"[\u4e0b]dddd LT",lastDay:"[\u6628\u5929] LT",lastWeek:"[\u4e0a]dddd LT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(\u65e5|\u6708|\u9031)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\u65e5";case"M":return e+"\u6708";case"w":case"W":return e+"\u9031";default:return e}},relativeTime:{future:"%s\u5f8c",past:"%s\u524d",s:"\u5e7e\u79d2",ss:"%d \u79d2",m:"1 \u5206\u9418",mm:"%d \u5206\u9418",h:"1 \u5c0f\u6642",hh:"%d \u5c0f\u6642",d:"1 \u5929",dd:"%d \u5929",M:"1 \u500b\u6708",MM:"%d \u500b\u6708",y:"1 \u5e74",yy:"%d \u5e74"}}),e.locale("en"),e});
		
	} ());

	const setLocale = () => {
	  const currentLang = document.documentElement.lang;
	  const availableLocales = moment$1.locales();
	  if (availableLocales.includes(currentLang)) {
	    moment$1.locale(currentLang);
	  } else {
	    moment$1.locale('en');
	  }
	};
	setLocale();
	if (mpaData && mpaData.settings && typeof mpaData.settings.start_of_week !== 'undefined') {
	  moment$1.updateLocale(document.documentElement.lang.slice(0, 2), {
	    week: {
	      dow: mpaData.settings.start_of_week
	    }
	  });
	}

	function _typeof$1(obj) {
	  "@babel/helpers - typeof";

	  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  }, _typeof$1(obj);
	}

	function _toPrimitive$1(input, hint) {
	  if (_typeof$1(input) !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];
	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (_typeof$1(res) !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (hint === "string" ? String : Number)(input);
	}

	function _toPropertyKey$1(arg) {
	  var key = _toPrimitive$1(arg, "string");
	  return _typeof$1(key) === "symbol" ? key : String(key);
	}

	function _defineProperty$2(obj, key, value) {
	  key = _toPropertyKey$1(key);
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}

	function ownKeys$2(object, enumerableOnly) {
	  var keys = Object.keys(object);
	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    enumerableOnly && (symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    })), keys.push.apply(keys, symbols);
	  }
	  return keys;
	}
	function _objectSpread2$8(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = null != arguments[i] ? arguments[i] : {};
	    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
	      _defineProperty$2(target, key, source[key]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
	      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	    });
	  }
	  return target;
	}

	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;
	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }
	  return target;
	}

	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};
	  var target = _objectWithoutPropertiesLoose(source, excluded);
	  var key, i;
	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }
	  return target;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties$2(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
	  }
	}
	function _createClass$1(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties$2(Constructor, staticProps);
	  Object.defineProperty(Constructor, "prototype", {
	    writable: false
	  });
	  return Constructor;
	}

	function _setPrototypeOf$1(o, p) {
	  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };
	  return _setPrototypeOf$1(o, p);
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }
	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  Object.defineProperty(subClass, "prototype", {
	    writable: false
	  });
	  if (superClass) _setPrototypeOf$1(subClass, superClass);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;
	  try {
	    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _assertThisInitialized$1(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
	    return call;
	  } else if (call !== void 0) {
	    throw new TypeError("Derived constructors may only return object or undefined");
	  }
	  return _assertThisInitialized$1(self);
	}

	function _createSuper(Derived) {
	  var hasNativeReflectConstruct = _isNativeReflectConstruct();
	  return function _createSuperInternal() {
	    var Super = _getPrototypeOf(Derived),
	      result;
	    if (hasNativeReflectConstruct) {
	      var NewTarget = _getPrototypeOf(this).constructor;
	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }
	    return _possibleConstructorReturn(this, result);
	  };
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArrayLimit(arr, i) {
	  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
	  if (null != _i) {
	    var _s,
	      _e,
	      _x,
	      _r,
	      _arr = [],
	      _n = !0,
	      _d = !1;
	    try {
	      if (_x = (_i = _i.call(arr)).next, 0 === i) {
	        if (Object(_i) !== _i) return;
	        _n = !1;
	      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
	    } catch (err) {
	      _d = !0, _e = err;
	    } finally {
	      try {
	        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	    return _arr;
	  }
	}

	function _arrayLikeToArray$1(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;
	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	  return arr2;
	}

	function _unsupportedIterableToArray$1(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
	}

	function _extends$1() {
	  _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends$1.apply(this, arguments);
	}

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	var invariant_1 = invariant;

	var invariant$1 = /*@__PURE__*/getDefaultExportFromCjs(invariant_1);

	var noop$5 = function noop() {};

	function uncontrolledPropTypes(controlledValues, displayName) {
	  var propTypes = {};
	  Object.keys(controlledValues).forEach(function (prop) {
	    // add default propTypes for folks that use runtime checks
	    propTypes[defaultKey(prop)] = noop$5;
	  });
	  return propTypes;
	}
	function isProp(props, prop) {
	  return props[prop] !== undefined;
	}
	function defaultKey(key) {
	  return 'default' + key.charAt(0).toUpperCase() + key.substr(1);
	}
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	function canAcceptRef(component) {
	  return !!component && (typeof component !== 'function' || component.prototype && component.prototype.isReactComponent);
	}

	function useUncontrolledProp(propValue, defaultValue, handler) {
	  var wasPropRef = React$1.useRef(propValue !== undefined);

	  var _useState = React$1.useState(defaultValue),
	      stateValue = _useState[0],
	      setState = _useState[1];

	  var isProp = propValue !== undefined;
	  var wasProp = wasPropRef.current;
	  wasPropRef.current = isProp;
	  /**
	   * If a prop switches from controlled to Uncontrolled
	   * reset its value to the defaultValue
	   */

	  if (!isProp && wasProp && stateValue !== defaultValue) {
	    setState(defaultValue);
	  }

	  return [isProp ? propValue : stateValue, React$1.useCallback(function (value) {
	    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    if (handler) handler.apply(void 0, [value].concat(args));
	    setState(value);
	  }, [handler])];
	}

	function _inheritsLoose$1(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  _setPrototypeOf$1(subClass, superClass);
	}

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	function componentWillMount() {
	  // Call this.constructor.gDSFP to support sub-classes.
	  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
	  if (state !== null && state !== undefined) {
	    this.setState(state);
	  }
	}

	function componentWillReceiveProps(nextProps) {
	  // Call this.constructor.gDSFP to support sub-classes.
	  // Use the setState() updater to ensure state isn't stale in certain edge cases.
	  function updater(prevState) {
	    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
	    return state !== null && state !== undefined ? state : null;
	  }
	  // Binding "this" is important for shallow renderer support.
	  this.setState(updater.bind(this));
	}

	function componentWillUpdate(nextProps, nextState) {
	  try {
	    var prevProps = this.props;
	    var prevState = this.state;
	    this.props = nextProps;
	    this.state = nextState;
	    this.__reactInternalSnapshotFlag = true;
	    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
	      prevProps,
	      prevState
	    );
	  } finally {
	    this.props = prevProps;
	    this.state = prevState;
	  }
	}

	// React may warn about cWM/cWRP/cWU methods being deprecated.
	// Add a flag to suppress these warnings for this special case.
	componentWillMount.__suppressDeprecationWarning = true;
	componentWillReceiveProps.__suppressDeprecationWarning = true;
	componentWillUpdate.__suppressDeprecationWarning = true;

	function polyfill(Component) {
	  var prototype = Component.prototype;

	  if (!prototype || !prototype.isReactComponent) {
	    throw new Error('Can only polyfill class components');
	  }

	  if (
	    typeof Component.getDerivedStateFromProps !== 'function' &&
	    typeof prototype.getSnapshotBeforeUpdate !== 'function'
	  ) {
	    return Component;
	  }

	  // If new component APIs are defined, "unsafe" lifecycles won't be called.
	  // Error if any of these lifecycles are present,
	  // Because they would work differently between older and newer (16.3+) versions of React.
	  var foundWillMountName = null;
	  var foundWillReceivePropsName = null;
	  var foundWillUpdateName = null;
	  if (typeof prototype.componentWillMount === 'function') {
	    foundWillMountName = 'componentWillMount';
	  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
	    foundWillMountName = 'UNSAFE_componentWillMount';
	  }
	  if (typeof prototype.componentWillReceiveProps === 'function') {
	    foundWillReceivePropsName = 'componentWillReceiveProps';
	  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
	    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
	  }
	  if (typeof prototype.componentWillUpdate === 'function') {
	    foundWillUpdateName = 'componentWillUpdate';
	  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
	    foundWillUpdateName = 'UNSAFE_componentWillUpdate';
	  }
	  if (
	    foundWillMountName !== null ||
	    foundWillReceivePropsName !== null ||
	    foundWillUpdateName !== null
	  ) {
	    var componentName = Component.displayName || Component.name;
	    var newApiName =
	      typeof Component.getDerivedStateFromProps === 'function'
	        ? 'getDerivedStateFromProps()'
	        : 'getSnapshotBeforeUpdate()';

	    throw Error(
	      'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' +
	        componentName +
	        ' uses ' +
	        newApiName +
	        ' but also contains the following legacy lifecycles:' +
	        (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') +
	        (foundWillReceivePropsName !== null
	          ? '\n  ' + foundWillReceivePropsName
	          : '') +
	        (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') +
	        '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' +
	        'https://fb.me/react-async-component-lifecycle-hooks'
	    );
	  }

	  // React <= 16.2 does not support static getDerivedStateFromProps.
	  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
	  // Newer versions of React will ignore these lifecycles if gDSFP exists.
	  if (typeof Component.getDerivedStateFromProps === 'function') {
	    prototype.componentWillMount = componentWillMount;
	    prototype.componentWillReceiveProps = componentWillReceiveProps;
	  }

	  // React <= 16.2 does not support getSnapshotBeforeUpdate.
	  // As a workaround, use cWU to invoke the new lifecycle.
	  // Newer versions of React will ignore that lifecycle if gSBU exists.
	  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
	    if (typeof prototype.componentDidUpdate !== 'function') {
	      throw new Error(
	        'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'
	      );
	    }

	    prototype.componentWillUpdate = componentWillUpdate;

	    var componentDidUpdate = prototype.componentDidUpdate;

	    prototype.componentDidUpdate = function componentDidUpdatePolyfill(
	      prevProps,
	      prevState,
	      maybeSnapshot
	    ) {
	      // 16.3+ will not execute our will-update method;
	      // It will pass a snapshot value to did-update though.
	      // Older versions will require our polyfilled will-update value.
	      // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
	      // Because for <= 15.x versions this might be a "prevContext" object.
	      // We also can't just check "__reactInternalSnapshot",
	      // Because get-snapshot might return a falsy value.
	      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
	      var snapshot = this.__reactInternalSnapshotFlag
	        ? this.__reactInternalSnapshot
	        : maybeSnapshot;

	      componentDidUpdate.call(this, prevProps, prevState, snapshot);
	    };
	  }

	  return Component;
	}

	var _jsxFileName = "/Users/jquense/src/uncontrollable/src/uncontrollable.js";
	function uncontrollable(Component, controlledValues, methods) {
	  if (methods === void 0) {
	    methods = [];
	  }

	  var displayName = Component.displayName || Component.name || 'Component';
	  var canAcceptRef$1 = canAcceptRef(Component);
	  var controlledProps = Object.keys(controlledValues);
	  var PROPS_TO_OMIT = controlledProps.map(defaultKey);
	  !(canAcceptRef$1 || !methods.length) ? invariant$1(false) : void 0;

	  var UncontrolledComponent =
	  /*#__PURE__*/
	  function (_React$Component) {
	    _inheritsLoose$1(UncontrolledComponent, _React$Component);

	    function UncontrolledComponent() {
	      var _this;

	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
	      _this.handlers = Object.create(null);
	      controlledProps.forEach(function (propName) {
	        var handlerName = controlledValues[propName];

	        var handleChange = function handleChange(value) {
	          if (_this.props[handlerName]) {
	            var _this$props;

	            _this._notifying = true;

	            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	              args[_key2 - 1] = arguments[_key2];
	            }

	            (_this$props = _this.props)[handlerName].apply(_this$props, [value].concat(args));

	            _this._notifying = false;
	          }

	          if (!_this.unmounted) _this.setState(function (_ref) {
	            var _extends2;

	            var values = _ref.values;
	            return {
	              values: _extends$1(Object.create(null), values, (_extends2 = {}, _extends2[propName] = value, _extends2))
	            };
	          });
	        };

	        _this.handlers[handlerName] = handleChange;
	      });
	      if (methods.length) _this.attachRef = function (ref) {
	        _this.inner = ref;
	      };
	      var values = Object.create(null);
	      controlledProps.forEach(function (key) {
	        values[key] = _this.props[defaultKey(key)];
	      });
	      _this.state = {
	        values: values,
	        prevProps: {}
	      };
	      return _this;
	    }

	    var _proto = UncontrolledComponent.prototype;

	    _proto.shouldComponentUpdate = function shouldComponentUpdate() {
	      //let setState trigger the update
	      return !this._notifying;
	    };

	    UncontrolledComponent.getDerivedStateFromProps = function getDerivedStateFromProps(props, _ref2) {
	      var values = _ref2.values,
	          prevProps = _ref2.prevProps;
	      var nextState = {
	        values: _extends$1(Object.create(null), values),
	        prevProps: {}
	      };
	      controlledProps.forEach(function (key) {
	        /**
	         * If a prop switches from controlled to Uncontrolled
	         * reset its value to the defaultValue
	         */
	        nextState.prevProps[key] = props[key];

	        if (!isProp(props, key) && isProp(prevProps, key)) {
	          nextState.values[key] = props[defaultKey(key)];
	        }
	      });
	      return nextState;
	    };

	    _proto.componentWillUnmount = function componentWillUnmount() {
	      this.unmounted = true;
	    };

	    _proto.render = function render() {
	      var _this2 = this;

	      var _this$props2 = this.props,
	          innerRef = _this$props2.innerRef,
	          props = _objectWithoutPropertiesLoose(_this$props2, ["innerRef"]);

	      PROPS_TO_OMIT.forEach(function (prop) {
	        delete props[prop];
	      });
	      var newProps = {};
	      controlledProps.forEach(function (propName) {
	        var propValue = _this2.props[propName];
	        newProps[propName] = propValue !== undefined ? propValue : _this2.state.values[propName];
	      });
	      return React$1.createElement(Component, _extends$1({}, props, newProps, this.handlers, {
	        ref: innerRef || this.attachRef
	      }));
	    };

	    return UncontrolledComponent;
	  }(React$1.Component);

	  polyfill(UncontrolledComponent);
	  UncontrolledComponent.displayName = "Uncontrolled(" + displayName + ")";
	  UncontrolledComponent.propTypes = _extends$1({
	    innerRef: function innerRef() {}
	  }, uncontrolledPropTypes(controlledValues));
	  methods.forEach(function (method) {
	    UncontrolledComponent.prototype[method] = function $proxiedMethod() {
	      var _this$inner;

	      return (_this$inner = this.inner)[method].apply(_this$inner, arguments);
	    };
	  });
	  var WrappedComponent = UncontrolledComponent;

	  if (React$1.forwardRef) {
	    WrappedComponent = React$1.forwardRef(function (props, ref) {
	      return React$1.createElement(UncontrolledComponent, _extends$1({}, props, {
	        innerRef: ref,
	        __source: {
	          fileName: _jsxFileName,
	          lineNumber: 128
	        },
	        __self: this
	      }));
	    });
	    WrappedComponent.propTypes = UncontrolledComponent.propTypes;
	  }

	  WrappedComponent.ControlledComponent = Component;
	  /**
	   * useful when wrapping a Component and you want to control
	   * everything
	   */

	  WrappedComponent.deferControlTo = function (newComponent, additions, nextMethods) {
	    if (additions === void 0) {
	      additions = {};
	    }

	    return uncontrollable(newComponent, _extends$1({}, controlledValues, additions), nextMethods);
	  };

	  return WrappedComponent;
	}

	function r$1(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r$1(e[t]))&&(n&&(n+=" "),n+=f);else for(t in e)e[t]&&(n&&(n+=" "),n+=t);return n}function clsx(){for(var e,t,f=0,n="";f<arguments.length;)(e=arguments[f++])&&(t=r$1(e))&&(n&&(n+=" "),n+=t);return n}

	var clsx_m = /*#__PURE__*/Object.freeze({
		__proto__: null,
		clsx: clsx,
		default: clsx
	});

	var propTypes$8 = {exports: {}};

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var ReactPropTypesSecret$1 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var ReactPropTypesSecret = ReactPropTypesSecret_1;

	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;

	var factoryWithThrowingShims = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error(
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	    err.name = 'Invariant Violation';
	    throw err;
	  }  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bigint: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,

	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };

	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	{
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  propTypes$8.exports = factoryWithThrowingShims();
	}

	var propTypesExports = propTypes$8.exports;
	var PropTypes = /*@__PURE__*/getDefaultExportFromCjs(propTypesExports);

	var MILI    = 'milliseconds'
	  , SECONDS = 'seconds'
	  , MINUTES = 'minutes'
	  , HOURS   = 'hours'
	  , DAY     = 'day'
	  , WEEK    = 'week'
	  , MONTH   = 'month'
	  , YEAR    = 'year'
	  , DECADE  = 'decade'
	  , CENTURY = 'century';

	var multiplierMilli = {
	  'milliseconds': 1,
	  'seconds': 1000,
	  'minutes': 60 * 1000,
	  'hours': 60 * 60 * 1000,
	  'day': 24 * 60 * 60 * 1000,
	  'week': 7 * 24 * 60 * 60 * 1000 
	};

	var multiplierMonth = {
	  'month': 1,
	  'year': 12,
	  'decade': 10 * 12,
	  'century': 100 * 12
	};

	function daysOf(year) {
	  return [31, daysInFeb(year), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
	}

	function daysInFeb(year) {
	  return (
	      year % 4 === 0 
	      && year % 100 !== 0
	    ) || year % 400 === 0
	      ? 29
	      : 28
	}

	function add(d, num, unit) {
	  d = new Date(d);

	  switch (unit){
	    case MILI:
	    case SECONDS:
	    case MINUTES:
	    case HOURS:
	    case DAY:
	    case WEEK:
	      return addMillis(d, num * multiplierMilli[unit])
	    case MONTH:
	    case YEAR:
	    case DECADE:
	    case CENTURY:
	      return addMonths(d, num * multiplierMonth[unit])
	  }

	  throw new TypeError('Invalid units: "' + unit + '"')
	}

	function addMillis(d, num) {
	  var nextDate = new Date(+(d) + num);

	  return solveDST(d, nextDate)
	}

	function addMonths(d, num) {
	  var year = d.getFullYear()
	    , month = d.getMonth()
	    , day = d.getDate()
	    , totalMonths = year * 12 + month + num
	    , nextYear = Math.trunc(totalMonths / 12)
	    , nextMonth = totalMonths % 12
	    , nextDay = Math.min(day, daysOf(nextYear)[nextMonth]);

	  var nextDate = new Date(d);
	  nextDate.setFullYear(nextYear);

	  // To avoid a bug when sets the Feb month
	  // with a date > 28 or date > 29 (leap year)
	  nextDate.setDate(1);

	  nextDate.setMonth(nextMonth);
	  nextDate.setDate(nextDay);

	  return nextDate
	}

	function solveDST(currentDate, nextDate) {
	  var currentOffset = currentDate.getTimezoneOffset()
	    , nextOffset = nextDate.getTimezoneOffset();

	  // if is DST, add the difference in minutes
	  // else the difference is zero
	  var diffMinutes = (nextOffset - currentOffset);

	  return new Date(+(nextDate) + diffMinutes * multiplierMilli['minutes'])
	}

	function subtract(d, num, unit) {
	  return add(d, -num, unit)
	}

	function startOf(d, unit, firstOfWeek) {
	  d = new Date(d);

	  switch (unit) {
	    case CENTURY:
	    case DECADE:
	    case YEAR:
	        d = month(d, 0);
	    case MONTH:
	        d = date(d, 1);
	    case WEEK:
	    case DAY:
	        d = hours(d, 0);
	    case HOURS:
	        d = minutes(d, 0);
	    case MINUTES:
	        d = seconds(d, 0);
	    case SECONDS:
	        d = milliseconds(d, 0);
	  }

	  if (unit === DECADE)
	    d = subtract(d, year(d) % 10, 'year');

	  if (unit === CENTURY)
	    d = subtract(d, year(d) % 100, 'year');

	  if (unit === WEEK)
	    d = weekday(d, 0, firstOfWeek);

	  return d
	}

	function endOf(d, unit, firstOfWeek){
	  d = new Date(d);
	  d = startOf(d, unit, firstOfWeek);
	  switch (unit) {
	    case CENTURY:
	    case DECADE:
	    case YEAR:
	    case MONTH:
	    case WEEK:
	      d = add(d, 1, unit);
	      d = subtract(d, 1, DAY);
	      d.setHours(23, 59, 59, 999);
	      break;
	    case DAY:
	      d.setHours(23, 59, 59, 999);
	      break;
	    case HOURS:
	    case MINUTES:
	    case SECONDS:
	      d = add(d, 1, unit);
	      d = subtract(d, 1, MILI);
	  }
	  return d
	}

	var eq$6 =  createComparer(function(a, b){ return a === b });
	var neq = createComparer(function(a, b){ return a !== b });
	var gt =  createComparer(function(a, b){ return a > b });
	var gte = createComparer(function(a, b){ return a >= b });
	var lt =  createComparer(function(a, b){ return a < b });
	var lte = createComparer(function(a, b){ return a <= b });

	function min$2(){
	  return new Date(Math.min.apply(Math, arguments))
	}

	function max$2(){
	  return new Date(Math.max.apply(Math, arguments))
	}

	function inRange$2(day, min, max, unit){
	  unit = unit || 'day';

	  return (!min || gte(day, min, unit))
	      && (!max || lte(day, max, unit))
	}

	var milliseconds = createAccessor('Milliseconds');
	var seconds =      createAccessor('Seconds');
	var minutes =      createAccessor('Minutes');
	var hours =        createAccessor('Hours');
	var day =          createAccessor('Day');
	var date =         createAccessor('Date');
	var month =        createAccessor('Month');
	var year =         createAccessor('FullYear');

	function weekday(d, val, firstDay) {
	    var w = (day(d) + 7 - (firstDay || 0) ) % 7;

	    return val === undefined
	      ? w
	      : add(d, val - w, DAY);
	}

	function createAccessor(method){
	  var hourLength = (function(method) {  
	    switch(method) {
	      case 'Milliseconds':
	        return 3600000;
	      case 'Seconds':
	        return 3600;
	      case 'Minutes':
	        return 60;
	      case 'Hours':
	        return 1;
	      default:
	        return null;
	    }
	  })(method);
	  
	  return function(d, val){
	    if (val === undefined)
	      return d['get' + method]()

	    var dateOut = new Date(d);
	    dateOut['set' + method](val);
	    
	    if(hourLength && dateOut['get'+method]() != val && (method === 'Hours' || val >=hourLength && (dateOut.getHours()-d.getHours()<Math.floor(val/hourLength))) ){
	      //Skip DST hour, if it occurs
	      dateOut['set'+method](val+hourLength);
	    }
	    
	    return dateOut
	  }
	}

	function createComparer(operator) {
	  return function (a, b, unit) {
	    return operator(+startOf(a, unit), +startOf(b, unit))
	  };
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
	}

	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice$2(array, start, end) {
	  var index = -1,
	      length = array.length;

	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = end > length ? length : end;
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;

	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq$5(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var global$1 = (typeof global !== "undefined" ? global :
	  typeof self !== "undefined" ? self :
	  typeof window !== "undefined" ? window : {});

	/** Detect free variable `global` from Node.js. */
	var freeGlobal$2 = typeof global$1 == 'object' && global$1 && global$1.Object === Object && global$1;

	var freeGlobal$3 = freeGlobal$2;

	/** Detect free variable `self`. */
	var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root$9 = freeGlobal$3 || freeSelf$1 || Function('return this')();

	var root$a = root$9;

	/** Built-in value references. */
	var Symbol$7 = root$a.Symbol;

	var Symbol$8 = Symbol$7;

	/** Used for built-in method references. */
	var objectProto$s = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$n = objectProto$s.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$3 = objectProto$s.toString;

	/** Built-in value references. */
	var symToStringTag$3 = Symbol$8 ? Symbol$8.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag$2(value) {
	  var isOwn = hasOwnProperty$n.call(value, symToStringTag$3),
	      tag = value[symToStringTag$3];

	  try {
	    value[symToStringTag$3] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString$3.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$3] = tag;
	    } else {
	      delete value[symToStringTag$3];
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$r = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$2 = objectProto$r.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString$2(value) {
	  return nativeObjectToString$2.call(value);
	}

	/** `Object#toString` result references. */
	var nullTag$1 = '[object Null]',
	    undefinedTag$1 = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$2 = Symbol$8 ? Symbol$8.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag$6(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag$1 : nullTag$1;
	  }
	  return (symToStringTag$2 && symToStringTag$2 in Object(value))
	    ? getRawTag$2(value)
	    : objectToString$2(value);
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject$7(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/** `Object#toString` result references. */
	var asyncTag$1 = '[object AsyncFunction]',
	    funcTag$4 = '[object Function]',
	    genTag$2 = '[object GeneratorFunction]',
	    proxyTag$1 = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction$6(value) {
	  if (!isObject$7(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag$6(value);
	  return tag == funcTag$4 || tag == genTag$2 || tag == asyncTag$1 || tag == proxyTag$1;
	}

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$3 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength$4(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$3;
	}

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike$5(value) {
	  return value != null && isLength$4(value.length) && !isFunction$6(value);
	}

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$2 = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint$1 = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex$4(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER$2 : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint$1.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall$4(value, index, object) {
	  if (!isObject$7(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike$5(object) && isIndex$4(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq$5(object[index], value);
	  }
	  return false;
	}

	/** Used to match a single whitespace character. */
	var reWhitespace$1 = /\s/;

	/**
	 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
	 * character of `string`.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {number} Returns the index of the last non-whitespace character.
	 */
	function trimmedEndIndex$2(string) {
	  var index = string.length;

	  while (index-- && reWhitespace$1.test(string.charAt(index))) {}
	  return index;
	}

	/** Used to match leading whitespace. */
	var reTrimStart$1 = /^\s+/;

	/**
	 * The base implementation of `_.trim`.
	 *
	 * @private
	 * @param {string} string The string to trim.
	 * @returns {string} Returns the trimmed string.
	 */
	function baseTrim$2(string) {
	  return string
	    ? string.slice(0, trimmedEndIndex$2(string) + 1).replace(reTrimStart$1, '')
	    : string;
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike$6(value) {
	  return value != null && typeof value == 'object';
	}

	/** `Object#toString` result references. */
	var symbolTag$5 = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol$6(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike$6(value) && baseGetTag$6(value) == symbolTag$5);
	}

	/** Used as references for various `Number` constants. */
	var NAN$1 = 0 / 0;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary$1 = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal$1 = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt$1 = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber$2(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol$6(value)) {
	    return NAN$1;
	  }
	  if (isObject$7(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject$7(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = baseTrim$2(value);
	  var isBinary = reIsBinary$1.test(value);
	  return (isBinary || reIsOctal$1.test(value))
	    ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex$1.test(value) ? NAN$1 : +value);
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$5 = 1 / 0,
	    MAX_INTEGER$1 = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite$3(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber$2(value);
	  if (value === INFINITY$5 || value === -INFINITY$5) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER$1;
	  }
	  return value === value ? value : 0;
	}

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger$3(value) {
	  var result = toFinite$3(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil$3 = Math.ceil,
	    nativeMax$7 = Math.max;

	/**
	 * Creates an array of elements split into groups the length of `size`.
	 * If `array` can't be split evenly, the final chunk will be the remaining
	 * elements.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to process.
	 * @param {number} [size=1] The length of each chunk
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the new array of chunks.
	 * @example
	 *
	 * _.chunk(['a', 'b', 'c', 'd'], 2);
	 * // => [['a', 'b'], ['c', 'd']]
	 *
	 * _.chunk(['a', 'b', 'c', 'd'], 3);
	 * // => [['a', 'b', 'c'], ['d']]
	 */
	function chunk$1(array, size, guard) {
	  if ((guard ? isIterateeCall$4(array, size, guard) : size === undefined)) {
	    size = 1;
	  } else {
	    size = nativeMax$7(toInteger$3(size), 0);
	  }
	  var length = array == null ? 0 : array.length;
	  if (!length || size < 1) {
	    return [];
	  }
	  var index = 0,
	      resIndex = 0,
	      result = Array(nativeCeil$3(length / size));

	  while (index < length) {
	    result[resIndex++] = baseSlice$2(array, index, (index += size));
	  }
	  return result;
	}

	/**
	 * Returns the owner document of a given element.
	 * 
	 * @param node the element
	 */
	function ownerDocument$1(node) {
	  return node && node.ownerDocument || document;
	}

	/**
	 * Returns the owner window of a given element.
	 * 
	 * @param node the element
	 */

	function ownerWindow(node) {
	  var doc = ownerDocument$1(node);
	  return doc && doc.defaultView || window;
	}

	/**
	 * Returns one or all computed style properties of an element.
	 * 
	 * @param node the element
	 * @param psuedoElement the style property
	 */

	function getComputedStyle$3(node, psuedoElement) {
	  return ownerWindow(node).getComputedStyle(node, psuedoElement);
	}

	var rUpper = /([A-Z])/g;
	function hyphenate(string) {
	  return string.replace(rUpper, '-$1').toLowerCase();
	}

	/**
	 * Copyright 2013-2014, Facebook, Inc.
	 * All rights reserved.
	 * https://github.com/facebook/react/blob/2aeb8a2a6beb00617a4217f7f8284924fa2ad819/src/vendor/core/hyphenateStyleName.js
	 */
	var msPattern = /^ms-/;
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}

	var supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i;
	function isTransform(value) {
	  return !!(value && supportedTransforms.test(value));
	}

	function style(node, property) {
	  var css = '';
	  var transforms = '';

	  if (typeof property === 'string') {
	    return node.style.getPropertyValue(hyphenateStyleName(property)) || getComputedStyle$3(node).getPropertyValue(hyphenateStyleName(property));
	  }

	  Object.keys(property).forEach(function (key) {
	    var value = property[key];

	    if (!value && value !== 0) {
	      node.style.removeProperty(hyphenateStyleName(key));
	    } else if (isTransform(key)) {
	      transforms += key + "(" + value + ") ";
	    } else {
	      css += hyphenateStyleName(key) + ": " + value + ";";
	    }
	  });

	  if (transforms) {
	    css += "transform: " + transforms + ";";
	  }

	  node.style.cssText += ";" + css;
	}

	/* eslint-disable no-bitwise, no-cond-assign */

	/**
	 * Checks if an element contains another given element.
	 * 
	 * @param context the context element
	 * @param node the element to check
	 */
	function contains$1(context, node) {
	  // HTML DOM and SVG DOM may have different support levels,
	  // so we need to check on context instead of a document root element.
	  if (context.contains) return context.contains(node);
	  if (context.compareDocumentPosition) return context === node || !!(context.compareDocumentPosition(node) & 16);
	}

	var contains$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: contains$1
	});

	function isDocument(element) {
	  return 'nodeType' in element && element.nodeType === document.DOCUMENT_NODE;
	}

	function isWindow(node) {
	  if ('window' in node && node.window === node) return node;
	  if (isDocument(node)) return node.defaultView || false;
	  return false;
	}

	function getscrollAccessor(offset) {
	  var prop = offset === 'pageXOffset' ? 'scrollLeft' : 'scrollTop';

	  function scrollAccessor(node, val) {
	    var win = isWindow(node);

	    if (val === undefined) {
	      return win ? win[offset] : node[prop];
	    }

	    if (win) {
	      win.scrollTo(win[offset], val);
	    } else {
	      node[prop] = val;
	    }
	  }

	  return scrollAccessor;
	}

	/**
	 * Gets or sets the scroll left position of a given element.
	 * 
	 * @param node the element
	 * @param val the position to set
	 */

	var scrollLeft = getscrollAccessor('pageXOffset');

	/**
	 * Gets or sets the scroll top position of a given element.
	 * 
	 * @param node the element
	 * @param val the position to set
	 */

	var scrollTop = getscrollAccessor('pageYOffset');

	/**
	 * Returns the offset of a given element, including top and left positions, width and height.
	 * 
	 * @param node the element
	 */

	function offset$2(node) {
	  var doc = ownerDocument$1(node);
	  var box = {
	    top: 0,
	    left: 0,
	    height: 0,
	    width: 0
	  };
	  var docElem = doc && doc.documentElement; // Make sure it's not a disconnected DOM node

	  if (!docElem || !contains$1(docElem, node)) return box;
	  if (node.getBoundingClientRect !== undefined) box = node.getBoundingClientRect();
	  box = {
	    top: box.top + scrollTop(docElem) - (docElem.clientTop || 0),
	    left: box.left + scrollLeft(docElem) - (docElem.clientLeft || 0),
	    width: box.width,
	    height: box.height
	  };
	  return box;
	}

	var offset$3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: offset$2
	});

	var isHTMLElement$2 = function isHTMLElement(e) {
	  return !!e && 'offsetParent' in e;
	};

	function offsetParent(node) {
	  var doc = ownerDocument$1(node);
	  var parent = node && node.offsetParent;

	  while (isHTMLElement$2(parent) && parent.nodeName !== 'HTML' && style(parent, 'position') === 'static') {
	    parent = parent.offsetParent;
	  }

	  return parent || doc.documentElement;
	}

	var nodeName = function nodeName(node) {
	  return node.nodeName && node.nodeName.toLowerCase();
	};
	/**
	 * Returns the relative position of a given element.
	 * 
	 * @param node the element
	 * @param offsetParent the offset parent
	 */


	function position$1(node, offsetParent$1) {
	  var parentOffset = {
	    top: 0,
	    left: 0
	  };
	  var offset; // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
	  // because it is its only offset parent

	  if (style(node, 'position') === 'fixed') {
	    offset = node.getBoundingClientRect();
	  } else {
	    var parent = offsetParent$1 || offsetParent(node);
	    offset = offset$2(node);
	    if (nodeName(parent) !== 'html') parentOffset = offset$2(parent);
	    var borderTop = String(style(parent, 'borderTopWidth') || 0);
	    parentOffset.top += parseInt(borderTop, 10) - scrollTop(parent) || 0;
	    var borderLeft = String(style(parent, 'borderLeftWidth') || 0);
	    parentOffset.left += parseInt(borderLeft, 10) - scrollLeft(parent) || 0;
	  }

	  var marginTop = String(style(node, 'marginTop') || 0);
	  var marginLeft = String(style(node, 'marginLeft') || 0); // Subtract parent offsets and node margins

	  return _extends$1({}, offset, {
	    top: offset.top - parentOffset.top - (parseInt(marginTop, 10) || 0),
	    left: offset.left - parentOffset.left - (parseInt(marginLeft, 10) || 0)
	  });
	}

	var position$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: position$1
	});

	var canUseDOM$1 = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

	/* https://github.com/component/raf */
	var prev$1 = new Date().getTime();

	function fallback(fn) {
	  var curr = new Date().getTime();
	  var ms = Math.max(0, 16 - (curr - prev$1));
	  var handle = setTimeout(fn, ms);
	  prev$1 = curr;
	  return handle;
	}

	var vendors = ['', 'webkit', 'moz', 'o', 'ms'];
	var cancelMethod = 'clearTimeout';
	var rafImpl = fallback; // eslint-disable-next-line import/no-mutable-exports

	var getKey$2 = function getKey(vendor, k) {
	  return vendor + (!vendor ? k : k[0].toUpperCase() + k.substr(1)) + "AnimationFrame";
	};

	if (canUseDOM$1) {
	  vendors.some(function (vendor) {
	    var rafMethod = getKey$2(vendor, 'request');

	    if (rafMethod in window) {
	      cancelMethod = getKey$2(vendor, 'cancel'); // @ts-ignore

	      rafImpl = function rafImpl(cb) {
	        return window[rafMethod](cb);
	      };
	    }

	    return !!rafImpl;
	  });
	}

	var cancel = function cancel(id) {
	  // @ts-ignore
	  if (typeof window[cancelMethod] === 'function') window[cancelMethod](id);
	};
	var request = rafImpl;

	var animationFrame$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		cancel: cancel,
		request: request
	});

	var matchesImpl;
	/**
	 * Checks if a given element matches a selector.
	 * 
	 * @param node the element
	 * @param selector the selector
	 */

	function matches(node, selector) {
	  if (!matchesImpl) {
	    var body = document.body;
	    var nativeMatch = body.matches || body.matchesSelector || body.webkitMatchesSelector || body.mozMatchesSelector || body.msMatchesSelector;

	    matchesImpl = function matchesImpl(n, s) {
	      return nativeMatch.call(n, s);
	    };
	  }

	  return matchesImpl(node, selector);
	}

	var toArray$1 = Function.prototype.bind.call(Function.prototype.call, [].slice);
	/**
	 * Runs `querySelectorAll` on a given element.
	 * 
	 * @param element the element
	 * @param selector the selector
	 */

	function qsa(element, selector) {
	  return toArray$1(element.querySelectorAll(selector));
	}

	var querySelectorAll = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: qsa
	});

	/* eslint-disable no-return-assign */
	var optionsSupported = false;
	var onceSupported = false;

	try {
	  var options$1 = {
	    get passive() {
	      return optionsSupported = true;
	    },

	    get once() {
	      // eslint-disable-next-line no-multi-assign
	      return onceSupported = optionsSupported = true;
	    }

	  };

	  if (canUseDOM$1) {
	    window.addEventListener('test', options$1, options$1);
	    window.removeEventListener('test', options$1, true);
	  }
	} catch (e) {
	  /* */
	}

	/**
	 * An `addEventListener` ponyfill, supports the `once` option
	 * 
	 * @param node the element
	 * @param eventName the event name
	 * @param handle the handler
	 * @param options event options
	 */
	function addEventListener$2(node, eventName, handler, options) {
	  if (options && typeof options !== 'boolean' && !onceSupported) {
	    var once = options.once,
	        capture = options.capture;
	    var wrappedHandler = handler;

	    if (!onceSupported && once) {
	      wrappedHandler = handler.__once || function onceHandler(event) {
	        this.removeEventListener(eventName, onceHandler, capture);
	        handler.call(this, event);
	      };

	      handler.__once = wrappedHandler;
	    }

	    node.addEventListener(eventName, wrappedHandler, optionsSupported ? options : capture);
	  }

	  node.addEventListener(eventName, handler, options);
	}

	/**
	 * Store the last of some value. Tracked via a `Ref` only updating it
	 * after the component renders.
	 *
	 * Helpful if you need to compare a prop value to it's previous value during render.
	 *
	 * ```ts
	 * function Component(props) {
	 *   const lastProps = usePrevious(props)
	 *
	 *   if (lastProps.foo !== props.foo)
	 *     resetValueFromProps(props.foo)
	 * }
	 * ```
	 *
	 * @param value the value to track
	 */

	function usePrevious(value) {
	  var ref = React$1.useRef(null);
	  React$1.useEffect(function () {
	    ref.current = value;
	  });
	  return ref.current;
	}

	/**
	 * Returns a function that triggers a component update. the hook equivalent to
	 * `this.forceUpdate()` in a class component. In most cases using a state value directly
	 * is preferable but may be required in some advanced usages of refs for interop or
	 * when direct DOM manipulation is required.
	 *
	 * ```ts
	 * const forceUpdate = useForceUpdate();
	 *
	 * const updateOnClick = useCallback(() => {
	 *  forceUpdate()
	 * }, [forceUpdate])
	 *
	 * return <button type="button" onClick={updateOnClick}>Hi there</button>
	 * ```
	 */

	function useForceUpdate() {
	  // The toggling state value is designed to defeat React optimizations for skipping
	  // updates when they are stricting equal to the last state value
	  var _useReducer = React$1.useReducer(function (state) {
	    return !state;
	  }, false),
	      dispatch = _useReducer[1];

	  return dispatch;
	}

	/**
	 * Creates a `Ref` whose value is updated in an effect, ensuring the most recent
	 * value is the one rendered with. Generally only required for Concurrent mode usage
	 * where previous work in `render()` may be discarded before being used.
	 *
	 * This is safe to access in an event handler.
	 *
	 * @param value The `Ref` value
	 */

	function useCommittedRef(value) {
	  var ref = React$1.useRef(value);
	  React$1.useEffect(function () {
	    ref.current = value;
	  }, [value]);
	  return ref;
	}

	function useEventCallback(fn) {
	  var ref = useCommittedRef(fn);
	  return React$1.useCallback(function () {
	    return ref.current && ref.current.apply(ref, arguments);
	  }, [ref]);
	}

	/**
	 * Attaches an event handler outside directly to specified DOM element
	 * bypassing the react synthetic event system.
	 *
	 * @param element The target to listen for events on
	 * @param event The DOM event name
	 * @param handler An event handler
	 * @param capture Whether or not to listen during the capture event phase
	 */
	function useEventListener(eventTarget, event, listener, capture) {
	  if (capture === void 0) {
	    capture = false;
	  }

	  var handler = useEventCallback(listener);
	  React$1.useEffect(function () {
	    var target = typeof eventTarget === 'function' ? eventTarget() : eventTarget;
	    target.addEventListener(event, handler, capture);
	    return function () {
	      return target.removeEventListener(event, handler, capture);
	    };
	  }, [eventTarget]);
	}

	/**
	 * Attaches an event handler outside directly to the `document`,
	 * bypassing the react synthetic event system.
	 *
	 * ```ts
	 * useGlobalListener('keydown', (event) => {
	 *  console.log(event.key)
	 * })
	 * ```
	 *
	 * @param event The DOM event name
	 * @param handler An event handler
	 * @param capture Whether or not to listen during the capture event phase
	 */
	function useGlobalListener(event, handler, capture) {
	  if (capture === void 0) {
	    capture = false;
	  }

	  var documentTarget = React$1.useCallback(function () {
	    return document;
	  }, []);
	  return useEventListener(documentTarget, event, handler, capture);
	}

	var DropdownContext = /*#__PURE__*/React$1.createContext(null);
	var DropdownContext$1 = DropdownContext;

	/**
	 * A convenience hook around `useState` designed to be paired with
	 * the component [callback ref](https://reactjs.org/docs/refs-and-the-dom.html#callback-refs) api.
	 * Callback refs are useful over `useRef()` when you need to respond to the ref being set
	 * instead of lazily accessing it in an effect.
	 *
	 * ```ts
	 * const [element, attachRef] = useCallbackRef<HTMLDivElement>()
	 *
	 * useEffect(() => {
	 *   if (!element) return
	 *
	 *   const calendar = new FullCalendar.Calendar(element)
	 *
	 *   return () => {
	 *     calendar.destroy()
	 *   }
	 * }, [element])
	 *
	 * return <div ref={attachRef} />
	 * ```
	 *
	 * @category refs
	 */

	function useCallbackRef() {
	  return React$1.useState(null);
	}

	/**
	 * Track whether a component is current mounted. Generally less preferable than
	 * properlly canceling effects so they don't run after a component is unmounted,
	 * but helpful in cases where that isn't feasible, such as a `Promise` resolution.
	 *
	 * @returns a function that returns the current isMounted state of the component
	 *
	 * ```ts
	 * const [data, setData] = useState(null)
	 * const isMounted = useMounted()
	 *
	 * useEffect(() => {
	 *   fetchdata().then((newData) => {
	 *      if (isMounted()) {
	 *        setData(newData);
	 *      }
	 *   })
	 * })
	 * ```
	 */

	function useMounted() {
	  var mounted = React$1.useRef(true);
	  var isMounted = React$1.useRef(function () {
	    return mounted.current;
	  });
	  React$1.useEffect(function () {
	    mounted.current = true;
	    return function () {
	      mounted.current = false;
	    };
	  }, []);
	  return isMounted.current;
	}

	function useSafeState(state) {
	  var isMounted = useMounted();
	  return [state[0], React$1.useCallback(function (nextState) {
	    if (!isMounted()) return;
	    return state[1](nextState);
	  }, [isMounted, state[1]])];
	}

	var top = 'top';
	var bottom = 'bottom';
	var right = 'right';
	var left = 'left';
	var auto = 'auto';
	var basePlacements = [top, bottom, right, left];
	var start = 'start';
	var end = 'end';
	var clippingParents = 'clippingParents';
	var viewport = 'viewport';
	var popper = 'popper';
	var reference = 'reference';
	var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
	  return acc.concat([placement + "-" + start, placement + "-" + end]);
	}, []);
	var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
	  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
	}, []); // modifiers that need to read the DOM

	var beforeRead = 'beforeRead';
	var read = 'read';
	var afterRead = 'afterRead'; // pure-logic modifiers

	var beforeMain = 'beforeMain';
	var main = 'main';
	var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

	var beforeWrite = 'beforeWrite';
	var write = 'write';
	var afterWrite = 'afterWrite';
	var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

	function getBasePlacement(placement) {
	  return placement.split('-')[0];
	}

	function getWindow$1(node) {
	  if (node == null) {
	    return window;
	  }

	  if (node.toString() !== '[object Window]') {
	    var ownerDocument = node.ownerDocument;
	    return ownerDocument ? ownerDocument.defaultView || window : window;
	  }

	  return node;
	}

	function isElement$1(node) {
	  var OwnElement = getWindow$1(node).Element;
	  return node instanceof OwnElement || node instanceof Element;
	}

	function isHTMLElement$1(node) {
	  var OwnElement = getWindow$1(node).HTMLElement;
	  return node instanceof OwnElement || node instanceof HTMLElement;
	}

	function isShadowRoot$1(node) {
	  // IE 11 has no ShadowRoot
	  if (typeof ShadowRoot === 'undefined') {
	    return false;
	  }

	  var OwnElement = getWindow$1(node).ShadowRoot;
	  return node instanceof OwnElement || node instanceof ShadowRoot;
	}

	var max$1 = Math.max;
	var min$1 = Math.min;
	var round$1 = Math.round;

	function getUAString() {
	  var uaData = navigator.userAgentData;

	  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
	    return uaData.brands.map(function (item) {
	      return item.brand + "/" + item.version;
	    }).join(' ');
	  }

	  return navigator.userAgent;
	}

	function isLayoutViewport() {
	  return !/^((?!chrome|android).)*safari/i.test(getUAString());
	}

	function getBoundingClientRect$1(element, includeScale, isFixedStrategy) {
	  if (includeScale === void 0) {
	    includeScale = false;
	  }

	  if (isFixedStrategy === void 0) {
	    isFixedStrategy = false;
	  }

	  var clientRect = element.getBoundingClientRect();
	  var scaleX = 1;
	  var scaleY = 1;

	  if (includeScale && isHTMLElement$1(element)) {
	    scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
	    scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
	  }

	  var _ref = isElement$1(element) ? getWindow$1(element) : window,
	      visualViewport = _ref.visualViewport;

	  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
	  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
	  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
	  var width = clientRect.width / scaleX;
	  var height = clientRect.height / scaleY;
	  return {
	    width: width,
	    height: height,
	    top: y,
	    right: x + width,
	    bottom: y + height,
	    left: x,
	    x: x,
	    y: y
	  };
	}

	// means it doesn't take into account transforms.

	function getLayoutRect(element) {
	  var clientRect = getBoundingClientRect$1(element); // Use the clientRect sizes if it's not been transformed.
	  // Fixes https://github.com/popperjs/popper-core/issues/1223

	  var width = element.offsetWidth;
	  var height = element.offsetHeight;

	  if (Math.abs(clientRect.width - width) <= 1) {
	    width = clientRect.width;
	  }

	  if (Math.abs(clientRect.height - height) <= 1) {
	    height = clientRect.height;
	  }

	  return {
	    x: element.offsetLeft,
	    y: element.offsetTop,
	    width: width,
	    height: height
	  };
	}

	function contains(parent, child) {
	  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

	  if (parent.contains(child)) {
	    return true;
	  } // then fallback to custom implementation with Shadow DOM support
	  else if (rootNode && isShadowRoot$1(rootNode)) {
	      var next = child;

	      do {
	        if (next && parent.isSameNode(next)) {
	          return true;
	        } // $FlowFixMe[prop-missing]: need a better way to handle this...


	        next = next.parentNode || next.host;
	      } while (next);
	    } // Give up, the result is false


	  return false;
	}

	function getNodeName$1(element) {
	  return element ? (element.nodeName || '').toLowerCase() : null;
	}

	function getComputedStyle$2(element) {
	  return getWindow$1(element).getComputedStyle(element);
	}

	function isTableElement(element) {
	  return ['table', 'td', 'th'].indexOf(getNodeName$1(element)) >= 0;
	}

	function getDocumentElement$1(element) {
	  // $FlowFixMe[incompatible-return]: assume body is always available
	  return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
	  element.document) || window.document).documentElement;
	}

	function getParentNode$1(element) {
	  if (getNodeName$1(element) === 'html') {
	    return element;
	  }

	  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
	    // $FlowFixMe[incompatible-return]
	    // $FlowFixMe[prop-missing]
	    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
	    element.parentNode || ( // DOM Element detected
	    isShadowRoot$1(element) ? element.host : null) || // ShadowRoot detected
	    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
	    getDocumentElement$1(element) // fallback

	  );
	}

	function getTrueOffsetParent(element) {
	  if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
	  getComputedStyle$2(element).position === 'fixed') {
	    return null;
	  }

	  return element.offsetParent;
	} // `.offsetParent` reports `null` for fixed elements, while absolute elements
	// return the containing block


	function getContainingBlock(element) {
	  var isFirefox = /firefox/i.test(getUAString());
	  var isIE = /Trident/i.test(getUAString());

	  if (isIE && isHTMLElement$1(element)) {
	    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
	    var elementCss = getComputedStyle$2(element);

	    if (elementCss.position === 'fixed') {
	      return null;
	    }
	  }

	  var currentNode = getParentNode$1(element);

	  if (isShadowRoot$1(currentNode)) {
	    currentNode = currentNode.host;
	  }

	  while (isHTMLElement$1(currentNode) && ['html', 'body'].indexOf(getNodeName$1(currentNode)) < 0) {
	    var css = getComputedStyle$2(currentNode); // This is non-exhaustive but covers the most common CSS properties that
	    // create a containing block.
	    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

	    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
	      return currentNode;
	    } else {
	      currentNode = currentNode.parentNode;
	    }
	  }

	  return null;
	} // Gets the closest ancestor positioned element. Handles some edge cases,
	// such as table ancestors and cross browser bugs.


	function getOffsetParent(element) {
	  var window = getWindow$1(element);
	  var offsetParent = getTrueOffsetParent(element);

	  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$2(offsetParent).position === 'static') {
	    offsetParent = getTrueOffsetParent(offsetParent);
	  }

	  if (offsetParent && (getNodeName$1(offsetParent) === 'html' || getNodeName$1(offsetParent) === 'body' && getComputedStyle$2(offsetParent).position === 'static')) {
	    return window;
	  }

	  return offsetParent || getContainingBlock(element) || window;
	}

	function getMainAxisFromPlacement(placement) {
	  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
	}

	function within(min, value, max) {
	  return max$1(min, min$1(value, max));
	}
	function withinMaxClamp(min, value, max) {
	  var v = within(min, value, max);
	  return v > max ? max : v;
	}

	function getFreshSideObject() {
	  return {
	    top: 0,
	    right: 0,
	    bottom: 0,
	    left: 0
	  };
	}

	function mergePaddingObject(paddingObject) {
	  return Object.assign({}, getFreshSideObject(), paddingObject);
	}

	function expandToHashMap(value, keys) {
	  return keys.reduce(function (hashMap, key) {
	    hashMap[key] = value;
	    return hashMap;
	  }, {});
	}

	var toPaddingObject = function toPaddingObject(padding, state) {
	  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
	    placement: state.placement
	  })) : padding;
	  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
	};

	function arrow(_ref) {
	  var _state$modifiersData$;

	  var state = _ref.state,
	      name = _ref.name,
	      options = _ref.options;
	  var arrowElement = state.elements.arrow;
	  var popperOffsets = state.modifiersData.popperOffsets;
	  var basePlacement = getBasePlacement(state.placement);
	  var axis = getMainAxisFromPlacement(basePlacement);
	  var isVertical = [left, right].indexOf(basePlacement) >= 0;
	  var len = isVertical ? 'height' : 'width';

	  if (!arrowElement || !popperOffsets) {
	    return;
	  }

	  var paddingObject = toPaddingObject(options.padding, state);
	  var arrowRect = getLayoutRect(arrowElement);
	  var minProp = axis === 'y' ? top : left;
	  var maxProp = axis === 'y' ? bottom : right;
	  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
	  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
	  var arrowOffsetParent = getOffsetParent(arrowElement);
	  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
	  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
	  // outside of the popper bounds

	  var min = paddingObject[minProp];
	  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
	  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
	  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

	  var axisProp = axis;
	  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
	}

	function effect$1(_ref2) {
	  var state = _ref2.state,
	      options = _ref2.options;
	  var _options$element = options.element,
	      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

	  if (arrowElement == null) {
	    return;
	  } // CSS selector


	  if (typeof arrowElement === 'string') {
	    arrowElement = state.elements.popper.querySelector(arrowElement);

	    if (!arrowElement) {
	      return;
	    }
	  }

	  if (!contains(state.elements.popper, arrowElement)) {
	    return;
	  }

	  state.elements.arrow = arrowElement;
	} // eslint-disable-next-line import/no-unused-modules


	var arrow$1 = {
	  name: 'arrow',
	  enabled: true,
	  phase: 'main',
	  fn: arrow,
	  effect: effect$1,
	  requires: ['popperOffsets'],
	  requiresIfExists: ['preventOverflow']
	};

	function getVariation(placement) {
	  return placement.split('-')[1];
	}

	var unsetSides = {
	  top: 'auto',
	  right: 'auto',
	  bottom: 'auto',
	  left: 'auto'
	}; // Round the offsets to the nearest suitable subpixel based on the DPR.
	// Zooming can change the DPR, but it seems to report a value that will
	// cleanly divide the values into the appropriate subpixels.

	function roundOffsetsByDPR(_ref, win) {
	  var x = _ref.x,
	      y = _ref.y;
	  var dpr = win.devicePixelRatio || 1;
	  return {
	    x: round$1(x * dpr) / dpr || 0,
	    y: round$1(y * dpr) / dpr || 0
	  };
	}

	function mapToStyles(_ref2) {
	  var _Object$assign2;

	  var popper = _ref2.popper,
	      popperRect = _ref2.popperRect,
	      placement = _ref2.placement,
	      variation = _ref2.variation,
	      offsets = _ref2.offsets,
	      position = _ref2.position,
	      gpuAcceleration = _ref2.gpuAcceleration,
	      adaptive = _ref2.adaptive,
	      roundOffsets = _ref2.roundOffsets,
	      isFixed = _ref2.isFixed;
	  var _offsets$x = offsets.x,
	      x = _offsets$x === void 0 ? 0 : _offsets$x,
	      _offsets$y = offsets.y,
	      y = _offsets$y === void 0 ? 0 : _offsets$y;

	  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
	    x: x,
	    y: y
	  }) : {
	    x: x,
	    y: y
	  };

	  x = _ref3.x;
	  y = _ref3.y;
	  var hasX = offsets.hasOwnProperty('x');
	  var hasY = offsets.hasOwnProperty('y');
	  var sideX = left;
	  var sideY = top;
	  var win = window;

	  if (adaptive) {
	    var offsetParent = getOffsetParent(popper);
	    var heightProp = 'clientHeight';
	    var widthProp = 'clientWidth';

	    if (offsetParent === getWindow$1(popper)) {
	      offsetParent = getDocumentElement$1(popper);

	      if (getComputedStyle$2(offsetParent).position !== 'static' && position === 'absolute') {
	        heightProp = 'scrollHeight';
	        widthProp = 'scrollWidth';
	      }
	    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


	    offsetParent = offsetParent;

	    if (placement === top || (placement === left || placement === right) && variation === end) {
	      sideY = bottom;
	      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
	      offsetParent[heightProp];
	      y -= offsetY - popperRect.height;
	      y *= gpuAcceleration ? 1 : -1;
	    }

	    if (placement === left || (placement === top || placement === bottom) && variation === end) {
	      sideX = right;
	      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
	      offsetParent[widthProp];
	      x -= offsetX - popperRect.width;
	      x *= gpuAcceleration ? 1 : -1;
	    }
	  }

	  var commonStyles = Object.assign({
	    position: position
	  }, adaptive && unsetSides);

	  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
	    x: x,
	    y: y
	  }, getWindow$1(popper)) : {
	    x: x,
	    y: y
	  };

	  x = _ref4.x;
	  y = _ref4.y;

	  if (gpuAcceleration) {
	    var _Object$assign;

	    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
	  }

	  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
	}

	function computeStyles(_ref5) {
	  var state = _ref5.state,
	      options = _ref5.options;
	  var _options$gpuAccelerat = options.gpuAcceleration,
	      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
	      _options$adaptive = options.adaptive,
	      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
	      _options$roundOffsets = options.roundOffsets,
	      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
	  var commonStyles = {
	    placement: getBasePlacement(state.placement),
	    variation: getVariation(state.placement),
	    popper: state.elements.popper,
	    popperRect: state.rects.popper,
	    gpuAcceleration: gpuAcceleration,
	    isFixed: state.options.strategy === 'fixed'
	  };

	  if (state.modifiersData.popperOffsets != null) {
	    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
	      offsets: state.modifiersData.popperOffsets,
	      position: state.options.strategy,
	      adaptive: adaptive,
	      roundOffsets: roundOffsets
	    })));
	  }

	  if (state.modifiersData.arrow != null) {
	    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
	      offsets: state.modifiersData.arrow,
	      position: 'absolute',
	      adaptive: false,
	      roundOffsets: roundOffsets
	    })));
	  }

	  state.attributes.popper = Object.assign({}, state.attributes.popper, {
	    'data-popper-placement': state.placement
	  });
	} // eslint-disable-next-line import/no-unused-modules


	var computeStyles$1 = {
	  name: 'computeStyles',
	  enabled: true,
	  phase: 'beforeWrite',
	  fn: computeStyles,
	  data: {}
	};

	var passive = {
	  passive: true
	};

	function effect(_ref) {
	  var state = _ref.state,
	      instance = _ref.instance,
	      options = _ref.options;
	  var _options$scroll = options.scroll,
	      scroll = _options$scroll === void 0 ? true : _options$scroll,
	      _options$resize = options.resize,
	      resize = _options$resize === void 0 ? true : _options$resize;
	  var window = getWindow$1(state.elements.popper);
	  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

	  if (scroll) {
	    scrollParents.forEach(function (scrollParent) {
	      scrollParent.addEventListener('scroll', instance.update, passive);
	    });
	  }

	  if (resize) {
	    window.addEventListener('resize', instance.update, passive);
	  }

	  return function () {
	    if (scroll) {
	      scrollParents.forEach(function (scrollParent) {
	        scrollParent.removeEventListener('scroll', instance.update, passive);
	      });
	    }

	    if (resize) {
	      window.removeEventListener('resize', instance.update, passive);
	    }
	  };
	} // eslint-disable-next-line import/no-unused-modules


	var eventListeners = {
	  name: 'eventListeners',
	  enabled: true,
	  phase: 'write',
	  fn: function fn() {},
	  effect: effect,
	  data: {}
	};

	var hash$2 = {
	  left: 'right',
	  right: 'left',
	  bottom: 'top',
	  top: 'bottom'
	};
	function getOppositePlacement(placement) {
	  return placement.replace(/left|right|bottom|top/g, function (matched) {
	    return hash$2[matched];
	  });
	}

	var hash$1 = {
	  start: 'end',
	  end: 'start'
	};
	function getOppositeVariationPlacement(placement) {
	  return placement.replace(/start|end/g, function (matched) {
	    return hash$1[matched];
	  });
	}

	function getWindowScroll(node) {
	  var win = getWindow$1(node);
	  var scrollLeft = win.pageXOffset;
	  var scrollTop = win.pageYOffset;
	  return {
	    scrollLeft: scrollLeft,
	    scrollTop: scrollTop
	  };
	}

	function getWindowScrollBarX(element) {
	  // If <html> has a CSS width greater than the viewport, then this will be
	  // incorrect for RTL.
	  // Popper 1 is broken in this case and never had a bug report so let's assume
	  // it's not an issue. I don't think anyone ever specifies width on <html>
	  // anyway.
	  // Browsers where the left scrollbar doesn't cause an issue report `0` for
	  // this (e.g. Edge 2019, IE11, Safari)
	  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getWindowScroll(element).scrollLeft;
	}

	function getViewportRect(element, strategy) {
	  var win = getWindow$1(element);
	  var html = getDocumentElement$1(element);
	  var visualViewport = win.visualViewport;
	  var width = html.clientWidth;
	  var height = html.clientHeight;
	  var x = 0;
	  var y = 0;

	  if (visualViewport) {
	    width = visualViewport.width;
	    height = visualViewport.height;
	    var layoutViewport = isLayoutViewport();

	    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
	      x = visualViewport.offsetLeft;
	      y = visualViewport.offsetTop;
	    }
	  }

	  return {
	    width: width,
	    height: height,
	    x: x + getWindowScrollBarX(element),
	    y: y
	  };
	}

	// of the `<html>` and `<body>` rect bounds if horizontally scrollable

	function getDocumentRect(element) {
	  var _element$ownerDocumen;

	  var html = getDocumentElement$1(element);
	  var winScroll = getWindowScroll(element);
	  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
	  var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
	  var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
	  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
	  var y = -winScroll.scrollTop;

	  if (getComputedStyle$2(body || html).direction === 'rtl') {
	    x += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
	  }

	  return {
	    width: width,
	    height: height,
	    x: x,
	    y: y
	  };
	}

	function isScrollParent(element) {
	  // Firefox wants us to check `-x` and `-y` variations as well
	  var _getComputedStyle = getComputedStyle$2(element),
	      overflow = _getComputedStyle.overflow,
	      overflowX = _getComputedStyle.overflowX,
	      overflowY = _getComputedStyle.overflowY;

	  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
	}

	function getScrollParent$1(node) {
	  if (['html', 'body', '#document'].indexOf(getNodeName$1(node)) >= 0) {
	    // $FlowFixMe[incompatible-return]: assume body is always available
	    return node.ownerDocument.body;
	  }

	  if (isHTMLElement$1(node) && isScrollParent(node)) {
	    return node;
	  }

	  return getScrollParent$1(getParentNode$1(node));
	}

	/*
	given a DOM element, return the list of all scroll parents, up the list of ancesors
	until we get to the top window object. This list is what we attach scroll listeners
	to, because if any of these parent elements scroll, we'll need to re-calculate the
	reference element's position.
	*/

	function listScrollParents(element, list) {
	  var _element$ownerDocumen;

	  if (list === void 0) {
	    list = [];
	  }

	  var scrollParent = getScrollParent$1(element);
	  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
	  var win = getWindow$1(scrollParent);
	  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
	  var updatedList = list.concat(target);
	  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
	  updatedList.concat(listScrollParents(getParentNode$1(target)));
	}

	function rectToClientRect$1(rect) {
	  return Object.assign({}, rect, {
	    left: rect.x,
	    top: rect.y,
	    right: rect.x + rect.width,
	    bottom: rect.y + rect.height
	  });
	}

	function getInnerBoundingClientRect(element, strategy) {
	  var rect = getBoundingClientRect$1(element, false, strategy === 'fixed');
	  rect.top = rect.top + element.clientTop;
	  rect.left = rect.left + element.clientLeft;
	  rect.bottom = rect.top + element.clientHeight;
	  rect.right = rect.left + element.clientWidth;
	  rect.width = element.clientWidth;
	  rect.height = element.clientHeight;
	  rect.x = rect.left;
	  rect.y = rect.top;
	  return rect;
	}

	function getClientRectFromMixedType(element, clippingParent, strategy) {
	  return clippingParent === viewport ? rectToClientRect$1(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect$1(getDocumentRect(getDocumentElement$1(element)));
	} // A "clipping parent" is an overflowable container with the characteristic of
	// clipping (or hiding) overflowing elements with a position different from
	// `initial`


	function getClippingParents(element) {
	  var clippingParents = listScrollParents(getParentNode$1(element));
	  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$2(element).position) >= 0;
	  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;

	  if (!isElement$1(clipperElement)) {
	    return [];
	  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


	  return clippingParents.filter(function (clippingParent) {
	    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== 'body';
	  });
	} // Gets the maximum area that the element is visible in due to any number of
	// clipping parents


	function getClippingRect(element, boundary, rootBoundary, strategy) {
	  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
	  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
	  var firstClippingParent = clippingParents[0];
	  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
	    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
	    accRect.top = max$1(rect.top, accRect.top);
	    accRect.right = min$1(rect.right, accRect.right);
	    accRect.bottom = min$1(rect.bottom, accRect.bottom);
	    accRect.left = max$1(rect.left, accRect.left);
	    return accRect;
	  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
	  clippingRect.width = clippingRect.right - clippingRect.left;
	  clippingRect.height = clippingRect.bottom - clippingRect.top;
	  clippingRect.x = clippingRect.left;
	  clippingRect.y = clippingRect.top;
	  return clippingRect;
	}

	function computeOffsets(_ref) {
	  var reference = _ref.reference,
	      element = _ref.element,
	      placement = _ref.placement;
	  var basePlacement = placement ? getBasePlacement(placement) : null;
	  var variation = placement ? getVariation(placement) : null;
	  var commonX = reference.x + reference.width / 2 - element.width / 2;
	  var commonY = reference.y + reference.height / 2 - element.height / 2;
	  var offsets;

	  switch (basePlacement) {
	    case top:
	      offsets = {
	        x: commonX,
	        y: reference.y - element.height
	      };
	      break;

	    case bottom:
	      offsets = {
	        x: commonX,
	        y: reference.y + reference.height
	      };
	      break;

	    case right:
	      offsets = {
	        x: reference.x + reference.width,
	        y: commonY
	      };
	      break;

	    case left:
	      offsets = {
	        x: reference.x - element.width,
	        y: commonY
	      };
	      break;

	    default:
	      offsets = {
	        x: reference.x,
	        y: reference.y
	      };
	  }

	  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

	  if (mainAxis != null) {
	    var len = mainAxis === 'y' ? 'height' : 'width';

	    switch (variation) {
	      case start:
	        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
	        break;

	      case end:
	        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
	        break;
	    }
	  }

	  return offsets;
	}

	function detectOverflow(state, options) {
	  if (options === void 0) {
	    options = {};
	  }

	  var _options = options,
	      _options$placement = _options.placement,
	      placement = _options$placement === void 0 ? state.placement : _options$placement,
	      _options$strategy = _options.strategy,
	      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
	      _options$boundary = _options.boundary,
	      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
	      _options$rootBoundary = _options.rootBoundary,
	      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
	      _options$elementConte = _options.elementContext,
	      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
	      _options$altBoundary = _options.altBoundary,
	      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
	      _options$padding = _options.padding,
	      padding = _options$padding === void 0 ? 0 : _options$padding;
	  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
	  var altContext = elementContext === popper ? reference : popper;
	  var popperRect = state.rects.popper;
	  var element = state.elements[altBoundary ? altContext : elementContext];
	  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement$1(state.elements.popper), boundary, rootBoundary, strategy);
	  var referenceClientRect = getBoundingClientRect$1(state.elements.reference);
	  var popperOffsets = computeOffsets({
	    reference: referenceClientRect,
	    element: popperRect,
	    strategy: 'absolute',
	    placement: placement
	  });
	  var popperClientRect = rectToClientRect$1(Object.assign({}, popperRect, popperOffsets));
	  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
	  // 0 or negative = within the clipping rect

	  var overflowOffsets = {
	    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
	    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
	    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
	    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
	  };
	  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

	  if (elementContext === popper && offsetData) {
	    var offset = offsetData[placement];
	    Object.keys(overflowOffsets).forEach(function (key) {
	      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
	      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
	      overflowOffsets[key] += offset[axis] * multiply;
	    });
	  }

	  return overflowOffsets;
	}

	function computeAutoPlacement(state, options) {
	  if (options === void 0) {
	    options = {};
	  }

	  var _options = options,
	      placement = _options.placement,
	      boundary = _options.boundary,
	      rootBoundary = _options.rootBoundary,
	      padding = _options.padding,
	      flipVariations = _options.flipVariations,
	      _options$allowedAutoP = _options.allowedAutoPlacements,
	      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
	  var variation = getVariation(placement);
	  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
	    return getVariation(placement) === variation;
	  }) : basePlacements;
	  var allowedPlacements = placements$1.filter(function (placement) {
	    return allowedAutoPlacements.indexOf(placement) >= 0;
	  });

	  if (allowedPlacements.length === 0) {
	    allowedPlacements = placements$1;
	  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


	  var overflows = allowedPlacements.reduce(function (acc, placement) {
	    acc[placement] = detectOverflow(state, {
	      placement: placement,
	      boundary: boundary,
	      rootBoundary: rootBoundary,
	      padding: padding
	    })[getBasePlacement(placement)];
	    return acc;
	  }, {});
	  return Object.keys(overflows).sort(function (a, b) {
	    return overflows[a] - overflows[b];
	  });
	}

	function getExpandedFallbackPlacements(placement) {
	  if (getBasePlacement(placement) === auto) {
	    return [];
	  }

	  var oppositePlacement = getOppositePlacement(placement);
	  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
	}

	function flip(_ref) {
	  var state = _ref.state,
	      options = _ref.options,
	      name = _ref.name;

	  if (state.modifiersData[name]._skip) {
	    return;
	  }

	  var _options$mainAxis = options.mainAxis,
	      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
	      _options$altAxis = options.altAxis,
	      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
	      specifiedFallbackPlacements = options.fallbackPlacements,
	      padding = options.padding,
	      boundary = options.boundary,
	      rootBoundary = options.rootBoundary,
	      altBoundary = options.altBoundary,
	      _options$flipVariatio = options.flipVariations,
	      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
	      allowedAutoPlacements = options.allowedAutoPlacements;
	  var preferredPlacement = state.options.placement;
	  var basePlacement = getBasePlacement(preferredPlacement);
	  var isBasePlacement = basePlacement === preferredPlacement;
	  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
	  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
	    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
	      placement: placement,
	      boundary: boundary,
	      rootBoundary: rootBoundary,
	      padding: padding,
	      flipVariations: flipVariations,
	      allowedAutoPlacements: allowedAutoPlacements
	    }) : placement);
	  }, []);
	  var referenceRect = state.rects.reference;
	  var popperRect = state.rects.popper;
	  var checksMap = new Map();
	  var makeFallbackChecks = true;
	  var firstFittingPlacement = placements[0];

	  for (var i = 0; i < placements.length; i++) {
	    var placement = placements[i];

	    var _basePlacement = getBasePlacement(placement);

	    var isStartVariation = getVariation(placement) === start;
	    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
	    var len = isVertical ? 'width' : 'height';
	    var overflow = detectOverflow(state, {
	      placement: placement,
	      boundary: boundary,
	      rootBoundary: rootBoundary,
	      altBoundary: altBoundary,
	      padding: padding
	    });
	    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

	    if (referenceRect[len] > popperRect[len]) {
	      mainVariationSide = getOppositePlacement(mainVariationSide);
	    }

	    var altVariationSide = getOppositePlacement(mainVariationSide);
	    var checks = [];

	    if (checkMainAxis) {
	      checks.push(overflow[_basePlacement] <= 0);
	    }

	    if (checkAltAxis) {
	      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
	    }

	    if (checks.every(function (check) {
	      return check;
	    })) {
	      firstFittingPlacement = placement;
	      makeFallbackChecks = false;
	      break;
	    }

	    checksMap.set(placement, checks);
	  }

	  if (makeFallbackChecks) {
	    // `2` may be desired in some cases  research later
	    var numberOfChecks = flipVariations ? 3 : 1;

	    var _loop = function _loop(_i) {
	      var fittingPlacement = placements.find(function (placement) {
	        var checks = checksMap.get(placement);

	        if (checks) {
	          return checks.slice(0, _i).every(function (check) {
	            return check;
	          });
	        }
	      });

	      if (fittingPlacement) {
	        firstFittingPlacement = fittingPlacement;
	        return "break";
	      }
	    };

	    for (var _i = numberOfChecks; _i > 0; _i--) {
	      var _ret = _loop(_i);

	      if (_ret === "break") break;
	    }
	  }

	  if (state.placement !== firstFittingPlacement) {
	    state.modifiersData[name]._skip = true;
	    state.placement = firstFittingPlacement;
	    state.reset = true;
	  }
	} // eslint-disable-next-line import/no-unused-modules


	var flip$1 = {
	  name: 'flip',
	  enabled: true,
	  phase: 'main',
	  fn: flip,
	  requiresIfExists: ['offset'],
	  data: {
	    _skip: false
	  }
	};

	function getSideOffsets(overflow, rect, preventedOffsets) {
	  if (preventedOffsets === void 0) {
	    preventedOffsets = {
	      x: 0,
	      y: 0
	    };
	  }

	  return {
	    top: overflow.top - rect.height - preventedOffsets.y,
	    right: overflow.right - rect.width + preventedOffsets.x,
	    bottom: overflow.bottom - rect.height + preventedOffsets.y,
	    left: overflow.left - rect.width - preventedOffsets.x
	  };
	}

	function isAnySideFullyClipped(overflow) {
	  return [top, right, bottom, left].some(function (side) {
	    return overflow[side] >= 0;
	  });
	}

	function hide(_ref) {
	  var state = _ref.state,
	      name = _ref.name;
	  var referenceRect = state.rects.reference;
	  var popperRect = state.rects.popper;
	  var preventedOffsets = state.modifiersData.preventOverflow;
	  var referenceOverflow = detectOverflow(state, {
	    elementContext: 'reference'
	  });
	  var popperAltOverflow = detectOverflow(state, {
	    altBoundary: true
	  });
	  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
	  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
	  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
	  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
	  state.modifiersData[name] = {
	    referenceClippingOffsets: referenceClippingOffsets,
	    popperEscapeOffsets: popperEscapeOffsets,
	    isReferenceHidden: isReferenceHidden,
	    hasPopperEscaped: hasPopperEscaped
	  };
	  state.attributes.popper = Object.assign({}, state.attributes.popper, {
	    'data-popper-reference-hidden': isReferenceHidden,
	    'data-popper-escaped': hasPopperEscaped
	  });
	} // eslint-disable-next-line import/no-unused-modules


	var hide$1 = {
	  name: 'hide',
	  enabled: true,
	  phase: 'main',
	  requiresIfExists: ['preventOverflow'],
	  fn: hide
	};

	function distanceAndSkiddingToXY(placement, rects, offset) {
	  var basePlacement = getBasePlacement(placement);
	  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

	  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
	    placement: placement
	  })) : offset,
	      skidding = _ref[0],
	      distance = _ref[1];

	  skidding = skidding || 0;
	  distance = (distance || 0) * invertDistance;
	  return [left, right].indexOf(basePlacement) >= 0 ? {
	    x: distance,
	    y: skidding
	  } : {
	    x: skidding,
	    y: distance
	  };
	}

	function offset(_ref2) {
	  var state = _ref2.state,
	      options = _ref2.options,
	      name = _ref2.name;
	  var _options$offset = options.offset,
	      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
	  var data = placements.reduce(function (acc, placement) {
	    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
	    return acc;
	  }, {});
	  var _data$state$placement = data[state.placement],
	      x = _data$state$placement.x,
	      y = _data$state$placement.y;

	  if (state.modifiersData.popperOffsets != null) {
	    state.modifiersData.popperOffsets.x += x;
	    state.modifiersData.popperOffsets.y += y;
	  }

	  state.modifiersData[name] = data;
	} // eslint-disable-next-line import/no-unused-modules


	var offset$1 = {
	  name: 'offset',
	  enabled: true,
	  phase: 'main',
	  requires: ['popperOffsets'],
	  fn: offset
	};

	function popperOffsets(_ref) {
	  var state = _ref.state,
	      name = _ref.name;
	  // Offsets are the actual position the popper needs to have to be
	  // properly positioned near its reference element
	  // This is the most basic placement, and will be adjusted by
	  // the modifiers in the next step
	  state.modifiersData[name] = computeOffsets({
	    reference: state.rects.reference,
	    element: state.rects.popper,
	    strategy: 'absolute',
	    placement: state.placement
	  });
	} // eslint-disable-next-line import/no-unused-modules


	var popperOffsets$1 = {
	  name: 'popperOffsets',
	  enabled: true,
	  phase: 'read',
	  fn: popperOffsets,
	  data: {}
	};

	function getAltAxis(axis) {
	  return axis === 'x' ? 'y' : 'x';
	}

	function preventOverflow(_ref) {
	  var state = _ref.state,
	      options = _ref.options,
	      name = _ref.name;
	  var _options$mainAxis = options.mainAxis,
	      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
	      _options$altAxis = options.altAxis,
	      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
	      boundary = options.boundary,
	      rootBoundary = options.rootBoundary,
	      altBoundary = options.altBoundary,
	      padding = options.padding,
	      _options$tether = options.tether,
	      tether = _options$tether === void 0 ? true : _options$tether,
	      _options$tetherOffset = options.tetherOffset,
	      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
	  var overflow = detectOverflow(state, {
	    boundary: boundary,
	    rootBoundary: rootBoundary,
	    padding: padding,
	    altBoundary: altBoundary
	  });
	  var basePlacement = getBasePlacement(state.placement);
	  var variation = getVariation(state.placement);
	  var isBasePlacement = !variation;
	  var mainAxis = getMainAxisFromPlacement(basePlacement);
	  var altAxis = getAltAxis(mainAxis);
	  var popperOffsets = state.modifiersData.popperOffsets;
	  var referenceRect = state.rects.reference;
	  var popperRect = state.rects.popper;
	  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
	    placement: state.placement
	  })) : tetherOffset;
	  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
	    mainAxis: tetherOffsetValue,
	    altAxis: tetherOffsetValue
	  } : Object.assign({
	    mainAxis: 0,
	    altAxis: 0
	  }, tetherOffsetValue);
	  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
	  var data = {
	    x: 0,
	    y: 0
	  };

	  if (!popperOffsets) {
	    return;
	  }

	  if (checkMainAxis) {
	    var _offsetModifierState$;

	    var mainSide = mainAxis === 'y' ? top : left;
	    var altSide = mainAxis === 'y' ? bottom : right;
	    var len = mainAxis === 'y' ? 'height' : 'width';
	    var offset = popperOffsets[mainAxis];
	    var min = offset + overflow[mainSide];
	    var max = offset - overflow[altSide];
	    var additive = tether ? -popperRect[len] / 2 : 0;
	    var minLen = variation === start ? referenceRect[len] : popperRect[len];
	    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
	    // outside the reference bounds

	    var arrowElement = state.elements.arrow;
	    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
	      width: 0,
	      height: 0
	    };
	    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
	    var arrowPaddingMin = arrowPaddingObject[mainSide];
	    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
	    // to include its full size in the calculation. If the reference is small
	    // and near the edge of a boundary, the popper can overflow even if the
	    // reference is not overflowing as well (e.g. virtual elements with no
	    // width or height)

	    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
	    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
	    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
	    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
	    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
	    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
	    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
	    var tetherMax = offset + maxOffset - offsetModifierValue;
	    var preventedOffset = within(tether ? min$1(min, tetherMin) : min, offset, tether ? max$1(max, tetherMax) : max);
	    popperOffsets[mainAxis] = preventedOffset;
	    data[mainAxis] = preventedOffset - offset;
	  }

	  if (checkAltAxis) {
	    var _offsetModifierState$2;

	    var _mainSide = mainAxis === 'x' ? top : left;

	    var _altSide = mainAxis === 'x' ? bottom : right;

	    var _offset = popperOffsets[altAxis];

	    var _len = altAxis === 'y' ? 'height' : 'width';

	    var _min = _offset + overflow[_mainSide];

	    var _max = _offset - overflow[_altSide];

	    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

	    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

	    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

	    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

	    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

	    popperOffsets[altAxis] = _preventedOffset;
	    data[altAxis] = _preventedOffset - _offset;
	  }

	  state.modifiersData[name] = data;
	} // eslint-disable-next-line import/no-unused-modules


	var preventOverflow$1 = {
	  name: 'preventOverflow',
	  enabled: true,
	  phase: 'main',
	  fn: preventOverflow,
	  requiresIfExists: ['offset']
	};

	function getHTMLElementScroll(element) {
	  return {
	    scrollLeft: element.scrollLeft,
	    scrollTop: element.scrollTop
	  };
	}

	function getNodeScroll(node) {
	  if (node === getWindow$1(node) || !isHTMLElement$1(node)) {
	    return getWindowScroll(node);
	  } else {
	    return getHTMLElementScroll(node);
	  }
	}

	function isElementScaled(element) {
	  var rect = element.getBoundingClientRect();
	  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
	  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
	  return scaleX !== 1 || scaleY !== 1;
	} // Returns the composite rect of an element relative to its offsetParent.
	// Composite means it takes into account transforms as well as layout.


	function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
	  if (isFixed === void 0) {
	    isFixed = false;
	  }

	  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
	  var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
	  var documentElement = getDocumentElement$1(offsetParent);
	  var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled, isFixed);
	  var scroll = {
	    scrollLeft: 0,
	    scrollTop: 0
	  };
	  var offsets = {
	    x: 0,
	    y: 0
	  };

	  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
	    if (getNodeName$1(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
	    isScrollParent(documentElement)) {
	      scroll = getNodeScroll(offsetParent);
	    }

	    if (isHTMLElement$1(offsetParent)) {
	      offsets = getBoundingClientRect$1(offsetParent, true);
	      offsets.x += offsetParent.clientLeft;
	      offsets.y += offsetParent.clientTop;
	    } else if (documentElement) {
	      offsets.x = getWindowScrollBarX(documentElement);
	    }
	  }

	  return {
	    x: rect.left + scroll.scrollLeft - offsets.x,
	    y: rect.top + scroll.scrollTop - offsets.y,
	    width: rect.width,
	    height: rect.height
	  };
	}

	function order(modifiers) {
	  var map = new Map();
	  var visited = new Set();
	  var result = [];
	  modifiers.forEach(function (modifier) {
	    map.set(modifier.name, modifier);
	  }); // On visiting object, check for its dependencies and visit them recursively

	  function sort(modifier) {
	    visited.add(modifier.name);
	    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
	    requires.forEach(function (dep) {
	      if (!visited.has(dep)) {
	        var depModifier = map.get(dep);

	        if (depModifier) {
	          sort(depModifier);
	        }
	      }
	    });
	    result.push(modifier);
	  }

	  modifiers.forEach(function (modifier) {
	    if (!visited.has(modifier.name)) {
	      // check for visited object
	      sort(modifier);
	    }
	  });
	  return result;
	}

	function orderModifiers(modifiers) {
	  // order based on dependencies
	  var orderedModifiers = order(modifiers); // order based on phase

	  return modifierPhases.reduce(function (acc, phase) {
	    return acc.concat(orderedModifiers.filter(function (modifier) {
	      return modifier.phase === phase;
	    }));
	  }, []);
	}

	function debounce(fn) {
	  var pending;
	  return function () {
	    if (!pending) {
	      pending = new Promise(function (resolve) {
	        Promise.resolve().then(function () {
	          pending = undefined;
	          resolve(fn());
	        });
	      });
	    }

	    return pending;
	  };
	}

	function mergeByName(modifiers) {
	  var merged = modifiers.reduce(function (merged, current) {
	    var existing = merged[current.name];
	    merged[current.name] = existing ? Object.assign({}, existing, current, {
	      options: Object.assign({}, existing.options, current.options),
	      data: Object.assign({}, existing.data, current.data)
	    }) : current;
	    return merged;
	  }, {}); // IE11 does not support Object.values

	  return Object.keys(merged).map(function (key) {
	    return merged[key];
	  });
	}

	var DEFAULT_OPTIONS = {
	  placement: 'bottom',
	  modifiers: [],
	  strategy: 'absolute'
	};

	function areValidElements() {
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return !args.some(function (element) {
	    return !(element && typeof element.getBoundingClientRect === 'function');
	  });
	}

	function popperGenerator(generatorOptions) {
	  if (generatorOptions === void 0) {
	    generatorOptions = {};
	  }

	  var _generatorOptions = generatorOptions,
	      _generatorOptions$def = _generatorOptions.defaultModifiers,
	      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
	      _generatorOptions$def2 = _generatorOptions.defaultOptions,
	      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
	  return function createPopper(reference, popper, options) {
	    if (options === void 0) {
	      options = defaultOptions;
	    }

	    var state = {
	      placement: 'bottom',
	      orderedModifiers: [],
	      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
	      modifiersData: {},
	      elements: {
	        reference: reference,
	        popper: popper
	      },
	      attributes: {},
	      styles: {}
	    };
	    var effectCleanupFns = [];
	    var isDestroyed = false;
	    var instance = {
	      state: state,
	      setOptions: function setOptions(setOptionsAction) {
	        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
	        cleanupModifierEffects();
	        state.options = Object.assign({}, defaultOptions, state.options, options);
	        state.scrollParents = {
	          reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
	          popper: listScrollParents(popper)
	        }; // Orders the modifiers based on their dependencies and `phase`
	        // properties

	        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

	        state.orderedModifiers = orderedModifiers.filter(function (m) {
	          return m.enabled;
	        });
	        runModifierEffects();
	        return instance.update();
	      },
	      // Sync update  it will always be executed, even if not necessary. This
	      // is useful for low frequency updates where sync behavior simplifies the
	      // logic.
	      // For high frequency updates (e.g. `resize` and `scroll` events), always
	      // prefer the async Popper#update method
	      forceUpdate: function forceUpdate() {
	        if (isDestroyed) {
	          return;
	        }

	        var _state$elements = state.elements,
	            reference = _state$elements.reference,
	            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
	        // anymore

	        if (!areValidElements(reference, popper)) {
	          return;
	        } // Store the reference and popper rects to be read by modifiers


	        state.rects = {
	          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
	          popper: getLayoutRect(popper)
	        }; // Modifiers have the ability to reset the current update cycle. The
	        // most common use case for this is the `flip` modifier changing the
	        // placement, which then needs to re-run all the modifiers, because the
	        // logic was previously ran for the previous placement and is therefore
	        // stale/incorrect

	        state.reset = false;
	        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
	        // is filled with the initial data specified by the modifier. This means
	        // it doesn't persist and is fresh on each update.
	        // To ensure persistent data, use `${name}#persistent`

	        state.orderedModifiers.forEach(function (modifier) {
	          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
	        });

	        for (var index = 0; index < state.orderedModifiers.length; index++) {
	          if (state.reset === true) {
	            state.reset = false;
	            index = -1;
	            continue;
	          }

	          var _state$orderedModifie = state.orderedModifiers[index],
	              fn = _state$orderedModifie.fn,
	              _state$orderedModifie2 = _state$orderedModifie.options,
	              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
	              name = _state$orderedModifie.name;

	          if (typeof fn === 'function') {
	            state = fn({
	              state: state,
	              options: _options,
	              name: name,
	              instance: instance
	            }) || state;
	          }
	        }
	      },
	      // Async and optimistically optimized update  it will not be executed if
	      // not necessary (debounced to run at most once-per-tick)
	      update: debounce(function () {
	        return new Promise(function (resolve) {
	          instance.forceUpdate();
	          resolve(state);
	        });
	      }),
	      destroy: function destroy() {
	        cleanupModifierEffects();
	        isDestroyed = true;
	      }
	    };

	    if (!areValidElements(reference, popper)) {
	      return instance;
	    }

	    instance.setOptions(options).then(function (state) {
	      if (!isDestroyed && options.onFirstUpdate) {
	        options.onFirstUpdate(state);
	      }
	    }); // Modifiers have the ability to execute arbitrary code before the first
	    // update cycle runs. They will be executed in the same order as the update
	    // cycle. This is useful when a modifier adds some persistent data that
	    // other modifiers need to use, but the modifier is run after the dependent
	    // one.

	    function runModifierEffects() {
	      state.orderedModifiers.forEach(function (_ref) {
	        var name = _ref.name,
	            _ref$options = _ref.options,
	            options = _ref$options === void 0 ? {} : _ref$options,
	            effect = _ref.effect;

	        if (typeof effect === 'function') {
	          var cleanupFn = effect({
	            state: state,
	            name: name,
	            instance: instance,
	            options: options
	          });

	          var noopFn = function noopFn() {};

	          effectCleanupFns.push(cleanupFn || noopFn);
	        }
	      });
	    }

	    function cleanupModifierEffects() {
	      effectCleanupFns.forEach(function (fn) {
	        return fn();
	      });
	      effectCleanupFns = [];
	    }

	    return instance;
	  };
	}

	// This is b/c the Popper lib is all esm files, and would break in a common js only environment

	var createPopper = popperGenerator({
	  defaultModifiers: [hide$1, popperOffsets$1, computeStyles$1, eventListeners, offset$1, flip$1, preventOverflow$1, arrow$1]
	});

	var initialPopperStyles = function initialPopperStyles(position) {
	  return {
	    position: position,
	    top: '0',
	    left: '0',
	    opacity: '0',
	    pointerEvents: 'none'
	  };
	};

	var disabledApplyStylesModifier = {
	  name: 'applyStyles',
	  enabled: false
	}; // In order to satisfy the current usage of options, including undefined

	var ariaDescribedByModifier = {
	  name: 'ariaDescribedBy',
	  enabled: true,
	  phase: 'afterWrite',
	  effect: function effect(_ref) {
	    var state = _ref.state;
	    return function () {
	      var _state$elements = state.elements,
	          reference = _state$elements.reference,
	          popper = _state$elements.popper;

	      if ('removeAttribute' in reference) {
	        var ids = (reference.getAttribute('aria-describedby') || '').split(',').filter(function (id) {
	          return id.trim() !== popper.id;
	        });
	        if (!ids.length) reference.removeAttribute('aria-describedby');else reference.setAttribute('aria-describedby', ids.join(','));
	      }
	    };
	  },
	  fn: function fn(_ref2) {
	    var _popper$getAttribute;

	    var state = _ref2.state;
	    var _state$elements2 = state.elements,
	        popper = _state$elements2.popper,
	        reference = _state$elements2.reference;
	    var role = (_popper$getAttribute = popper.getAttribute('role')) == null ? void 0 : _popper$getAttribute.toLowerCase();

	    if (popper.id && role === 'tooltip' && 'setAttribute' in reference) {
	      var ids = reference.getAttribute('aria-describedby');

	      if (ids && ids.split(',').indexOf(popper.id) !== -1) {
	        return;
	      }

	      reference.setAttribute('aria-describedby', ids ? ids + "," + popper.id : popper.id);
	    }
	  }
	};
	var EMPTY_MODIFIERS = [];
	/**
	 * Position an element relative some reference element using Popper.js
	 *
	 * @param referenceElement
	 * @param popperElement
	 * @param {object}      options
	 * @param {object=}     options.modifiers Popper.js modifiers
	 * @param {boolean=}    options.enabled toggle the popper functionality on/off
	 * @param {string=}     options.placement The popper element placement relative to the reference element
	 * @param {string=}     options.strategy the positioning strategy
	 * @param {boolean=}    options.eventsEnabled have Popper listen on window resize events to reposition the element
	 * @param {function=}   options.onCreate called when the popper is created
	 * @param {function=}   options.onUpdate called when the popper is updated
	 *
	 * @returns {UsePopperState} The popper state
	 */

	function usePopper(referenceElement, popperElement, _temp) {
	  var _ref3 = _temp === void 0 ? {} : _temp,
	      _ref3$enabled = _ref3.enabled,
	      enabled = _ref3$enabled === void 0 ? true : _ref3$enabled,
	      _ref3$placement = _ref3.placement,
	      placement = _ref3$placement === void 0 ? 'bottom' : _ref3$placement,
	      _ref3$strategy = _ref3.strategy,
	      strategy = _ref3$strategy === void 0 ? 'absolute' : _ref3$strategy,
	      _ref3$modifiers = _ref3.modifiers,
	      modifiers = _ref3$modifiers === void 0 ? EMPTY_MODIFIERS : _ref3$modifiers,
	      config = _objectWithoutPropertiesLoose(_ref3, ["enabled", "placement", "strategy", "modifiers"]);

	  var popperInstanceRef = React$1.useRef();
	  var update = React$1.useCallback(function () {
	    var _popperInstanceRef$cu;

	    (_popperInstanceRef$cu = popperInstanceRef.current) == null ? void 0 : _popperInstanceRef$cu.update();
	  }, []);
	  var forceUpdate = React$1.useCallback(function () {
	    var _popperInstanceRef$cu2;

	    (_popperInstanceRef$cu2 = popperInstanceRef.current) == null ? void 0 : _popperInstanceRef$cu2.forceUpdate();
	  }, []);

	  var _useSafeState = useSafeState(React$1.useState({
	    placement: placement,
	    update: update,
	    forceUpdate: forceUpdate,
	    attributes: {},
	    styles: {
	      popper: initialPopperStyles(strategy),
	      arrow: {}
	    }
	  })),
	      popperState = _useSafeState[0],
	      setState = _useSafeState[1];

	  var updateModifier = React$1.useMemo(function () {
	    return {
	      name: 'updateStateModifier',
	      enabled: true,
	      phase: 'write',
	      requires: ['computeStyles'],
	      fn: function fn(_ref4) {
	        var state = _ref4.state;
	        var styles = {};
	        var attributes = {};
	        Object.keys(state.elements).forEach(function (element) {
	          styles[element] = state.styles[element];
	          attributes[element] = state.attributes[element];
	        });
	        setState({
	          state: state,
	          styles: styles,
	          attributes: attributes,
	          update: update,
	          forceUpdate: forceUpdate,
	          placement: state.placement
	        });
	      }
	    };
	  }, [update, forceUpdate, setState]);
	  React$1.useEffect(function () {
	    if (!popperInstanceRef.current || !enabled) return;
	    popperInstanceRef.current.setOptions({
	      placement: placement,
	      strategy: strategy,
	      modifiers: [].concat(modifiers, [updateModifier, disabledApplyStylesModifier])
	    }); // intentionally NOT re-running on new modifiers
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	  }, [strategy, placement, updateModifier, enabled]);
	  React$1.useEffect(function () {
	    if (!enabled || referenceElement == null || popperElement == null) {
	      return undefined;
	    }

	    popperInstanceRef.current = createPopper(referenceElement, popperElement, _extends$1({}, config, {
	      placement: placement,
	      strategy: strategy,
	      modifiers: [].concat(modifiers, [ariaDescribedByModifier, updateModifier])
	    }));
	    return function () {
	      if (popperInstanceRef.current != null) {
	        popperInstanceRef.current.destroy();
	        popperInstanceRef.current = undefined;
	        setState(function (s) {
	          return _extends$1({}, s, {
	            attributes: {},
	            styles: {
	              popper: initialPopperStyles(strategy)
	            }
	          });
	        });
	      }
	    }; // This is only run once to _create_ the popper
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	  }, [enabled, referenceElement, popperElement]);
	  return popperState;
	}

	/**
	 * A `removeEventListener` ponyfill
	 * 
	 * @param node the element
	 * @param eventName the event name
	 * @param handle the handler
	 * @param options event options
	 */
	function removeEventListener(node, eventName, handler, options) {
	  var capture = options && typeof options !== 'boolean' ? options.capture : options;
	  node.removeEventListener(eventName, handler, capture);

	  if (handler.__once) {
	    node.removeEventListener(eventName, handler.__once, capture);
	  }
	}

	function listen(node, eventName, handler, options) {
	  addEventListener$2(node, eventName, handler, options);
	  return function () {
	    removeEventListener(node, eventName, handler, options);
	  };
	}

	var listen$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: listen
	});

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var warning = function() {};

	var warning_1 = warning;

	var warning$1 = /*@__PURE__*/getDefaultExportFromCjs(warning_1);

	function safeFindDOMNode(componentOrElement) {
	  if (componentOrElement && 'setState' in componentOrElement) {
	    return ReactDOM.findDOMNode(componentOrElement);
	  }

	  return componentOrElement != null ? componentOrElement : null;
	}

	var ownerDocument = (function (componentOrElement) {
	  return ownerDocument$1(safeFindDOMNode(componentOrElement));
	});

	var escapeKeyCode = 27;

	var noop$4 = function noop() {};

	function isLeftClickEvent(event) {
	  return event.button === 0;
	}

	function isModifiedEvent(event) {
	  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}

	var getRefTarget = function getRefTarget(ref) {
	  return ref && ('current' in ref ? ref.current : ref);
	};

	/**
	 * The `useRootClose` hook registers your callback on the document
	 * when rendered. Powers the `<Overlay/>` component. This is used achieve modal
	 * style behavior where your callback is triggered when the user tries to
	 * interact with the rest of the document or hits the `esc` key.
	 *
	 * @param {Ref<HTMLElement>| HTMLElement} ref  The element boundary
	 * @param {function} onRootClose
	 * @param {object=}  options
	 * @param {boolean=} options.disabled
	 * @param {string=}  options.clickTrigger The DOM event name (click, mousedown, etc) to attach listeners on
	 */
	function useRootClose(ref, onRootClose, _temp) {
	  var _ref = _temp === void 0 ? {} : _temp,
	      disabled = _ref.disabled,
	      _ref$clickTrigger = _ref.clickTrigger,
	      clickTrigger = _ref$clickTrigger === void 0 ? 'click' : _ref$clickTrigger;

	  var preventMouseRootCloseRef = React$1.useRef(false);
	  var onClose = onRootClose || noop$4;
	  var handleMouseCapture = React$1.useCallback(function (e) {
	    var _e$composedPath$;

	    var currentTarget = getRefTarget(ref);
	    warning$1(!!currentTarget, 'RootClose captured a close event but does not have a ref to compare it to. ' + 'useRootClose(), should be passed a ref that resolves to a DOM node');
	    preventMouseRootCloseRef.current = !currentTarget || isModifiedEvent(e) || !isLeftClickEvent(e) || !!contains$1(currentTarget, (_e$composedPath$ = e.composedPath == null ? void 0 : e.composedPath()[0]) != null ? _e$composedPath$ : e.target);
	  }, [ref]);
	  var handleMouse = useEventCallback(function (e) {
	    if (!preventMouseRootCloseRef.current) {
	      onClose(e);
	    }
	  });
	  var handleKeyUp = useEventCallback(function (e) {
	    if (e.keyCode === escapeKeyCode) {
	      onClose(e);
	    }
	  });
	  React$1.useEffect(function () {
	    if (disabled || ref == null) return undefined; // Store the current event to avoid triggering handlers immediately
	    // https://github.com/facebook/react/issues/20074

	    var currentEvent = window.event;
	    var doc = ownerDocument(getRefTarget(ref)); // Use capture for this listener so it fires before React's listener, to
	    // avoid false positives in the contains() check below if the target DOM
	    // element is removed in the React mouse callback.

	    var removeMouseCaptureListener = listen(doc, clickTrigger, handleMouseCapture, true);
	    var removeMouseListener = listen(doc, clickTrigger, function (e) {
	      // skip if this event is the same as the one running when we added the handlers
	      if (e === currentEvent) {
	        currentEvent = undefined;
	        return;
	      }

	      handleMouse(e);
	    });
	    var removeKeyupListener = listen(doc, 'keyup', function (e) {
	      // skip if this event is the same as the one running when we added the handlers
	      if (e === currentEvent) {
	        currentEvent = undefined;
	        return;
	      }

	      handleKeyUp(e);
	    });
	    var mobileSafariHackListeners = [];

	    if ('ontouchstart' in doc.documentElement) {
	      mobileSafariHackListeners = [].slice.call(doc.body.children).map(function (el) {
	        return listen(el, 'mousemove', noop$4);
	      });
	    }

	    return function () {
	      removeMouseCaptureListener();
	      removeMouseListener();
	      removeKeyupListener();
	      mobileSafariHackListeners.forEach(function (remove) {
	        return remove();
	      });
	    };
	  }, [ref, disabled, clickTrigger, handleMouseCapture, handleMouse, handleKeyUp]);
	}

	function toModifierMap(modifiers) {
	  var result = {};

	  if (!Array.isArray(modifiers)) {
	    return modifiers || result;
	  } // eslint-disable-next-line no-unused-expressions


	  modifiers == null ? void 0 : modifiers.forEach(function (m) {
	    result[m.name] = m;
	  });
	  return result;
	}
	function toModifierArray(map) {
	  if (map === void 0) {
	    map = {};
	  }

	  if (Array.isArray(map)) return map;
	  return Object.keys(map).map(function (k) {
	    map[k].name = k;
	    return map[k];
	  });
	}
	function mergeOptionsWithPopperConfig(_ref) {
	  var _modifiers$preventOve, _modifiers$preventOve2, _modifiers$offset, _modifiers$arrow;

	  var enabled = _ref.enabled,
	      enableEvents = _ref.enableEvents,
	      placement = _ref.placement,
	      flip = _ref.flip,
	      offset = _ref.offset,
	      fixed = _ref.fixed,
	      containerPadding = _ref.containerPadding,
	      arrowElement = _ref.arrowElement,
	      _ref$popperConfig = _ref.popperConfig,
	      popperConfig = _ref$popperConfig === void 0 ? {} : _ref$popperConfig;
	  var modifiers = toModifierMap(popperConfig.modifiers);
	  return _extends$1({}, popperConfig, {
	    placement: placement,
	    enabled: enabled,
	    strategy: fixed ? 'fixed' : popperConfig.strategy,
	    modifiers: toModifierArray(_extends$1({}, modifiers, {
	      eventListeners: {
	        enabled: enableEvents
	      },
	      preventOverflow: _extends$1({}, modifiers.preventOverflow, {
	        options: containerPadding ? _extends$1({
	          padding: containerPadding
	        }, (_modifiers$preventOve = modifiers.preventOverflow) == null ? void 0 : _modifiers$preventOve.options) : (_modifiers$preventOve2 = modifiers.preventOverflow) == null ? void 0 : _modifiers$preventOve2.options
	      }),
	      offset: {
	        options: _extends$1({
	          offset: offset
	        }, (_modifiers$offset = modifiers.offset) == null ? void 0 : _modifiers$offset.options)
	      },
	      arrow: _extends$1({}, modifiers.arrow, {
	        enabled: !!arrowElement,
	        options: _extends$1({}, (_modifiers$arrow = modifiers.arrow) == null ? void 0 : _modifiers$arrow.options, {
	          element: arrowElement
	        })
	      }),
	      flip: _extends$1({
	        enabled: !!flip
	      }, modifiers.flip)
	    }))
	  });
	}

	var noop$3 = function noop() {};
	/**
	 * @memberOf Dropdown
	 * @param {object}  options
	 * @param {boolean} options.flip Automatically adjust the menu `drop` position based on viewport edge detection
	 * @param {[number, number]} options.offset Define an offset distance between the Menu and the Toggle
	 * @param {boolean} options.show Display the menu manually, ignored in the context of a `Dropdown`
	 * @param {boolean} options.usePopper opt in/out of using PopperJS to position menus. When disabled you must position it yourself.
	 * @param {string}  options.rootCloseEvent The pointer event to listen for when determining "clicks outside" the menu for triggering a close.
	 * @param {object}  options.popperConfig Options passed to the [`usePopper`](/api/usePopper) hook.
	 */


	function useDropdownMenu(options) {
	  if (options === void 0) {
	    options = {};
	  }

	  var context = React$1.useContext(DropdownContext$1);

	  var _useCallbackRef = useCallbackRef(),
	      arrowElement = _useCallbackRef[0],
	      attachArrowRef = _useCallbackRef[1];

	  var hasShownRef = React$1.useRef(false);
	  var _options = options,
	      flip = _options.flip,
	      offset = _options.offset,
	      rootCloseEvent = _options.rootCloseEvent,
	      _options$fixed = _options.fixed,
	      fixed = _options$fixed === void 0 ? false : _options$fixed,
	      _options$popperConfig = _options.popperConfig,
	      popperConfig = _options$popperConfig === void 0 ? {} : _options$popperConfig,
	      _options$usePopper = _options.usePopper,
	      shouldUsePopper = _options$usePopper === void 0 ? !!context : _options$usePopper;
	  var show = (context == null ? void 0 : context.show) == null ? !!options.show : context.show;
	  var alignEnd = (context == null ? void 0 : context.alignEnd) == null ? options.alignEnd : context.alignEnd;

	  if (show && !hasShownRef.current) {
	    hasShownRef.current = true;
	  }

	  var handleClose = function handleClose(e) {
	    context == null ? void 0 : context.toggle(false, e);
	  };

	  var _ref = context || {},
	      drop = _ref.drop,
	      setMenu = _ref.setMenu,
	      menuElement = _ref.menuElement,
	      toggleElement = _ref.toggleElement;

	  var placement = alignEnd ? 'bottom-end' : 'bottom-start';
	  if (drop === 'up') placement = alignEnd ? 'top-end' : 'top-start';else if (drop === 'right') placement = alignEnd ? 'right-end' : 'right-start';else if (drop === 'left') placement = alignEnd ? 'left-end' : 'left-start';
	  var popper = usePopper(toggleElement, menuElement, mergeOptionsWithPopperConfig({
	    placement: placement,
	    enabled: !!(shouldUsePopper && show),
	    enableEvents: show,
	    offset: offset,
	    flip: flip,
	    fixed: fixed,
	    arrowElement: arrowElement,
	    popperConfig: popperConfig
	  }));

	  var menuProps = _extends$1({
	    ref: setMenu || noop$3,
	    'aria-labelledby': toggleElement == null ? void 0 : toggleElement.id
	  }, popper.attributes.popper, {
	    style: popper.styles.popper
	  });

	  var metadata = {
	    show: show,
	    alignEnd: alignEnd,
	    hasShown: hasShownRef.current,
	    toggle: context == null ? void 0 : context.toggle,
	    popper: shouldUsePopper ? popper : null,
	    arrowProps: shouldUsePopper ? _extends$1({
	      ref: attachArrowRef
	    }, popper.attributes.arrow, {
	      style: popper.styles.arrow
	    }) : {}
	  };
	  useRootClose(menuElement, handleClose, {
	    clickTrigger: rootCloseEvent,
	    disabled: !show
	  });
	  return [menuProps, metadata];
	}
	var propTypes$7 = {
	  /**
	   * A render prop that returns a Menu element. The `props`
	   * argument should spread through to **a component that can accept a ref**.
	   *
	   * @type {Function ({
	   *   show: boolean,
	   *   alignEnd: boolean,
	   *   close: (?SyntheticEvent) => void,
	   *   placement: Placement,
	   *   update: () => void,
	   *   forceUpdate: () => void,
	   *   props: {
	   *     ref: (?HTMLElement) => void,
	   *     style: { [string]: string | number },
	   *     aria-labelledby: ?string
	   *   },
	   *   arrowProps: {
	   *     ref: (?HTMLElement) => void,
	   *     style: { [string]: string | number },
	   *   },
	   * }) => React.Element}
	   */
	  children: PropTypes.func.isRequired,

	  /**
	   * Controls the visible state of the menu, generally this is
	   * provided by the parent `Dropdown` component,
	   * but may also be specified as a prop directly.
	   */
	  show: PropTypes.bool,

	  /**
	   * Aligns the dropdown menu to the 'end' of it's placement position.
	   * Generally this is provided by the parent `Dropdown` component,
	   * but may also be specified as a prop directly.
	   */
	  alignEnd: PropTypes.bool,

	  /**
	   * Enables the Popper.js `flip` modifier, allowing the Dropdown to
	   * automatically adjust it's placement in case of overlap with the viewport or toggle.
	   * Refer to the [flip docs](https://popper.js.org/popper-documentation.html#modifiers..flip.enabled) for more info
	   */
	  flip: PropTypes.bool,
	  usePopper: PropTypes.oneOf([true, false]),

	  /**
	   * A set of popper options and props passed directly to react-popper's Popper component.
	   */
	  popperConfig: PropTypes.object,

	  /**
	   * Override the default event used by RootCloseWrapper.
	   */
	  rootCloseEvent: PropTypes.string
	};
	var defaultProps$1 = {
	  usePopper: true
	};

	/**
	 * Also exported as `<Dropdown.Menu>` from `Dropdown`.
	 *
	 * @displayName DropdownMenu
	 * @memberOf Dropdown
	 */
	function DropdownMenu(_ref2) {
	  var children = _ref2.children,
	      options = _objectWithoutPropertiesLoose(_ref2, ["children"]);

	  var _useDropdownMenu = useDropdownMenu(options),
	      props = _useDropdownMenu[0],
	      meta = _useDropdownMenu[1];

	  return /*#__PURE__*/React$1.createElement(React$1.Fragment, null, meta.hasShown ? children(props, meta) : null);
	}

	DropdownMenu.displayName = 'ReactOverlaysDropdownMenu';
	DropdownMenu.propTypes = propTypes$7;
	DropdownMenu.defaultProps = defaultProps$1;

	var noop$2 = function noop() {};
	/**
	 * Wires up Dropdown toggle functionality, returning a set a props to attach
	 * to the element that functions as the dropdown toggle (generally a button).
	 *
	 * @memberOf Dropdown
	 */


	function useDropdownToggle() {
	  var _ref = React$1.useContext(DropdownContext$1) || {},
	      _ref$show = _ref.show,
	      show = _ref$show === void 0 ? false : _ref$show,
	      _ref$toggle = _ref.toggle,
	      toggle = _ref$toggle === void 0 ? noop$2 : _ref$toggle,
	      setToggle = _ref.setToggle;

	  var handleClick = React$1.useCallback(function (e) {
	    toggle(!show, e);
	  }, [show, toggle]);
	  return [{
	    ref: setToggle || noop$2,
	    onClick: handleClick,
	    'aria-haspopup': true,
	    'aria-expanded': !!show
	  }, {
	    show: show,
	    toggle: toggle
	  }];
	}
	var propTypes$6 = {
	  /**
	   * A render prop that returns a Toggle element. The `props`
	   * argument should spread through to **a component that can accept a ref**. Use
	   * the `onToggle` argument to toggle the menu open or closed
	   *
	   * @type {Function ({
	   *   show: boolean,
	   *   toggle: (show: boolean) => void,
	   *   props: {
	   *     ref: (?HTMLElement) => void,
	   *     aria-haspopup: true
	   *     aria-expanded: boolean
	   *   },
	   * }) => React.Element}
	   */
	  children: PropTypes.func.isRequired
	};

	/**
	 * Also exported as `<Dropdown.Toggle>` from `Dropdown`.
	 *
	 * @displayName DropdownToggle
	 * @memberOf Dropdown
	 */
	function DropdownToggle(_ref2) {
	  var children = _ref2.children;

	  var _useDropdownToggle = useDropdownToggle(),
	      props = _useDropdownToggle[0],
	      meta = _useDropdownToggle[1];

	  return /*#__PURE__*/React$1.createElement(React$1.Fragment, null, children(props, meta));
	}

	DropdownToggle.displayName = 'ReactOverlaysDropdownToggle';
	DropdownToggle.propTypes = propTypes$6;

	var propTypes$5 = {
	  /**
	   * A render prop that returns the root dropdown element. The `props`
	   * argument should spread through to an element containing _both_ the
	   * menu and toggle in order to handle keyboard events for focus management.
	   *
	   * @type {Function ({
	   *   props: {
	   *     onKeyDown: (SyntheticEvent) => void,
	   *   },
	   * }) => React.Element}
	   */
	  children: PropTypes.node,

	  /**
	   * Determines the direction and location of the Menu in relation to it's Toggle.
	   */
	  drop: PropTypes.oneOf(['up', 'left', 'right', 'down']),

	  /**
	   * Controls the focus behavior for when the Dropdown is opened. Set to
	   * `true` to always focus the first menu item, `keyboard` to focus only when
	   * navigating via the keyboard, or `false` to disable completely
	   *
	   * The Default behavior is `false` **unless** the Menu has a `role="menu"`
	   * where it will default to `keyboard` to match the recommended [ARIA Authoring practices](https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton).
	   */
	  focusFirstItemOnShow: PropTypes.oneOf([false, true, 'keyboard']),

	  /**
	   * A css slector string that will return __focusable__ menu items.
	   * Selectors should be relative to the menu component:
	   * e.g. ` > li:not('.disabled')`
	   */
	  itemSelector: PropTypes.string,

	  /**
	   * Align the menu to the 'end' side of the placement side of the Dropdown toggle. The default placement is `top-start` or `bottom-start`.
	   */
	  alignEnd: PropTypes.bool,

	  /**
	   * Whether or not the Dropdown is visible.
	   *
	   * @controllable onToggle
	   */
	  show: PropTypes.bool,

	  /**
	   * Sets the initial show position of the Dropdown.
	   */
	  defaultShow: PropTypes.bool,

	  /**
	   * A callback fired when the Dropdown wishes to change visibility. Called with the requested
	   * `show` value, the DOM event, and the source that fired it: `'click'`,`'keydown'`,`'rootClose'`, or `'select'`.
	   *
	   * ```ts static
	   * function(
	   *   isOpen: boolean,
	   *   event: SyntheticEvent,
	   * ): void
	   * ```
	   *
	   * @controllable show
	   */
	  onToggle: PropTypes.func
	};

	function useRefWithUpdate() {
	  var forceUpdate = useForceUpdate();
	  var ref = React$1.useRef(null);
	  var attachRef = React$1.useCallback(function (element) {
	    ref.current = element; // ensure that a menu set triggers an update for consumers

	    forceUpdate();
	  }, [forceUpdate]);
	  return [ref, attachRef];
	}
	/**
	 * @displayName Dropdown
	 * @public
	 */


	function Dropdown(_ref) {
	  var drop = _ref.drop,
	      alignEnd = _ref.alignEnd,
	      defaultShow = _ref.defaultShow,
	      rawShow = _ref.show,
	      rawOnToggle = _ref.onToggle,
	      _ref$itemSelector = _ref.itemSelector,
	      itemSelector = _ref$itemSelector === void 0 ? '* > *' : _ref$itemSelector,
	      focusFirstItemOnShow = _ref.focusFirstItemOnShow,
	      children = _ref.children;

	  var _useUncontrolledProp = useUncontrolledProp(rawShow, defaultShow, rawOnToggle),
	      show = _useUncontrolledProp[0],
	      onToggle = _useUncontrolledProp[1]; // We use normal refs instead of useCallbackRef in order to populate the
	  // the value as quickly as possible, otherwise the effect to focus the element
	  // may run before the state value is set


	  var _useRefWithUpdate = useRefWithUpdate(),
	      menuRef = _useRefWithUpdate[0],
	      setMenu = _useRefWithUpdate[1];

	  var menuElement = menuRef.current;

	  var _useRefWithUpdate2 = useRefWithUpdate(),
	      toggleRef = _useRefWithUpdate2[0],
	      setToggle = _useRefWithUpdate2[1];

	  var toggleElement = toggleRef.current;
	  var lastShow = usePrevious(show);
	  var lastSourceEvent = React$1.useRef(null);
	  var focusInDropdown = React$1.useRef(false);
	  var toggle = React$1.useCallback(function (nextShow, event) {
	    onToggle(nextShow, event);
	  }, [onToggle]);
	  var context = React$1.useMemo(function () {
	    return {
	      toggle: toggle,
	      drop: drop,
	      show: show,
	      alignEnd: alignEnd,
	      menuElement: menuElement,
	      toggleElement: toggleElement,
	      setMenu: setMenu,
	      setToggle: setToggle
	    };
	  }, [toggle, drop, show, alignEnd, menuElement, toggleElement, setMenu, setToggle]);

	  if (menuElement && lastShow && !show) {
	    focusInDropdown.current = menuElement.contains(document.activeElement);
	  }

	  var focusToggle = useEventCallback(function () {
	    if (toggleElement && toggleElement.focus) {
	      toggleElement.focus();
	    }
	  });
	  var maybeFocusFirst = useEventCallback(function () {
	    var type = lastSourceEvent.current;
	    var focusType = focusFirstItemOnShow;

	    if (focusType == null) {
	      focusType = menuRef.current && matches(menuRef.current, '[role=menu]') ? 'keyboard' : false;
	    }

	    if (focusType === false || focusType === 'keyboard' && !/^key.+$/.test(type)) {
	      return;
	    }

	    var first = qsa(menuRef.current, itemSelector)[0];
	    if (first && first.focus) first.focus();
	  });
	  React$1.useEffect(function () {
	    if (show) maybeFocusFirst();else if (focusInDropdown.current) {
	      focusInDropdown.current = false;
	      focusToggle();
	    } // only `show` should be changing
	  }, [show, focusInDropdown, focusToggle, maybeFocusFirst]);
	  React$1.useEffect(function () {
	    lastSourceEvent.current = null;
	  });

	  var getNextFocusedChild = function getNextFocusedChild(current, offset) {
	    if (!menuRef.current) return null;
	    var items = qsa(menuRef.current, itemSelector);
	    var index = items.indexOf(current) + offset;
	    index = Math.max(0, Math.min(index, items.length));
	    return items[index];
	  };

	  useGlobalListener('keydown', function (event) {
	    var _menuRef$current, _toggleRef$current;

	    var key = event.key;
	    var target = event.target;
	    var fromMenu = (_menuRef$current = menuRef.current) == null ? void 0 : _menuRef$current.contains(target);
	    var fromToggle = (_toggleRef$current = toggleRef.current) == null ? void 0 : _toggleRef$current.contains(target); // Second only to https://github.com/twbs/bootstrap/blob/8cfbf6933b8a0146ac3fbc369f19e520bd1ebdac/js/src/dropdown.js#L400
	    // in inscrutability

	    var isInput = /input|textarea/i.test(target.tagName);

	    if (isInput && (key === ' ' || key !== 'Escape' && fromMenu)) {
	      return;
	    }

	    if (!fromMenu && !fromToggle) {
	      return;
	    }

	    if (!menuRef.current && key === 'Tab') {
	      return;
	    }

	    lastSourceEvent.current = event.type;

	    switch (key) {
	      case 'ArrowUp':
	        {
	          var next = getNextFocusedChild(target, -1);
	          if (next && next.focus) next.focus();
	          event.preventDefault();
	          return;
	        }

	      case 'ArrowDown':
	        event.preventDefault();

	        if (!show) {
	          onToggle(true, event);
	        } else {
	          var _next = getNextFocusedChild(target, 1);

	          if (_next && _next.focus) _next.focus();
	        }

	        return;

	      case 'Tab':
	        // on keydown the target is the element being tabbed FROM, we need that
	        // to know if this event is relevant to this dropdown (e.g. in this menu).
	        // On `keyup` the target is the element being tagged TO which we use to check
	        // if focus has left the menu
	        addEventListener$2(document, 'keyup', function (e) {
	          var _menuRef$current2;

	          if (e.key === 'Tab' && !e.target || !((_menuRef$current2 = menuRef.current) != null && _menuRef$current2.contains(e.target))) {
	            onToggle(false, event);
	          }
	        }, {
	          once: true
	        });
	        break;

	      case 'Escape':
	        event.preventDefault();
	        event.stopPropagation();
	        onToggle(false, event);
	        break;
	    }
	  });
	  return /*#__PURE__*/React$1.createElement(DropdownContext$1.Provider, {
	    value: context
	  }, children);
	}

	Dropdown.displayName = 'ReactOverlaysDropdown';
	Dropdown.propTypes = propTypes$5;
	Dropdown.Menu = DropdownMenu;
	Dropdown.Toggle = DropdownToggle;

	/**
	 * Returns the actively focused element safely.
	 *
	 * @param doc the document to check
	 */

	function activeElement(doc) {
	  if (doc === void 0) {
	    doc = ownerDocument$1();
	  }

	  // Support: IE 9 only
	  // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
	  try {
	    var active = doc.activeElement; // IE11 returns a seemingly empty object in some cases when accessing
	    // document.activeElement from an <iframe>

	    if (!active || !active.nodeName) return null;
	    return active;
	  } catch (e) {
	    /* ie throws if no active element */
	    return doc.body;
	  }
	}

	/**
	 * Returns a ref that is immediately updated with the new value
	 *
	 * @param value The Ref value
	 * @category refs
	 */

	function useUpdatedRef(value) {
	  var valueRef = React$1.useRef(value);
	  valueRef.current = value;
	  return valueRef;
	}

	/**
	 * Attach a callback that fires when a component unmounts
	 *
	 * @param fn Handler to run when the component unmounts
	 * @category effects
	 */

	function useWillUnmount(fn) {
	  var onUnmount = useUpdatedRef(fn);
	  React$1.useEffect(function () {
	    return function () {
	      return onUnmount.current();
	    };
	  }, []);
	}

	/**
	 * Checks if a given element has a CSS class.
	 * 
	 * @param element the element
	 * @param className the CSS class name
	 */
	function hasClass(element, className) {
	  if (element.classList) return !!className && element.classList.contains(className);
	  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
	}

	/**
	 * Adds a CSS class to a given element.
	 * 
	 * @param element the element
	 * @param className the CSS class name
	 */

	function addClass(element, className) {
	  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
	}

	var addClass$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: addClass
	});

	function replaceClassName(origClass, classToRemove) {
	  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
	}
	/**
	 * Removes a CSS class from a given element.
	 * 
	 * @param element the element
	 * @param className the CSS class name
	 */


	function removeClass(element, className) {
	  if (element.classList) {
	    element.classList.remove(className);
	  } else if (typeof element.className === 'string') {
	    element.className = replaceClassName(element.className, className);
	  } else {
	    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
	  }
	}

	var removeClass$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: removeClass
	});

	var size;
	function scrollbarSize(recalc) {
	  if (!size && size !== 0 || recalc) {
	    if (canUseDOM$1) {
	      var scrollDiv = document.createElement('div');
	      scrollDiv.style.position = 'absolute';
	      scrollDiv.style.top = '-9999px';
	      scrollDiv.style.width = '50px';
	      scrollDiv.style.height = '50px';
	      scrollDiv.style.overflow = 'scroll';
	      document.body.appendChild(scrollDiv);
	      size = scrollDiv.offsetWidth - scrollDiv.clientWidth;
	      document.body.removeChild(scrollDiv);
	    }
	  }

	  return size;
	}

	var scrollbarSize$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: scrollbarSize
	});

	function isBody(node) {
	  return node && node.tagName.toLowerCase() === 'body';
	}

	function bodyIsOverflowing(node) {
	  var doc = isWindow(node) ? ownerDocument$1() : ownerDocument$1(node);
	  var win = isWindow(node) || doc.defaultView;
	  return doc.body.clientWidth < win.innerWidth;
	}

	function isOverflowing(container) {
	  var win = isWindow(container);
	  return win || isBody(container) ? bodyIsOverflowing(container) : container.scrollHeight > container.clientHeight;
	}

	var BLACKLIST = ['template', 'script', 'style'];

	var isHidable = function isHidable(_ref) {
	  var nodeType = _ref.nodeType,
	      tagName = _ref.tagName;
	  return nodeType === 1 && BLACKLIST.indexOf(tagName.toLowerCase()) === -1;
	};

	var siblings = function siblings(container, exclude, cb) {
	  [].forEach.call(container.children, function (node) {
	    if (exclude.indexOf(node) === -1 && isHidable(node)) {
	      cb(node);
	    }
	  });
	};

	function ariaHidden(hide, node) {
	  if (!node) return;

	  if (hide) {
	    node.setAttribute('aria-hidden', 'true');
	  } else {
	    node.removeAttribute('aria-hidden');
	  }
	}
	function hideSiblings(container, _ref2) {
	  var dialog = _ref2.dialog,
	      backdrop = _ref2.backdrop;
	  siblings(container, [dialog, backdrop], function (node) {
	    return ariaHidden(true, node);
	  });
	}
	function showSiblings(container, _ref3) {
	  var dialog = _ref3.dialog,
	      backdrop = _ref3.backdrop;
	  siblings(container, [dialog, backdrop], function (node) {
	    return ariaHidden(false, node);
	  });
	}

	function findIndexOf(arr, cb) {
	  var idx = -1;
	  arr.some(function (d, i) {
	    if (cb(d, i)) {
	      idx = i;
	      return true;
	    }

	    return false;
	  });
	  return idx;
	}

	/**
	 * Proper state management for containers and the modals in those containers.
	 *
	 * @internal Used by the Modal to ensure proper styling of containers.
	 */
	var ModalManager = /*#__PURE__*/function () {
	  function ModalManager(_temp) {
	    var _ref = _temp === void 0 ? {} : _temp,
	        _ref$hideSiblingNodes = _ref.hideSiblingNodes,
	        hideSiblingNodes = _ref$hideSiblingNodes === void 0 ? true : _ref$hideSiblingNodes,
	        _ref$handleContainerO = _ref.handleContainerOverflow,
	        handleContainerOverflow = _ref$handleContainerO === void 0 ? true : _ref$handleContainerO;

	    this.hideSiblingNodes = void 0;
	    this.handleContainerOverflow = void 0;
	    this.modals = void 0;
	    this.containers = void 0;
	    this.data = void 0;
	    this.scrollbarSize = void 0;
	    this.hideSiblingNodes = hideSiblingNodes;
	    this.handleContainerOverflow = handleContainerOverflow;
	    this.modals = [];
	    this.containers = [];
	    this.data = [];
	    this.scrollbarSize = scrollbarSize();
	  }

	  var _proto = ModalManager.prototype;

	  _proto.isContainerOverflowing = function isContainerOverflowing(modal) {
	    var data = this.data[this.containerIndexFromModal(modal)];
	    return data && data.overflowing;
	  };

	  _proto.containerIndexFromModal = function containerIndexFromModal(modal) {
	    return findIndexOf(this.data, function (d) {
	      return d.modals.indexOf(modal) !== -1;
	    });
	  };

	  _proto.setContainerStyle = function setContainerStyle(containerState, container) {
	    var style$1 = {
	      overflow: 'hidden'
	    }; // we are only interested in the actual `style` here
	    // because we will override it

	    containerState.style = {
	      overflow: container.style.overflow,
	      paddingRight: container.style.paddingRight
	    };

	    if (containerState.overflowing) {
	      // use computed style, here to get the real padding
	      // to add our scrollbar width
	      style$1.paddingRight = parseInt(style(container, 'paddingRight') || '0', 10) + this.scrollbarSize + "px";
	    }

	    style(container, style$1);
	  };

	  _proto.removeContainerStyle = function removeContainerStyle(containerState, container) {
	    Object.assign(container.style, containerState.style);
	  };

	  _proto.add = function add(modal, container, className) {
	    var modalIdx = this.modals.indexOf(modal);
	    var containerIdx = this.containers.indexOf(container);

	    if (modalIdx !== -1) {
	      return modalIdx;
	    }

	    modalIdx = this.modals.length;
	    this.modals.push(modal);

	    if (this.hideSiblingNodes) {
	      hideSiblings(container, modal);
	    }

	    if (containerIdx !== -1) {
	      this.data[containerIdx].modals.push(modal);
	      return modalIdx;
	    }

	    var data = {
	      modals: [modal],
	      // right now only the first modal of a container will have its classes applied
	      classes: className ? className.split(/\s+/) : [],
	      overflowing: isOverflowing(container)
	    };

	    if (this.handleContainerOverflow) {
	      this.setContainerStyle(data, container);
	    }

	    data.classes.forEach(addClass.bind(null, container));
	    this.containers.push(container);
	    this.data.push(data);
	    return modalIdx;
	  };

	  _proto.remove = function remove(modal) {
	    var modalIdx = this.modals.indexOf(modal);

	    if (modalIdx === -1) {
	      return;
	    }

	    var containerIdx = this.containerIndexFromModal(modal);
	    var data = this.data[containerIdx];
	    var container = this.containers[containerIdx];
	    data.modals.splice(data.modals.indexOf(modal), 1);
	    this.modals.splice(modalIdx, 1); // if that was the last modal in a container,
	    // clean up the container

	    if (data.modals.length === 0) {
	      data.classes.forEach(removeClass.bind(null, container));

	      if (this.handleContainerOverflow) {
	        this.removeContainerStyle(data, container);
	      }

	      if (this.hideSiblingNodes) {
	        showSiblings(container, modal);
	      }

	      this.containers.splice(containerIdx, 1);
	      this.data.splice(containerIdx, 1);
	    } else if (this.hideSiblingNodes) {
	      // otherwise make sure the next top modal is visible to a SR
	      var _data$modals = data.modals[data.modals.length - 1],
	          backdrop = _data$modals.backdrop,
	          dialog = _data$modals.dialog;
	      ariaHidden(false, dialog);
	      ariaHidden(false, backdrop);
	    }
	  };

	  _proto.isTopModal = function isTopModal(modal) {
	    return !!this.modals.length && this.modals[this.modals.length - 1] === modal;
	  };

	  return ModalManager;
	}();

	var ModalManager$1 = ModalManager;

	var resolveContainerRef = function resolveContainerRef(ref) {
	  var _ref;

	  if (typeof document === 'undefined') return null;
	  if (ref == null) return ownerDocument$1().body;
	  if (typeof ref === 'function') ref = ref();
	  if (ref && 'current' in ref) ref = ref.current;
	  if ((_ref = ref) != null && _ref.nodeType) return ref || null;
	  return null;
	};
	function useWaitForDOMRef(ref, onResolved) {
	  var _useState = React$1.useState(function () {
	    return resolveContainerRef(ref);
	  }),
	      resolvedRef = _useState[0],
	      setRef = _useState[1];

	  if (!resolvedRef) {
	    var earlyRef = resolveContainerRef(ref);
	    if (earlyRef) setRef(earlyRef);
	  }

	  React$1.useEffect(function () {
	    if (onResolved && resolvedRef) {
	      onResolved(resolvedRef);
	    }
	  }, [onResolved, resolvedRef]);
	  React$1.useEffect(function () {
	    var nextRef = resolveContainerRef(ref);

	    if (nextRef !== resolvedRef) {
	      setRef(nextRef);
	    }
	  }, [ref, resolvedRef]);
	  return resolvedRef;
	}

	var manager;

	function getManager() {
	  if (!manager) manager = new ModalManager$1();
	  return manager;
	}

	function useModalManager(provided) {
	  var modalManager = provided || getManager();
	  var modal = React$1.useRef({
	    dialog: null,
	    backdrop: null
	  });
	  return Object.assign(modal.current, {
	    add: function add(container, className) {
	      return modalManager.add(modal.current, container, className);
	    },
	    remove: function remove() {
	      return modalManager.remove(modal.current);
	    },
	    isTopModal: function isTopModal() {
	      return modalManager.isTopModal(modal.current);
	    },
	    setDialogRef: React$1.useCallback(function (ref) {
	      modal.current.dialog = ref;
	    }, []),
	    setBackdropRef: React$1.useCallback(function (ref) {
	      modal.current.backdrop = ref;
	    }, [])
	  });
	}

	var Modal$2 = /*#__PURE__*/React$1.forwardRef(function (_ref, ref) {
	  var _ref$show = _ref.show,
	      show = _ref$show === void 0 ? false : _ref$show,
	      _ref$role = _ref.role,
	      role = _ref$role === void 0 ? 'dialog' : _ref$role,
	      className = _ref.className,
	      style = _ref.style,
	      children = _ref.children,
	      _ref$backdrop = _ref.backdrop,
	      backdrop = _ref$backdrop === void 0 ? true : _ref$backdrop,
	      _ref$keyboard = _ref.keyboard,
	      keyboard = _ref$keyboard === void 0 ? true : _ref$keyboard,
	      onBackdropClick = _ref.onBackdropClick,
	      onEscapeKeyDown = _ref.onEscapeKeyDown,
	      transition = _ref.transition,
	      backdropTransition = _ref.backdropTransition,
	      _ref$autoFocus = _ref.autoFocus,
	      autoFocus = _ref$autoFocus === void 0 ? true : _ref$autoFocus,
	      _ref$enforceFocus = _ref.enforceFocus,
	      enforceFocus = _ref$enforceFocus === void 0 ? true : _ref$enforceFocus,
	      _ref$restoreFocus = _ref.restoreFocus,
	      restoreFocus = _ref$restoreFocus === void 0 ? true : _ref$restoreFocus,
	      restoreFocusOptions = _ref.restoreFocusOptions,
	      renderDialog = _ref.renderDialog,
	      _ref$renderBackdrop = _ref.renderBackdrop,
	      renderBackdrop = _ref$renderBackdrop === void 0 ? function (props) {
	    return /*#__PURE__*/React$1.createElement("div", props);
	  } : _ref$renderBackdrop,
	      providedManager = _ref.manager,
	      containerRef = _ref.container,
	      containerClassName = _ref.containerClassName,
	      onShow = _ref.onShow,
	      _ref$onHide = _ref.onHide,
	      onHide = _ref$onHide === void 0 ? function () {} : _ref$onHide,
	      onExit = _ref.onExit,
	      onExited = _ref.onExited,
	      onExiting = _ref.onExiting,
	      onEnter = _ref.onEnter,
	      onEntering = _ref.onEntering,
	      onEntered = _ref.onEntered,
	      rest = _objectWithoutPropertiesLoose(_ref, ["show", "role", "className", "style", "children", "backdrop", "keyboard", "onBackdropClick", "onEscapeKeyDown", "transition", "backdropTransition", "autoFocus", "enforceFocus", "restoreFocus", "restoreFocusOptions", "renderDialog", "renderBackdrop", "manager", "container", "containerClassName", "onShow", "onHide", "onExit", "onExited", "onExiting", "onEnter", "onEntering", "onEntered"]);

	  var container = useWaitForDOMRef(containerRef);
	  var modal = useModalManager(providedManager);
	  var isMounted = useMounted();
	  var prevShow = usePrevious(show);

	  var _useState = React$1.useState(!show),
	      exited = _useState[0],
	      setExited = _useState[1];

	  var lastFocusRef = React$1.useRef(null);
	  React$1.useImperativeHandle(ref, function () {
	    return modal;
	  }, [modal]);

	  if (canUseDOM$1 && !prevShow && show) {
	    lastFocusRef.current = activeElement();
	  }

	  if (!transition && !show && !exited) {
	    setExited(true);
	  } else if (show && exited) {
	    setExited(false);
	  }

	  var handleShow = useEventCallback(function () {
	    modal.add(container, containerClassName);
	    removeKeydownListenerRef.current = listen(document, 'keydown', handleDocumentKeyDown);
	    removeFocusListenerRef.current = listen(document, 'focus', // the timeout is necessary b/c this will run before the new modal is mounted
	    // and so steals focus from it
	    function () {
	      return setTimeout(handleEnforceFocus);
	    }, true);

	    if (onShow) {
	      onShow();
	    } // autofocus after onShow to not trigger a focus event for previous
	    // modals before this one is shown.


	    if (autoFocus) {
	      var currentActiveElement = activeElement(document);

	      if (modal.dialog && currentActiveElement && !contains$1(modal.dialog, currentActiveElement)) {
	        lastFocusRef.current = currentActiveElement;
	        modal.dialog.focus();
	      }
	    }
	  });
	  var handleHide = useEventCallback(function () {
	    modal.remove();
	    removeKeydownListenerRef.current == null ? void 0 : removeKeydownListenerRef.current();
	    removeFocusListenerRef.current == null ? void 0 : removeFocusListenerRef.current();

	    if (restoreFocus) {
	      var _lastFocusRef$current;

	      // Support: <=IE11 doesn't support `focus()` on svg elements (RB: #917)
	      (_lastFocusRef$current = lastFocusRef.current) == null ? void 0 : _lastFocusRef$current.focus == null ? void 0 : _lastFocusRef$current.focus(restoreFocusOptions);
	      lastFocusRef.current = null;
	    }
	  }); // TODO: try and combine these effects: https://github.com/react-bootstrap/react-overlays/pull/794#discussion_r409954120
	  // Show logic when:
	  //  - show is `true` _and_ `container` has resolved

	  React$1.useEffect(function () {
	    if (!show || !container) return;
	    handleShow();
	  }, [show, container,
	  /* should never change: */
	  handleShow]); // Hide cleanup logic when:
	  //  - `exited` switches to true
	  //  - component unmounts;

	  React$1.useEffect(function () {
	    if (!exited) return;
	    handleHide();
	  }, [exited, handleHide]);
	  useWillUnmount(function () {
	    handleHide();
	  }); // --------------------------------

	  var handleEnforceFocus = useEventCallback(function () {
	    if (!enforceFocus || !isMounted() || !modal.isTopModal()) {
	      return;
	    }

	    var currentActiveElement = activeElement();

	    if (modal.dialog && currentActiveElement && !contains$1(modal.dialog, currentActiveElement)) {
	      modal.dialog.focus();
	    }
	  });
	  var handleBackdropClick = useEventCallback(function (e) {
	    if (e.target !== e.currentTarget) {
	      return;
	    }

	    onBackdropClick == null ? void 0 : onBackdropClick(e);

	    if (backdrop === true) {
	      onHide();
	    }
	  });
	  var handleDocumentKeyDown = useEventCallback(function (e) {
	    if (keyboard && e.keyCode === 27 && modal.isTopModal()) {
	      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(e);

	      if (!e.defaultPrevented) {
	        onHide();
	      }
	    }
	  });
	  var removeFocusListenerRef = React$1.useRef();
	  var removeKeydownListenerRef = React$1.useRef();

	  var handleHidden = function handleHidden() {
	    setExited(true);

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    onExited == null ? void 0 : onExited.apply(void 0, args);
	  };

	  var Transition = transition;

	  if (!container || !(show || Transition && !exited)) {
	    return null;
	  }

	  var dialogProps = _extends$1({
	    role: role,
	    ref: modal.setDialogRef,
	    // apparently only works on the dialog role element
	    'aria-modal': role === 'dialog' ? true : undefined
	  }, rest, {
	    style: style,
	    className: className,
	    tabIndex: -1
	  });

	  var dialog = renderDialog ? renderDialog(dialogProps) : /*#__PURE__*/React$1.createElement("div", dialogProps, /*#__PURE__*/React$1.cloneElement(children, {
	    role: 'document'
	  }));

	  if (Transition) {
	    dialog = /*#__PURE__*/React$1.createElement(Transition, {
	      appear: true,
	      unmountOnExit: true,
	      "in": !!show,
	      onExit: onExit,
	      onExiting: onExiting,
	      onExited: handleHidden,
	      onEnter: onEnter,
	      onEntering: onEntering,
	      onEntered: onEntered
	    }, dialog);
	  }

	  var backdropElement = null;

	  if (backdrop) {
	    var BackdropTransition = backdropTransition;
	    backdropElement = renderBackdrop({
	      ref: modal.setBackdropRef,
	      onClick: handleBackdropClick
	    });

	    if (BackdropTransition) {
	      backdropElement = /*#__PURE__*/React$1.createElement(BackdropTransition, {
	        appear: true,
	        "in": !!show
	      }, backdropElement);
	    }
	  }

	  return /*#__PURE__*/React$1.createElement(React$1.Fragment, null, /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React$1.createElement(React$1.Fragment, null, backdropElement, dialog), container));
	});
	var propTypes$4 = {
	  /**
	   * Set the visibility of the Modal
	   */
	  show: PropTypes.bool,

	  /**
	   * A DOM element, a `ref` to an element, or function that returns either. The Modal is appended to it's `container` element.
	   *
	   * For the sake of assistive technologies, the container should usually be the document body, so that the rest of the
	   * page content can be placed behind a virtual backdrop as well as a visual one.
	   */
	  container: PropTypes.any,

	  /**
	   * A callback fired when the Modal is opening.
	   */
	  onShow: PropTypes.func,

	  /**
	   * A callback fired when either the backdrop is clicked, or the escape key is pressed.
	   *
	   * The `onHide` callback only signals intent from the Modal,
	   * you must actually set the `show` prop to `false` for the Modal to close.
	   */
	  onHide: PropTypes.func,

	  /**
	   * Include a backdrop component.
	   */
	  backdrop: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['static'])]),

	  /**
	   * A function that returns the dialog component. Useful for custom
	   * rendering. **Note:** the component should make sure to apply the provided ref.
	   *
	   * ```js static
	   * renderDialog={props => <MyDialog {...props} />}
	   * ```
	   */
	  renderDialog: PropTypes.func,

	  /**
	   * A function that returns a backdrop component. Useful for custom
	   * backdrop rendering.
	   *
	   * ```js
	   *  renderBackdrop={props => <MyBackdrop {...props} />}
	   * ```
	   */
	  renderBackdrop: PropTypes.func,

	  /**
	   * A callback fired when the escape key, if specified in `keyboard`, is pressed.
	   *
	   * If preventDefault() is called on the keyboard event, closing the modal will be cancelled.
	   */
	  onEscapeKeyDown: PropTypes.func,

	  /**
	   * A callback fired when the backdrop, if specified, is clicked.
	   */
	  onBackdropClick: PropTypes.func,

	  /**
	   * A css class or set of classes applied to the modal container when the modal is open,
	   * and removed when it is closed.
	   */
	  containerClassName: PropTypes.string,

	  /**
	   * Close the modal when escape key is pressed
	   */
	  keyboard: PropTypes.bool,

	  /**
	   * A `react-transition-group@2.0.0` `<Transition/>` component used
	   * to control animations for the dialog component.
	   */
	  transition: PropTypes.elementType,

	  /**
	   * A `react-transition-group@2.0.0` `<Transition/>` component used
	   * to control animations for the backdrop components.
	   */
	  backdropTransition: PropTypes.elementType,

	  /**
	   * When `true` The modal will automatically shift focus to itself when it opens, and
	   * replace it to the last focused element when it closes. This also
	   * works correctly with any Modal children that have the `autoFocus` prop.
	   *
	   * Generally this should never be set to `false` as it makes the Modal less
	   * accessible to assistive technologies, like screen readers.
	   */
	  autoFocus: PropTypes.bool,

	  /**
	   * When `true` The modal will prevent focus from leaving the Modal while open.
	   *
	   * Generally this should never be set to `false` as it makes the Modal less
	   * accessible to assistive technologies, like screen readers.
	   */
	  enforceFocus: PropTypes.bool,

	  /**
	   * When `true` The modal will restore focus to previously focused element once
	   * modal is hidden
	   */
	  restoreFocus: PropTypes.bool,

	  /**
	   * Options passed to focus function when `restoreFocus` is set to `true`
	   *
	   * @link  https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus#Parameters
	   */
	  restoreFocusOptions: PropTypes.shape({
	    preventScroll: PropTypes.bool
	  }),

	  /**
	   * Callback fired before the Modal transitions in
	   */
	  onEnter: PropTypes.func,

	  /**
	   * Callback fired as the Modal begins to transition in
	   */
	  onEntering: PropTypes.func,

	  /**
	   * Callback fired after the Modal finishes transitioning in
	   */
	  onEntered: PropTypes.func,

	  /**
	   * Callback fired right before the Modal transitions out
	   */
	  onExit: PropTypes.func,

	  /**
	   * Callback fired as the Modal begins to transition out
	   */
	  onExiting: PropTypes.func,

	  /**
	   * Callback fired after the Modal finishes transitioning out
	   */
	  onExited: PropTypes.func,

	  /**
	   * A ModalManager instance used to track and manage the state of open
	   * Modals. Useful when customizing how modals interact within a container
	   */
	  manager: PropTypes.instanceOf(ModalManager$1)
	};
	Modal$2.displayName = 'Modal';
	Modal$2.propTypes = propTypes$4;
	var Modal$3 = Object.assign(Modal$2, {
	  Manager: ModalManager$1
	});

	var toFnRef = function toFnRef(ref) {
	  return !ref || typeof ref === 'function' ? ref : function (value) {
	    ref.current = value;
	  };
	};

	function mergeRefs(refA, refB) {
	  var a = toFnRef(refA);
	  var b = toFnRef(refB);
	  return function (value) {
	    if (a) a(value);
	    if (b) b(value);
	  };
	}
	/**
	 * Create and returns a single callback ref composed from two other Refs.
	 *
	 * ```tsx
	 * const Button = React.forwardRef((props, ref) => {
	 *   const [element, attachRef] = useCallbackRef<HTMLButtonElement>();
	 *   const mergedRef = useMergedRefs(ref, attachRef);
	 *
	 *   return <button ref={mergedRef} {...props}/>
	 * })
	 * ```
	 *
	 * @param refA A Callback or mutable Ref
	 * @param refB A Callback or mutable Ref
	 * @category refs
	 */

	function useMergedRefs(refA, refB) {
	  return React$1.useMemo(function () {
	    return mergeRefs(refA, refB);
	  }, [refA, refB]);
	}

	/**
	 * Built on top of `Popper.js`, the overlay component is
	 * great for custom tooltip overlays.
	 */
	var Overlay = /*#__PURE__*/React$1.forwardRef(function (props, outerRef) {
	  var flip = props.flip,
	      offset = props.offset,
	      placement = props.placement,
	      _props$containerPaddi = props.containerPadding,
	      containerPadding = _props$containerPaddi === void 0 ? 5 : _props$containerPaddi,
	      _props$popperConfig = props.popperConfig,
	      popperConfig = _props$popperConfig === void 0 ? {} : _props$popperConfig,
	      Transition = props.transition;

	  var _useCallbackRef = useCallbackRef(),
	      rootElement = _useCallbackRef[0],
	      attachRef = _useCallbackRef[1];

	  var _useCallbackRef2 = useCallbackRef(),
	      arrowElement = _useCallbackRef2[0],
	      attachArrowRef = _useCallbackRef2[1];

	  var mergedRef = useMergedRefs(attachRef, outerRef);
	  var container = useWaitForDOMRef(props.container);
	  var target = useWaitForDOMRef(props.target);

	  var _useState = React$1.useState(!props.show),
	      exited = _useState[0],
	      setExited = _useState[1];

	  var _usePopper = usePopper(target, rootElement, mergeOptionsWithPopperConfig({
	    placement: placement,
	    enableEvents: !!props.show,
	    containerPadding: containerPadding || 5,
	    flip: flip,
	    offset: offset,
	    arrowElement: arrowElement,
	    popperConfig: popperConfig
	  })),
	      styles = _usePopper.styles,
	      attributes = _usePopper.attributes,
	      popper = _objectWithoutPropertiesLoose(_usePopper, ["styles", "attributes"]);

	  if (props.show) {
	    if (exited) setExited(false);
	  } else if (!props.transition && !exited) {
	    setExited(true);
	  }

	  var handleHidden = function handleHidden() {
	    setExited(true);

	    if (props.onExited) {
	      props.onExited.apply(props, arguments);
	    }
	  }; // Don't un-render the overlay while it's transitioning out.


	  var mountOverlay = props.show || Transition && !exited;
	  useRootClose(rootElement, props.onHide, {
	    disabled: !props.rootClose || props.rootCloseDisabled,
	    clickTrigger: props.rootCloseEvent
	  });

	  if (!mountOverlay) {
	    // Don't bother showing anything if we don't have to.
	    return null;
	  }

	  var child = props.children(_extends$1({}, popper, {
	    show: !!props.show,
	    props: _extends$1({}, attributes.popper, {
	      style: styles.popper,
	      ref: mergedRef
	    }),
	    arrowProps: _extends$1({}, attributes.arrow, {
	      style: styles.arrow,
	      ref: attachArrowRef
	    })
	  }));

	  if (Transition) {
	    var onExit = props.onExit,
	        onExiting = props.onExiting,
	        onEnter = props.onEnter,
	        onEntering = props.onEntering,
	        onEntered = props.onEntered;
	    child = /*#__PURE__*/React$1.createElement(Transition, {
	      "in": props.show,
	      appear: true,
	      onExit: onExit,
	      onExiting: onExiting,
	      onExited: handleHidden,
	      onEnter: onEnter,
	      onEntering: onEntering,
	      onEntered: onEntered
	    }, child);
	  }

	  return container ? /*#__PURE__*/ReactDOM.createPortal(child, container) : null;
	});
	Overlay.displayName = 'Overlay';
	Overlay.propTypes = {
	  /**
	   * Set the visibility of the Overlay
	   */
	  show: PropTypes.bool,

	  /** Specify where the overlay element is positioned in relation to the target element */
	  placement: PropTypes.oneOf(placements),

	  /**
	   * A DOM Element, Ref to an element, or function that returns either. The `target` element is where
	   * the overlay is positioned relative to.
	   */
	  target: PropTypes.any,

	  /**
	   * A DOM Element, Ref to an element, or function that returns either. The `container` will have the Portal children
	   * appended to it.
	   */
	  container: PropTypes.any,

	  /**
	   * Enables the Popper.js `flip` modifier, allowing the Overlay to
	   * automatically adjust it's placement in case of overlap with the viewport or toggle.
	   * Refer to the [flip docs](https://popper.js.org/popper-documentation.html#modifiers..flip.enabled) for more info
	   */
	  flip: PropTypes.bool,

	  /**
	   * A render prop that returns an element to overlay and position. See
	   * the [react-popper documentation](https://github.com/FezVrasta/react-popper#children) for more info.
	   *
	   * @type {Function ({
	   *   show: boolean,
	   *   placement: Placement,
	   *   update: () => void,
	   *   forceUpdate: () => void,
	   *   props: {
	   *     ref: (?HTMLElement) => void,
	   *     style: { [string]: string | number },
	   *     aria-labelledby: ?string
	   *     [string]: string | number,
	   *   },
	   *   arrowProps: {
	   *     ref: (?HTMLElement) => void,
	   *     style: { [string]: string | number },
	   *     [string]: string | number,
	   *   },
	   * }) => React.Element}
	   */
	  children: PropTypes.func.isRequired,

	  /**
	   * Control how much space there is between the edge of the boundary element and overlay.
	   * A convenience shortcut to setting `popperConfig.modfiers.preventOverflow.padding`
	   */
	  containerPadding: PropTypes.number,

	  /**
	   * A set of popper options and props passed directly to react-popper's Popper component.
	   */
	  popperConfig: PropTypes.object,

	  /**
	   * Specify whether the overlay should trigger `onHide` when the user clicks outside the overlay
	   */
	  rootClose: PropTypes.bool,

	  /**
	   * Specify event for toggling overlay
	   */
	  rootCloseEvent: PropTypes.oneOf(['click', 'mousedown']),

	  /**
	   * Specify disabled for disable RootCloseWrapper
	   */
	  rootCloseDisabled: PropTypes.bool,

	  /**
	   * A Callback fired by the Overlay when it wishes to be hidden.
	   *
	   * __required__ when `rootClose` is `true`.
	   *
	   * @type func
	   */
	  onHide: function onHide(props) {
	    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    if (props.rootClose) {
	      var _PropTypes$func;

	      return (_PropTypes$func = PropTypes.func).isRequired.apply(_PropTypes$func, [props].concat(args));
	    }

	    return PropTypes.func.apply(PropTypes, [props].concat(args));
	  },

	  /**
	   * A `react-transition-group@2.0.0` `<Transition/>` component
	   * used to animate the overlay as it changes visibility.
	   */
	  // @ts-ignore
	  transition: PropTypes.elementType,

	  /**
	   * Callback fired before the Overlay transitions in
	   */
	  onEnter: PropTypes.func,

	  /**
	   * Callback fired as the Overlay begins to transition in
	   */
	  onEntering: PropTypes.func,

	  /**
	   * Callback fired after the Overlay finishes transitioning in
	   */
	  onEntered: PropTypes.func,

	  /**
	   * Callback fired right before the Overlay transitions out
	   */
	  onExit: PropTypes.func,

	  /**
	   * Callback fired as the Overlay begins to transition out
	   */
	  onExiting: PropTypes.func,

	  /**
	   * Callback fired after the Overlay finishes transitioning out
	   */
	  onExited: PropTypes.func
	};
	var Overlay$1 = Overlay;

	var propTypes$3 = {
	  /**
	   * A DOM element, Ref to an element, or function that returns either. The `container` will have the Portal children
	   * appended to it.
	   */
	  container: PropTypes.any,
	  onRendered: PropTypes.func
	};

	/**
	 * @public
	 */
	var Portal = function Portal(_ref) {
	  var container = _ref.container,
	      children = _ref.children,
	      onRendered = _ref.onRendered;
	  var resolvedContainer = useWaitForDOMRef(container, onRendered);
	  return resolvedContainer ? /*#__PURE__*/React$1.createElement(React$1.Fragment, null, /*#__PURE__*/ReactDOM.createPortal(children, resolvedContainer)) : null;
	};

	Portal.displayName = 'Portal';
	Portal.propTypes = propTypes$3;
	var Portal$1 = Portal;

	var esm = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Dropdown: Dropdown,
		Modal: Modal$3,
		Overlay: Overlay$1,
		Portal: Portal$1,
		useDropdownMenu: useDropdownMenu,
		useDropdownToggle: useDropdownToggle,
		useRootClose: useRootClose
	});

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear$2() {
	  this.__data__ = [];
	  this.size = 0;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf$5(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq$5(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/** Used for built-in method references. */
	var arrayProto$1 = Array.prototype;

	/** Built-in value references. */
	var splice$1 = arrayProto$1.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete$2(key) {
	  var data = this.__data__,
	      index = assocIndexOf$5(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice$1.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet$2(key) {
	  var data = this.__data__,
	      index = assocIndexOf$5(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas$2(key) {
	  return assocIndexOf$5(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet$2(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf$5(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache$5(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache$5.prototype.clear = listCacheClear$2;
	ListCache$5.prototype['delete'] = listCacheDelete$2;
	ListCache$5.prototype.get = listCacheGet$2;
	ListCache$5.prototype.has = listCacheHas$2;
	ListCache$5.prototype.set = listCacheSet$2;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear$2() {
	  this.__data__ = new ListCache$5;
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete$2(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet$2(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas$2(key) {
	  return this.__data__.has(key);
	}

	/** Used to detect overreaching core-js shims. */
	var coreJsData$2 = root$a['__core-js_shared__'];

	var coreJsData$3 = coreJsData$2;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey$1 = (function() {
	  var uid = /[^.]+$/.exec(coreJsData$3 && coreJsData$3.keys && coreJsData$3.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked$2(func) {
	  return !!maskSrcKey$1 && (maskSrcKey$1 in func);
	}

	/** Used for built-in method references. */
	var funcProto$4 = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$4 = funcProto$4.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource$3(func) {
	  if (func != null) {
	    try {
	      return funcToString$4.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$3 = Function.prototype,
	    objectProto$q = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$3 = funcProto$3.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$m = objectProto$q.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative$1 = RegExp('^' +
	  funcToString$3.call(hasOwnProperty$m).replace(reRegExpChar$1, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative$2(value) {
	  if (!isObject$7(value) || isMasked$2(value)) {
	    return false;
	  }
	  var pattern = isFunction$6(value) ? reIsNative$1 : reIsHostCtor$1;
	  return pattern.test(toSource$3(value));
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue$2(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative$8(object, key) {
	  var value = getValue$2(object, key);
	  return baseIsNative$2(value) ? value : undefined;
	}

	/* Built-in method references that are verified to be native. */
	var Map$5 = getNative$8(root$a, 'Map');

	var Map$6 = Map$5;

	/* Built-in method references that are verified to be native. */
	var nativeCreate$5 = getNative$8(Object, 'create');

	var nativeCreate$6 = nativeCreate$5;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear$2() {
	  this.__data__ = nativeCreate$6 ? nativeCreate$6(null) : {};
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete$2(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$5 = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$p = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$l = objectProto$p.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet$2(key) {
	  var data = this.__data__;
	  if (nativeCreate$6) {
	    var result = data[key];
	    return result === HASH_UNDEFINED$5 ? undefined : result;
	  }
	  return hasOwnProperty$l.call(data, key) ? data[key] : undefined;
	}

	/** Used for built-in method references. */
	var objectProto$o = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$k = objectProto$o.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas$2(key) {
	  var data = this.__data__;
	  return nativeCreate$6 ? (data[key] !== undefined) : hasOwnProperty$k.call(data, key);
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$4 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet$2(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate$6 && value === undefined) ? HASH_UNDEFINED$4 : value;
	  return this;
	}

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash$2(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash$2.prototype.clear = hashClear$2;
	Hash$2.prototype['delete'] = hashDelete$2;
	Hash$2.prototype.get = hashGet$2;
	Hash$2.prototype.has = hashHas$2;
	Hash$2.prototype.set = hashSet$2;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear$2() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash$2,
	    'map': new (Map$6 || ListCache$5),
	    'string': new Hash$2
	  };
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable$2(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData$5(map, key) {
	  var data = map.__data__;
	  return isKeyable$2(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete$2(key) {
	  var result = getMapData$5(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet$2(key) {
	  return getMapData$5(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas$2(key) {
	  return getMapData$5(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet$2(key, value) {
	  var data = getMapData$5(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache$4(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache$4.prototype.clear = mapCacheClear$2;
	MapCache$4.prototype['delete'] = mapCacheDelete$2;
	MapCache$4.prototype.get = mapCacheGet$2;
	MapCache$4.prototype.has = mapCacheHas$2;
	MapCache$4.prototype.set = mapCacheSet$2;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE$1 = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet$2(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache$5) {
	    var pairs = data.__data__;
	    if (!Map$6 || (pairs.length < LARGE_ARRAY_SIZE$1 - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache$4(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack$3(entries) {
	  var data = this.__data__ = new ListCache$5(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack$3.prototype.clear = stackClear$2;
	Stack$3.prototype['delete'] = stackDelete$2;
	Stack$3.prototype.get = stackGet$2;
	Stack$3.prototype.has = stackHas$2;
	Stack$3.prototype.set = stackSet$2;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$3 = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd$2(value) {
	  this.__data__.set(value, HASH_UNDEFINED$3);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas$2(value) {
	  return this.__data__.has(value);
	}

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache$2(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache$4;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd$2;
	SetCache$2.prototype.has = setCacheHas$2;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome$2(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas$2(cache, key) {
	  return cache.has(key);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$b = 1,
	    COMPARE_UNORDERED_FLAG$7 = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays$3(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$b,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Check that cyclic values are equal.
	  var arrStacked = stack.get(array);
	  var othStacked = stack.get(other);
	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG$7) ? new SetCache$2 : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome$2(other, function(othValue, othIndex) {
	            if (!cacheHas$2(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/** Built-in value references. */
	var Uint8Array$2 = root$a.Uint8Array;

	var Uint8Array$3 = Uint8Array$2;

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray$2(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray$2(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$a = 1,
	    COMPARE_UNORDERED_FLAG$6 = 2;

	/** `Object#toString` result references. */
	var boolTag$5 = '[object Boolean]',
	    dateTag$5 = '[object Date]',
	    errorTag$4 = '[object Error]',
	    mapTag$8 = '[object Map]',
	    numberTag$5 = '[object Number]',
	    regexpTag$5 = '[object RegExp]',
	    setTag$8 = '[object Set]',
	    stringTag$5 = '[object String]',
	    symbolTag$4 = '[object Symbol]';

	var arrayBufferTag$5 = '[object ArrayBuffer]',
	    dataViewTag$7 = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$4 = Symbol$8 ? Symbol$8.prototype : undefined,
	    symbolValueOf$2 = symbolProto$4 ? symbolProto$4.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag$2(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag$7:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag$5:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array$3(object), new Uint8Array$3(other))) {
	        return false;
	      }
	      return true;

	    case boolTag$5:
	    case dateTag$5:
	    case numberTag$5:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq$5(+object, +other);

	    case errorTag$4:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag$5:
	    case stringTag$5:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag$8:
	      var convert = mapToArray$2;

	    case setTag$8:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$a;
	      convert || (convert = setToArray$2);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG$6;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays$3(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag$4:
	      if (symbolValueOf$2) {
	        return symbolValueOf$2.call(object) == symbolValueOf$2.call(other);
	      }
	  }
	  return false;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush$3(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray$c = Array.isArray;

	var isArray$d = isArray$c;

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray$d(object) ? result : arrayPush$3(result, symbolsFunc(object));
	}

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter$2(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray$2() {
	  return [];
	}

	/** Used for built-in method references. */
	var objectProto$n = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable$3 = objectProto$n.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$2 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols$2 = !nativeGetSymbols$2 ? stubArray$2 : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter$2(nativeGetSymbols$2(object), function(symbol) {
	    return propertyIsEnumerable$3.call(object, symbol);
	  });
	};

	var getSymbols$3 = getSymbols$2;

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes$2(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/** `Object#toString` result references. */
	var argsTag$6 = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments$2(value) {
	  return isObjectLike$6(value) && baseGetTag$6(value) == argsTag$6;
	}

	/** Used for built-in method references. */
	var objectProto$m = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$j = objectProto$m.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable$2 = objectProto$m.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments$4 = baseIsArguments$2(function() { return arguments; }()) ? baseIsArguments$2 : function(value) {
	  return isObjectLike$6(value) && hasOwnProperty$j.call(value, 'callee') &&
	    !propertyIsEnumerable$2.call(value, 'callee');
	};

	var isArguments$5 = isArguments$4;

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse$1() {
	  return false;
	}

	/** Detect free variable `exports`. */
	var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

	/** Built-in value references. */
	var Buffer$1 = moduleExports$2 ? root$a.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer$3 = nativeIsBuffer || stubFalse$1;

	var isBuffer$4 = isBuffer$3;

	/** `Object#toString` result references. */
	var argsTag$5 = '[object Arguments]',
	    arrayTag$4 = '[object Array]',
	    boolTag$4 = '[object Boolean]',
	    dateTag$4 = '[object Date]',
	    errorTag$3 = '[object Error]',
	    funcTag$3 = '[object Function]',
	    mapTag$7 = '[object Map]',
	    numberTag$4 = '[object Number]',
	    objectTag$7 = '[object Object]',
	    regexpTag$4 = '[object RegExp]',
	    setTag$7 = '[object Set]',
	    stringTag$4 = '[object String]',
	    weakMapTag$4 = '[object WeakMap]';

	var arrayBufferTag$4 = '[object ArrayBuffer]',
	    dataViewTag$6 = '[object DataView]',
	    float32Tag$3 = '[object Float32Array]',
	    float64Tag$3 = '[object Float64Array]',
	    int8Tag$3 = '[object Int8Array]',
	    int16Tag$3 = '[object Int16Array]',
	    int32Tag$3 = '[object Int32Array]',
	    uint8Tag$3 = '[object Uint8Array]',
	    uint8ClampedTag$3 = '[object Uint8ClampedArray]',
	    uint16Tag$3 = '[object Uint16Array]',
	    uint32Tag$3 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags$1 = {};
	typedArrayTags$1[float32Tag$3] = typedArrayTags$1[float64Tag$3] =
	typedArrayTags$1[int8Tag$3] = typedArrayTags$1[int16Tag$3] =
	typedArrayTags$1[int32Tag$3] = typedArrayTags$1[uint8Tag$3] =
	typedArrayTags$1[uint8ClampedTag$3] = typedArrayTags$1[uint16Tag$3] =
	typedArrayTags$1[uint32Tag$3] = true;
	typedArrayTags$1[argsTag$5] = typedArrayTags$1[arrayTag$4] =
	typedArrayTags$1[arrayBufferTag$4] = typedArrayTags$1[boolTag$4] =
	typedArrayTags$1[dataViewTag$6] = typedArrayTags$1[dateTag$4] =
	typedArrayTags$1[errorTag$3] = typedArrayTags$1[funcTag$3] =
	typedArrayTags$1[mapTag$7] = typedArrayTags$1[numberTag$4] =
	typedArrayTags$1[objectTag$7] = typedArrayTags$1[regexpTag$4] =
	typedArrayTags$1[setTag$7] = typedArrayTags$1[stringTag$4] =
	typedArrayTags$1[weakMapTag$4] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray$2(value) {
	  return isObjectLike$6(value) &&
	    isLength$4(value.length) && !!typedArrayTags$1[baseGetTag$6(value)];
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary$3(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/** Detect free variable `exports`. */
	var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports$1 && freeGlobal$3.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil$1 = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	var nodeUtil$2 = nodeUtil$1;

	/* Node.js helper references. */
	var nodeIsTypedArray$1 = nodeUtil$2 && nodeUtil$2.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray$3 = nodeIsTypedArray$1 ? baseUnary$3(nodeIsTypedArray$1) : baseIsTypedArray$2;

	var isTypedArray$4 = isTypedArray$3;

	/** Used for built-in method references. */
	var objectProto$l = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$i = objectProto$l.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys$2(value, inherited) {
	  var isArr = isArray$d(value),
	      isArg = !isArr && isArguments$5(value),
	      isBuff = !isArr && !isArg && isBuffer$4(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray$4(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes$2(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$i.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex$4(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$k = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype$2(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$k;

	  return value === proto;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg$2(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys$2 = overArg$2(Object.keys, Object);

	var nativeKeys$3 = nativeKeys$2;

	/** Used for built-in method references. */
	var objectProto$j = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$h = objectProto$j.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys$2(object) {
	  if (!isPrototype$2(object)) {
	    return nativeKeys$3(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$h.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys$4(object) {
	  return isArrayLike$5(object) ? arrayLikeKeys$2(object) : baseKeys$2(object);
	}

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys$2(object) {
	  return baseGetAllKeys$2(object, keys$4, getSymbols$3);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$9 = 1;

	/** Used for built-in method references. */
	var objectProto$i = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$g = objectProto$i.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects$2(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$9,
	      objProps = getAllKeys$2(object),
	      objLength = objProps.length,
	      othProps = getAllKeys$2(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty$g.call(other, key))) {
	      return false;
	    }
	  }
	  // Check that cyclic values are equal.
	  var objStacked = stack.get(object);
	  var othStacked = stack.get(other);
	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/* Built-in method references that are verified to be native. */
	var DataView$2 = getNative$8(root$a, 'DataView');

	var DataView$3 = DataView$2;

	/* Built-in method references that are verified to be native. */
	var Promise$3 = getNative$8(root$a, 'Promise');

	var Promise$4 = Promise$3;

	/* Built-in method references that are verified to be native. */
	var Set$3 = getNative$8(root$a, 'Set');

	var Set$4 = Set$3;

	/* Built-in method references that are verified to be native. */
	var WeakMap$3 = getNative$8(root$a, 'WeakMap');

	var WeakMap$4 = WeakMap$3;

	/** `Object#toString` result references. */
	var mapTag$6 = '[object Map]',
	    objectTag$6 = '[object Object]',
	    promiseTag$1 = '[object Promise]',
	    setTag$6 = '[object Set]',
	    weakMapTag$3 = '[object WeakMap]';

	var dataViewTag$5 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString$1 = toSource$3(DataView$3),
	    mapCtorString$1 = toSource$3(Map$6),
	    promiseCtorString$1 = toSource$3(Promise$4),
	    setCtorString$1 = toSource$3(Set$4),
	    weakMapCtorString$1 = toSource$3(WeakMap$4);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag$2 = baseGetTag$6;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView$3 && getTag$2(new DataView$3(new ArrayBuffer(1))) != dataViewTag$5) ||
	    (Map$6 && getTag$2(new Map$6) != mapTag$6) ||
	    (Promise$4 && getTag$2(Promise$4.resolve()) != promiseTag$1) ||
	    (Set$4 && getTag$2(new Set$4) != setTag$6) ||
	    (WeakMap$4 && getTag$2(new WeakMap$4) != weakMapTag$3)) {
	  getTag$2 = function(value) {
	    var result = baseGetTag$6(value),
	        Ctor = result == objectTag$6 ? value.constructor : undefined,
	        ctorString = Ctor ? toSource$3(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString$1: return dataViewTag$5;
	        case mapCtorString$1: return mapTag$6;
	        case promiseCtorString$1: return promiseTag$1;
	        case setCtorString$1: return setTag$6;
	        case weakMapCtorString$1: return weakMapTag$3;
	      }
	    }
	    return result;
	  };
	}

	var getTag$3 = getTag$2;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$8 = 1;

	/** `Object#toString` result references. */
	var argsTag$4 = '[object Arguments]',
	    arrayTag$3 = '[object Array]',
	    objectTag$5 = '[object Object]';

	/** Used for built-in method references. */
	var objectProto$h = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$f = objectProto$h.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep$2(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray$d(object),
	      othIsArr = isArray$d(other),
	      objTag = objIsArr ? arrayTag$3 : getTag$3(object),
	      othTag = othIsArr ? arrayTag$3 : getTag$3(other);

	  objTag = objTag == argsTag$4 ? objectTag$5 : objTag;
	  othTag = othTag == argsTag$4 ? objectTag$5 : othTag;

	  var objIsObj = objTag == objectTag$5,
	      othIsObj = othTag == objectTag$5,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer$4(object)) {
	    if (!isBuffer$4(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack$3);
	    return (objIsArr || isTypedArray$4(object))
	      ? equalArrays$3(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag$2(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG$8)) {
	    var objIsWrapped = objIsObj && hasOwnProperty$f.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty$f.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack$3);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack$3);
	  return equalObjects$2(object, other, bitmask, customizer, equalFunc, stack);
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual$4(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike$6(value) && !isObjectLike$6(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep$2(value, other, bitmask, customizer, baseIsEqual$4, stack);
	}

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual$4(value, other) {
	  return baseIsEqual$4(value, other);
	}

	/**
	 * Returns the height of a given element.
	 * 
	 * @param node the element
	 * @param client whether to use `clientHeight` if possible
	 */

	function height(node, client) {
	  var win = isWindow(node);
	  return win ? win.innerHeight : client ? node.clientHeight : offset$2(node).height;
	}

	var height$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: height
	});

	/**
	 * Returns the closest parent element that matches a given selector.
	 * 
	 * @param node the reference element
	 * @param selector the selector to match
	 * @param stopAt stop traversing when this element is found
	 */

	function closest(node, selector, stopAt) {
	  if (node.closest && !stopAt) node.closest(selector);
	  var nextNode = node;

	  do {
	    if (matches(nextNode, selector)) return nextNode;
	    nextNode = nextNode.parentElement;
	  } while (nextNode && nextNode !== stopAt && nextNode.nodeType === document.ELEMENT_NODE);

	  return null;
	}

	var closest$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: closest
	});

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex$2(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$7 = 1,
	    COMPARE_UNORDERED_FLAG$5 = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch$2(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack$3;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual$4(srcValue, objValue, COMPARE_PARTIAL_FLAG$7 | COMPARE_UNORDERED_FLAG$5, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable$3(value) {
	  return value === value && !isObject$7(value);
	}

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData$2(object) {
	  var result = keys$4(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable$3(value)];
	  }
	  return result;
	}

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable$3(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches$2(source) {
	  var matchData = getMatchData$2(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable$3(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch$2(object, source, matchData);
	  };
	}

	/** Used to match property names within property paths. */
	var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp$1 = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey$4(value, object) {
	  if (isArray$d(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol$6(value)) {
	    return true;
	  }
	  return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) ||
	    (object != null && value in Object(object));
	}

	/** Error message constants. */
	var FUNC_ERROR_TEXT$1 = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize$3(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT$1);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize$3.Cache || MapCache$4);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize$3.Cache = MapCache$4;

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE$1 = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped$2(func) {
	  var result = memoize$3(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE$1) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	/** Used to match property names within property paths. */
	var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar$1 = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath$2 = memoizeCapped$2(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName$1, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar$1, '$1') : (number || match));
	  });
	  return result;
	});

	var stringToPath$3 = stringToPath$2;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap$3(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$4 = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$3 = Symbol$8 ? Symbol$8.prototype : undefined,
	    symbolToString$1 = symbolProto$3 ? symbolProto$3.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString$2(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray$d(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap$3(value, baseToString$2) + '';
	  }
	  if (isSymbol$6(value)) {
	    return symbolToString$1 ? symbolToString$1.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$4) ? '-0' : result;
	}

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString$3(value) {
	  return value == null ? '' : baseToString$2(value);
	}

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath$3(value, object) {
	  if (isArray$d(value)) {
	    return value;
	  }
	  return isKey$4(value, object) ? [value] : stringToPath$3(toString$3(value));
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$3 = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey$5(value) {
	  if (typeof value == 'string' || isSymbol$6(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$3) ? '-0' : result;
	}

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet$4(object, path) {
	  path = castPath$3(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey$5(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get$2(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet$4(object, path);
	  return result === undefined ? defaultValue : result;
	}

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn$2(object, key) {
	  return object != null && key in Object(object);
	}

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath$2(object, path, hasFunc) {
	  path = castPath$3(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey$5(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength$4(length) && isIndex$4(key, length) &&
	    (isArray$d(object) || isArguments$5(object));
	}

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn$2(object, path) {
	  return object != null && hasPath$2(object, path, baseHasIn$2);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$6 = 1,
	    COMPARE_UNORDERED_FLAG$4 = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty$2(path, srcValue) {
	  if (isKey$4(path) && isStrictComparable$3(srcValue)) {
	    return matchesStrictComparable$3(toKey$5(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get$2(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn$2(object, path)
	      : baseIsEqual$4(srcValue, objValue, COMPARE_PARTIAL_FLAG$6 | COMPARE_UNORDERED_FLAG$4);
	  };
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity$5(value) {
	  return value;
	}

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty$2(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep$2(path) {
	  return function(object) {
	    return baseGet$4(object, path);
	  };
	}

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property$2(path) {
	  return isKey$4(path) ? baseProperty$2(toKey$5(path)) : basePropertyDeep$2(path);
	}

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee$3(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity$5;
	  }
	  if (typeof value == 'object') {
	    return isArray$d(value)
	      ? baseMatchesProperty$2(value[0], value[1])
	      : baseMatches$2(value);
	  }
	  return property$2(value);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$6 = Math.max;

	/**
	 * This method is like `_.find` except that it returns the index of the first
	 * element `predicate` returns truthy for instead of the element itself.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {number} Returns the index of the found element, else `-1`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': false },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': true }
	 * ];
	 *
	 * _.findIndex(users, function(o) { return o.user == 'barney'; });
	 * // => 0
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findIndex(users, { 'user': 'fred', 'active': false });
	 * // => 1
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findIndex(users, ['active', false]);
	 * // => 0
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findIndex(users, 'active');
	 * // => 2
	 */
	function findIndex$1(array, predicate, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = fromIndex == null ? 0 : toInteger$3(fromIndex);
	  if (index < 0) {
	    index = nativeMax$6(length + index, 0);
	  }
	  return baseFindIndex$2(array, baseIteratee$3(predicate), index);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil$2 = Math.ceil,
	    nativeMax$5 = Math.max;

	/**
	 * The base implementation of `_.range` and `_.rangeRight` which doesn't
	 * coerce arguments.
	 *
	 * @private
	 * @param {number} start The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} step The value to increment or decrement by.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Array} Returns the range of numbers.
	 */
	function baseRange$2(start, end, step, fromRight) {
	  var index = -1,
	      length = nativeMax$5(nativeCeil$2((end - start) / (step || 1)), 0),
	      result = Array(length);

	  while (length--) {
	    result[fromRight ? length : ++index] = start;
	    start += step;
	  }
	  return result;
	}

	/**
	 * Creates a `_.range` or `_.rangeRight` function.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new range function.
	 */
	function createRange$2(fromRight) {
	  return function(start, end, step) {
	    if (step && typeof step != 'number' && isIterateeCall$4(start, end, step)) {
	      end = step = undefined;
	    }
	    // Ensure the sign of `-0` is preserved.
	    start = toFinite$3(start);
	    if (end === undefined) {
	      end = start;
	      start = 0;
	    } else {
	      end = toFinite$3(end);
	    }
	    step = step === undefined ? (start < end ? 1 : -1) : toFinite$3(step);
	    return baseRange$2(start, end, step, fromRight);
	  };
	}

	/**
	 * Creates an array of numbers (positive and/or negative) progressing from
	 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	 * `start` is specified without an `end` or `step`. If `end` is not specified,
	 * it's set to `start` with `start` then set to `0`.
	 *
	 * **Note:** JavaScript follows the IEEE-754 standard for resolving
	 * floating-point values which can produce unexpected results.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {number} [start=0] The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} [step=1] The value to increment or decrement by.
	 * @returns {Array} Returns the range of numbers.
	 * @see _.inRange, _.rangeRight
	 * @example
	 *
	 * _.range(4);
	 * // => [0, 1, 2, 3]
	 *
	 * _.range(-4);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 5);
	 * // => [1, 2, 3, 4]
	 *
	 * _.range(0, 20, 5);
	 * // => [0, 5, 10, 15]
	 *
	 * _.range(0, -4, -1);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 4, 0);
	 * // => [1, 1, 1]
	 *
	 * _.range(0);
	 * // => []
	 */
	var range$2 = createRange$2();

	var range$1$1 = range$2;

	var safeIsNaN = Number.isNaN ||
	    function ponyfill(value) {
	        return typeof value === 'number' && value !== value;
	    };
	function isEqual$3(first, second) {
	    if (first === second) {
	        return true;
	    }
	    if (safeIsNaN(first) && safeIsNaN(second)) {
	        return true;
	    }
	    return false;
	}
	function areInputsEqual(newInputs, lastInputs) {
	    if (newInputs.length !== lastInputs.length) {
	        return false;
	    }
	    for (var i = 0; i < newInputs.length; i++) {
	        if (!isEqual$3(newInputs[i], lastInputs[i])) {
	            return false;
	        }
	    }
	    return true;
	}

	function memoizeOne(resultFn, isEqual) {
	    if (isEqual === void 0) { isEqual = areInputsEqual; }
	    var cache = null;
	    function memoized() {
	        var newArgs = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            newArgs[_i] = arguments[_i];
	        }
	        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {
	            return cache.lastResult;
	        }
	        var lastResult = resultFn.apply(this, newArgs);
	        cache = {
	            lastResult: lastResult,
	            lastArgs: newArgs,
	            lastThis: this,
	        };
	        return lastResult;
	    }
	    memoized.clear = function clear() {
	        cache = null;
	    };
	    return memoized;
	}

	var memoizeOne_esm = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: memoizeOne
	});

	/** Built-in value references. */
	var spreadableSymbol$1 = Symbol$8 ? Symbol$8.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable$2(value) {
	  return isArray$d(value) || isArguments$5(value) ||
	    !!(spreadableSymbol$1 && value && value[spreadableSymbol$1]);
	}

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten$2(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable$2);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten$2(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush$3(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor$2(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor$2 = createBaseFor$2();

	var baseFor$3 = baseFor$2;

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn$2(object, iteratee) {
	  return object && baseFor$3(object, iteratee, keys$4);
	}

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach$2(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike$5(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach$2 = createBaseEach$2(baseForOwn$2);

	var baseEach$3 = baseEach$2;

	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap$2(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike$5(collection) ? Array(collection.length) : [];

	  baseEach$3(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}

	/**
	 * The base implementation of `_.sortBy` which uses `comparer` to define the
	 * sort order of `array` and replaces criteria objects with their corresponding
	 * values.
	 *
	 * @private
	 * @param {Array} array The array to sort.
	 * @param {Function} comparer The function to define sort order.
	 * @returns {Array} Returns `array`.
	 */
	function baseSortBy$2(array, comparer) {
	  var length = array.length;

	  array.sort(comparer);
	  while (length--) {
	    array[length] = array[length].value;
	  }
	  return array;
	}

	/**
	 * Compares values to sort them in ascending order.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {number} Returns the sort order indicator for `value`.
	 */
	function compareAscending$2(value, other) {
	  if (value !== other) {
	    var valIsDefined = value !== undefined,
	        valIsNull = value === null,
	        valIsReflexive = value === value,
	        valIsSymbol = isSymbol$6(value);

	    var othIsDefined = other !== undefined,
	        othIsNull = other === null,
	        othIsReflexive = other === other,
	        othIsSymbol = isSymbol$6(other);

	    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	        (valIsNull && othIsDefined && othIsReflexive) ||
	        (!valIsDefined && othIsReflexive) ||
	        !valIsReflexive) {
	      return 1;
	    }
	    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	        (othIsNull && valIsDefined && valIsReflexive) ||
	        (!othIsDefined && valIsReflexive) ||
	        !othIsReflexive) {
	      return -1;
	    }
	  }
	  return 0;
	}

	/**
	 * Used by `_.orderBy` to compare multiple properties of a value to another
	 * and stable sort them.
	 *
	 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	 * specify an order of "desc" for descending or "asc" for ascending sort order
	 * of corresponding values.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {boolean[]|string[]} orders The order to sort by for each property.
	 * @returns {number} Returns the sort order indicator for `object`.
	 */
	function compareMultiple$2(object, other, orders) {
	  var index = -1,
	      objCriteria = object.criteria,
	      othCriteria = other.criteria,
	      length = objCriteria.length,
	      ordersLength = orders.length;

	  while (++index < length) {
	    var result = compareAscending$2(objCriteria[index], othCriteria[index]);
	    if (result) {
	      if (index >= ordersLength) {
	        return result;
	      }
	      var order = orders[index];
	      return result * (order == 'desc' ? -1 : 1);
	    }
	  }
	  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	  // that causes it, under certain circumstances, to provide the same value for
	  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	  // for more details.
	  //
	  // This also ensures a stable sort in V8 and other engines.
	  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	  return object.index - other.index;
	}

	/**
	 * The base implementation of `_.orderBy` without param guards.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	 * @param {string[]} orders The sort orders of `iteratees`.
	 * @returns {Array} Returns the new sorted array.
	 */
	function baseOrderBy$2(collection, iteratees, orders) {
	  if (iteratees.length) {
	    iteratees = arrayMap$3(iteratees, function(iteratee) {
	      if (isArray$d(iteratee)) {
	        return function(value) {
	          return baseGet$4(value, iteratee.length === 1 ? iteratee[0] : iteratee);
	        }
	      }
	      return iteratee;
	    });
	  } else {
	    iteratees = [identity$5];
	  }

	  var index = -1;
	  iteratees = arrayMap$3(iteratees, baseUnary$3(baseIteratee$3));

	  var result = baseMap$2(collection, function(value, key, collection) {
	    var criteria = arrayMap$3(iteratees, function(iteratee) {
	      return iteratee(value);
	    });
	    return { 'criteria': criteria, 'index': ++index, 'value': value };
	  });

	  return baseSortBy$2(result, function(object, other) {
	    return compareMultiple$2(object, other, orders);
	  });
	}

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply$2(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$4 = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest$2(func, start, transform) {
	  start = nativeMax$4(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax$4(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply$2(func, this, otherArgs);
	  };
	}

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant$2(value) {
	  return function() {
	    return value;
	  };
	}

	var defineProperty$4 = (function() {
	  try {
	    var func = getNative$8(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	var defineProperty$5 = defineProperty$4;

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString$2 = !defineProperty$5 ? identity$5 : function(func, string) {
	  return defineProperty$5(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant$2(string),
	    'writable': true
	  });
	};

	var baseSetToString$3 = baseSetToString$2;

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT$1 = 800,
	    HOT_SPAN$1 = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow$1 = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut$2(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow$1(),
	        remaining = HOT_SPAN$1 - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT$1) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString$2 = shortOut$2(baseSetToString$3);

	var setToString$3 = setToString$2;

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest$2(func, start) {
	  return setToString$3(overRest$2(func, start, identity$5), func + '');
	}

	/**
	 * Creates an array of elements, sorted in ascending order by the results of
	 * running each element in a collection thru each iteratee. This method
	 * performs a stable sort, that is, it preserves the original sort order of
	 * equal elements. The iteratees are invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {...(Function|Function[])} [iteratees=[_.identity]]
	 *  The iteratees to sort by.
	 * @returns {Array} Returns the new sorted array.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'fred',   'age': 48 },
	 *   { 'user': 'barney', 'age': 36 },
	 *   { 'user': 'fred',   'age': 30 },
	 *   { 'user': 'barney', 'age': 34 }
	 * ];
	 *
	 * _.sortBy(users, [function(o) { return o.user; }]);
	 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
	 *
	 * _.sortBy(users, ['user', 'age']);
	 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
	 */
	var sortBy$1 = baseRest$2(function(collection, iteratees) {
	  if (collection == null) {
	    return [];
	  }
	  var length = iteratees.length;
	  if (length > 1 && isIterateeCall$4(collection, iteratees[0], iteratees[1])) {
	    iteratees = [];
	  } else if (length > 2 && isIterateeCall$4(iteratees[0], iteratees[1], iteratees[2])) {
	    iteratees = [iteratees[0]];
	  }
	  return baseOrderBy$2(collection, baseFlatten$2(iteratees, 1), []);
	});

	var sortBy$2 = sortBy$1;

	/**
	 * Returns the width of a given element.
	 * 
	 * @param node the element
	 * @param client whether to use `clientWidth` if possible
	 */

	function getWidth(node, client) {
	  var win = isWindow(node);
	  return win ? win.innerWidth : client ? node.clientWidth : offset$2(node).width;
	}

	var width = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: getWidth
	});

	function _toArray(arr) {
	  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableRest();
	}

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty$5) {
	    defineProperty$5(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	/** Used for built-in method references. */
	var objectProto$g = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$e = objectProto$g.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$e.call(object, key) && eq$5(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && copyObject(source, keys$4(source), object);
	}

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$f = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$d = objectProto$f.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject$7(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype$2(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$d.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike$5(object) ? arrayLikeKeys$2(object, true) : baseKeysIn(object);
	}

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && copyObject(source, keysIn(source), object);
	}

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root$a.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return copyObject(source, getSymbols$3(source), object);
	}

	/** Built-in value references. */
	var getPrototype = overArg$2(Object.getPrototypeOf, Object);

	var getPrototype$1 = getPrototype;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn = !nativeGetSymbols$1 ? stubArray$2 : function(object) {
	  var result = [];
	  while (object) {
	    arrayPush$3(result, getSymbols$3(object));
	    object = getPrototype$1(object);
	  }
	  return result;
	};

	var getSymbolsIn$1 = getSymbolsIn;

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return copyObject(source, getSymbolsIn$1(source), object);
	}

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn(object) {
	  return baseGetAllKeys$2(object, keysIn, getSymbolsIn$1);
	}

	/** Used for built-in method references. */
	var objectProto$e = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$c = objectProto$e.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty$c.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array$3(result).set(new Uint8Array$3(arrayBuffer));
	  return result;
	}

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$2 = Symbol$8 ? Symbol$8.prototype : undefined,
	    symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
	}

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	/** `Object#toString` result references. */
	var boolTag$3 = '[object Boolean]',
	    dateTag$3 = '[object Date]',
	    mapTag$5 = '[object Map]',
	    numberTag$3 = '[object Number]',
	    regexpTag$3 = '[object RegExp]',
	    setTag$5 = '[object Set]',
	    stringTag$3 = '[object String]',
	    symbolTag$3 = '[object Symbol]';

	var arrayBufferTag$3 = '[object ArrayBuffer]',
	    dataViewTag$4 = '[object DataView]',
	    float32Tag$2 = '[object Float32Array]',
	    float64Tag$2 = '[object Float64Array]',
	    int8Tag$2 = '[object Int8Array]',
	    int16Tag$2 = '[object Int16Array]',
	    int32Tag$2 = '[object Int32Array]',
	    uint8Tag$2 = '[object Uint8Array]',
	    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
	    uint16Tag$2 = '[object Uint16Array]',
	    uint32Tag$2 = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag$3:
	      return cloneArrayBuffer(object);

	    case boolTag$3:
	    case dateTag$3:
	      return new Ctor(+object);

	    case dataViewTag$4:
	      return cloneDataView(object, isDeep);

	    case float32Tag$2: case float64Tag$2:
	    case int8Tag$2: case int16Tag$2: case int32Tag$2:
	    case uint8Tag$2: case uint8ClampedTag$2: case uint16Tag$2: case uint32Tag$2:
	      return cloneTypedArray(object, isDeep);

	    case mapTag$5:
	      return new Ctor;

	    case numberTag$3:
	    case stringTag$3:
	      return new Ctor(object);

	    case regexpTag$3:
	      return cloneRegExp(object);

	    case setTag$5:
	      return new Ctor;

	    case symbolTag$3:
	      return cloneSymbol(object);
	  }
	}

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject$7(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	var baseCreate$1 = baseCreate;

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype$2(object))
	    ? baseCreate$1(getPrototype$1(object))
	    : {};
	}

	/** `Object#toString` result references. */
	var mapTag$4 = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap(value) {
	  return isObjectLike$6(value) && getTag$3(value) == mapTag$4;
	}

	/* Node.js helper references. */
	var nodeIsMap = nodeUtil$2 && nodeUtil$2.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap = nodeIsMap ? baseUnary$3(nodeIsMap) : baseIsMap;

	var isMap$1 = isMap;

	/** `Object#toString` result references. */
	var setTag$4 = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike$6(value) && getTag$3(value) == setTag$4;
	}

	/* Node.js helper references. */
	var nodeIsSet = nodeUtil$2 && nodeUtil$2.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? baseUnary$3(nodeIsSet) : baseIsSet;

	var isSet$1 = isSet;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$1 = 1,
	    CLONE_FLAT_FLAG$1 = 2,
	    CLONE_SYMBOLS_FLAG$1 = 4;

	/** `Object#toString` result references. */
	var argsTag$3 = '[object Arguments]',
	    arrayTag$2 = '[object Array]',
	    boolTag$2 = '[object Boolean]',
	    dateTag$2 = '[object Date]',
	    errorTag$2 = '[object Error]',
	    funcTag$2 = '[object Function]',
	    genTag$1 = '[object GeneratorFunction]',
	    mapTag$3 = '[object Map]',
	    numberTag$2 = '[object Number]',
	    objectTag$4 = '[object Object]',
	    regexpTag$2 = '[object RegExp]',
	    setTag$3 = '[object Set]',
	    stringTag$2 = '[object String]',
	    symbolTag$2 = '[object Symbol]',
	    weakMapTag$2 = '[object WeakMap]';

	var arrayBufferTag$2 = '[object ArrayBuffer]',
	    dataViewTag$3 = '[object DataView]',
	    float32Tag$1 = '[object Float32Array]',
	    float64Tag$1 = '[object Float64Array]',
	    int8Tag$1 = '[object Int8Array]',
	    int16Tag$1 = '[object Int16Array]',
	    int32Tag$1 = '[object Int32Array]',
	    uint8Tag$1 = '[object Uint8Array]',
	    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
	    uint16Tag$1 = '[object Uint16Array]',
	    uint32Tag$1 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] =
	cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] =
	cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
	cloneableTags[float32Tag$1] = cloneableTags[float64Tag$1] =
	cloneableTags[int8Tag$1] = cloneableTags[int16Tag$1] =
	cloneableTags[int32Tag$1] = cloneableTags[mapTag$3] =
	cloneableTags[numberTag$2] = cloneableTags[objectTag$4] =
	cloneableTags[regexpTag$2] = cloneableTags[setTag$3] =
	cloneableTags[stringTag$2] = cloneableTags[symbolTag$2] =
	cloneableTags[uint8Tag$1] = cloneableTags[uint8ClampedTag$1] =
	cloneableTags[uint16Tag$1] = cloneableTags[uint32Tag$1] = true;
	cloneableTags[errorTag$2] = cloneableTags[funcTag$2] =
	cloneableTags[weakMapTag$2] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG$1,
	      isFlat = bitmask & CLONE_FLAT_FLAG$1,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject$7(value)) {
	    return value;
	  }
	  var isArr = isArray$d(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    var tag = getTag$3(value),
	        isFunc = tag == funcTag$2 || tag == genTag$1;

	    if (isBuffer$4(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag$4 || tag == argsTag$3 || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? copySymbolsIn(value, baseAssignIn(result, value))
	          : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack$3);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet$1(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap$1(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? getAllKeysIn : getAllKeys$2)
	    : (isFlat ? keysIn : keys$4);

	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	/**
	 * Gets the last element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the last element of `array`.
	 * @example
	 *
	 * _.last([1, 2, 3]);
	 * // => 3
	 */
	function last(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? array[length - 1] : undefined;
	}

	/**
	 * Gets the parent value at `path` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} path The path to get the parent value of.
	 * @returns {*} Returns the parent value.
	 */
	function parent(object, path) {
	  return path.length < 2 ? object : baseGet$4(object, baseSlice$2(path, 0, -1));
	}

	/**
	 * The base implementation of `_.unset`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The property path to unset.
	 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	 */
	function baseUnset(object, path) {
	  path = castPath$3(path, object);
	  object = parent(object, path);
	  return object == null || delete object[toKey$5(last(path))];
	}

	/** `Object#toString` result references. */
	var objectTag$3 = '[object Object]';

	/** Used for built-in method references. */
	var funcProto$2 = Function.prototype,
	    objectProto$d = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$2 = funcProto$2.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$b = objectProto$d.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString$2.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject$1(value) {
	  if (!isObjectLike$6(value) || baseGetTag$6(value) != objectTag$3) {
	    return false;
	  }
	  var proto = getPrototype$1(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty$b.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString$2.call(Ctor) == objectCtorString;
	}

	/**
	 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
	 * objects.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {string} key The key of the property to inspect.
	 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
	 */
	function customOmitClone(value) {
	  return isPlainObject$1(value) ? undefined : value;
	}

	/**
	 * Flattens `array` a single level deep.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flatten([1, [2, [3, [4]], 5]]);
	 * // => [1, 2, [3, [4]], 5]
	 */
	function flatten(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseFlatten$2(array, 1) : [];
	}

	/**
	 * A specialized version of `baseRest` which flattens the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @returns {Function} Returns the new function.
	 */
	function flatRest(func) {
	  return setToString$3(overRest$2(func, undefined, flatten), func + '');
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/**
	 * The opposite of `_.pick`; this method creates an object composed of the
	 * own and inherited enumerable property paths of `object` that are not omitted.
	 *
	 * **Note:** This method is considerably slower than `_.pick`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {...(string|string[])} [paths] The property paths to omit.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.omit(object, ['a', 'c']);
	 * // => { 'b': '2' }
	 */
	var omit = flatRest(function(object, paths) {
	  var result = {};
	  if (object == null) {
	    return result;
	  }
	  var isDeep = false;
	  paths = arrayMap$3(paths, function(path) {
	    path = castPath$3(path, object);
	    isDeep || (isDeep = path.length > 1);
	    return path;
	  });
	  copyObject(object, getAllKeysIn(object), result);
	  if (isDeep) {
	    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
	  }
	  var length = paths.length;
	  while (length--) {
	    baseUnset(result, paths[length]);
	  }
	  return result;
	});

	var omit$1 = omit;

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$a = objectProto$c.hasOwnProperty;

	/**
	 * Assigns own and inherited enumerable string keyed properties of source
	 * objects to the destination object for all destination properties that
	 * resolve to `undefined`. Source objects are applied from left to right.
	 * Once a property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.defaultsDeep
	 * @example
	 *
	 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var defaults = baseRest$2(function(object, sources) {
	  object = Object(object);

	  var index = -1;
	  var length = sources.length;
	  var guard = length > 2 ? sources[2] : undefined;

	  if (guard && isIterateeCall$4(sources[0], sources[1], guard)) {
	    length = 1;
	  }

	  while (++index < length) {
	    var source = sources[index];
	    var props = keysIn(source);
	    var propsIndex = -1;
	    var propsLength = props.length;

	    while (++propsIndex < propsLength) {
	      var key = props[propsIndex];
	      var value = object[key];

	      if (value === undefined ||
	          (eq$5(value, objectProto$c[key]) && !hasOwnProperty$a.call(object, key))) {
	        object[key] = source[key];
	      }
	    }
	  }

	  return object;
	});

	var defaults$1 = defaults;

	/**
	 * An alternative to `_.reduce`; this method transforms `object` to a new
	 * `accumulator` object which is the result of running each of its own
	 * enumerable string keyed properties thru `iteratee`, with each invocation
	 * potentially mutating the `accumulator` object. If `accumulator` is not
	 * provided, a new object with the same `[[Prototype]]` will be used. The
	 * iteratee is invoked with four arguments: (accumulator, value, key, object).
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.3.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [accumulator] The custom accumulator value.
	 * @returns {*} Returns the accumulated value.
	 * @example
	 *
	 * _.transform([2, 3, 4], function(result, n) {
	 *   result.push(n *= n);
	 *   return n % 2 == 0;
	 * }, []);
	 * // => [4, 9]
	 *
	 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	 *   (result[value] || (result[value] = [])).push(key);
	 * }, {});
	 * // => { '1': ['a', 'c'], '2': ['b'] }
	 */
	function transform(object, iteratee, accumulator) {
	  var isArr = isArray$d(object),
	      isArrLike = isArr || isBuffer$4(object) || isTypedArray$4(object);

	  iteratee = baseIteratee$3(iteratee);
	  if (accumulator == null) {
	    var Ctor = object && object.constructor;
	    if (isArrLike) {
	      accumulator = isArr ? new Ctor : [];
	    }
	    else if (isObject$7(object)) {
	      accumulator = isFunction$6(Ctor) ? baseCreate$1(getPrototype$1(object)) : {};
	    }
	    else {
	      accumulator = {};
	    }
	  }
	  (isArrLike ? arrayEach : baseForOwn$2)(object, function(value, index, object) {
	    return iteratee(accumulator, value, index, object);
	  });
	  return accumulator;
	}

	/**
	 * Creates an object with the same keys as `object` and values generated
	 * by running each own enumerable string keyed property of `object` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, key, object).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns the new mapped object.
	 * @see _.mapKeys
	 * @example
	 *
	 * var users = {
	 *   'fred':    { 'user': 'fred',    'age': 40 },
	 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	 * };
	 *
	 * _.mapValues(users, function(o) { return o.age; });
	 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.mapValues(users, 'age');
	 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	 */
	function mapValues(object, iteratee) {
	  var result = {};
	  iteratee = baseIteratee$3(iteratee);

	  baseForOwn$2(object, function(value, key, object) {
	    baseAssignValue(result, key, iteratee(value, key, object));
	  });
	  return result;
	}

	var isBetween = {exports: {}};

	(function (module, exports) {
		!function(e,i){module.exports=i();}(commonjsGlobal,(function(){return function(e,i,t){i.prototype.isBetween=function(e,i,s,f){var n=t(e),o=t(i),r="("===(f=f||"()")[0],u=")"===f[1];return (r?this.isAfter(n,s):!this.isBefore(n,s))&&(u?this.isBefore(o,s):!this.isAfter(o,s))||(r?this.isBefore(n,s):!this.isAfter(n,s))&&(u?this.isAfter(o,s):!this.isBefore(o,s))};}})); 
	} (isBetween));

	var isSameOrAfter = {exports: {}};

	(function (module, exports) {
		!function(e,t){module.exports=t();}(commonjsGlobal,(function(){return function(e,t){t.prototype.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)};}})); 
	} (isSameOrAfter));

	var isSameOrBefore = {exports: {}};

	(function (module, exports) {
		!function(e,i){module.exports=i();}(commonjsGlobal,(function(){return function(e,i){i.prototype.isSameOrBefore=function(e,i){return this.isSame(e,i)||this.isBefore(e,i)};}})); 
	} (isSameOrBefore));

	var localeData = {exports: {}};

	(function (module, exports) {
		!function(n,e){module.exports=e();}(commonjsGlobal,(function(){return function(n,e,t){var r=e.prototype,o=function(n){return n&&(n.indexOf?n:n.s)},u=function(n,e,t,r,u){var i=n.name?n:n.$locale(),a=o(i[e]),s=o(i[t]),f=a||s.map((function(n){return n.slice(0,r)}));if(!u)return f;var d=i.weekStart;return f.map((function(n,e){return f[(e+(d||0))%7]}))},i=function(){return t.Ls[t.locale()]},a=function(n,e){return n.formats[e]||function(n){return n.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(n,e,t){return e||t.slice(1)}))}(n.formats[e.toUpperCase()])},s=function(){var n=this;return {months:function(e){return e?e.format("MMMM"):u(n,"months")},monthsShort:function(e){return e?e.format("MMM"):u(n,"monthsShort","months",3)},firstDayOfWeek:function(){return n.$locale().weekStart||0},weekdays:function(e){return e?e.format("dddd"):u(n,"weekdays")},weekdaysMin:function(e){return e?e.format("dd"):u(n,"weekdaysMin","weekdays",2)},weekdaysShort:function(e){return e?e.format("ddd"):u(n,"weekdaysShort","weekdays",3)},longDateFormat:function(e){return a(n.$locale(),e)},meridiem:this.$locale().meridiem,ordinal:this.$locale().ordinal}};r.localeData=function(){return s.bind(this)()},t.localeData=function(){var n=i();return {firstDayOfWeek:function(){return n.weekStart||0},weekdays:function(){return t.weekdays()},weekdaysShort:function(){return t.weekdaysShort()},weekdaysMin:function(){return t.weekdaysMin()},months:function(){return t.months()},monthsShort:function(){return t.monthsShort()},longDateFormat:function(e){return a(n,e)},meridiem:n.meridiem,ordinal:n.ordinal}},t.months=function(){return u(i(),"months")},t.monthsShort=function(){return u(i(),"monthsShort","months",3)},t.weekdays=function(n){return u(i(),"weekdays",null,null,n)},t.weekdaysShort=function(n){return u(i(),"weekdaysShort","weekdays",3,n)},t.weekdaysMin=function(n){return u(i(),"weekdaysMin","weekdays",2,n)};}})); 
	} (localeData));

	var localizedFormat = {exports: {}};

	(function (module, exports) {
		!function(e,t){module.exports=t();}(commonjsGlobal,(function(){var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};return function(t,o,n){var r=o.prototype,i=r.format;n.en.formats=e,r.format=function(t){void 0===t&&(t="YYYY-MM-DDTHH:mm:ssZ");var o=this.$locale().formats,n=function(t,o){return t.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var i=r&&r.toUpperCase();return n||o[r]||e[r]||o[i].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,o){return t||o.slice(1)}))}))}(t,void 0===o?{}:o);return i.call(this,n)};}})); 
	} (localizedFormat));

	var minMax = {exports: {}};

	(function (module, exports) {
		!function(e,n){module.exports=n();}(commonjsGlobal,(function(){return function(e,n,t){var i=function(e,n){if(!n||!n.length||1===n.length&&!n[0]||1===n.length&&Array.isArray(n[0])&&!n[0].length)return null;var t;1===n.length&&n[0].length>0&&(n=n[0]);t=(n=n.filter((function(e){return e})))[0];for(var i=1;i<n.length;i+=1)n[i].isValid()&&!n[i][e](t)||(t=n[i]);return t};t.max=function(){var e=[].slice.call(arguments,0);return i("isAfter",e)},t.min=function(){var e=[].slice.call(arguments,0);return i("isBefore",e)};}})); 
	} (minMax));

	var utc = {exports: {}};

	(function (module, exports) {
		!function(t,i){module.exports=i();}(commonjsGlobal,(function(){var t="minute",i=/[+-]\d\d(?::?\d\d)?/g,e=/([+-]|\d\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var o=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),o.call(this,t);};var r=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds();}else r.call(this);};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if("string"==typeof s&&(s=function(t){void 0===t&&(t="");var s=t.match(i);if(!s)return null;var f=(""+s[0]).match(e)||["-",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:"+"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s,o=this;if(f)return o.$offset=u,o.$u=0===s,o;if(0!==s){var r=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(o=this.local().add(u+r,t)).$offset=u,o.$x.$localOffset=r;}else o=this.utc();return o};var h=u.format;u.format=function(t){var i=t||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return !!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return "s"===t&&this.$offset?n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)};}})); 
	} (utc));

	function NoopWrapper$2(props) {
	  return props.children;
	}

	var navigate$1 = {
	  PREVIOUS: 'PREV',
	  NEXT: 'NEXT',
	  TODAY: 'TODAY',
	  DATE: 'DATE'
	};
	var views$2 = {
	  MONTH: 'month',
	  WEEK: 'week',
	  WORK_WEEK: 'work_week',
	  DAY: 'day',
	  AGENDA: 'agenda'
	};

	var viewNames$1 = Object.keys(views$2).map(function (k) {
	  return views$2[k];
	});
	PropTypes.oneOfType([PropTypes.string, PropTypes.func]);
	PropTypes.any;
	PropTypes.func;

	/**
	 * accepts either an array of builtin view names:
	 *
	 * ```
	 * views={['month', 'day', 'agenda']}
	 * ```
	 *
	 * or an object hash of the view name and the component (or boolean for builtin)
	 *
	 * ```
	 * views={{
	 *   month: true,
	 *   week: false,
	 *   workweek: WorkWeekViewComponent,
	 * }}
	 * ```
	 */

	PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOf(viewNames$1)), PropTypes.objectOf(function (prop, key) {
	  var isBuiltinView = viewNames$1.indexOf(key) !== -1 && typeof prop[key] === 'boolean';
	  if (isBuiltinView) {
	    return null;
	  } else {
	    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	    return PropTypes.elementType.apply(PropTypes, [prop, key].concat(args));
	  }
	})]);
	PropTypes.oneOfType([PropTypes.oneOf(['overlap', 'no-overlap']), PropTypes.func]);

	function notify$1(handler, args) {
	  handler && handler.apply(null, [].concat(args));
	}

	/* eslint no-fallthrough: off */
	var MILLI = {
	  seconds: 1000,
	  minutes: 1000 * 60,
	  hours: 1000 * 60 * 60,
	  day: 1000 * 60 * 60 * 24
	};
	function firstVisibleDay(date, localizer) {
	  var firstOfMonth = startOf(date, 'month');
	  return startOf(firstOfMonth, 'week', localizer.startOfWeek());
	}
	function lastVisibleDay(date, localizer) {
	  var endOfMonth = endOf(date, 'month');
	  return endOf(endOfMonth, 'week', localizer.startOfWeek());
	}
	function visibleDays(date, localizer) {
	  var current = firstVisibleDay(date, localizer),
	    last = lastVisibleDay(date, localizer),
	    days = [];
	  while (lte(current, last, 'day')) {
	    days.push(current);
	    current = add(current, 1, 'day');
	  }
	  return days;
	}
	function ceil(date, unit) {
	  var floor = startOf(date, unit);
	  return eq$6(floor, date) ? floor : add(floor, 1, unit);
	}
	function range$1(start, end) {
	  var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'day';
	  var current = start,
	    days = [];
	  while (lte(current, end, unit)) {
	    days.push(current);
	    current = add(current, 1, unit);
	  }
	  return days;
	}
	function merge(date, time) {
	  if (time == null && date == null) return null;
	  if (time == null) time = new Date();
	  if (date == null) date = new Date();
	  date = startOf(date, 'day');
	  date = hours(date, hours(time));
	  date = minutes(date, minutes(time));
	  date = seconds(date, seconds(time));
	  return milliseconds(date, milliseconds(time));
	}
	function isJustDate(date) {
	  return hours(date) === 0 && minutes(date) === 0 && seconds(date) === 0 && milliseconds(date) === 0;
	}
	function diff(dateA, dateB, unit) {
	  if (!unit || unit === 'milliseconds') return Math.abs(+dateA - +dateB);

	  // the .round() handles an edge case
	  // with DST where the total won't be exact
	  // since one day in the range may be shorter/longer by an hour
	  return Math.round(Math.abs(+startOf(dateA, unit) / MILLI[unit] - +startOf(dateB, unit) / MILLI[unit]));
	}

	var localePropType = PropTypes.oneOfType([PropTypes.string, PropTypes.func]);
	function _format(localizer, formatter, value, format, culture) {
	  var result = typeof format === 'function' ? format(value, culture, localizer) : formatter.call(localizer, value, format, culture);
	  invariant$1(result == null || typeof result === 'string', '`localizer format(..)` must return a string, null, or undefined');
	  return result;
	}

	/**
	 * This date conversion was moved out of TimeSlots.js, to
	 * allow for localizer override
	 * @param {Date} dt - The date to start from
	 * @param {Number} minutesFromMidnight
	 * @param {Number} offset
	 * @returns {Date}
	 */
	function getSlotDate(dt, minutesFromMidnight, offset) {
	  return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate(), 0, minutesFromMidnight + offset, 0, 0);
	}
	function getDstOffset(start, end) {
	  return start.getTimezoneOffset() - end.getTimezoneOffset();
	}

	// if the start is on a DST-changing day but *after* the moment of DST
	// transition we need to add those extra minutes to our minutesFromMidnight
	function getTotalMin(start, end) {
	  return diff(start, end, 'minutes') + getDstOffset(start, end);
	}
	function getMinutesFromMidnight(start) {
	  var daystart = startOf(start, 'day');
	  return diff(daystart, start, 'minutes') + getDstOffset(daystart, start);
	}

	// These two are used by DateSlotMetrics
	function continuesPrior(start, first) {
	  return lt(start, first, 'day');
	}
	function continuesAfter(start, end, last) {
	  var singleDayDuration = eq$6(start, end, 'minutes');
	  return singleDayDuration ? gte(end, last, 'minutes') : gt(end, last, 'minutes');
	}

	// These two are used by eventLevels
	function sortEvents$1(_ref) {
	  var _ref$evtA = _ref.evtA,
	    aStart = _ref$evtA.start,
	    aEnd = _ref$evtA.end,
	    aAllDay = _ref$evtA.allDay,
	    _ref$evtB = _ref.evtB,
	    bStart = _ref$evtB.start,
	    bEnd = _ref$evtB.end,
	    bAllDay = _ref$evtB.allDay;
	  var startSort = +startOf(aStart, 'day') - +startOf(bStart, 'day');
	  var durA = diff(aStart, ceil(aEnd, 'day'), 'day');
	  var durB = diff(bStart, ceil(bEnd, 'day'), 'day');
	  return startSort ||
	  // sort by start Day first
	  Math.max(durB, 1) - Math.max(durA, 1) ||
	  // events spanning multiple days go first
	  !!bAllDay - !!aAllDay ||
	  // then allDay single day events
	  +aStart - +bStart ||
	  // then sort by start time
	  +aEnd - +bEnd // then sort by end time
	  ;
	}

	function inEventRange(_ref2) {
	  var _ref2$event = _ref2.event,
	    start = _ref2$event.start,
	    end = _ref2$event.end,
	    _ref2$range = _ref2.range,
	    rangeStart = _ref2$range.start,
	    rangeEnd = _ref2$range.end;
	  var eStart = startOf(start, 'day');
	  var startsBeforeEnd = lte(eStart, rangeEnd, 'day');
	  // when the event is zero duration we need to handle a bit differently
	  var sameMin = neq(eStart, end, 'minutes');
	  var endsAfterStart = sameMin ? gt(end, rangeStart, 'minutes') : gte(end, rangeStart, 'minutes');
	  return startsBeforeEnd && endsAfterStart;
	}

	// other localizers treats 'day' and 'date' equality very differently, so we
	// abstract the change the 'localizer.eq(date1, date2, 'day') into this
	// new method, where they can be treated correctly by the localizer overrides
	function isSameDate(date1, date2) {
	  return eq$6(date1, date2, 'day');
	}
	function startAndEndAreDateOnly(start, end) {
	  return isJustDate(start) && isJustDate(end);
	}
	var DateLocalizer = /*#__PURE__*/_createClass$1(function DateLocalizer(spec) {
	  var _this = this;
	  _classCallCheck(this, DateLocalizer);
	  invariant$1(typeof spec.format === 'function', 'date localizer `format(..)` must be a function');
	  invariant$1(typeof spec.firstOfWeek === 'function', 'date localizer `firstOfWeek(..)` must be a function');
	  this.propType = spec.propType || localePropType;
	  this.formats = spec.formats;
	  this.format = function () {
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    return _format.apply(void 0, [_this, spec.format].concat(args));
	  };
	  // These date arithmetic methods can be overriden by the localizer
	  this.startOfWeek = spec.firstOfWeek;
	  this.merge = spec.merge || merge;
	  this.inRange = spec.inRange || inRange$2;
	  this.lt = spec.lt || lt;
	  this.lte = spec.lte || lte;
	  this.gt = spec.gt || gt;
	  this.gte = spec.gte || gte;
	  this.eq = spec.eq || eq$6;
	  this.neq = spec.neq || neq;
	  this.startOf = spec.startOf || startOf;
	  this.endOf = spec.endOf || endOf;
	  this.add = spec.add || add;
	  this.range = spec.range || range$1;
	  this.diff = spec.diff || diff;
	  this.ceil = spec.ceil || ceil;
	  this.min = spec.min || min$2;
	  this.max = spec.max || max$2;
	  this.minutes = spec.minutes || minutes;
	  this.firstVisibleDay = spec.firstVisibleDay || firstVisibleDay;
	  this.lastVisibleDay = spec.lastVisibleDay || lastVisibleDay;
	  this.visibleDays = spec.visibleDays || visibleDays;
	  this.getSlotDate = spec.getSlotDate || getSlotDate;
	  this.getTimezoneOffset = spec.getTimezoneOffset || function (value) {
	    return value.getTimezoneOffset();
	  };
	  this.getDstOffset = spec.getDstOffset || getDstOffset;
	  this.getTotalMin = spec.getTotalMin || getTotalMin;
	  this.getMinutesFromMidnight = spec.getMinutesFromMidnight || getMinutesFromMidnight;
	  this.continuesPrior = spec.continuesPrior || continuesPrior;
	  this.continuesAfter = spec.continuesAfter || continuesAfter;
	  this.sortEvents = spec.sortEvents || sortEvents$1;
	  this.inEventRange = spec.inEventRange || inEventRange;
	  this.isSameDate = spec.isSameDate || isSameDate;
	  this.startAndEndAreDateOnly = spec.startAndEndAreDateOnly || startAndEndAreDateOnly;
	  this.segmentOffset = spec.browserTZOffset ? spec.browserTZOffset() : 0;
	});
	function mergeWithDefaults(localizer, culture, formatOverrides, messages) {
	  var formats = _objectSpread2$8(_objectSpread2$8({}, localizer.formats), formatOverrides);
	  return _objectSpread2$8(_objectSpread2$8({}, localizer), {}, {
	    messages: messages,
	    startOfWeek: function startOfWeek() {
	      return localizer.startOfWeek(culture);
	    },
	    format: function format(value, _format2) {
	      return localizer.format(value, formats[_format2] || _format2, culture);
	    }
	  });
	}

	var defaultMessages = {
	  date: 'Date',
	  time: 'Time',
	  event: 'Event',
	  allDay: 'All Day',
	  week: 'Week',
	  work_week: 'Work Week',
	  day: 'Day',
	  month: 'Month',
	  previous: 'Back',
	  next: 'Next',
	  yesterday: 'Yesterday',
	  tomorrow: 'Tomorrow',
	  today: 'Today',
	  agenda: 'Agenda',
	  noEventsInRange: 'There are no events in this range.',
	  showMore: function showMore(total) {
	    return "+".concat(total, " more");
	  }
	};
	function messages(msgs) {
	  return _objectSpread2$8(_objectSpread2$8({}, defaultMessages), msgs);
	}

	function useClickOutside$2(_ref) {
	  var ref = _ref.ref,
	    callback = _ref.callback;
	  React$1.useEffect(function () {
	    var handleClickOutside = function handleClickOutside(e) {
	      if (ref.current && !ref.current.contains(e.target)) {
	        callback();
	      }
	    };
	    document.addEventListener('mousedown', handleClickOutside);
	    return function () {
	      document.removeEventListener('mousedown', handleClickOutside);
	    };
	  }, [ref, callback]);
	}

	var _excluded$7$1 = ["style", "className", "event", "selected", "isAllDay", "onSelect", "onDoubleClick", "onKeyPress", "localizer", "continuesPrior", "continuesAfter", "accessors", "getters", "children", "components", "slotStart", "slotEnd"];
	var EventCell$2 = /*#__PURE__*/function (_React$Component) {
	  _inherits(EventCell, _React$Component);
	  var _super = _createSuper(EventCell);
	  function EventCell() {
	    _classCallCheck(this, EventCell);
	    return _super.apply(this, arguments);
	  }
	  _createClass$1(EventCell, [{
	    key: "render",
	    value: function render() {
	      var _this$props = this.props,
	        style = _this$props.style,
	        className = _this$props.className,
	        event = _this$props.event,
	        selected = _this$props.selected,
	        isAllDay = _this$props.isAllDay,
	        onSelect = _this$props.onSelect,
	        _onDoubleClick = _this$props.onDoubleClick,
	        _onKeyPress = _this$props.onKeyPress,
	        localizer = _this$props.localizer,
	        continuesPrior = _this$props.continuesPrior,
	        continuesAfter = _this$props.continuesAfter,
	        accessors = _this$props.accessors,
	        getters = _this$props.getters,
	        children = _this$props.children,
	        _this$props$component = _this$props.components,
	        Event = _this$props$component.event,
	        EventWrapper = _this$props$component.eventWrapper,
	        slotStart = _this$props.slotStart,
	        slotEnd = _this$props.slotEnd,
	        props = _objectWithoutProperties(_this$props, _excluded$7$1);
	      delete props.resizable;
	      var title = accessors.title(event);
	      var tooltip = accessors.tooltip(event);
	      var end = accessors.end(event);
	      var start = accessors.start(event);
	      var allDay = accessors.allDay(event);
	      var showAsAllDay = isAllDay || allDay || localizer.diff(start, localizer.ceil(end, 'day'), 'day') > 1;
	      var userProps = getters.eventProp(event, start, end, selected);
	      var content = /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-event-content",
	        title: tooltip || undefined
	      }, Event ? /*#__PURE__*/React$1.createElement(Event, {
	        event: event,
	        continuesPrior: continuesPrior,
	        continuesAfter: continuesAfter,
	        title: title,
	        isAllDay: allDay,
	        localizer: localizer,
	        slotStart: slotStart,
	        slotEnd: slotEnd
	      }) : title);
	      return /*#__PURE__*/React$1.createElement(EventWrapper, Object.assign({}, this.props, {
	        type: "date"
	      }), /*#__PURE__*/React$1.createElement("div", Object.assign({}, props, {
	        tabIndex: 0,
	        style: _objectSpread2$8(_objectSpread2$8({}, userProps.style), style),
	        className: clsx('rbc-event', className, userProps.className, {
	          'rbc-selected': selected,
	          'rbc-event-allday': showAsAllDay,
	          'rbc-event-continues-prior': continuesPrior,
	          'rbc-event-continues-after': continuesAfter
	        }),
	        onClick: function onClick(e) {
	          return onSelect && onSelect(event, e);
	        },
	        onDoubleClick: function onDoubleClick(e) {
	          return _onDoubleClick && _onDoubleClick(event, e);
	        },
	        onKeyPress: function onKeyPress(e) {
	          return _onKeyPress && _onKeyPress(event, e);
	        }
	      }), typeof children === 'function' ? children(content) : content));
	    }
	  }]);
	  return EventCell;
	}(React$1.Component);

	function isSelected$1(event, selected) {
	  if (!event || selected == null) return false;
	  return isEqual$4(event, selected);
	}
	function slotWidth$1(rowBox, slots) {
	  var rowWidth = rowBox.right - rowBox.left;
	  var cellWidth = rowWidth / slots;
	  return cellWidth;
	}
	function getSlotAtX$1(rowBox, x, rtl, slots) {
	  var cellWidth = slotWidth$1(rowBox, slots);
	  return rtl ? slots - 1 - Math.floor((x - rowBox.left) / cellWidth) : Math.floor((x - rowBox.left) / cellWidth);
	}
	function pointInBox$1(box, _ref) {
	  var x = _ref.x,
	    y = _ref.y;
	  return y >= box.top && y <= box.bottom && x >= box.left && x <= box.right;
	}
	function dateCellSelection$1(start, rowBox, box, slots, rtl) {
	  var startIdx = -1;
	  var endIdx = -1;
	  var lastSlotIdx = slots - 1;
	  var cellWidth = slotWidth$1(rowBox, slots);

	  // cell under the mouse
	  var currentSlot = getSlotAtX$1(rowBox, box.x, rtl, slots);

	  // Identify row as either the initial row
	  // or the row under the current mouse point
	  var isCurrentRow = rowBox.top < box.y && rowBox.bottom > box.y;
	  var isStartRow = rowBox.top < start.y && rowBox.bottom > start.y;

	  // this row's position relative to the start point
	  var isAboveStart = start.y > rowBox.bottom;
	  var isBelowStart = rowBox.top > start.y;
	  var isBetween = box.top < rowBox.top && box.bottom > rowBox.bottom;

	  // this row is between the current and start rows, so entirely selected
	  if (isBetween) {
	    startIdx = 0;
	    endIdx = lastSlotIdx;
	  }
	  if (isCurrentRow) {
	    if (isBelowStart) {
	      startIdx = 0;
	      endIdx = currentSlot;
	    } else if (isAboveStart) {
	      startIdx = currentSlot;
	      endIdx = lastSlotIdx;
	    }
	  }
	  if (isStartRow) {
	    // select the cell under the initial point
	    startIdx = endIdx = rtl ? lastSlotIdx - Math.floor((start.x - rowBox.left) / cellWidth) : Math.floor((start.x - rowBox.left) / cellWidth);
	    if (isCurrentRow) {
	      if (currentSlot < startIdx) startIdx = currentSlot;else endIdx = currentSlot; //select current range
	    } else if (start.y < box.y) {
	      // the current row is below start row
	      // select cells to the right of the start cell
	      endIdx = lastSlotIdx;
	    } else {
	      // select cells to the left of the start cell
	      startIdx = 0;
	    }
	  }
	  return {
	    startIdx: startIdx,
	    endIdx: endIdx
	  };
	}

	/**
	 * Changes to react-overlays cause issue with auto positioning,
	 * so we need to manually calculate the position of the popper,
	 * and constrain it to the Month container.
	 */
	function getPosition$1(_ref) {
	  var target = _ref.target,
	    offset = _ref.offset,
	    container = _ref.container,
	    box = _ref.box;
	  var _getOffset = offset$2(target),
	    top = _getOffset.top,
	    left = _getOffset.left,
	    width = _getOffset.width,
	    height = _getOffset.height;
	  var _getOffset2 = offset$2(container),
	    cTop = _getOffset2.top,
	    cLeft = _getOffset2.left,
	    cWidth = _getOffset2.width,
	    cHeight = _getOffset2.height;
	  var _getOffset3 = offset$2(box),
	    bWidth = _getOffset3.width,
	    bHeight = _getOffset3.height;
	  var viewBottom = cTop + cHeight;
	  var viewRight = cLeft + cWidth;
	  var bottom = top + bHeight;
	  var right = left + bWidth;
	  var x = offset.x,
	    y = offset.y;
	  var topOffset = bottom > viewBottom ? top - bHeight - y : top + y + height;
	  var leftOffset = right > viewRight ? left + x - bWidth + width : left + x;
	  return {
	    topOffset: topOffset,
	    leftOffset: leftOffset
	  };
	}
	function Pop$1(_ref2) {
	  var containerRef = _ref2.containerRef,
	    accessors = _ref2.accessors,
	    getters = _ref2.getters,
	    selected = _ref2.selected,
	    components = _ref2.components,
	    localizer = _ref2.localizer,
	    position = _ref2.position,
	    show = _ref2.show,
	    events = _ref2.events,
	    slotStart = _ref2.slotStart,
	    slotEnd = _ref2.slotEnd,
	    onSelect = _ref2.onSelect,
	    onDoubleClick = _ref2.onDoubleClick,
	    onKeyPress = _ref2.onKeyPress,
	    handleDragStart = _ref2.handleDragStart,
	    popperRef = _ref2.popperRef,
	    target = _ref2.target,
	    offset = _ref2.offset;
	  useClickOutside$2({
	    ref: popperRef,
	    callback: show
	  });
	  React$1.useLayoutEffect(function () {
	    var _getPosition = getPosition$1({
	        target: target,
	        offset: offset,
	        container: containerRef.current,
	        box: popperRef.current
	      }),
	      topOffset = _getPosition.topOffset,
	      leftOffset = _getPosition.leftOffset;
	    popperRef.current.style.top = "".concat(topOffset, "px");
	    popperRef.current.style.left = "".concat(leftOffset, "px");
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	  }, [offset.x, offset.y, target]);
	  var width = position.width;
	  var style = {
	    minWidth: width + width / 2
	  };
	  return /*#__PURE__*/React$1.createElement("div", {
	    style: style,
	    className: "rbc-overlay",
	    ref: popperRef
	  }, /*#__PURE__*/React$1.createElement("div", {
	    className: "rbc-overlay-header"
	  }, localizer.format(slotStart, 'dayHeaderFormat')), events.map(function (event, idx) {
	    return /*#__PURE__*/React$1.createElement(EventCell$2, {
	      key: idx,
	      type: "popup",
	      localizer: localizer,
	      event: event,
	      getters: getters,
	      onSelect: onSelect,
	      accessors: accessors,
	      components: components,
	      onDoubleClick: onDoubleClick,
	      onKeyPress: onKeyPress,
	      continuesPrior: localizer.lt(accessors.end(event), slotStart, 'day'),
	      continuesAfter: localizer.gte(accessors.start(event), slotEnd, 'day'),
	      slotStart: slotStart,
	      slotEnd: slotEnd,
	      selected: isSelected$1(event, selected),
	      draggable: true,
	      onDragStart: function onDragStart() {
	        return handleDragStart(event);
	      },
	      onDragEnd: function onDragEnd() {
	        return show();
	      }
	    });
	  }));
	}
	var Popup$2 = /*#__PURE__*/React$1.forwardRef(function (props, ref) {
	  return /*#__PURE__*/React$1.createElement(Pop$1, Object.assign({}, props, {
	    popperRef: ref
	  }));
	});
	Popup$2.propTypes = {
	  accessors: PropTypes.object.isRequired,
	  getters: PropTypes.object.isRequired,
	  selected: PropTypes.object,
	  components: PropTypes.object.isRequired,
	  localizer: PropTypes.object.isRequired,
	  position: PropTypes.object.isRequired,
	  show: PropTypes.func.isRequired,
	  events: PropTypes.array.isRequired,
	  slotStart: PropTypes.instanceOf(Date).isRequired,
	  slotEnd: PropTypes.instanceOf(Date),
	  onSelect: PropTypes.func,
	  onDoubleClick: PropTypes.func,
	  onKeyPress: PropTypes.func,
	  handleDragStart: PropTypes.func,
	  style: PropTypes.object,
	  offset: PropTypes.shape({
	    x: PropTypes.number,
	    y: PropTypes.number
	  })
	};

	function CalOverlay$1(_ref) {
	  var containerRef = _ref.containerRef,
	    _ref$popupOffset = _ref.popupOffset,
	    popupOffset = _ref$popupOffset === void 0 ? 5 : _ref$popupOffset,
	    overlay = _ref.overlay,
	    accessors = _ref.accessors,
	    localizer = _ref.localizer,
	    components = _ref.components,
	    getters = _ref.getters,
	    selected = _ref.selected,
	    handleSelectEvent = _ref.handleSelectEvent,
	    handleDoubleClickEvent = _ref.handleDoubleClickEvent,
	    handleKeyPressEvent = _ref.handleKeyPressEvent,
	    handleDragStart = _ref.handleDragStart,
	    onHide = _ref.onHide,
	    overlayDisplay = _ref.overlayDisplay;
	  var popperRef = React$1.useRef(null);
	  if (!overlay.position) return null;
	  var offset = popupOffset;
	  if (!isNaN(popupOffset)) {
	    offset = {
	      x: popupOffset,
	      y: popupOffset
	    };
	  }
	  var position = overlay.position,
	    events = overlay.events,
	    date = overlay.date,
	    end = overlay.end;
	  return /*#__PURE__*/React$1.createElement(Overlay$1, {
	    rootClose: true,
	    flip: true,
	    show: true,
	    placement: "bottom",
	    onHide: onHide,
	    target: overlay.target
	  }, function (_ref2) {
	    var props = _ref2.props;
	    return /*#__PURE__*/React$1.createElement(Popup$2, Object.assign({}, props, {
	      containerRef: containerRef,
	      ref: popperRef,
	      target: overlay.target,
	      offset: offset,
	      accessors: accessors,
	      getters: getters,
	      selected: selected,
	      components: components,
	      localizer: localizer,
	      position: position,
	      show: overlayDisplay,
	      events: events,
	      slotStart: date,
	      slotEnd: end,
	      onSelect: handleSelectEvent,
	      onDoubleClick: handleDoubleClickEvent,
	      onKeyPress: handleKeyPressEvent,
	      handleDragStart: handleDragStart
	    }));
	  });
	}
	var PopOverlay$2 = /*#__PURE__*/React$1.forwardRef(function (props, ref) {
	  return /*#__PURE__*/React$1.createElement(CalOverlay$1, Object.assign({}, props, {
	    containerRef: ref
	  }));
	});
	PopOverlay$2.propTypes = {
	  popupOffset: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
	    x: PropTypes.number,
	    y: PropTypes.number
	  })]),
	  overlay: PropTypes.shape({
	    position: PropTypes.object,
	    events: PropTypes.array,
	    date: PropTypes.instanceOf(Date),
	    end: PropTypes.instanceOf(Date)
	  }),
	  accessors: PropTypes.object.isRequired,
	  localizer: PropTypes.object.isRequired,
	  components: PropTypes.object.isRequired,
	  getters: PropTypes.object.isRequired,
	  selected: PropTypes.object,
	  handleSelectEvent: PropTypes.func,
	  handleDoubleClickEvent: PropTypes.func,
	  handleKeyPressEvent: PropTypes.func,
	  handleDragStart: PropTypes.func,
	  onHide: PropTypes.func,
	  overlayDisplay: PropTypes.func
	};

	function addEventListener$1(type, handler) {
	  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
	  return listen(target, type, handler, {
	    passive: false
	  });
	}
	function isOverContainer$1(container, x, y) {
	  return !container || contains$1(container, document.elementFromPoint(x, y));
	}
	function getEventNodeFromPoint$1(node, _ref) {
	  var clientX = _ref.clientX,
	    clientY = _ref.clientY;
	  var target = document.elementFromPoint(clientX, clientY);
	  return closest(target, '.rbc-event', node);
	}
	function getShowMoreNodeFromPoint$1(node, _ref2) {
	  var clientX = _ref2.clientX,
	    clientY = _ref2.clientY;
	  var target = document.elementFromPoint(clientX, clientY);
	  return closest(target, '.rbc-show-more', node);
	}
	function isEvent$1(node, bounds) {
	  return !!getEventNodeFromPoint$1(node, bounds);
	}
	function isShowMore$1(node, bounds) {
	  return !!getShowMoreNodeFromPoint$1(node, bounds);
	}
	function getEventCoordinates$1(e) {
	  var target = e;
	  if (e.touches && e.touches.length) {
	    target = e.touches[0];
	  }
	  return {
	    clientX: target.clientX,
	    clientY: target.clientY,
	    pageX: target.pageX,
	    pageY: target.pageY
	  };
	}
	var clickTolerance$1 = 5;
	var clickInterval$1 = 250;
	var Selection$2 = /*#__PURE__*/function () {
	  function Selection(node) {
	    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref3$global = _ref3.global,
	      global = _ref3$global === void 0 ? false : _ref3$global,
	      _ref3$longPressThresh = _ref3.longPressThreshold,
	      longPressThreshold = _ref3$longPressThresh === void 0 ? 250 : _ref3$longPressThresh,
	      _ref3$validContainers = _ref3.validContainers,
	      validContainers = _ref3$validContainers === void 0 ? [] : _ref3$validContainers;
	    _classCallCheck(this, Selection);
	    this.isDetached = false;
	    this.container = node;
	    this.globalMouse = !node || global;
	    this.longPressThreshold = longPressThreshold;
	    this.validContainers = validContainers;
	    this._listeners = Object.create(null);
	    this._handleInitialEvent = this._handleInitialEvent.bind(this);
	    this._handleMoveEvent = this._handleMoveEvent.bind(this);
	    this._handleTerminatingEvent = this._handleTerminatingEvent.bind(this);
	    this._keyListener = this._keyListener.bind(this);
	    this._dropFromOutsideListener = this._dropFromOutsideListener.bind(this);
	    this._dragOverFromOutsideListener = this._dragOverFromOutsideListener.bind(this);

	    // Fixes an iOS 10 bug where scrolling could not be prevented on the window.
	    // https://github.com/metafizzy/flickity/issues/457#issuecomment-254501356
	    this._removeTouchMoveWindowListener = addEventListener$1('touchmove', function () {}, window);
	    this._removeKeyDownListener = addEventListener$1('keydown', this._keyListener);
	    this._removeKeyUpListener = addEventListener$1('keyup', this._keyListener);
	    this._removeDropFromOutsideListener = addEventListener$1('drop', this._dropFromOutsideListener);
	    this._removeDragOverFromOutsideListener = addEventListener$1('dragover', this._dragOverFromOutsideListener);
	    this._addInitialEventListener();
	  }
	  _createClass$1(Selection, [{
	    key: "on",
	    value: function on(type, handler) {
	      var handlers = this._listeners[type] || (this._listeners[type] = []);
	      handlers.push(handler);
	      return {
	        remove: function remove() {
	          var idx = handlers.indexOf(handler);
	          if (idx !== -1) handlers.splice(idx, 1);
	        }
	      };
	    }
	  }, {
	    key: "emit",
	    value: function emit(type) {
	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	      var result;
	      var handlers = this._listeners[type] || [];
	      handlers.forEach(function (fn) {
	        if (result === undefined) result = fn.apply(void 0, args);
	      });
	      return result;
	    }
	  }, {
	    key: "teardown",
	    value: function teardown() {
	      this.isDetached = true;
	      this._listeners = Object.create(null);
	      this._removeTouchMoveWindowListener && this._removeTouchMoveWindowListener();
	      this._removeInitialEventListener && this._removeInitialEventListener();
	      this._removeEndListener && this._removeEndListener();
	      this._onEscListener && this._onEscListener();
	      this._removeMoveListener && this._removeMoveListener();
	      this._removeKeyUpListener && this._removeKeyUpListener();
	      this._removeKeyDownListener && this._removeKeyDownListener();
	      this._removeDropFromOutsideListener && this._removeDropFromOutsideListener();
	      this._removeDragOverFromOutsideListener && this._removeDragOverFromOutsideListener();
	    }
	  }, {
	    key: "isSelected",
	    value: function isSelected(node) {
	      var box = this._selectRect;
	      if (!box || !this.selecting) return false;
	      return objectsCollide$1(box, getBoundsForNode$1(node));
	    }
	  }, {
	    key: "filter",
	    value: function filter(items) {
	      var box = this._selectRect;

	      //not selecting
	      if (!box || !this.selecting) return [];
	      return items.filter(this.isSelected, this);
	    }

	    // Adds a listener that will call the handler only after the user has pressed on the screen
	    // without moving their finger for 250ms.
	  }, {
	    key: "_addLongPressListener",
	    value: function _addLongPressListener(handler, initialEvent) {
	      var _this = this;
	      var timer = null;
	      var removeTouchMoveListener = null;
	      var removeTouchEndListener = null;
	      var handleTouchStart = function handleTouchStart(initialEvent) {
	        timer = setTimeout(function () {
	          cleanup();
	          handler(initialEvent);
	        }, _this.longPressThreshold);
	        removeTouchMoveListener = addEventListener$1('touchmove', function () {
	          return cleanup();
	        });
	        removeTouchEndListener = addEventListener$1('touchend', function () {
	          return cleanup();
	        });
	      };
	      var removeTouchStartListener = addEventListener$1('touchstart', handleTouchStart);
	      var cleanup = function cleanup() {
	        if (timer) {
	          clearTimeout(timer);
	        }
	        if (removeTouchMoveListener) {
	          removeTouchMoveListener();
	        }
	        if (removeTouchEndListener) {
	          removeTouchEndListener();
	        }
	        timer = null;
	        removeTouchMoveListener = null;
	        removeTouchEndListener = null;
	      };
	      if (initialEvent) {
	        handleTouchStart(initialEvent);
	      }
	      return function () {
	        cleanup();
	        removeTouchStartListener();
	      };
	    }

	    // Listen for mousedown and touchstart events. When one is received, disable the other and setup
	    // future event handling based on the type of event.
	  }, {
	    key: "_addInitialEventListener",
	    value: function _addInitialEventListener() {
	      var _this2 = this;
	      var removeMouseDownListener = addEventListener$1('mousedown', function (e) {
	        _this2._removeInitialEventListener();
	        _this2._handleInitialEvent(e);
	        _this2._removeInitialEventListener = addEventListener$1('mousedown', _this2._handleInitialEvent);
	      });
	      var removeTouchStartListener = addEventListener$1('touchstart', function (e) {
	        _this2._removeInitialEventListener();
	        _this2._removeInitialEventListener = _this2._addLongPressListener(_this2._handleInitialEvent, e);
	      });
	      this._removeInitialEventListener = function () {
	        removeMouseDownListener();
	        removeTouchStartListener();
	      };
	    }
	  }, {
	    key: "_dropFromOutsideListener",
	    value: function _dropFromOutsideListener(e) {
	      var _getEventCoordinates = getEventCoordinates$1(e),
	        pageX = _getEventCoordinates.pageX,
	        pageY = _getEventCoordinates.pageY,
	        clientX = _getEventCoordinates.clientX,
	        clientY = _getEventCoordinates.clientY;
	      this.emit('dropFromOutside', {
	        x: pageX,
	        y: pageY,
	        clientX: clientX,
	        clientY: clientY
	      });
	      e.preventDefault();
	    }
	  }, {
	    key: "_dragOverFromOutsideListener",
	    value: function _dragOverFromOutsideListener(e) {
	      var _getEventCoordinates2 = getEventCoordinates$1(e),
	        pageX = _getEventCoordinates2.pageX,
	        pageY = _getEventCoordinates2.pageY,
	        clientX = _getEventCoordinates2.clientX,
	        clientY = _getEventCoordinates2.clientY;
	      this.emit('dragOverFromOutside', {
	        x: pageX,
	        y: pageY,
	        clientX: clientX,
	        clientY: clientY
	      });
	      e.preventDefault();
	    }
	  }, {
	    key: "_handleInitialEvent",
	    value: function _handleInitialEvent(e) {
	      if (this.isDetached) {
	        return;
	      }
	      var _getEventCoordinates3 = getEventCoordinates$1(e),
	        clientX = _getEventCoordinates3.clientX,
	        clientY = _getEventCoordinates3.clientY,
	        pageX = _getEventCoordinates3.pageX,
	        pageY = _getEventCoordinates3.pageY;
	      var node = this.container(),
	        collides,
	        offsetData;

	      // Right clicks
	      if (e.which === 3 || e.button === 2 || !isOverContainer$1(node, clientX, clientY)) return;
	      if (!this.globalMouse && node && !contains$1(node, e.target)) {
	        var _normalizeDistance = normalizeDistance$1(0),
	          top = _normalizeDistance.top,
	          left = _normalizeDistance.left,
	          bottom = _normalizeDistance.bottom,
	          right = _normalizeDistance.right;
	        offsetData = getBoundsForNode$1(node);
	        collides = objectsCollide$1({
	          top: offsetData.top - top,
	          left: offsetData.left - left,
	          bottom: offsetData.bottom + bottom,
	          right: offsetData.right + right
	        }, {
	          top: pageY,
	          left: pageX
	        });
	        if (!collides) return;
	      }
	      var result = this.emit('beforeSelect', this._initialEventData = {
	        isTouch: /^touch/.test(e.type),
	        x: pageX,
	        y: pageY,
	        clientX: clientX,
	        clientY: clientY
	      });
	      if (result === false) return;
	      switch (e.type) {
	        case 'mousedown':
	          this._removeEndListener = addEventListener$1('mouseup', this._handleTerminatingEvent);
	          this._onEscListener = addEventListener$1('keydown', this._handleTerminatingEvent);
	          this._removeMoveListener = addEventListener$1('mousemove', this._handleMoveEvent);
	          break;
	        case 'touchstart':
	          this._handleMoveEvent(e);
	          this._removeEndListener = addEventListener$1('touchend', this._handleTerminatingEvent);
	          this._removeMoveListener = addEventListener$1('touchmove', this._handleMoveEvent);
	          break;
	      }
	    }

	    // Check whether provided event target element
	    // - is contained within a valid container
	  }, {
	    key: "_isWithinValidContainer",
	    value: function _isWithinValidContainer(e) {
	      var eventTarget = e.target;
	      var containers = this.validContainers;
	      if (!containers || !containers.length || !eventTarget) {
	        return true;
	      }
	      return containers.some(function (target) {
	        return !!eventTarget.closest(target);
	      });
	    }
	  }, {
	    key: "_handleTerminatingEvent",
	    value: function _handleTerminatingEvent(e) {
	      var _getEventCoordinates4 = getEventCoordinates$1(e),
	        pageX = _getEventCoordinates4.pageX,
	        pageY = _getEventCoordinates4.pageY;
	      this.selecting = false;
	      this._removeEndListener && this._removeEndListener();
	      this._removeMoveListener && this._removeMoveListener();
	      if (!this._initialEventData) return;
	      var inRoot = !this.container || contains$1(this.container(), e.target);
	      var isWithinValidContainer = this._isWithinValidContainer(e);
	      var bounds = this._selectRect;
	      var click = this.isClick(pageX, pageY);
	      this._initialEventData = null;
	      if (e.key === 'Escape' || !isWithinValidContainer) {
	        return this.emit('reset');
	      }
	      if (click && inRoot) {
	        return this._handleClickEvent(e);
	      }

	      // User drag-clicked in the Selectable area
	      if (!click) return this.emit('select', bounds);
	      return this.emit('reset');
	    }
	  }, {
	    key: "_handleClickEvent",
	    value: function _handleClickEvent(e) {
	      var _getEventCoordinates5 = getEventCoordinates$1(e),
	        pageX = _getEventCoordinates5.pageX,
	        pageY = _getEventCoordinates5.pageY,
	        clientX = _getEventCoordinates5.clientX,
	        clientY = _getEventCoordinates5.clientY;
	      var now = new Date().getTime();
	      if (this._lastClickData && now - this._lastClickData.timestamp < clickInterval$1) {
	        // Double click event
	        this._lastClickData = null;
	        return this.emit('doubleClick', {
	          x: pageX,
	          y: pageY,
	          clientX: clientX,
	          clientY: clientY
	        });
	      }

	      // Click event
	      this._lastClickData = {
	        timestamp: now
	      };
	      return this.emit('click', {
	        x: pageX,
	        y: pageY,
	        clientX: clientX,
	        clientY: clientY
	      });
	    }
	  }, {
	    key: "_handleMoveEvent",
	    value: function _handleMoveEvent(e) {
	      if (this._initialEventData === null || this.isDetached) {
	        return;
	      }
	      var _this$_initialEventDa = this._initialEventData,
	        x = _this$_initialEventDa.x,
	        y = _this$_initialEventDa.y;
	      var _getEventCoordinates6 = getEventCoordinates$1(e),
	        pageX = _getEventCoordinates6.pageX,
	        pageY = _getEventCoordinates6.pageY;
	      var w = Math.abs(x - pageX);
	      var h = Math.abs(y - pageY);
	      var left = Math.min(pageX, x),
	        top = Math.min(pageY, y),
	        old = this.selecting;

	      // Prevent emitting selectStart event until mouse is moved.
	      // in Chrome on Windows, mouseMove event may be fired just after mouseDown event.
	      if (this.isClick(pageX, pageY) && !old && !(w || h)) {
	        return;
	      }
	      this.selecting = true;
	      this._selectRect = {
	        top: top,
	        left: left,
	        x: pageX,
	        y: pageY,
	        right: left + w,
	        bottom: top + h
	      };
	      if (!old) {
	        this.emit('selectStart', this._initialEventData);
	      }
	      if (!this.isClick(pageX, pageY)) this.emit('selecting', this._selectRect);
	      e.preventDefault();
	    }
	  }, {
	    key: "_keyListener",
	    value: function _keyListener(e) {
	      this.ctrl = e.metaKey || e.ctrlKey;
	    }
	  }, {
	    key: "isClick",
	    value: function isClick(pageX, pageY) {
	      var _this$_initialEventDa2 = this._initialEventData,
	        x = _this$_initialEventDa2.x,
	        y = _this$_initialEventDa2.y,
	        isTouch = _this$_initialEventDa2.isTouch;
	      return !isTouch && Math.abs(pageX - x) <= clickTolerance$1 && Math.abs(pageY - y) <= clickTolerance$1;
	    }
	  }]);
	  return Selection;
	}();
	/**
	 * Resolve the disance prop from either an Int or an Object
	 * @return {Object}
	 */
	function normalizeDistance$1() {
	  var distance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	  if (_typeof$1(distance) !== 'object') distance = {
	    top: distance,
	    left: distance,
	    right: distance,
	    bottom: distance
	  };
	  return distance;
	}

	/**
	 * Given two objects containing "top", "left", "offsetWidth" and "offsetHeight"
	 * properties, determine if they collide.
	 * @param  {Object|HTMLElement} a
	 * @param  {Object|HTMLElement} b
	 * @return {bool}
	 */
	function objectsCollide$1(nodeA, nodeB) {
	  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	  var _getBoundsForNode = getBoundsForNode$1(nodeA),
	    aTop = _getBoundsForNode.top,
	    aLeft = _getBoundsForNode.left,
	    _getBoundsForNode$rig = _getBoundsForNode.right,
	    aRight = _getBoundsForNode$rig === void 0 ? aLeft : _getBoundsForNode$rig,
	    _getBoundsForNode$bot = _getBoundsForNode.bottom,
	    aBottom = _getBoundsForNode$bot === void 0 ? aTop : _getBoundsForNode$bot;
	  var _getBoundsForNode2 = getBoundsForNode$1(nodeB),
	    bTop = _getBoundsForNode2.top,
	    bLeft = _getBoundsForNode2.left,
	    _getBoundsForNode2$ri = _getBoundsForNode2.right,
	    bRight = _getBoundsForNode2$ri === void 0 ? bLeft : _getBoundsForNode2$ri,
	    _getBoundsForNode2$bo = _getBoundsForNode2.bottom,
	    bBottom = _getBoundsForNode2$bo === void 0 ? bTop : _getBoundsForNode2$bo;
	  return !(
	  // 'a' bottom doesn't touch 'b' top

	  aBottom - tolerance < bTop ||
	  // 'a' top doesn't touch 'b' bottom
	  aTop + tolerance > bBottom ||
	  // 'a' right doesn't touch 'b' left
	  aRight - tolerance < bLeft ||
	  // 'a' left doesn't touch 'b' right
	  aLeft + tolerance > bRight);
	}

	/**
	 * Given a node, get everything needed to calculate its boundaries
	 * @param  {HTMLElement} node
	 * @return {Object}
	 */
	function getBoundsForNode$1(node) {
	  if (!node.getBoundingClientRect) return node;
	  var rect = node.getBoundingClientRect(),
	    left = rect.left + pageOffset$1('left'),
	    top = rect.top + pageOffset$1('top');
	  return {
	    top: top,
	    left: left,
	    right: (node.offsetWidth || 0) + left,
	    bottom: (node.offsetHeight || 0) + top
	  };
	}
	function pageOffset$1(dir) {
	  if (dir === 'left') return window.pageXOffset || document.body.scrollLeft || 0;
	  if (dir === 'top') return window.pageYOffset || document.body.scrollTop || 0;
	}

	var BackgroundCells$2 = /*#__PURE__*/function (_React$Component) {
	  _inherits(BackgroundCells, _React$Component);
	  var _super = _createSuper(BackgroundCells);
	  function BackgroundCells(props, context) {
	    var _this;
	    _classCallCheck(this, BackgroundCells);
	    _this = _super.call(this, props, context);
	    _this.state = {
	      selecting: false
	    };
	    _this.containerRef = /*#__PURE__*/React$1.createRef();
	    return _this;
	  }
	  _createClass$1(BackgroundCells, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      this.props.selectable && this._selectable();
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      this._teardownSelectable();
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate(prevProps) {
	      if (!prevProps.selectable && this.props.selectable) this._selectable();
	      if (prevProps.selectable && !this.props.selectable) this._teardownSelectable();
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this$props = this.props,
	        range = _this$props.range,
	        getNow = _this$props.getNow,
	        getters = _this$props.getters,
	        currentDate = _this$props.date,
	        Wrapper = _this$props.components.dateCellWrapper,
	        localizer = _this$props.localizer;
	      var _this$state = this.state,
	        selecting = _this$state.selecting,
	        startIdx = _this$state.startIdx,
	        endIdx = _this$state.endIdx;
	      var current = getNow();
	      return /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-row-bg",
	        ref: this.containerRef
	      }, range.map(function (date, index) {
	        var selected = selecting && index >= startIdx && index <= endIdx;
	        var _getters$dayProp = getters.dayProp(date),
	          className = _getters$dayProp.className,
	          style = _getters$dayProp.style;
	        return /*#__PURE__*/React$1.createElement(Wrapper, {
	          key: index,
	          value: date,
	          range: range
	        }, /*#__PURE__*/React$1.createElement("div", {
	          style: style,
	          className: clsx('rbc-day-bg', className, selected && 'rbc-selected-cell', localizer.isSameDate(date, current) && 'rbc-today', currentDate && localizer.neq(currentDate, date, 'month') && 'rbc-off-range-bg')
	        }));
	      }));
	    }
	  }, {
	    key: "_selectable",
	    value: function _selectable() {
	      var _this2 = this;
	      var node = this.containerRef.current;
	      var selector = this._selector = new Selection$2(this.props.container, {
	        longPressThreshold: this.props.longPressThreshold
	      });
	      var selectorClicksHandler = function selectorClicksHandler(point, actionType) {
	        if (!isEvent$1(node, point) && !isShowMore$1(node, point)) {
	          var rowBox = getBoundsForNode$1(node);
	          var _this2$props = _this2.props,
	            range = _this2$props.range,
	            rtl = _this2$props.rtl;
	          if (pointInBox$1(rowBox, point)) {
	            var currentCell = getSlotAtX$1(rowBox, point.x, rtl, range.length);
	            _this2._selectSlot({
	              startIdx: currentCell,
	              endIdx: currentCell,
	              action: actionType,
	              box: point
	            });
	          }
	        }
	        _this2._initial = {};
	        _this2.setState({
	          selecting: false
	        });
	      };
	      selector.on('selecting', function (box) {
	        var _this2$props2 = _this2.props,
	          range = _this2$props2.range,
	          rtl = _this2$props2.rtl;
	        var startIdx = -1;
	        var endIdx = -1;
	        if (!_this2.state.selecting) {
	          notify$1(_this2.props.onSelectStart, [box]);
	          _this2._initial = {
	            x: box.x,
	            y: box.y
	          };
	        }
	        if (selector.isSelected(node)) {
	          var nodeBox = getBoundsForNode$1(node);
	          var _dateCellSelection = dateCellSelection$1(_this2._initial, nodeBox, box, range.length, rtl);
	          startIdx = _dateCellSelection.startIdx;
	          endIdx = _dateCellSelection.endIdx;
	        }
	        _this2.setState({
	          selecting: true,
	          startIdx: startIdx,
	          endIdx: endIdx
	        });
	      });
	      selector.on('beforeSelect', function (box) {
	        if (_this2.props.selectable !== 'ignoreEvents') return;
	        return !isEvent$1(_this2.containerRef.current, box);
	      });
	      selector.on('click', function (point) {
	        return selectorClicksHandler(point, 'click');
	      });
	      selector.on('doubleClick', function (point) {
	        return selectorClicksHandler(point, 'doubleClick');
	      });
	      selector.on('select', function (bounds) {
	        _this2._selectSlot(_objectSpread2$8(_objectSpread2$8({}, _this2.state), {}, {
	          action: 'select',
	          bounds: bounds
	        }));
	        _this2._initial = {};
	        _this2.setState({
	          selecting: false
	        });
	        notify$1(_this2.props.onSelectEnd, [_this2.state]);
	      });
	    }
	  }, {
	    key: "_teardownSelectable",
	    value: function _teardownSelectable() {
	      if (!this._selector) return;
	      this._selector.teardown();
	      this._selector = null;
	    }
	  }, {
	    key: "_selectSlot",
	    value: function _selectSlot(_ref) {
	      var endIdx = _ref.endIdx,
	        startIdx = _ref.startIdx,
	        action = _ref.action,
	        bounds = _ref.bounds,
	        box = _ref.box;
	      if (endIdx !== -1 && startIdx !== -1) this.props.onSelectSlot && this.props.onSelectSlot({
	        start: startIdx,
	        end: endIdx,
	        action: action,
	        bounds: bounds,
	        box: box,
	        resourceId: this.props.resourceId
	      });
	    }
	  }]);
	  return BackgroundCells;
	}(React$1.Component);

	/* eslint-disable react/prop-types */
	var EventRowMixin$1 = {
	  propTypes: {
	    slotMetrics: PropTypes.object.isRequired,
	    selected: PropTypes.object,
	    isAllDay: PropTypes.bool,
	    accessors: PropTypes.object.isRequired,
	    localizer: PropTypes.object.isRequired,
	    components: PropTypes.object.isRequired,
	    getters: PropTypes.object.isRequired,
	    onSelect: PropTypes.func,
	    onDoubleClick: PropTypes.func,
	    onKeyPress: PropTypes.func
	  },
	  defaultProps: {
	    segments: [],
	    selected: {}
	  },
	  renderEvent: function renderEvent(props, event) {
	    var selected = props.selected;
	      props.isAllDay;
	      var accessors = props.accessors,
	      getters = props.getters,
	      onSelect = props.onSelect,
	      onDoubleClick = props.onDoubleClick,
	      onKeyPress = props.onKeyPress,
	      localizer = props.localizer,
	      slotMetrics = props.slotMetrics,
	      components = props.components,
	      resizable = props.resizable;
	    var continuesPrior = slotMetrics.continuesPrior(event);
	    var continuesAfter = slotMetrics.continuesAfter(event);
	    return /*#__PURE__*/React$1.createElement(EventCell$2, {
	      event: event,
	      getters: getters,
	      localizer: localizer,
	      accessors: accessors,
	      components: components,
	      onSelect: onSelect,
	      onDoubleClick: onDoubleClick,
	      onKeyPress: onKeyPress,
	      continuesPrior: continuesPrior,
	      continuesAfter: continuesAfter,
	      slotStart: slotMetrics.first,
	      slotEnd: slotMetrics.last,
	      selected: isSelected$1(event, selected),
	      resizable: resizable
	    });
	  },
	  renderSpan: function renderSpan(slots, len, key) {
	    var content = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ' ';
	    var per = Math.abs(len) / slots * 100 + '%';
	    return /*#__PURE__*/React$1.createElement("div", {
	      key: key,
	      className: "rbc-row-segment"
	      // IE10/11 need max-width. flex-basis doesn't respect box-sizing
	      ,
	      style: {
	        WebkitFlexBasis: per,
	        flexBasis: per,
	        maxWidth: per
	      }
	    }, content);
	  }
	};

	var EventRow$2 = /*#__PURE__*/function (_React$Component) {
	  _inherits(EventRow, _React$Component);
	  var _super = _createSuper(EventRow);
	  function EventRow() {
	    _classCallCheck(this, EventRow);
	    return _super.apply(this, arguments);
	  }
	  _createClass$1(EventRow, [{
	    key: "render",
	    value: function render() {
	      var _this = this;
	      var _this$props = this.props,
	        segments = _this$props.segments,
	        slots = _this$props.slotMetrics.slots,
	        className = _this$props.className;
	      var lastEnd = 1;
	      return /*#__PURE__*/React$1.createElement("div", {
	        className: clsx(className, 'rbc-row')
	      }, segments.reduce(function (row, _ref, li) {
	        var event = _ref.event,
	          left = _ref.left,
	          right = _ref.right,
	          span = _ref.span;
	        var key = '_lvl_' + li;
	        var gap = left - lastEnd;
	        var content = EventRowMixin$1.renderEvent(_this.props, event);
	        if (gap) row.push(EventRowMixin$1.renderSpan(slots, gap, "".concat(key, "_gap")));
	        row.push(EventRowMixin$1.renderSpan(slots, span, key, content));
	        lastEnd = right + 1;
	        return row;
	      }, []));
	    }
	  }]);
	  return EventRow;
	}(React$1.Component);
	EventRow$2.defaultProps = _objectSpread2$8({}, EventRowMixin$1.defaultProps);

	function endOfRange$1(_ref) {
	  var dateRange = _ref.dateRange,
	    _ref$unit = _ref.unit,
	    unit = _ref$unit === void 0 ? 'day' : _ref$unit,
	    localizer = _ref.localizer;
	  return {
	    first: dateRange[0],
	    last: localizer.add(dateRange[dateRange.length - 1], 1, unit)
	  };
	}

	// properly calculating segments requires working with dates in
	// the timezone we're working with, so we use the localizer
	function eventSegments$1(event, range, accessors, localizer) {
	  var _endOfRange = endOfRange$1({
	      dateRange: range,
	      localizer: localizer
	    }),
	    first = _endOfRange.first,
	    last = _endOfRange.last;
	  var slots = localizer.diff(first, last, 'day');
	  var start = localizer.max(localizer.startOf(accessors.start(event), 'day'), first);
	  var end = localizer.min(localizer.ceil(accessors.end(event), 'day'), last);
	  var padding = findIndex$1(range, function (x) {
	    return localizer.isSameDate(x, start);
	  });
	  var span = localizer.diff(start, end, 'day');
	  span = Math.min(span, slots);
	  // The segmentOffset is necessary when adjusting for timezones
	  // ahead of the browser timezone
	  span = Math.max(span - localizer.segmentOffset, 1);
	  return {
	    event: event,
	    span: span,
	    left: padding + 1,
	    right: Math.max(padding + span, 1)
	  };
	}
	function eventLevels$2(rowSegments) {
	  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
	  var i,
	    j,
	    seg,
	    levels = [],
	    extra = [];
	  for (i = 0; i < rowSegments.length; i++) {
	    seg = rowSegments[i];
	    for (j = 0; j < levels.length; j++) if (!segsOverlap$1(seg, levels[j])) break;
	    if (j >= limit) {
	      extra.push(seg);
	    } else {
	      (levels[j] || (levels[j] = [])).push(seg);
	    }
	  }
	  for (i = 0; i < levels.length; i++) {
	    levels[i].sort(function (a, b) {
	      return a.left - b.left;
	    }); //eslint-disable-line
	  }

	  return {
	    levels: levels,
	    extra: extra
	  };
	}
	function inRange$1(e, start, end, accessors, localizer) {
	  var event = {
	    start: accessors.start(e),
	    end: accessors.end(e)
	  };
	  var range = {
	    start: start,
	    end: end
	  };
	  return localizer.inEventRange({
	    event: event,
	    range: range
	  });
	}
	function segsOverlap$1(seg, otherSegs) {
	  return otherSegs.some(function (otherSeg) {
	    return otherSeg.left <= seg.right && otherSeg.right >= seg.left;
	  });
	}
	function sortEvents$2(eventA, eventB, accessors, localizer) {
	  var evtA = {
	    start: accessors.start(eventA),
	    end: accessors.end(eventA),
	    allDay: accessors.allDay(eventA)
	  };
	  var evtB = {
	    start: accessors.start(eventB),
	    end: accessors.end(eventB),
	    allDay: accessors.allDay(eventB)
	  };
	  return localizer.sortEvents({
	    evtA: evtA,
	    evtB: evtB
	  });
	}

	var isSegmentInSlot$1$1 = function isSegmentInSlot(seg, slot) {
	  return seg.left <= slot && seg.right >= slot;
	};
	var eventsInSlot$1 = function eventsInSlot(segments, slot) {
	  return segments.filter(function (seg) {
	    return isSegmentInSlot$1$1(seg, slot);
	  }).length;
	};
	var EventEndingRow$2 = /*#__PURE__*/function (_React$Component) {
	  _inherits(EventEndingRow, _React$Component);
	  var _super = _createSuper(EventEndingRow);
	  function EventEndingRow() {
	    _classCallCheck(this, EventEndingRow);
	    return _super.apply(this, arguments);
	  }
	  _createClass$1(EventEndingRow, [{
	    key: "render",
	    value: function render() {
	      var _this$props = this.props,
	        segments = _this$props.segments,
	        slots = _this$props.slotMetrics.slots;
	      var rowSegments = eventLevels$2(segments).levels[0];
	      var current = 1,
	        lastEnd = 1,
	        row = [];
	      while (current <= slots) {
	        var key = '_lvl_' + current;
	        var _ref = rowSegments.filter(function (seg) {
	            return isSegmentInSlot$1$1(seg, current);
	          })[0] || {},
	          event = _ref.event,
	          left = _ref.left,
	          right = _ref.right,
	          span = _ref.span; //eslint-disable-line

	        if (!event) {
	          current++;
	          continue;
	        }
	        var gap = Math.max(0, left - lastEnd);
	        if (this.canRenderSlotEvent(left, span)) {
	          var content = EventRowMixin$1.renderEvent(this.props, event);
	          if (gap) {
	            row.push(EventRowMixin$1.renderSpan(slots, gap, key + '_gap'));
	          }
	          row.push(EventRowMixin$1.renderSpan(slots, span, key, content));
	          lastEnd = current = right + 1;
	        } else {
	          if (gap) {
	            row.push(EventRowMixin$1.renderSpan(slots, gap, key + '_gap'));
	          }
	          row.push(EventRowMixin$1.renderSpan(slots, 1, key, this.renderShowMore(segments, current)));
	          lastEnd = current = current + 1;
	        }
	      }
	      return /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-row"
	      }, row);
	    }
	  }, {
	    key: "canRenderSlotEvent",
	    value: function canRenderSlotEvent(slot, span) {
	      var segments = this.props.segments;
	      return range$1$1(slot, slot + span).every(function (s) {
	        var count = eventsInSlot$1(segments, s);
	        return count === 1;
	      });
	    }
	  }, {
	    key: "renderShowMore",
	    value: function renderShowMore(segments, slot) {
	      var _this = this;
	      var localizer = this.props.localizer;
	      var count = eventsInSlot$1(segments, slot);
	      return count ? /*#__PURE__*/React$1.createElement("button", {
	        type: "button",
	        key: 'sm_' + slot,
	        className: clsx('rbc-button-link', 'rbc-show-more'),
	        onClick: function onClick(e) {
	          return _this.showMore(slot, e);
	        }
	      }, localizer.messages.showMore(count)) : false;
	    }
	  }, {
	    key: "showMore",
	    value: function showMore(slot, e) {
	      e.preventDefault();
	      e.stopPropagation();
	      this.props.onShowMore(slot, e.target);
	    }
	  }]);
	  return EventEndingRow;
	}(React$1.Component);
	EventEndingRow$2.defaultProps = _objectSpread2$8({}, EventRowMixin$1.defaultProps);

	var ScrollableWeekWrapper$2 = function ScrollableWeekWrapper(_ref) {
	  var children = _ref.children;
	  return /*#__PURE__*/React$1.createElement("div", {
	    className: "rbc-row-content-scroll-container"
	  }, children);
	};

	var isSegmentInSlot$2 = function isSegmentInSlot(seg, slot) {
	  return seg.left <= slot && seg.right >= slot;
	};
	var isEqual$2 = function isEqual(a, b) {
	  return a[0].range === b[0].range && a[0].events === b[0].events;
	};
	function getSlotMetrics$1$1() {
	  return memoizeOne(function (options) {
	    var range = options.range,
	      events = options.events,
	      maxRows = options.maxRows,
	      minRows = options.minRows,
	      accessors = options.accessors,
	      localizer = options.localizer;
	    var _endOfRange = endOfRange$1({
	        dateRange: range,
	        localizer: localizer
	      }),
	      first = _endOfRange.first,
	      last = _endOfRange.last;
	    var segments = events.map(function (evt) {
	      return eventSegments$1(evt, range, accessors, localizer);
	    });
	    var _eventLevels = eventLevels$2(segments, Math.max(maxRows - 1, 1)),
	      levels = _eventLevels.levels,
	      extra = _eventLevels.extra;
	    // Subtract 1 from minRows to not include showMore button row when
	    // it would be rendered
	    var minEventRows = extra.length > 0 ? minRows - 1 : minRows;
	    while (levels.length < minEventRows) levels.push([]);
	    return {
	      first: first,
	      last: last,
	      levels: levels,
	      extra: extra,
	      range: range,
	      slots: range.length,
	      clone: function clone(args) {
	        var metrics = getSlotMetrics$1$1();
	        return metrics(_objectSpread2$8(_objectSpread2$8({}, options), args));
	      },
	      getDateForSlot: function getDateForSlot(slotNumber) {
	        return range[slotNumber];
	      },
	      getSlotForDate: function getSlotForDate(date) {
	        return range.find(function (r) {
	          return localizer.isSameDate(r, date);
	        });
	      },
	      getEventsForSlot: function getEventsForSlot(slot) {
	        return segments.filter(function (seg) {
	          return isSegmentInSlot$2(seg, slot);
	        }).map(function (seg) {
	          return seg.event;
	        });
	      },
	      continuesPrior: function continuesPrior(event) {
	        return localizer.continuesPrior(accessors.start(event), first);
	      },
	      continuesAfter: function continuesAfter(event) {
	        var start = accessors.start(event);
	        var end = accessors.end(event);
	        return localizer.continuesAfter(start, end, last);
	      }
	    };
	  }, isEqual$2);
	}

	var DateContentRow$2 = /*#__PURE__*/function (_React$Component) {
	  _inherits(DateContentRow, _React$Component);
	  var _super = _createSuper(DateContentRow);
	  function DateContentRow() {
	    var _this;
	    _classCallCheck(this, DateContentRow);
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(args));
	    _this.handleSelectSlot = function (slot) {
	      var _this$props = _this.props,
	        range = _this$props.range,
	        onSelectSlot = _this$props.onSelectSlot;
	      onSelectSlot(range.slice(slot.start, slot.end + 1), slot);
	    };
	    _this.handleShowMore = function (slot, target) {
	      var _this$props2 = _this.props,
	        range = _this$props2.range,
	        onShowMore = _this$props2.onShowMore;
	      var metrics = _this.slotMetrics(_this.props);
	      var row = qsa(_this.containerRef.current, '.rbc-row-bg')[0];
	      var cell;
	      if (row) cell = row.children[slot - 1];
	      var events = metrics.getEventsForSlot(slot);
	      onShowMore(events, range[slot - 1], cell, slot, target);
	    };
	    _this.getContainer = function () {
	      var container = _this.props.container;
	      return container ? container() : _this.containerRef.current;
	    };
	    _this.renderHeadingCell = function (date, index) {
	      var _this$props3 = _this.props,
	        renderHeader = _this$props3.renderHeader,
	        getNow = _this$props3.getNow,
	        localizer = _this$props3.localizer;
	      return renderHeader({
	        date: date,
	        key: "header_".concat(index),
	        className: clsx('rbc-date-cell', localizer.isSameDate(date, getNow()) && 'rbc-now')
	      });
	    };
	    _this.renderDummy = function () {
	      var _this$props4 = _this.props,
	        className = _this$props4.className,
	        range = _this$props4.range,
	        renderHeader = _this$props4.renderHeader,
	        showAllEvents = _this$props4.showAllEvents;
	      return /*#__PURE__*/React$1.createElement("div", {
	        className: className,
	        ref: _this.containerRef
	      }, /*#__PURE__*/React$1.createElement("div", {
	        className: clsx('rbc-row-content', showAllEvents && 'rbc-row-content-scrollable')
	      }, renderHeader && /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-row",
	        ref: _this.headingRowRef
	      }, range.map(_this.renderHeadingCell)), /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-row",
	        ref: _this.eventRowRef
	      }, /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-row-segment"
	      }, /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-event"
	      }, /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-event-content"
	      }, "\xA0"))))));
	    };
	    _this.containerRef = /*#__PURE__*/React$1.createRef();
	    _this.headingRowRef = /*#__PURE__*/React$1.createRef();
	    _this.eventRowRef = /*#__PURE__*/React$1.createRef();
	    _this.slotMetrics = getSlotMetrics$1$1();
	    return _this;
	  }
	  _createClass$1(DateContentRow, [{
	    key: "getRowLimit",
	    value: function getRowLimit() {
	      var _this$headingRowRef;
	      /* Guessing this only gets called on the dummyRow */
	      var eventHeight = height(this.eventRowRef.current);
	      var headingHeight = (_this$headingRowRef = this.headingRowRef) !== null && _this$headingRowRef !== void 0 && _this$headingRowRef.current ? height(this.headingRowRef.current) : 0;
	      var eventSpace = height(this.containerRef.current) - headingHeight;
	      return Math.max(Math.floor(eventSpace / eventHeight), 1);
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this$props5 = this.props,
	        date = _this$props5.date,
	        rtl = _this$props5.rtl,
	        range = _this$props5.range,
	        className = _this$props5.className,
	        selected = _this$props5.selected,
	        selectable = _this$props5.selectable,
	        renderForMeasure = _this$props5.renderForMeasure,
	        accessors = _this$props5.accessors,
	        getters = _this$props5.getters,
	        components = _this$props5.components,
	        getNow = _this$props5.getNow,
	        renderHeader = _this$props5.renderHeader,
	        onSelect = _this$props5.onSelect,
	        localizer = _this$props5.localizer,
	        onSelectStart = _this$props5.onSelectStart,
	        onSelectEnd = _this$props5.onSelectEnd,
	        onDoubleClick = _this$props5.onDoubleClick,
	        onKeyPress = _this$props5.onKeyPress,
	        resourceId = _this$props5.resourceId,
	        longPressThreshold = _this$props5.longPressThreshold,
	        isAllDay = _this$props5.isAllDay,
	        resizable = _this$props5.resizable,
	        showAllEvents = _this$props5.showAllEvents;
	      if (renderForMeasure) return this.renderDummy();
	      var metrics = this.slotMetrics(this.props);
	      var levels = metrics.levels,
	        extra = metrics.extra;
	      var ScrollableWeekComponent = showAllEvents ? ScrollableWeekWrapper$2 : NoopWrapper$2;
	      var WeekWrapper = components.weekWrapper;
	      var eventRowProps = {
	        selected: selected,
	        accessors: accessors,
	        getters: getters,
	        localizer: localizer,
	        components: components,
	        onSelect: onSelect,
	        onDoubleClick: onDoubleClick,
	        onKeyPress: onKeyPress,
	        resourceId: resourceId,
	        slotMetrics: metrics,
	        resizable: resizable
	      };
	      return /*#__PURE__*/React$1.createElement("div", {
	        className: className,
	        role: "rowgroup",
	        ref: this.containerRef
	      }, /*#__PURE__*/React$1.createElement(BackgroundCells$2, {
	        localizer: localizer,
	        date: date,
	        getNow: getNow,
	        rtl: rtl,
	        range: range,
	        selectable: selectable,
	        container: this.getContainer,
	        getters: getters,
	        onSelectStart: onSelectStart,
	        onSelectEnd: onSelectEnd,
	        onSelectSlot: this.handleSelectSlot,
	        components: components,
	        longPressThreshold: longPressThreshold,
	        resourceId: resourceId
	      }), /*#__PURE__*/React$1.createElement("div", {
	        className: clsx('rbc-row-content', showAllEvents && 'rbc-row-content-scrollable'),
	        role: "row"
	      }, renderHeader && /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-row ",
	        ref: this.headingRowRef
	      }, range.map(this.renderHeadingCell)), /*#__PURE__*/React$1.createElement(ScrollableWeekComponent, null, /*#__PURE__*/React$1.createElement(WeekWrapper, Object.assign({
	        isAllDay: isAllDay
	      }, eventRowProps), levels.map(function (segs, idx) {
	        return /*#__PURE__*/React$1.createElement(EventRow$2, Object.assign({
	          key: idx,
	          segments: segs
	        }, eventRowProps));
	      }), !!extra.length && /*#__PURE__*/React$1.createElement(EventEndingRow$2, Object.assign({
	        segments: extra,
	        onShowMore: this.handleShowMore
	      }, eventRowProps))))));
	    }
	  }]);
	  return DateContentRow;
	}(React$1.Component);
	DateContentRow$2.defaultProps = {
	  minRows: 0,
	  maxRows: Infinity
	};

	var Header$2 = function Header(_ref) {
	  var label = _ref.label;
	  return /*#__PURE__*/React$1.createElement("span", {
	    role: "columnheader",
	    "aria-sort": "none"
	  }, label);
	};

	var DateHeader$2 = function DateHeader(_ref) {
	  var label = _ref.label,
	    drilldownView = _ref.drilldownView,
	    onDrillDown = _ref.onDrillDown;
	  if (!drilldownView) {
	    return /*#__PURE__*/React$1.createElement("span", null, label);
	  }
	  return /*#__PURE__*/React$1.createElement("button", {
	    type: "button",
	    className: "rbc-button-link",
	    onClick: onDrillDown,
	    role: "cell"
	  }, label);
	};

	var _excluded$6$1 = ["date", "className"];
	var eventsForWeek$1 = function eventsForWeek(evts, start, end, accessors, localizer) {
	  return evts.filter(function (e) {
	    return inRange$1(e, start, end, accessors, localizer);
	  });
	};
	var MonthView$1 = /*#__PURE__*/function (_React$Component) {
	  _inherits(MonthView, _React$Component);
	  var _super = _createSuper(MonthView);
	  function MonthView() {
	    var _this;
	    _classCallCheck(this, MonthView);
	    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
	      _args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(_args));
	    _this.getContainer = function () {
	      return _this.containerRef.current;
	    };
	    _this.renderWeek = function (week, weekIdx) {
	      var _this$props = _this.props,
	        events = _this$props.events,
	        components = _this$props.components,
	        selectable = _this$props.selectable,
	        getNow = _this$props.getNow,
	        selected = _this$props.selected,
	        date = _this$props.date,
	        localizer = _this$props.localizer,
	        longPressThreshold = _this$props.longPressThreshold,
	        accessors = _this$props.accessors,
	        getters = _this$props.getters,
	        showAllEvents = _this$props.showAllEvents;
	      var _this$state = _this.state,
	        needLimitMeasure = _this$state.needLimitMeasure,
	        rowLimit = _this$state.rowLimit;

	      // let's not mutate props
	      var weeksEvents = eventsForWeek$1(_toConsumableArray(events), week[0], week[week.length - 1], accessors, localizer);
	      weeksEvents.sort(function (a, b) {
	        return sortEvents$2(a, b, accessors, localizer);
	      });
	      return /*#__PURE__*/React$1.createElement(DateContentRow$2, {
	        key: weekIdx,
	        ref: weekIdx === 0 ? _this.slotRowRef : undefined,
	        container: _this.getContainer,
	        className: "rbc-month-row",
	        getNow: getNow,
	        date: date,
	        range: week,
	        events: weeksEvents,
	        maxRows: showAllEvents ? Infinity : rowLimit,
	        selected: selected,
	        selectable: selectable,
	        components: components,
	        accessors: accessors,
	        getters: getters,
	        localizer: localizer,
	        renderHeader: _this.readerDateHeading,
	        renderForMeasure: needLimitMeasure,
	        onShowMore: _this.handleShowMore,
	        onSelect: _this.handleSelectEvent,
	        onDoubleClick: _this.handleDoubleClickEvent,
	        onKeyPress: _this.handleKeyPressEvent,
	        onSelectSlot: _this.handleSelectSlot,
	        longPressThreshold: longPressThreshold,
	        rtl: _this.props.rtl,
	        resizable: _this.props.resizable,
	        showAllEvents: showAllEvents
	      });
	    };
	    _this.readerDateHeading = function (_ref) {
	      var date = _ref.date,
	        className = _ref.className,
	        props = _objectWithoutProperties(_ref, _excluded$6$1);
	      var _this$props2 = _this.props,
	        currentDate = _this$props2.date,
	        getDrilldownView = _this$props2.getDrilldownView,
	        localizer = _this$props2.localizer;
	      var isOffRange = localizer.neq(date, currentDate, 'month');
	      var isCurrent = localizer.isSameDate(date, currentDate);
	      var drilldownView = getDrilldownView(date);
	      var label = localizer.format(date, 'dateFormat');
	      var DateHeaderComponent = _this.props.components.dateHeader || DateHeader$2;
	      return /*#__PURE__*/React$1.createElement("div", Object.assign({}, props, {
	        className: clsx(className, isOffRange && 'rbc-off-range', isCurrent && 'rbc-current'),
	        role: "cell"
	      }), /*#__PURE__*/React$1.createElement(DateHeaderComponent, {
	        label: label,
	        date: date,
	        drilldownView: drilldownView,
	        isOffRange: isOffRange,
	        onDrillDown: function onDrillDown(e) {
	          return _this.handleHeadingClick(date, drilldownView, e);
	        }
	      }));
	    };
	    _this.handleSelectSlot = function (range, slotInfo) {
	      _this._pendingSelection = _this._pendingSelection.concat(range);
	      clearTimeout(_this._selectTimer);
	      _this._selectTimer = setTimeout(function () {
	        return _this.selectDates(slotInfo);
	      });
	    };
	    _this.handleHeadingClick = function (date, view, e) {
	      e.preventDefault();
	      _this.clearSelection();
	      notify$1(_this.props.onDrillDown, [date, view]);
	    };
	    _this.handleSelectEvent = function () {
	      _this.clearSelection();
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	      notify$1(_this.props.onSelectEvent, args);
	    };
	    _this.handleDoubleClickEvent = function () {
	      _this.clearSelection();
	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }
	      notify$1(_this.props.onDoubleClickEvent, args);
	    };
	    _this.handleKeyPressEvent = function () {
	      _this.clearSelection();
	      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	        args[_key4] = arguments[_key4];
	      }
	      notify$1(_this.props.onKeyPressEvent, args);
	    };
	    _this.handleShowMore = function (events, date, cell, slot, target) {
	      var _this$props3 = _this.props,
	        popup = _this$props3.popup,
	        onDrillDown = _this$props3.onDrillDown,
	        onShowMore = _this$props3.onShowMore,
	        getDrilldownView = _this$props3.getDrilldownView,
	        doShowMoreDrillDown = _this$props3.doShowMoreDrillDown;
	      //cancel any pending selections so only the event click goes through.
	      _this.clearSelection();
	      if (popup) {
	        var position = position$1(cell, _this.containerRef.current);
	        _this.setState({
	          overlay: {
	            date: date,
	            events: events,
	            position: position,
	            target: target
	          }
	        });
	      } else if (doShowMoreDrillDown) {
	        notify$1(onDrillDown, [date, getDrilldownView(date) || views$2.DAY]);
	      }
	      notify$1(onShowMore, [events, date, slot]);
	    };
	    _this.overlayDisplay = function () {
	      _this.setState({
	        overlay: null
	      });
	    };
	    _this.state = {
	      rowLimit: 5,
	      needLimitMeasure: true,
	      date: null
	    };
	    _this.containerRef = /*#__PURE__*/React$1.createRef();
	    _this.slotRowRef = /*#__PURE__*/React$1.createRef();
	    _this._bgRows = [];
	    _this._pendingSelection = [];
	    return _this;
	  }
	  _createClass$1(MonthView, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      var _this2 = this;
	      var running;
	      if (this.state.needLimitMeasure) this.measureRowLimit(this.props);
	      window.addEventListener('resize', this._resizeListener = function () {
	        if (!running) {
	          request(function () {
	            running = false;
	            _this2.setState({
	              needLimitMeasure: true
	            }); //eslint-disable-line
	          });
	        }
	      }, false);
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate() {
	      if (this.state.needLimitMeasure) this.measureRowLimit(this.props);
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      window.removeEventListener('resize', this._resizeListener, false);
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this$props4 = this.props,
	        date = _this$props4.date,
	        localizer = _this$props4.localizer,
	        className = _this$props4.className,
	        month = localizer.visibleDays(date, localizer),
	        weeks = chunk$1(month, 7);
	      this._weekCount = weeks.length;
	      return /*#__PURE__*/React$1.createElement("div", {
	        className: clsx('rbc-month-view', className),
	        role: "table",
	        "aria-label": "Month View",
	        ref: this.containerRef
	      }, /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-row rbc-month-header",
	        role: "row"
	      }, this.renderHeaders(weeks[0])), weeks.map(this.renderWeek), this.props.popup && this.renderOverlay());
	    }
	  }, {
	    key: "renderHeaders",
	    value: function renderHeaders(row) {
	      var _this$props5 = this.props,
	        localizer = _this$props5.localizer,
	        components = _this$props5.components;
	      var first = row[0];
	      var last = row[row.length - 1];
	      var HeaderComponent = components.header || Header$2;
	      return localizer.range(first, last, 'day').map(function (day, idx) {
	        return /*#__PURE__*/React$1.createElement("div", {
	          key: 'header_' + idx,
	          className: "rbc-header"
	        }, /*#__PURE__*/React$1.createElement(HeaderComponent, {
	          date: day,
	          localizer: localizer,
	          label: localizer.format(day, 'weekdayFormat')
	        }));
	      });
	    }
	  }, {
	    key: "renderOverlay",
	    value: function renderOverlay() {
	      var _this$state$overlay,
	        _this$state2,
	        _this3 = this;
	      var overlay = (_this$state$overlay = (_this$state2 = this.state) === null || _this$state2 === void 0 ? void 0 : _this$state2.overlay) !== null && _this$state$overlay !== void 0 ? _this$state$overlay : {};
	      var _this$props6 = this.props,
	        accessors = _this$props6.accessors,
	        localizer = _this$props6.localizer,
	        components = _this$props6.components,
	        getters = _this$props6.getters,
	        selected = _this$props6.selected,
	        popupOffset = _this$props6.popupOffset,
	        handleDragStart = _this$props6.handleDragStart;
	      var onHide = function onHide() {
	        return _this3.setState({
	          overlay: null
	        });
	      };
	      return /*#__PURE__*/React$1.createElement(PopOverlay$2, {
	        overlay: overlay,
	        accessors: accessors,
	        localizer: localizer,
	        components: components,
	        getters: getters,
	        selected: selected,
	        popupOffset: popupOffset,
	        ref: this.containerRef,
	        handleKeyPressEvent: this.handleKeyPressEvent,
	        handleSelectEvent: this.handleSelectEvent,
	        handleDoubleClickEvent: this.handleDoubleClickEvent,
	        handleDragStart: handleDragStart,
	        show: !!overlay.position,
	        overlayDisplay: this.overlayDisplay,
	        onHide: onHide
	      });

	      /* return (
	        <Overlay
	          rootClose
	          placement="bottom"
	          show={!!overlay.position}
	          onHide={() => this.setState({ overlay: null })}
	          target={() => overlay.target}
	        >
	          {({ props }) => (
	            <Popup
	              {...props}
	              popupOffset={popupOffset}
	              accessors={accessors}
	              getters={getters}
	              selected={selected}
	              components={components}
	              localizer={localizer}
	              position={overlay.position}
	              show={this.overlayDisplay}
	              events={overlay.events}
	              slotStart={overlay.date}
	              slotEnd={overlay.end}
	              onSelect={this.handleSelectEvent}
	              onDoubleClick={this.handleDoubleClickEvent}
	              onKeyPress={this.handleKeyPressEvent}
	              handleDragStart={this.props.handleDragStart}
	            />
	          )}
	        </Overlay>
	      ) */
	    }
	  }, {
	    key: "measureRowLimit",
	    value: function measureRowLimit() {
	      this.setState({
	        needLimitMeasure: false,
	        rowLimit: this.slotRowRef.current.getRowLimit()
	      });
	    }
	  }, {
	    key: "selectDates",
	    value: function selectDates(slotInfo) {
	      var slots = this._pendingSelection.slice();
	      this._pendingSelection = [];
	      slots.sort(function (a, b) {
	        return +a - +b;
	      });
	      var start = new Date(slots[0]);
	      var end = new Date(slots[slots.length - 1]);
	      end.setDate(slots[slots.length - 1].getDate() + 1);
	      notify$1(this.props.onSelectSlot, {
	        slots: slots,
	        start: start,
	        end: end,
	        action: slotInfo.action,
	        bounds: slotInfo.bounds,
	        box: slotInfo.box
	      });
	    }
	  }, {
	    key: "clearSelection",
	    value: function clearSelection() {
	      clearTimeout(this._selectTimer);
	      this._pendingSelection = [];
	    }
	  }], [{
	    key: "getDerivedStateFromProps",
	    value: function getDerivedStateFromProps(_ref2, state) {
	      var date = _ref2.date,
	        localizer = _ref2.localizer;
	      return {
	        date: date,
	        needLimitMeasure: localizer.neq(date, state.date, 'month')
	      };
	    }
	  }]);
	  return MonthView;
	}(React$1.Component);
	MonthView$1.range = function (date, _ref3) {
	  var localizer = _ref3.localizer;
	  var start = localizer.firstVisibleDay(date, localizer);
	  var end = localizer.lastVisibleDay(date, localizer);
	  return {
	    start: start,
	    end: end
	  };
	};
	MonthView$1.navigate = function (date, action, _ref4) {
	  var localizer = _ref4.localizer;
	  switch (action) {
	    case navigate$1.PREVIOUS:
	      return localizer.add(date, -1, 'month');
	    case navigate$1.NEXT:
	      return localizer.add(date, 1, 'month');
	    default:
	      return date;
	  }
	};
	MonthView$1.title = function (date, _ref5) {
	  var localizer = _ref5.localizer;
	  return localizer.format(date, 'monthHeaderFormat');
	};

	var getKey$1 = function getKey(_ref) {
	  var min = _ref.min,
	    max = _ref.max,
	    step = _ref.step,
	    slots = _ref.slots,
	    localizer = _ref.localizer;
	  return "".concat(+localizer.startOf(min, 'minutes')) + "".concat(+localizer.startOf(max, 'minutes')) + "".concat(step, "-").concat(slots);
	};
	function getSlotMetrics$2(_ref2) {
	  var start = _ref2.min,
	    end = _ref2.max,
	    step = _ref2.step,
	    timeslots = _ref2.timeslots,
	    localizer = _ref2.localizer;
	  var key = getKey$1({
	    start: start,
	    end: end,
	    step: step,
	    timeslots: timeslots,
	    localizer: localizer
	  });

	  // DST differences are handled inside the localizer
	  var totalMin = 1 + localizer.getTotalMin(start, end);
	  var minutesFromMidnight = localizer.getMinutesFromMidnight(start);
	  var numGroups = Math.ceil((totalMin - 1) / (step * timeslots));
	  var numSlots = numGroups * timeslots;
	  var groups = new Array(numGroups);
	  var slots = new Array(numSlots);
	  // Each slot date is created from "zero", instead of adding `step` to
	  // the previous one, in order to avoid DST oddities
	  for (var grp = 0; grp < numGroups; grp++) {
	    groups[grp] = new Array(timeslots);
	    for (var slot = 0; slot < timeslots; slot++) {
	      var slotIdx = grp * timeslots + slot;
	      var minFromStart = slotIdx * step;
	      // A date with total minutes calculated from the start of the day
	      slots[slotIdx] = groups[grp][slot] = localizer.getSlotDate(start, minutesFromMidnight, minFromStart);
	    }
	  }

	  // Necessary to be able to select up until the last timeslot in a day
	  var lastSlotMinFromStart = slots.length * step;
	  slots.push(localizer.getSlotDate(start, minutesFromMidnight, lastSlotMinFromStart));
	  function positionFromDate(date) {
	    var diff = localizer.diff(start, date, 'minutes') + localizer.getDstOffset(start, date);
	    return Math.min(diff, totalMin);
	  }
	  return {
	    groups: groups,
	    update: function update(args) {
	      if (getKey$1(args) !== key) return getSlotMetrics$2(args);
	      return this;
	    },
	    dateIsInGroup: function dateIsInGroup(date, groupIndex) {
	      var nextGroup = groups[groupIndex + 1];
	      return localizer.inRange(date, groups[groupIndex][0], nextGroup ? nextGroup[0] : end, 'minutes');
	    },
	    nextSlot: function nextSlot(slot) {
	      var next = slots[Math.min(slots.indexOf(slot) + 1, slots.length - 1)];
	      // in the case of the last slot we won't a long enough range so manually get it
	      if (next === slot) next = localizer.add(slot, step, 'minutes');
	      return next;
	    },
	    closestSlotToPosition: function closestSlotToPosition(percent) {
	      var slot = Math.min(slots.length - 1, Math.max(0, Math.floor(percent * numSlots)));
	      return slots[slot];
	    },
	    closestSlotFromPoint: function closestSlotFromPoint(point, boundaryRect) {
	      var range = Math.abs(boundaryRect.top - boundaryRect.bottom);
	      return this.closestSlotToPosition((point.y - boundaryRect.top) / range);
	    },
	    closestSlotFromDate: function closestSlotFromDate(date) {
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      if (localizer.lt(date, start, 'minutes')) return slots[0];
	      if (localizer.gt(date, end, 'minutes')) return slots[slots.length - 1];
	      var diffMins = localizer.diff(start, date, 'minutes');
	      return slots[(diffMins - diffMins % step) / step + offset];
	    },
	    startsBeforeDay: function startsBeforeDay(date) {
	      return localizer.lt(date, start, 'day');
	    },
	    startsAfterDay: function startsAfterDay(date) {
	      return localizer.gt(date, end, 'day');
	    },
	    startsBefore: function startsBefore(date) {
	      return localizer.lt(localizer.merge(start, date), start, 'minutes');
	    },
	    startsAfter: function startsAfter(date) {
	      return localizer.gt(localizer.merge(end, date), end, 'minutes');
	    },
	    getRange: function getRange(rangeStart, rangeEnd, ignoreMin, ignoreMax) {
	      if (!ignoreMin) rangeStart = localizer.min(end, localizer.max(start, rangeStart));
	      if (!ignoreMax) rangeEnd = localizer.min(end, localizer.max(start, rangeEnd));
	      var rangeStartMin = positionFromDate(rangeStart);
	      var rangeEndMin = positionFromDate(rangeEnd);
	      var top = rangeEndMin > step * numSlots && !localizer.eq(end, rangeEnd) ? (rangeStartMin - step) / (step * numSlots) * 100 : rangeStartMin / (step * numSlots) * 100;
	      return {
	        top: top,
	        height: rangeEndMin / (step * numSlots) * 100 - top,
	        start: positionFromDate(rangeStart),
	        startDate: rangeStart,
	        end: positionFromDate(rangeEnd),
	        endDate: rangeEnd
	      };
	    },
	    getCurrentTimePosition: function getCurrentTimePosition(rangeStart) {
	      var rangeStartMin = positionFromDate(rangeStart);
	      var top = rangeStartMin / (step * numSlots) * 100;
	      return top;
	    }
	  };
	}

	var Event$1 = /*#__PURE__*/function () {
	  function Event(data, _ref) {
	    var accessors = _ref.accessors,
	      slotMetrics = _ref.slotMetrics;
	    _classCallCheck(this, Event);
	    var _slotMetrics$getRange = slotMetrics.getRange(accessors.start(data), accessors.end(data)),
	      start = _slotMetrics$getRange.start,
	      startDate = _slotMetrics$getRange.startDate,
	      end = _slotMetrics$getRange.end,
	      endDate = _slotMetrics$getRange.endDate,
	      top = _slotMetrics$getRange.top,
	      height = _slotMetrics$getRange.height;
	    this.start = start;
	    this.end = end;
	    this.startMs = +startDate;
	    this.endMs = +endDate;
	    this.top = top;
	    this.height = height;
	    this.data = data;
	  }

	  /**
	   * The event's width without any overlap.
	   */
	  _createClass$1(Event, [{
	    key: "_width",
	    get: function get() {
	      // The container event's width is determined by the maximum number of
	      // events in any of its rows.
	      if (this.rows) {
	        var columns = this.rows.reduce(function (max, row) {
	          return Math.max(max, row.leaves.length + 1);
	        },
	        // add itself
	        0) + 1; // add the container

	        return 100 / columns;
	      }

	      // The row event's width is the space left by the container, divided
	      // among itself and its leaves.
	      if (this.leaves) {
	        var availableWidth = 100 - this.container._width;
	        return availableWidth / (this.leaves.length + 1);
	      }

	      // The leaf event's width is determined by its row's width
	      return this.row._width;
	    }

	    /**
	     * The event's calculated width, possibly with extra width added for
	     * overlapping effect.
	     */
	  }, {
	    key: "width",
	    get: function get() {
	      var noOverlap = this._width;
	      var overlap = Math.min(100, this._width * 1.7);

	      // Containers can always grow.
	      if (this.rows) {
	        return overlap;
	      }

	      // Rows can grow if they have leaves.
	      if (this.leaves) {
	        return this.leaves.length > 0 ? overlap : noOverlap;
	      }

	      // Leaves can grow unless they're the last item in a row.
	      var leaves = this.row.leaves;
	      var index = leaves.indexOf(this);
	      return index === leaves.length - 1 ? noOverlap : overlap;
	    }
	  }, {
	    key: "xOffset",
	    get: function get() {
	      // Containers have no offset.
	      if (this.rows) return 0;

	      // Rows always start where their container ends.
	      if (this.leaves) return this.container._width;

	      // Leaves are spread out evenly on the space left by its row.
	      var _this$row = this.row,
	        leaves = _this$row.leaves,
	        xOffset = _this$row.xOffset,
	        _width = _this$row._width;
	      var index = leaves.indexOf(this) + 1;
	      return xOffset + index * _width;
	    }
	  }]);
	  return Event;
	}();
	/**
	 * Return true if event a and b is considered to be on the same row.
	 */
	function onSameRow$1(a, b, minimumStartDifference) {
	  return (
	    // Occupies the same start slot.
	    Math.abs(b.start - a.start) < minimumStartDifference ||
	    // A's start slot overlaps with b's end slot.
	    b.start > a.start && b.start < a.end
	  );
	}
	function sortByRender$1(events) {
	  var sortedByTime = sortBy$2(events, ['startMs', function (e) {
	    return -e.endMs;
	  }]);
	  var sorted = [];
	  while (sortedByTime.length > 0) {
	    var event = sortedByTime.shift();
	    sorted.push(event);
	    for (var i = 0; i < sortedByTime.length; i++) {
	      var test = sortedByTime[i];

	      // Still inside this event, look for next.
	      if (event.endMs > test.startMs) continue;

	      // We've found the first event of the next event group.
	      // If that event is not right next to our current event, we have to
	      // move it here.
	      if (i > 0) {
	        var _event = sortedByTime.splice(i, 1)[0];
	        sorted.push(_event);
	      }

	      // We've already found the next event group, so stop looking.
	      break;
	    }
	  }
	  return sorted;
	}
	function getStyledEvents$1$1(_ref2) {
	  var events = _ref2.events,
	    minimumStartDifference = _ref2.minimumStartDifference,
	    slotMetrics = _ref2.slotMetrics,
	    accessors = _ref2.accessors;
	  // Create proxy events and order them so that we don't have
	  // to fiddle with z-indexes.
	  var proxies = events.map(function (event) {
	    return new Event$1(event, {
	      slotMetrics: slotMetrics,
	      accessors: accessors
	    });
	  });
	  var eventsInRenderOrder = sortByRender$1(proxies);

	  // Group overlapping events, while keeping order.
	  // Every event is always one of: container, row or leaf.
	  // Containers can contain rows, and rows can contain leaves.
	  var containerEvents = [];
	  var _loop = function _loop() {
	    var event = eventsInRenderOrder[i];

	    // Check if this event can go into a container event.
	    var container = containerEvents.find(function (c) {
	      return c.end > event.start || Math.abs(event.start - c.start) < minimumStartDifference;
	    });

	    // Couldn't find a container  that means this event is a container.
	    if (!container) {
	      event.rows = [];
	      containerEvents.push(event);
	      return "continue";
	    }

	    // Found a container for the event.
	    event.container = container;

	    // Check if the event can be placed in an existing row.
	    // Start looking from behind.
	    var row = null;
	    for (var j = container.rows.length - 1; !row && j >= 0; j--) {
	      if (onSameRow$1(container.rows[j], event, minimumStartDifference)) {
	        row = container.rows[j];
	      }
	    }
	    if (row) {
	      // Found a row, so add it.
	      row.leaves.push(event);
	      event.row = row;
	    } else {
	      // Couldn't find a row  that means this event is a row.
	      event.leaves = [];
	      container.rows.push(event);
	    }
	  };
	  for (var i = 0; i < eventsInRenderOrder.length; i++) {
	    var _ret = _loop();
	    if (_ret === "continue") continue;
	  }

	  // Return the original events, along with their styles.
	  return eventsInRenderOrder.map(function (event) {
	    return {
	      event: event.data,
	      style: {
	        top: event.top,
	        height: event.height,
	        width: event.width,
	        xOffset: Math.max(0, event.xOffset)
	      }
	    };
	  });
	}

	function getMaxIdxDFS$1(node, maxIdx, visited) {
	  for (var i = 0; i < node.friends.length; ++i) {
	    if (visited.indexOf(node.friends[i]) > -1) continue;
	    maxIdx = maxIdx > node.friends[i].idx ? maxIdx : node.friends[i].idx;
	    // TODO : trace it by not object but kinda index or something for performance
	    visited.push(node.friends[i]);
	    var newIdx = getMaxIdxDFS$1(node.friends[i], maxIdx, visited);
	    maxIdx = maxIdx > newIdx ? maxIdx : newIdx;
	  }
	  return maxIdx;
	}
	function noOverlap$1 (_ref) {
	  var events = _ref.events,
	    minimumStartDifference = _ref.minimumStartDifference,
	    slotMetrics = _ref.slotMetrics,
	    accessors = _ref.accessors;
	  var styledEvents = getStyledEvents$1$1({
	    events: events,
	    minimumStartDifference: minimumStartDifference,
	    slotMetrics: slotMetrics,
	    accessors: accessors
	  });
	  styledEvents.sort(function (a, b) {
	    a = a.style;
	    b = b.style;
	    if (a.top !== b.top) return a.top > b.top ? 1 : -1;else return a.top + a.height < b.top + b.height ? 1 : -1;
	  });
	  for (var i = 0; i < styledEvents.length; ++i) {
	    styledEvents[i].friends = [];
	    delete styledEvents[i].style.left;
	    delete styledEvents[i].style.left;
	    delete styledEvents[i].idx;
	    delete styledEvents[i].size;
	  }
	  for (var _i2 = 0; _i2 < styledEvents.length - 1; ++_i2) {
	    var se1 = styledEvents[_i2];
	    var y1 = se1.style.top;
	    var y2 = se1.style.top + se1.style.height;
	    for (var j = _i2 + 1; j < styledEvents.length; ++j) {
	      var se2 = styledEvents[j];
	      var y3 = se2.style.top;
	      var y4 = se2.style.top + se2.style.height;
	      if (y3 >= y1 && y4 <= y2 || y4 > y1 && y4 <= y2 || y3 >= y1 && y3 < y2) {
	        // TODO : hashmap would be effective for performance
	        se1.friends.push(se2);
	        se2.friends.push(se1);
	      }
	    }
	  }
	  for (var _i4 = 0; _i4 < styledEvents.length; ++_i4) {
	    var se = styledEvents[_i4];
	    var bitmap = [];
	    for (var _j2 = 0; _j2 < 100; ++_j2) bitmap.push(1); // 1 means available

	    for (var _j4 = 0; _j4 < se.friends.length; ++_j4) if (se.friends[_j4].idx !== undefined) bitmap[se.friends[_j4].idx] = 0; // 0 means reserved

	    se.idx = bitmap.indexOf(1);
	  }
	  for (var _i6 = 0; _i6 < styledEvents.length; ++_i6) {
	    var size = 0;
	    if (styledEvents[_i6].size) continue;
	    var allFriends = [];
	    var maxIdx = getMaxIdxDFS$1(styledEvents[_i6], 0, allFriends);
	    size = 100 / (maxIdx + 1);
	    styledEvents[_i6].size = size;
	    for (var _j6 = 0; _j6 < allFriends.length; ++_j6) allFriends[_j6].size = size;
	  }
	  for (var _i8 = 0; _i8 < styledEvents.length; ++_i8) {
	    var e = styledEvents[_i8];
	    e.style.left = e.idx * e.size;

	    // stretch to maximum
	    var _maxIdx = 0;
	    for (var _j8 = 0; _j8 < e.friends.length; ++_j8) {
	      var idx = e.friends[_j8].idx;
	      _maxIdx = _maxIdx > idx ? _maxIdx : idx;
	    }
	    if (_maxIdx <= e.idx) e.size = 100 - e.idx * e.size;

	    // padding between events
	    // for this feature, `width` is not percentage based unit anymore
	    // it will be used with calc()
	    var padding = e.idx === 0 ? 0 : 3;
	    e.style.width = "calc(".concat(e.size, "% - ").concat(padding, "px)");
	    e.style.height = "calc(".concat(e.style.height, "% - 2px)");
	    e.style.xOffset = "calc(".concat(e.style.left, "% + ").concat(padding, "px)");
	  }
	  return styledEvents;
	}

	/*eslint no-unused-vars: "off"*/
	var DefaultAlgorithms$1 = {
	  overlap: getStyledEvents$1$1,
	  'no-overlap': noOverlap$1
	};
	function isFunction$5(a) {
	  return !!(a && a.constructor && a.call && a.apply);
	}

	//
	function getStyledEvents$2(_ref) {
	  _ref.events;
	    _ref.minimumStartDifference;
	    _ref.slotMetrics;
	    _ref.accessors;
	    var dayLayoutAlgorithm = _ref.dayLayoutAlgorithm;
	  var algorithm = dayLayoutAlgorithm;
	  if (dayLayoutAlgorithm in DefaultAlgorithms$1) algorithm = DefaultAlgorithms$1[dayLayoutAlgorithm];
	  if (!isFunction$5(algorithm)) {
	    // invalid algorithm
	    return [];
	  }
	  return algorithm.apply(this, arguments);
	}

	var TimeSlotGroup$2 = /*#__PURE__*/function (_Component) {
	  _inherits(TimeSlotGroup, _Component);
	  var _super = _createSuper(TimeSlotGroup);
	  function TimeSlotGroup() {
	    _classCallCheck(this, TimeSlotGroup);
	    return _super.apply(this, arguments);
	  }
	  _createClass$1(TimeSlotGroup, [{
	    key: "render",
	    value: function render() {
	      var _this$props = this.props,
	        renderSlot = _this$props.renderSlot,
	        resource = _this$props.resource,
	        group = _this$props.group,
	        getters = _this$props.getters,
	        _this$props$component = _this$props.components,
	        _this$props$component2 = _this$props$component === void 0 ? {} : _this$props$component,
	        _this$props$component3 = _this$props$component2.timeSlotWrapper,
	        Wrapper = _this$props$component3 === void 0 ? NoopWrapper$2 : _this$props$component3;
	      var groupProps = getters ? getters.slotGroupProp(group) : {};
	      return /*#__PURE__*/React$1.createElement("div", Object.assign({
	        className: "rbc-timeslot-group"
	      }, groupProps), group.map(function (value, idx) {
	        var slotProps = getters ? getters.slotProp(value, resource) : {};
	        return /*#__PURE__*/React$1.createElement(Wrapper, {
	          key: idx,
	          value: value,
	          resource: resource
	        }, /*#__PURE__*/React$1.createElement("div", Object.assign({}, slotProps, {
	          className: clsx('rbc-time-slot', slotProps.className)
	        }), renderSlot && renderSlot(value, idx)));
	      }));
	    }
	  }]);
	  return TimeSlotGroup;
	}(React$1.Component);

	function stringifyPercent$1(v) {
	  return typeof v === 'string' ? v : v + '%';
	}

	/* eslint-disable react/prop-types */
	function TimeGridEvent$2(props) {
	  var style = props.style,
	    className = props.className,
	    event = props.event,
	    accessors = props.accessors,
	    rtl = props.rtl,
	    selected = props.selected,
	    label = props.label,
	    continuesPrior = props.continuesPrior,
	    continuesAfter = props.continuesAfter,
	    getters = props.getters,
	    onClick = props.onClick,
	    onDoubleClick = props.onDoubleClick,
	    isBackgroundEvent = props.isBackgroundEvent,
	    onKeyPress = props.onKeyPress,
	    _props$components = props.components,
	    Event = _props$components.event,
	    EventWrapper = _props$components.eventWrapper;
	  var title = accessors.title(event);
	  var tooltip = accessors.tooltip(event);
	  var end = accessors.end(event);
	  var start = accessors.start(event);
	  var userProps = getters.eventProp(event, start, end, selected);
	  var height = style.height,
	    top = style.top,
	    width = style.width,
	    xOffset = style.xOffset;
	  var inner = [/*#__PURE__*/React$1.createElement("div", {
	    key: "1",
	    className: "rbc-event-label"
	  }, label), /*#__PURE__*/React$1.createElement("div", {
	    key: "2",
	    className: "rbc-event-content"
	  }, Event ? /*#__PURE__*/React$1.createElement(Event, {
	    event: event,
	    title: title
	  }) : title)];
	  var eventStyle = isBackgroundEvent ? _objectSpread2$8(_objectSpread2$8({}, userProps.style), {}, _defineProperty$2({
	    top: stringifyPercent$1(top),
	    height: stringifyPercent$1(height),
	    // Adding 10px to take events container right margin into account
	    width: "calc(".concat(width, " + 10px)")
	  }, rtl ? 'right' : 'left', stringifyPercent$1(Math.max(0, xOffset)))) : _objectSpread2$8(_objectSpread2$8({}, userProps.style), {}, _defineProperty$2({
	    top: stringifyPercent$1(top),
	    width: stringifyPercent$1(width),
	    height: stringifyPercent$1(height)
	  }, rtl ? 'right' : 'left', stringifyPercent$1(xOffset)));
	  return /*#__PURE__*/React$1.createElement(EventWrapper, Object.assign({
	    type: "time"
	  }, props), /*#__PURE__*/React$1.createElement("div", {
	    onClick: onClick,
	    onDoubleClick: onDoubleClick,
	    style: eventStyle,
	    onKeyPress: onKeyPress,
	    title: tooltip ? (typeof label === 'string' ? label + ': ' : '') + tooltip : undefined,
	    className: clsx(isBackgroundEvent ? 'rbc-background-event' : 'rbc-event', className, userProps.className, {
	      'rbc-selected': selected,
	      'rbc-event-continues-earlier': continuesPrior,
	      'rbc-event-continues-later': continuesAfter
	    })
	  }, inner));
	}

	var DayColumnWrapper$2 = function DayColumnWrapper(_ref) {
	  var children = _ref.children,
	    className = _ref.className,
	    style = _ref.style,
	    innerRef = _ref.innerRef;
	  return /*#__PURE__*/React$1.createElement("div", {
	    className: className,
	    style: style,
	    ref: innerRef
	  }, children);
	};
	var DayColumnWrapper$1$1 = /*#__PURE__*/React$1.forwardRef(function (props, ref) {
	  return /*#__PURE__*/React$1.createElement(DayColumnWrapper$2, Object.assign({}, props, {
	    innerRef: ref
	  }));
	});

	var _excluded$5$1 = ["dayProp"],
	  _excluded2$1 = ["eventContainerWrapper"];
	var DayColumn$2 = /*#__PURE__*/function (_React$Component) {
	  _inherits(DayColumn, _React$Component);
	  var _super = _createSuper(DayColumn);
	  function DayColumn() {
	    var _this;
	    _classCallCheck(this, DayColumn);
	    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
	      _args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(_args));
	    _this.state = {
	      selecting: false,
	      timeIndicatorPosition: null
	    };
	    _this.intervalTriggered = false;
	    _this.renderEvents = function (_ref) {
	      var events = _ref.events,
	        isBackgroundEvent = _ref.isBackgroundEvent;
	      var _this$props = _this.props,
	        rtl = _this$props.rtl,
	        selected = _this$props.selected,
	        accessors = _this$props.accessors,
	        localizer = _this$props.localizer,
	        getters = _this$props.getters,
	        components = _this$props.components,
	        step = _this$props.step,
	        timeslots = _this$props.timeslots,
	        dayLayoutAlgorithm = _this$props.dayLayoutAlgorithm,
	        resizable = _this$props.resizable;
	      var _assertThisInitialize = _assertThisInitialized$1(_this),
	        slotMetrics = _assertThisInitialize.slotMetrics;
	      var messages = localizer.messages;
	      var styledEvents = getStyledEvents$2({
	        events: events,
	        accessors: accessors,
	        slotMetrics: slotMetrics,
	        minimumStartDifference: Math.ceil(step * timeslots / 2),
	        dayLayoutAlgorithm: dayLayoutAlgorithm
	      });
	      return styledEvents.map(function (_ref2, idx) {
	        var event = _ref2.event,
	          style = _ref2.style;
	        var end = accessors.end(event);
	        var start = accessors.start(event);
	        var format = 'eventTimeRangeFormat';
	        var label;
	        var startsBeforeDay = slotMetrics.startsBeforeDay(start);
	        var startsAfterDay = slotMetrics.startsAfterDay(end);
	        if (startsBeforeDay) format = 'eventTimeRangeEndFormat';else if (startsAfterDay) format = 'eventTimeRangeStartFormat';
	        if (startsBeforeDay && startsAfterDay) label = messages.allDay;else label = localizer.format({
	          start: start,
	          end: end
	        }, format);
	        var continuesPrior = startsBeforeDay || slotMetrics.startsBefore(start);
	        var continuesAfter = startsAfterDay || slotMetrics.startsAfter(end);
	        return /*#__PURE__*/React$1.createElement(TimeGridEvent$2, {
	          style: style,
	          event: event,
	          label: label,
	          key: 'evt_' + idx,
	          getters: getters,
	          rtl: rtl,
	          components: components,
	          continuesPrior: continuesPrior,
	          continuesAfter: continuesAfter,
	          accessors: accessors,
	          resource: _this.props.resource,
	          selected: isSelected$1(event, selected),
	          onClick: function onClick(e) {
	            return _this._select(_objectSpread2$8(_objectSpread2$8({}, event), {}, {
	              sourceResource: _this.props.resource
	            }), e);
	          },
	          onDoubleClick: function onDoubleClick(e) {
	            return _this._doubleClick(event, e);
	          },
	          isBackgroundEvent: isBackgroundEvent,
	          onKeyPress: function onKeyPress(e) {
	            return _this._keyPress(event, e);
	          },
	          resizable: resizable
	        });
	      });
	    };
	    _this._selectable = function () {
	      var node = _this.containerRef.current;
	      var _this$props2 = _this.props,
	        longPressThreshold = _this$props2.longPressThreshold,
	        localizer = _this$props2.localizer;
	      var selector = _this._selector = new Selection$2(function () {
	        return node;
	      }, {
	        longPressThreshold: longPressThreshold
	      });
	      var maybeSelect = function maybeSelect(box) {
	        var onSelecting = _this.props.onSelecting;
	        var current = _this.state || {};
	        var state = selectionState(box);
	        var start = state.startDate,
	          end = state.endDate;
	        if (onSelecting) {
	          if (localizer.eq(current.startDate, start, 'minutes') && localizer.eq(current.endDate, end, 'minutes') || onSelecting({
	            start: start,
	            end: end,
	            resourceId: _this.props.resource
	          }) === false) return;
	        }
	        if (_this.state.start !== state.start || _this.state.end !== state.end || _this.state.selecting !== state.selecting) {
	          _this.setState(state);
	        }
	      };
	      var selectionState = function selectionState(point) {
	        var currentSlot = _this.slotMetrics.closestSlotFromPoint(point, getBoundsForNode$1(node));
	        if (!_this.state.selecting) {
	          _this._initialSlot = currentSlot;
	        }
	        var initialSlot = _this._initialSlot;
	        if (localizer.lte(initialSlot, currentSlot)) {
	          currentSlot = _this.slotMetrics.nextSlot(currentSlot);
	        } else if (localizer.gt(initialSlot, currentSlot)) {
	          initialSlot = _this.slotMetrics.nextSlot(initialSlot);
	        }
	        var selectRange = _this.slotMetrics.getRange(localizer.min(initialSlot, currentSlot), localizer.max(initialSlot, currentSlot));
	        return _objectSpread2$8(_objectSpread2$8({}, selectRange), {}, {
	          selecting: true,
	          top: "".concat(selectRange.top, "%"),
	          height: "".concat(selectRange.height, "%")
	        });
	      };
	      var selectorClicksHandler = function selectorClicksHandler(box, actionType) {
	        if (!isEvent$1(_this.containerRef.current, box)) {
	          var _selectionState = selectionState(box),
	            startDate = _selectionState.startDate,
	            endDate = _selectionState.endDate;
	          _this._selectSlot({
	            startDate: startDate,
	            endDate: endDate,
	            action: actionType,
	            box: box
	          });
	        }
	        _this.setState({
	          selecting: false
	        });
	      };
	      selector.on('selecting', maybeSelect);
	      selector.on('selectStart', maybeSelect);
	      selector.on('beforeSelect', function (box) {
	        if (_this.props.selectable !== 'ignoreEvents') return;
	        return !isEvent$1(_this.containerRef.current, box);
	      });
	      selector.on('click', function (box) {
	        return selectorClicksHandler(box, 'click');
	      });
	      selector.on('doubleClick', function (box) {
	        return selectorClicksHandler(box, 'doubleClick');
	      });
	      selector.on('select', function (bounds) {
	        if (_this.state.selecting) {
	          _this._selectSlot(_objectSpread2$8(_objectSpread2$8({}, _this.state), {}, {
	            action: 'select',
	            bounds: bounds
	          }));
	          _this.setState({
	            selecting: false
	          });
	        }
	      });
	      selector.on('reset', function () {
	        if (_this.state.selecting) {
	          _this.setState({
	            selecting: false
	          });
	        }
	      });
	    };
	    _this._teardownSelectable = function () {
	      if (!_this._selector) return;
	      _this._selector.teardown();
	      _this._selector = null;
	    };
	    _this._selectSlot = function (_ref3) {
	      var startDate = _ref3.startDate,
	        endDate = _ref3.endDate,
	        action = _ref3.action,
	        bounds = _ref3.bounds,
	        box = _ref3.box;
	      var current = startDate,
	        slots = [];
	      while (_this.props.localizer.lte(current, endDate)) {
	        slots.push(current);
	        current = new Date(+current + _this.props.step * 60 * 1000); // using Date ensures not to create an endless loop the day DST begins
	      }

	      notify$1(_this.props.onSelectSlot, {
	        slots: slots,
	        start: startDate,
	        end: endDate,
	        resourceId: _this.props.resource,
	        action: action,
	        bounds: bounds,
	        box: box
	      });
	    };
	    _this._select = function () {
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	      notify$1(_this.props.onSelectEvent, args);
	    };
	    _this._doubleClick = function () {
	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }
	      notify$1(_this.props.onDoubleClickEvent, args);
	    };
	    _this._keyPress = function () {
	      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	        args[_key4] = arguments[_key4];
	      }
	      notify$1(_this.props.onKeyPressEvent, args);
	    };
	    _this.slotMetrics = getSlotMetrics$2(_this.props);
	    _this.containerRef = /*#__PURE__*/React$1.createRef();
	    return _this;
	  }
	  _createClass$1(DayColumn, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      this.props.selectable && this._selectable();
	      if (this.props.isNow) {
	        this.setTimeIndicatorPositionUpdateInterval();
	      }
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      this._teardownSelectable();
	      this.clearTimeIndicatorInterval();
	    }
	  }, {
	    key: "UNSAFE_componentWillReceiveProps",
	    value: function UNSAFE_componentWillReceiveProps(nextProps) {
	      if (nextProps.selectable && !this.props.selectable) this._selectable();
	      if (!nextProps.selectable && this.props.selectable) this._teardownSelectable();
	      this.slotMetrics = this.slotMetrics.update(nextProps);
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate(prevProps, prevState) {
	      var _this$props3 = this.props,
	        getNow = _this$props3.getNow,
	        isNow = _this$props3.isNow,
	        localizer = _this$props3.localizer,
	        date = _this$props3.date,
	        min = _this$props3.min,
	        max = _this$props3.max;
	      var getNowChanged = localizer.neq(prevProps.getNow(), getNow(), 'minutes');
	      if (prevProps.isNow !== isNow || getNowChanged) {
	        this.clearTimeIndicatorInterval();
	        if (isNow) {
	          var tail = !getNowChanged && localizer.eq(prevProps.date, date, 'minutes') && prevState.timeIndicatorPosition === this.state.timeIndicatorPosition;
	          this.setTimeIndicatorPositionUpdateInterval(tail);
	        }
	      } else if (isNow && (localizer.neq(prevProps.min, min, 'minutes') || localizer.neq(prevProps.max, max, 'minutes'))) {
	        this.positionTimeIndicator();
	      }
	    }

	    /**
	     * @param tail {Boolean} - whether `positionTimeIndicator` call should be
	     *   deferred or called upon setting interval (`true` - if deferred);
	     */
	  }, {
	    key: "setTimeIndicatorPositionUpdateInterval",
	    value: function setTimeIndicatorPositionUpdateInterval() {
	      var _this2 = this;
	      var tail = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      if (!this.intervalTriggered && !tail) {
	        this.positionTimeIndicator();
	      }
	      this._timeIndicatorTimeout = window.setTimeout(function () {
	        _this2.intervalTriggered = true;
	        _this2.positionTimeIndicator();
	        _this2.setTimeIndicatorPositionUpdateInterval();
	      }, 60000);
	    }
	  }, {
	    key: "clearTimeIndicatorInterval",
	    value: function clearTimeIndicatorInterval() {
	      this.intervalTriggered = false;
	      window.clearTimeout(this._timeIndicatorTimeout);
	    }
	  }, {
	    key: "positionTimeIndicator",
	    value: function positionTimeIndicator() {
	      var _this$props4 = this.props,
	        min = _this$props4.min,
	        max = _this$props4.max,
	        getNow = _this$props4.getNow;
	      var current = getNow();
	      if (current >= min && current <= max) {
	        var top = this.slotMetrics.getCurrentTimePosition(current);
	        this.intervalTriggered = true;
	        this.setState({
	          timeIndicatorPosition: top
	        });
	      } else {
	        this.clearTimeIndicatorInterval();
	      }
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this$props5 = this.props,
	        date = _this$props5.date,
	        max = _this$props5.max,
	        rtl = _this$props5.rtl,
	        isNow = _this$props5.isNow,
	        resource = _this$props5.resource,
	        accessors = _this$props5.accessors,
	        localizer = _this$props5.localizer,
	        _this$props5$getters = _this$props5.getters,
	        dayProp = _this$props5$getters.dayProp,
	        getters = _objectWithoutProperties(_this$props5$getters, _excluded$5$1),
	        _this$props5$componen = _this$props5.components,
	        EventContainer = _this$props5$componen.eventContainerWrapper,
	        components = _objectWithoutProperties(_this$props5$componen, _excluded2$1);
	      var slotMetrics = this.slotMetrics;
	      var _this$state = this.state,
	        selecting = _this$state.selecting,
	        top = _this$state.top,
	        height = _this$state.height,
	        startDate = _this$state.startDate,
	        endDate = _this$state.endDate;
	      var selectDates = {
	        start: startDate,
	        end: endDate
	      };
	      var _dayProp = dayProp(max),
	        className = _dayProp.className,
	        style = _dayProp.style;
	      var DayColumnWrapperComponent = components.dayColumnWrapper || DayColumnWrapper$1$1;
	      return /*#__PURE__*/React$1.createElement(DayColumnWrapperComponent, {
	        ref: this.containerRef,
	        date: date,
	        style: style,
	        className: clsx(className, 'rbc-day-slot', 'rbc-time-column', isNow && 'rbc-now', isNow && 'rbc-today',
	        // WHY
	        selecting && 'rbc-slot-selecting'),
	        slotMetrics: slotMetrics
	      }, slotMetrics.groups.map(function (grp, idx) {
	        return /*#__PURE__*/React$1.createElement(TimeSlotGroup$2, {
	          key: idx,
	          group: grp,
	          resource: resource,
	          getters: getters,
	          components: components
	        });
	      }), /*#__PURE__*/React$1.createElement(EventContainer, {
	        localizer: localizer,
	        resource: resource,
	        accessors: accessors,
	        getters: getters,
	        components: components,
	        slotMetrics: slotMetrics
	      }, /*#__PURE__*/React$1.createElement("div", {
	        className: clsx('rbc-events-container', rtl && 'rtl')
	      }, this.renderEvents({
	        events: this.props.backgroundEvents,
	        isBackgroundEvent: true
	      }), this.renderEvents({
	        events: this.props.events
	      }))), selecting && /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-slot-selection",
	        style: {
	          top: top,
	          height: height
	        }
	      }, /*#__PURE__*/React$1.createElement("span", null, localizer.format(selectDates, 'selectRangeFormat'))), isNow && this.intervalTriggered && /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-current-time-indicator",
	        style: {
	          top: "".concat(this.state.timeIndicatorPosition, "%")
	        }
	      }));
	    }
	  }]);
	  return DayColumn;
	}(React$1.Component);
	DayColumn$2.defaultProps = {
	  dragThroughEvents: true,
	  timeslots: 2
	};

	/**
	 * Since the TimeGutter only displays the 'times' of slots in a day, and is separate
	 * from the Day Columns themselves, we check to see if the range contains an offset difference
	 * and, if so, change the beginning and end 'date' by a day to properly display the slots times
	 * used.
	 */
	function adjustForDST$1(_ref) {
	  var min = _ref.min,
	    max = _ref.max,
	    localizer = _ref.localizer;
	  if (localizer.getTimezoneOffset(min) !== localizer.getTimezoneOffset(max)) {
	    return {
	      start: localizer.add(min, -1, 'day'),
	      end: localizer.add(max, -1, 'day')
	    };
	  }
	  return {
	    start: min,
	    end: max
	  };
	}
	var TimeGutter$2 = function TimeGutter(_ref2) {
	  var min = _ref2.min,
	    max = _ref2.max,
	    timeslots = _ref2.timeslots,
	    step = _ref2.step,
	    localizer = _ref2.localizer,
	    getNow = _ref2.getNow,
	    resource = _ref2.resource,
	    components = _ref2.components,
	    getters = _ref2.getters,
	    gutterRef = _ref2.gutterRef;
	  var TimeGutterWrapper = components.timeGutterWrapper;
	  var _useMemo = React$1.useMemo(function () {
	      return adjustForDST$1({
	        min: min,
	        max: max,
	        localizer: localizer
	      });
	    },
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	    [min === null || min === void 0 ? void 0 : min.toISOString(), max === null || max === void 0 ? void 0 : max.toISOString(), localizer]),
	    start = _useMemo.start,
	    end = _useMemo.end;
	  var _useState = React$1.useState(getSlotMetrics$2({
	      min: start,
	      max: end,
	      timeslots: timeslots,
	      step: step,
	      localizer: localizer
	    })),
	    _useState2 = _slicedToArray(_useState, 2),
	    slotMetrics = _useState2[0],
	    setSlotMetrics = _useState2[1];
	  React$1.useEffect(function () {
	    if (slotMetrics) {
	      setSlotMetrics(slotMetrics.update({
	        min: start,
	        max: end,
	        timeslots: timeslots,
	        step: step,
	        localizer: localizer
	      }));
	    }
	    /**
	     * We don't want this to fire when slotMetrics is updated as it would recursively bomb
	     */
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	  }, [start === null || start === void 0 ? void 0 : start.toISOString(), end === null || end === void 0 ? void 0 : end.toISOString(), timeslots, step]);
	  var renderSlot = React$1.useCallback(function (value, idx) {
	    if (idx) return null; // don't return the first (0) idx

	    var isNow = slotMetrics.dateIsInGroup(getNow(), idx);
	    return /*#__PURE__*/React$1.createElement("span", {
	      className: clsx('rbc-label', isNow && 'rbc-now')
	    }, localizer.format(value, 'timeGutterFormat'));
	  }, [slotMetrics, localizer, getNow]);
	  return /*#__PURE__*/React$1.createElement(TimeGutterWrapper, {
	    slotMetrics: slotMetrics
	  }, /*#__PURE__*/React$1.createElement("div", {
	    className: "rbc-time-gutter rbc-time-column",
	    ref: gutterRef
	  }, slotMetrics.groups.map(function (grp, idx) {
	    return /*#__PURE__*/React$1.createElement(TimeSlotGroup$2, {
	      key: idx,
	      group: grp,
	      resource: resource,
	      components: components,
	      renderSlot: renderSlot,
	      getters: getters
	    });
	  })));
	};
	var TimeGutter$1$1 = /*#__PURE__*/React$1.forwardRef(function (props, ref) {
	  return /*#__PURE__*/React$1.createElement(TimeGutter$2, Object.assign({
	    gutterRef: ref
	  }, props));
	});

	var ResourceHeader$2 = function ResourceHeader(_ref) {
	  var label = _ref.label;
	  return /*#__PURE__*/React$1.createElement(React$1.Fragment, null, label);
	};

	var TimeGridHeader$2 = /*#__PURE__*/function (_React$Component) {
	  _inherits(TimeGridHeader, _React$Component);
	  var _super = _createSuper(TimeGridHeader);
	  function TimeGridHeader() {
	    var _this;
	    _classCallCheck(this, TimeGridHeader);
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(args));
	    _this.handleHeaderClick = function (date, view, e) {
	      e.preventDefault();
	      notify$1(_this.props.onDrillDown, [date, view]);
	    };
	    _this.renderRow = function (resource) {
	      var _this$props = _this.props,
	        events = _this$props.events,
	        rtl = _this$props.rtl,
	        selectable = _this$props.selectable,
	        getNow = _this$props.getNow,
	        range = _this$props.range,
	        getters = _this$props.getters,
	        localizer = _this$props.localizer,
	        accessors = _this$props.accessors,
	        components = _this$props.components,
	        resizable = _this$props.resizable;
	      var resourceId = accessors.resourceId(resource);
	      var eventsToDisplay = resource ? events.filter(function (event) {
	        return accessors.resource(event) === resourceId;
	      }) : events;
	      return /*#__PURE__*/React$1.createElement(DateContentRow$2, {
	        isAllDay: true,
	        rtl: rtl,
	        getNow: getNow,
	        minRows: 2
	        // Add +1 to include showMore button row in the row limit
	        ,
	        maxRows: _this.props.allDayMaxRows + 1,
	        range: range,
	        events: eventsToDisplay,
	        resourceId: resourceId,
	        className: "rbc-allday-cell",
	        selectable: selectable,
	        selected: _this.props.selected,
	        components: components,
	        accessors: accessors,
	        getters: getters,
	        localizer: localizer,
	        onSelect: _this.props.onSelectEvent,
	        onShowMore: _this.props.onShowMore,
	        onDoubleClick: _this.props.onDoubleClickEvent,
	        onKeyPress: _this.props.onKeyPressEvent,
	        onSelectSlot: _this.props.onSelectSlot,
	        longPressThreshold: _this.props.longPressThreshold,
	        resizable: resizable
	      });
	    };
	    return _this;
	  }
	  _createClass$1(TimeGridHeader, [{
	    key: "renderHeaderCells",
	    value: function renderHeaderCells(range) {
	      var _this2 = this;
	      var _this$props2 = this.props,
	        localizer = _this$props2.localizer,
	        getDrilldownView = _this$props2.getDrilldownView,
	        getNow = _this$props2.getNow,
	        dayProp = _this$props2.getters.dayProp,
	        _this$props2$componen = _this$props2.components.header,
	        HeaderComponent = _this$props2$componen === void 0 ? Header$2 : _this$props2$componen;
	      var today = getNow();
	      return range.map(function (date, i) {
	        var drilldownView = getDrilldownView(date);
	        var label = localizer.format(date, 'dayFormat');
	        var _dayProp = dayProp(date),
	          className = _dayProp.className,
	          style = _dayProp.style;
	        var header = /*#__PURE__*/React$1.createElement(HeaderComponent, {
	          date: date,
	          label: label,
	          localizer: localizer
	        });
	        return /*#__PURE__*/React$1.createElement("div", {
	          key: i,
	          style: style,
	          className: clsx('rbc-header', className, localizer.isSameDate(date, today) && 'rbc-today')
	        }, drilldownView ? /*#__PURE__*/React$1.createElement("button", {
	          type: "button",
	          className: "rbc-button-link",
	          onClick: function onClick(e) {
	            return _this2.handleHeaderClick(date, drilldownView, e);
	          }
	        }, header) : /*#__PURE__*/React$1.createElement("span", null, header));
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this3 = this;
	      var _this$props3 = this.props,
	        width = _this$props3.width,
	        rtl = _this$props3.rtl,
	        resources = _this$props3.resources,
	        range = _this$props3.range,
	        events = _this$props3.events,
	        getNow = _this$props3.getNow,
	        accessors = _this$props3.accessors,
	        selectable = _this$props3.selectable,
	        components = _this$props3.components,
	        getters = _this$props3.getters,
	        scrollRef = _this$props3.scrollRef,
	        localizer = _this$props3.localizer,
	        isOverflowing = _this$props3.isOverflowing,
	        _this$props3$componen = _this$props3.components,
	        TimeGutterHeader = _this$props3$componen.timeGutterHeader,
	        _this$props3$componen2 = _this$props3$componen.resourceHeader,
	        ResourceHeaderComponent = _this$props3$componen2 === void 0 ? ResourceHeader$2 : _this$props3$componen2,
	        resizable = _this$props3.resizable;
	      var style = {};
	      if (isOverflowing) {
	        style[rtl ? 'marginLeft' : 'marginRight'] = "".concat(scrollbarSize() - 1, "px");
	      }
	      var groupedEvents = resources.groupEvents(events);
	      return /*#__PURE__*/React$1.createElement("div", {
	        style: style,
	        ref: scrollRef,
	        className: clsx('rbc-time-header', isOverflowing && 'rbc-overflowing')
	      }, /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-label rbc-time-header-gutter",
	        style: {
	          width: width,
	          minWidth: width,
	          maxWidth: width
	        }
	      }, TimeGutterHeader && /*#__PURE__*/React$1.createElement(TimeGutterHeader, null)), resources.map(function (_ref, idx) {
	        var _ref2 = _slicedToArray(_ref, 2),
	          id = _ref2[0],
	          resource = _ref2[1];
	        return /*#__PURE__*/React$1.createElement("div", {
	          className: "rbc-time-header-content",
	          key: id || idx
	        }, resource && /*#__PURE__*/React$1.createElement("div", {
	          className: "rbc-row rbc-row-resource",
	          key: "resource_".concat(idx)
	        }, /*#__PURE__*/React$1.createElement("div", {
	          className: "rbc-header"
	        }, /*#__PURE__*/React$1.createElement(ResourceHeaderComponent, {
	          index: idx,
	          label: accessors.resourceTitle(resource),
	          resource: resource
	        }))), /*#__PURE__*/React$1.createElement("div", {
	          className: "rbc-row rbc-time-header-cell".concat(range.length <= 1 ? ' rbc-time-header-cell-single-day' : '')
	        }, _this3.renderHeaderCells(range)), /*#__PURE__*/React$1.createElement(DateContentRow$2, {
	          isAllDay: true,
	          rtl: rtl,
	          getNow: getNow,
	          minRows: 2
	          // Add +1 to include showMore button row in the row limit
	          ,
	          maxRows: _this3.props.allDayMaxRows + 1,
	          range: range,
	          events: groupedEvents.get(id) || [],
	          resourceId: resource && id,
	          className: "rbc-allday-cell",
	          selectable: selectable,
	          selected: _this3.props.selected,
	          components: components,
	          accessors: accessors,
	          getters: getters,
	          localizer: localizer,
	          onSelect: _this3.props.onSelectEvent,
	          onShowMore: _this3.props.onShowMore,
	          onDoubleClick: _this3.props.onDoubleClickEvent,
	          onKeyPress: _this3.props.onKeyPressEvent,
	          onSelectSlot: _this3.props.onSelectSlot,
	          longPressThreshold: _this3.props.longPressThreshold,
	          resizable: resizable
	        }));
	      }));
	    }
	  }]);
	  return TimeGridHeader;
	}(React$1.Component);

	var NONE$1 = {};
	function Resources$2(resources, accessors) {
	  return {
	    map: function map(fn) {
	      if (!resources) return [fn([NONE$1, null], 0)];
	      return resources.map(function (resource, idx) {
	        return fn([accessors.resourceId(resource), resource], idx);
	      });
	    },
	    groupEvents: function groupEvents(events) {
	      var eventsByResource = new Map();
	      if (!resources) {
	        // Return all events if resources are not provided
	        eventsByResource.set(NONE$1, events);
	        return eventsByResource;
	      }
	      events.forEach(function (event) {
	        var id = accessors.resource(event) || NONE$1;
	        if (Array.isArray(id)) {
	          id.forEach(function (item) {
	            var resourceEvents = eventsByResource.get(item) || [];
	            resourceEvents.push(event);
	            eventsByResource.set(item, resourceEvents);
	          });
	        } else {
	          var resourceEvents = eventsByResource.get(id) || [];
	          resourceEvents.push(event);
	          eventsByResource.set(id, resourceEvents);
	        }
	      });
	      return eventsByResource;
	    }
	  };
	}

	var TimeGrid$2 = /*#__PURE__*/function (_Component) {
	  _inherits(TimeGrid, _Component);
	  var _super = _createSuper(TimeGrid);
	  function TimeGrid(props) {
	    var _this;
	    _classCallCheck(this, TimeGrid);
	    _this = _super.call(this, props);
	    _this.handleScroll = function (e) {
	      if (_this.scrollRef.current) {
	        _this.scrollRef.current.scrollLeft = e.target.scrollLeft;
	      }
	    };
	    _this.handleResize = function () {
	      cancel(_this.rafHandle);
	      _this.rafHandle = request(_this.checkOverflow);
	    };
	    _this.handleKeyPressEvent = function () {
	      _this.clearSelection();
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      notify$1(_this.props.onKeyPressEvent, args);
	    };
	    _this.handleSelectEvent = function () {
	      //cancel any pending selections so only the event click goes through.
	      _this.clearSelection();
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	      notify$1(_this.props.onSelectEvent, args);
	    };
	    _this.handleDoubleClickEvent = function () {
	      _this.clearSelection();
	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }
	      notify$1(_this.props.onDoubleClickEvent, args);
	    };
	    _this.handleShowMore = function (events, date, cell, slot, target) {
	      var _this$props = _this.props,
	        popup = _this$props.popup,
	        onDrillDown = _this$props.onDrillDown,
	        onShowMore = _this$props.onShowMore,
	        getDrilldownView = _this$props.getDrilldownView,
	        doShowMoreDrillDown = _this$props.doShowMoreDrillDown;
	      _this.clearSelection();
	      if (popup) {
	        var position = position$1(cell, _this.containerRef.current);
	        _this.setState({
	          overlay: {
	            date: date,
	            events: events,
	            position: _objectSpread2$8(_objectSpread2$8({}, position), {}, {
	              width: '200px'
	            }),
	            target: target
	          }
	        });
	      } else if (doShowMoreDrillDown) {
	        notify$1(onDrillDown, [date, getDrilldownView(date) || views$2.DAY]);
	      }
	      notify$1(onShowMore, [events, date, slot]);
	    };
	    _this.handleSelectAllDaySlot = function (slots, slotInfo) {
	      var onSelectSlot = _this.props.onSelectSlot;
	      var start = new Date(slots[0]);
	      var end = new Date(slots[slots.length - 1]);
	      end.setDate(slots[slots.length - 1].getDate() + 1);
	      notify$1(onSelectSlot, {
	        slots: slots,
	        start: start,
	        end: end,
	        action: slotInfo.action,
	        resourceId: slotInfo.resourceId
	      });
	    };
	    _this.overlayDisplay = function () {
	      _this.setState({
	        overlay: null
	      });
	    };
	    _this.checkOverflow = function () {
	      if (_this._updatingOverflow) return;
	      var content = _this.contentRef.current;
	      var isOverflowing = content.scrollHeight > content.clientHeight;
	      if (_this.state.isOverflowing !== isOverflowing) {
	        _this._updatingOverflow = true;
	        _this.setState({
	          isOverflowing: isOverflowing
	        }, function () {
	          _this._updatingOverflow = false;
	        });
	      }
	    };
	    _this.memoizedResources = memoizeOne(function (resources, accessors) {
	      return Resources$2(resources, accessors);
	    });
	    _this.state = {
	      gutterWidth: undefined,
	      isOverflowing: null
	    };
	    _this.scrollRef = /*#__PURE__*/React$1.createRef();
	    _this.contentRef = /*#__PURE__*/React$1.createRef();
	    _this.containerRef = /*#__PURE__*/React$1.createRef();
	    _this._scrollRatio = null;
	    _this.gutterRef = /*#__PURE__*/React$1.createRef();
	    return _this;
	  }
	  _createClass$1(TimeGrid, [{
	    key: "getSnapshotBeforeUpdate",
	    value: function getSnapshotBeforeUpdate() {
	      this.checkOverflow();
	      return null;
	    }
	  }, {
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      if (this.props.width == null) {
	        this.measureGutter();
	      }
	      this.calculateScroll();
	      this.applyScroll();
	      window.addEventListener('resize', this.handleResize);
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      window.removeEventListener('resize', this.handleResize);
	      cancel(this.rafHandle);
	      if (this.measureGutterAnimationFrameRequest) {
	        window.cancelAnimationFrame(this.measureGutterAnimationFrameRequest);
	      }
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate() {
	      this.applyScroll();
	    }
	  }, {
	    key: "renderEvents",
	    value: function renderEvents(range, events, backgroundEvents, now) {
	      var _this2 = this;
	      var _this$props2 = this.props,
	        min = _this$props2.min,
	        max = _this$props2.max,
	        components = _this$props2.components,
	        accessors = _this$props2.accessors,
	        localizer = _this$props2.localizer,
	        dayLayoutAlgorithm = _this$props2.dayLayoutAlgorithm;
	      var resources = this.memoizedResources(this.props.resources, accessors);
	      var groupedEvents = resources.groupEvents(events);
	      var groupedBackgroundEvents = resources.groupEvents(backgroundEvents);
	      return resources.map(function (_ref, i) {
	        var _ref2 = _slicedToArray(_ref, 2),
	          id = _ref2[0],
	          resource = _ref2[1];
	        return range.map(function (date, jj) {
	          var daysEvents = (groupedEvents.get(id) || []).filter(function (event) {
	            return localizer.inRange(date, accessors.start(event), accessors.end(event), 'day');
	          });
	          var daysBackgroundEvents = (groupedBackgroundEvents.get(id) || []).filter(function (event) {
	            return localizer.inRange(date, accessors.start(event), accessors.end(event), 'day');
	          });
	          return /*#__PURE__*/React$1.createElement(DayColumn$2, Object.assign({}, _this2.props, {
	            localizer: localizer,
	            min: localizer.merge(date, min),
	            max: localizer.merge(date, max),
	            resource: resource && id,
	            components: components,
	            isNow: localizer.isSameDate(date, now),
	            key: i + '-' + jj,
	            date: date,
	            events: daysEvents,
	            backgroundEvents: daysBackgroundEvents,
	            dayLayoutAlgorithm: dayLayoutAlgorithm
	          }));
	        });
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this$props$allDayMax;
	      var _this$props3 = this.props,
	        events = _this$props3.events,
	        backgroundEvents = _this$props3.backgroundEvents,
	        range = _this$props3.range,
	        width = _this$props3.width,
	        rtl = _this$props3.rtl,
	        selected = _this$props3.selected,
	        getNow = _this$props3.getNow,
	        resources = _this$props3.resources,
	        components = _this$props3.components,
	        accessors = _this$props3.accessors,
	        getters = _this$props3.getters,
	        localizer = _this$props3.localizer,
	        min = _this$props3.min,
	        max = _this$props3.max,
	        showMultiDayTimes = _this$props3.showMultiDayTimes,
	        longPressThreshold = _this$props3.longPressThreshold,
	        resizable = _this$props3.resizable;
	      width = width || this.state.gutterWidth;
	      var start = range[0],
	        end = range[range.length - 1];
	      this.slots = range.length;
	      var allDayEvents = [],
	        rangeEvents = [],
	        rangeBackgroundEvents = [];
	      events.forEach(function (event) {
	        if (inRange$1(event, start, end, accessors, localizer)) {
	          var eStart = accessors.start(event),
	            eEnd = accessors.end(event);
	          if (accessors.allDay(event) || localizer.startAndEndAreDateOnly(eStart, eEnd) || !showMultiDayTimes && !localizer.isSameDate(eStart, eEnd)) {
	            allDayEvents.push(event);
	          } else {
	            rangeEvents.push(event);
	          }
	        }
	      });
	      backgroundEvents.forEach(function (event) {
	        if (inRange$1(event, start, end, accessors, localizer)) {
	          rangeBackgroundEvents.push(event);
	        }
	      });
	      allDayEvents.sort(function (a, b) {
	        return sortEvents$2(a, b, accessors, localizer);
	      });
	      return /*#__PURE__*/React$1.createElement("div", {
	        className: clsx('rbc-time-view', resources && 'rbc-time-view-resources'),
	        ref: this.containerRef
	      }, /*#__PURE__*/React$1.createElement(TimeGridHeader$2, {
	        range: range,
	        events: allDayEvents,
	        width: width,
	        rtl: rtl,
	        getNow: getNow,
	        localizer: localizer,
	        selected: selected,
	        allDayMaxRows: this.props.showAllEvents ? Infinity : (_this$props$allDayMax = this.props.allDayMaxRows) !== null && _this$props$allDayMax !== void 0 ? _this$props$allDayMax : Infinity,
	        resources: this.memoizedResources(resources, accessors),
	        selectable: this.props.selectable,
	        accessors: accessors,
	        getters: getters,
	        components: components,
	        scrollRef: this.scrollRef,
	        isOverflowing: this.state.isOverflowing,
	        longPressThreshold: longPressThreshold,
	        onSelectSlot: this.handleSelectAllDaySlot,
	        onSelectEvent: this.handleSelectEvent,
	        onShowMore: this.handleShowMore,
	        onDoubleClickEvent: this.props.onDoubleClickEvent,
	        onKeyPressEvent: this.props.onKeyPressEvent,
	        onDrillDown: this.props.onDrillDown,
	        getDrilldownView: this.props.getDrilldownView,
	        resizable: resizable
	      }), this.props.popup && this.renderOverlay(), /*#__PURE__*/React$1.createElement("div", {
	        ref: this.contentRef,
	        className: "rbc-time-content",
	        onScroll: this.handleScroll
	      }, /*#__PURE__*/React$1.createElement(TimeGutter$1$1, {
	        date: start,
	        ref: this.gutterRef,
	        localizer: localizer,
	        min: localizer.merge(start, min),
	        max: localizer.merge(start, max),
	        step: this.props.step,
	        getNow: this.props.getNow,
	        timeslots: this.props.timeslots,
	        components: components,
	        className: "rbc-time-gutter",
	        getters: getters
	      }), this.renderEvents(range, rangeEvents, rangeBackgroundEvents, getNow())));
	    }
	  }, {
	    key: "renderOverlay",
	    value: function renderOverlay() {
	      var _this$state$overlay,
	        _this$state,
	        _this3 = this;
	      var overlay = (_this$state$overlay = (_this$state = this.state) === null || _this$state === void 0 ? void 0 : _this$state.overlay) !== null && _this$state$overlay !== void 0 ? _this$state$overlay : {};
	      var _this$props4 = this.props,
	        accessors = _this$props4.accessors,
	        localizer = _this$props4.localizer,
	        components = _this$props4.components,
	        getters = _this$props4.getters,
	        selected = _this$props4.selected,
	        popupOffset = _this$props4.popupOffset,
	        handleDragStart = _this$props4.handleDragStart;
	      var onHide = function onHide() {
	        return _this3.setState({
	          overlay: null
	        });
	      };
	      return /*#__PURE__*/React$1.createElement(PopOverlay$2, {
	        overlay: overlay,
	        accessors: accessors,
	        localizer: localizer,
	        components: components,
	        getters: getters,
	        selected: selected,
	        popupOffset: popupOffset,
	        ref: this.containerRef,
	        handleKeyPressEvent: this.handleKeyPressEvent,
	        handleSelectEvent: this.handleSelectEvent,
	        handleDoubleClickEvent: this.handleDoubleClickEvent,
	        handleDragStart: handleDragStart,
	        show: !!overlay.position,
	        overlayDisplay: this.overlayDisplay,
	        onHide: onHide
	      });
	    }
	  }, {
	    key: "clearSelection",
	    value: function clearSelection() {
	      clearTimeout(this._selectTimer);
	      this._pendingSelection = [];
	    }
	  }, {
	    key: "measureGutter",
	    value: function measureGutter() {
	      var _this4 = this;
	      if (this.measureGutterAnimationFrameRequest) {
	        window.cancelAnimationFrame(this.measureGutterAnimationFrameRequest);
	      }
	      this.measureGutterAnimationFrameRequest = window.requestAnimationFrame(function () {
	        var _this4$gutterRef;
	        var width = (_this4$gutterRef = _this4.gutterRef) !== null && _this4$gutterRef !== void 0 && _this4$gutterRef.current ? getWidth(_this4.gutterRef.current) : undefined;
	        if (width && _this4.state.gutterWidth !== width) {
	          _this4.setState({
	            gutterWidth: width
	          });
	        }
	      });
	    }
	  }, {
	    key: "applyScroll",
	    value: function applyScroll() {
	      // If auto-scroll is disabled, we don't actually apply the scroll
	      if (this._scrollRatio != null && this.props.enableAutoScroll === true) {
	        var content = this.contentRef.current;
	        content.scrollTop = content.scrollHeight * this._scrollRatio;
	        // Only do this once
	        this._scrollRatio = null;
	      }
	    }
	  }, {
	    key: "calculateScroll",
	    value: function calculateScroll() {
	      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	      var min = props.min,
	        max = props.max,
	        scrollToTime = props.scrollToTime,
	        localizer = props.localizer;
	      var diffMillis = localizer.diff(localizer.merge(scrollToTime, min), scrollToTime, 'milliseconds');
	      var totalMillis = localizer.diff(min, max, 'milliseconds');
	      this._scrollRatio = diffMillis / totalMillis;
	    }
	  }]);
	  return TimeGrid;
	}(React$1.Component);
	TimeGrid$2.defaultProps = {
	  step: 30,
	  timeslots: 2
	};

	var _excluded$4$1 = ["date", "localizer", "min", "max", "scrollToTime", "enableAutoScroll"];
	var Day$2 = /*#__PURE__*/function (_React$Component) {
	  _inherits(Day, _React$Component);
	  var _super = _createSuper(Day);
	  function Day() {
	    _classCallCheck(this, Day);
	    return _super.apply(this, arguments);
	  }
	  _createClass$1(Day, [{
	    key: "render",
	    value: function render() {
	      /**
	       * This allows us to default min, max, and scrollToTime
	       * using our localizer. This is necessary until such time
	       * as TODO: TimeGrid is converted to a functional component.
	       */
	      var _this$props = this.props,
	        date = _this$props.date,
	        localizer = _this$props.localizer,
	        _this$props$min = _this$props.min,
	        min = _this$props$min === void 0 ? localizer.startOf(new Date(), 'day') : _this$props$min,
	        _this$props$max = _this$props.max,
	        max = _this$props$max === void 0 ? localizer.endOf(new Date(), 'day') : _this$props$max,
	        _this$props$scrollToT = _this$props.scrollToTime,
	        scrollToTime = _this$props$scrollToT === void 0 ? localizer.startOf(new Date(), 'day') : _this$props$scrollToT,
	        _this$props$enableAut = _this$props.enableAutoScroll,
	        enableAutoScroll = _this$props$enableAut === void 0 ? true : _this$props$enableAut,
	        props = _objectWithoutProperties(_this$props, _excluded$4$1);
	      var range = Day.range(date, {
	        localizer: localizer
	      });
	      return /*#__PURE__*/React$1.createElement(TimeGrid$2, Object.assign({}, props, {
	        range: range,
	        eventOffset: 10,
	        localizer: localizer,
	        min: min,
	        max: max,
	        scrollToTime: scrollToTime,
	        enableAutoScroll: enableAutoScroll
	      }));
	    }
	  }]);
	  return Day;
	}(React$1.Component);
	Day$2.range = function (date, _ref) {
	  var localizer = _ref.localizer;
	  return [localizer.startOf(date, 'day')];
	};
	Day$2.navigate = function (date, action, _ref2) {
	  var localizer = _ref2.localizer;
	  switch (action) {
	    case navigate$1.PREVIOUS:
	      return localizer.add(date, -1, 'day');
	    case navigate$1.NEXT:
	      return localizer.add(date, 1, 'day');
	    default:
	      return date;
	  }
	};
	Day$2.title = function (date, _ref3) {
	  var localizer = _ref3.localizer;
	  return localizer.format(date, 'dayHeaderFormat');
	};

	var _excluded$3$1 = ["date", "localizer", "min", "max", "scrollToTime", "enableAutoScroll"];
	var Week$2 = /*#__PURE__*/function (_React$Component) {
	  _inherits(Week, _React$Component);
	  var _super = _createSuper(Week);
	  function Week() {
	    _classCallCheck(this, Week);
	    return _super.apply(this, arguments);
	  }
	  _createClass$1(Week, [{
	    key: "render",
	    value: function render() {
	      /**
	       * This allows us to default min, max, and scrollToTime
	       * using our localizer. This is necessary until such time
	       * as TimeGrid is converted to a functional component.
	       */
	      var _this$props = this.props,
	        date = _this$props.date,
	        localizer = _this$props.localizer,
	        _this$props$min = _this$props.min,
	        min = _this$props$min === void 0 ? localizer.startOf(new Date(), 'day') : _this$props$min,
	        _this$props$max = _this$props.max,
	        max = _this$props$max === void 0 ? localizer.endOf(new Date(), 'day') : _this$props$max,
	        _this$props$scrollToT = _this$props.scrollToTime,
	        scrollToTime = _this$props$scrollToT === void 0 ? localizer.startOf(new Date(), 'day') : _this$props$scrollToT,
	        _this$props$enableAut = _this$props.enableAutoScroll,
	        enableAutoScroll = _this$props$enableAut === void 0 ? true : _this$props$enableAut,
	        props = _objectWithoutProperties(_this$props, _excluded$3$1);
	      var range = Week.range(date, this.props);
	      return /*#__PURE__*/React$1.createElement(TimeGrid$2, Object.assign({}, props, {
	        range: range,
	        eventOffset: 15,
	        localizer: localizer,
	        min: min,
	        max: max,
	        scrollToTime: scrollToTime,
	        enableAutoScroll: enableAutoScroll
	      }));
	    }
	  }]);
	  return Week;
	}(React$1.Component);
	Week$2.defaultProps = TimeGrid$2.defaultProps;
	Week$2.navigate = function (date, action, _ref) {
	  var localizer = _ref.localizer;
	  switch (action) {
	    case navigate$1.PREVIOUS:
	      return localizer.add(date, -1, 'week');
	    case navigate$1.NEXT:
	      return localizer.add(date, 1, 'week');
	    default:
	      return date;
	  }
	};
	Week$2.range = function (date, _ref2) {
	  var localizer = _ref2.localizer;
	  var firstOfWeek = localizer.startOfWeek();
	  var start = localizer.startOf(date, 'week', firstOfWeek);
	  var end = localizer.endOf(date, 'week', firstOfWeek);
	  return localizer.range(start, end);
	};
	Week$2.title = function (date, _ref3) {
	  var localizer = _ref3.localizer;
	  var _Week$range = Week$2.range(date, {
	      localizer: localizer
	    }),
	    _Week$range2 = _toArray(_Week$range),
	    start = _Week$range2[0],
	    rest = _Week$range2.slice(1);
	  return localizer.format({
	    start: start,
	    end: rest.pop()
	  }, 'dayRangeHeaderFormat');
	};

	var _excluded$2$1 = ["date", "localizer", "min", "max", "scrollToTime", "enableAutoScroll"];
	function workWeekRange(date, options) {
	  return Week$2.range(date, options).filter(function (d) {
	    return [6, 0].indexOf(d.getDay()) === -1;
	  });
	}
	var WorkWeek = /*#__PURE__*/function (_React$Component) {
	  _inherits(WorkWeek, _React$Component);
	  var _super = _createSuper(WorkWeek);
	  function WorkWeek() {
	    _classCallCheck(this, WorkWeek);
	    return _super.apply(this, arguments);
	  }
	  _createClass$1(WorkWeek, [{
	    key: "render",
	    value: function render() {
	      /**
	       * This allows us to default min, max, and scrollToTime
	       * using our localizer. This is necessary until such time
	       * as TimeGrid is converted to a functional component.
	       */
	      var _this$props = this.props,
	        date = _this$props.date,
	        localizer = _this$props.localizer,
	        _this$props$min = _this$props.min,
	        min = _this$props$min === void 0 ? localizer.startOf(new Date(), 'day') : _this$props$min,
	        _this$props$max = _this$props.max,
	        max = _this$props$max === void 0 ? localizer.endOf(new Date(), 'day') : _this$props$max,
	        _this$props$scrollToT = _this$props.scrollToTime,
	        scrollToTime = _this$props$scrollToT === void 0 ? localizer.startOf(new Date(), 'day') : _this$props$scrollToT,
	        _this$props$enableAut = _this$props.enableAutoScroll,
	        enableAutoScroll = _this$props$enableAut === void 0 ? true : _this$props$enableAut,
	        props = _objectWithoutProperties(_this$props, _excluded$2$1);
	      var range = workWeekRange(date, this.props);
	      return /*#__PURE__*/React$1.createElement(TimeGrid$2, Object.assign({}, props, {
	        range: range,
	        eventOffset: 15,
	        localizer: localizer,
	        min: min,
	        max: max,
	        scrollToTime: scrollToTime,
	        enableAutoScroll: enableAutoScroll
	      }));
	    }
	  }]);
	  return WorkWeek;
	}(React$1.Component);
	WorkWeek.defaultProps = TimeGrid$2.defaultProps;
	WorkWeek.range = workWeekRange;
	WorkWeek.navigate = Week$2.navigate;
	WorkWeek.title = function (date, _ref) {
	  var localizer = _ref.localizer;
	  var _workWeekRange = workWeekRange(date, {
	      localizer: localizer
	    }),
	    _workWeekRange2 = _toArray(_workWeekRange),
	    start = _workWeekRange2[0],
	    rest = _workWeekRange2.slice(1);
	  return localizer.format({
	    start: start,
	    end: rest.pop()
	  }, 'dayRangeHeaderFormat');
	};

	function Agenda$2(_ref) {
	  var accessors = _ref.accessors,
	    components = _ref.components,
	    date = _ref.date,
	    events = _ref.events,
	    getters = _ref.getters,
	    length = _ref.length,
	    localizer = _ref.localizer,
	    onDoubleClickEvent = _ref.onDoubleClickEvent,
	    onSelectEvent = _ref.onSelectEvent,
	    selected = _ref.selected;
	  var headerRef = React$1.useRef(null);
	  var dateColRef = React$1.useRef(null);
	  var timeColRef = React$1.useRef(null);
	  var contentRef = React$1.useRef(null);
	  var tbodyRef = React$1.useRef(null);
	  React$1.useEffect(function () {
	    _adjustHeader();
	  });
	  var renderDay = function renderDay(day, events, dayKey) {
	    var Event = components.event,
	      AgendaDate = components.date;
	    events = events.filter(function (e) {
	      return inRange$1(e, localizer.startOf(day, 'day'), localizer.endOf(day, 'day'), accessors, localizer);
	    });
	    return events.map(function (event, idx) {
	      var title = accessors.title(event);
	      var end = accessors.end(event);
	      var start = accessors.start(event);
	      var userProps = getters.eventProp(event, start, end, isSelected$1(event, selected));
	      var dateLabel = idx === 0 && localizer.format(day, 'agendaDateFormat');
	      var first = idx === 0 ? /*#__PURE__*/React$1.createElement("td", {
	        rowSpan: events.length,
	        className: "rbc-agenda-date-cell"
	      }, AgendaDate ? /*#__PURE__*/React$1.createElement(AgendaDate, {
	        day: day,
	        label: dateLabel
	      }) : dateLabel) : false;
	      return /*#__PURE__*/React$1.createElement("tr", {
	        key: dayKey + '_' + idx,
	        className: userProps.className,
	        style: userProps.style
	      }, first, /*#__PURE__*/React$1.createElement("td", {
	        className: "rbc-agenda-time-cell"
	      }, timeRangeLabel(day, event)), /*#__PURE__*/React$1.createElement("td", {
	        className: "rbc-agenda-event-cell",
	        onClick: function onClick(e) {
	          return onSelectEvent && onSelectEvent(event, e);
	        },
	        onDoubleClick: function onDoubleClick(e) {
	          return onDoubleClickEvent && onDoubleClickEvent(event, e);
	        }
	      }, Event ? /*#__PURE__*/React$1.createElement(Event, {
	        event: event,
	        title: title
	      }) : title));
	    }, []);
	  };
	  var timeRangeLabel = function timeRangeLabel(day, event) {
	    var labelClass = '',
	      TimeComponent = components.time,
	      label = localizer.messages.allDay;
	    var end = accessors.end(event);
	    var start = accessors.start(event);
	    if (!accessors.allDay(event)) {
	      if (localizer.eq(start, end)) {
	        label = localizer.format(start, 'agendaTimeFormat');
	      } else if (localizer.isSameDate(start, end)) {
	        label = localizer.format({
	          start: start,
	          end: end
	        }, 'agendaTimeRangeFormat');
	      } else if (localizer.isSameDate(day, start)) {
	        label = localizer.format(start, 'agendaTimeFormat');
	      } else if (localizer.isSameDate(day, end)) {
	        label = localizer.format(end, 'agendaTimeFormat');
	      }
	    }
	    if (localizer.gt(day, start, 'day')) labelClass = 'rbc-continues-prior';
	    if (localizer.lt(day, end, 'day')) labelClass += ' rbc-continues-after';
	    return /*#__PURE__*/React$1.createElement("span", {
	      className: labelClass.trim()
	    }, TimeComponent ? /*#__PURE__*/React$1.createElement(TimeComponent, {
	      event: event,
	      day: day,
	      label: label
	    }) : label);
	  };
	  var _adjustHeader = function _adjustHeader() {
	    if (!tbodyRef.current) return;
	    var header = headerRef.current;
	    var firstRow = tbodyRef.current.firstChild;
	    if (!firstRow) return;
	    var isOverflowing = contentRef.current.scrollHeight > contentRef.current.clientHeight;
	    var _widths = [];
	    var widths = _widths;
	    _widths = [getWidth(firstRow.children[0]), getWidth(firstRow.children[1])];
	    if (widths[0] !== _widths[0] || widths[1] !== _widths[1]) {
	      dateColRef.current.style.width = _widths[0] + 'px';
	      timeColRef.current.style.width = _widths[1] + 'px';
	    }
	    if (isOverflowing) {
	      addClass(header, 'rbc-header-overflowing');
	      header.style.marginRight = scrollbarSize() + 'px';
	    } else {
	      removeClass(header, 'rbc-header-overflowing');
	    }
	  };
	  var messages = localizer.messages;
	  var end = localizer.add(date, length, 'day');
	  var range = localizer.range(date, end, 'day');
	  events = events.filter(function (event) {
	    return inRange$1(event, localizer.startOf(date, 'day'), localizer.endOf(end, 'day'), accessors, localizer);
	  });
	  events.sort(function (a, b) {
	    return +accessors.start(a) - +accessors.start(b);
	  });
	  return /*#__PURE__*/React$1.createElement("div", {
	    className: "rbc-agenda-view"
	  }, events.length !== 0 ? /*#__PURE__*/React$1.createElement(React$1.Fragment, null, /*#__PURE__*/React$1.createElement("table", {
	    ref: headerRef,
	    className: "rbc-agenda-table"
	  }, /*#__PURE__*/React$1.createElement("thead", null, /*#__PURE__*/React$1.createElement("tr", null, /*#__PURE__*/React$1.createElement("th", {
	    className: "rbc-header",
	    ref: dateColRef
	  }, messages.date), /*#__PURE__*/React$1.createElement("th", {
	    className: "rbc-header",
	    ref: timeColRef
	  }, messages.time), /*#__PURE__*/React$1.createElement("th", {
	    className: "rbc-header"
	  }, messages.event)))), /*#__PURE__*/React$1.createElement("div", {
	    className: "rbc-agenda-content",
	    ref: contentRef
	  }, /*#__PURE__*/React$1.createElement("table", {
	    className: "rbc-agenda-table"
	  }, /*#__PURE__*/React$1.createElement("tbody", {
	    ref: tbodyRef
	  }, range.map(function (day, idx) {
	    return renderDay(day, events, idx);
	  }))))) : /*#__PURE__*/React$1.createElement("span", {
	    className: "rbc-agenda-empty"
	  }, messages.noEventsInRange));
	}
	Agenda$2.defaultProps = {
	  length: 30
	};
	Agenda$2.range = function (start, _ref2) {
	  var _ref2$length = _ref2.length,
	    length = _ref2$length === void 0 ? Agenda$2.defaultProps.length : _ref2$length,
	    localizer = _ref2.localizer;
	  var end = localizer.add(start, length, 'day');
	  return {
	    start: start,
	    end: end
	  };
	};
	Agenda$2.navigate = function (date, action, _ref3) {
	  var _ref3$length = _ref3.length,
	    length = _ref3$length === void 0 ? Agenda$2.defaultProps.length : _ref3$length,
	    localizer = _ref3.localizer;
	  switch (action) {
	    case navigate$1.PREVIOUS:
	      return localizer.add(date, -length, 'day');
	    case navigate$1.NEXT:
	      return localizer.add(date, length, 'day');
	    default:
	      return date;
	  }
	};
	Agenda$2.title = function (start, _ref4) {
	  var _ref4$length = _ref4.length,
	    length = _ref4$length === void 0 ? Agenda$2.defaultProps.length : _ref4$length,
	    localizer = _ref4.localizer;
	  var end = localizer.add(start, length, 'day');
	  return localizer.format({
	    start: start,
	    end: end
	  }, 'agendaHeaderFormat');
	};

	var _VIEWS;
	var VIEWS$1 = (_VIEWS = {}, _defineProperty$2(_VIEWS, views$2.MONTH, MonthView$1), _defineProperty$2(_VIEWS, views$2.WEEK, Week$2), _defineProperty$2(_VIEWS, views$2.WORK_WEEK, WorkWeek), _defineProperty$2(_VIEWS, views$2.DAY, Day$2), _defineProperty$2(_VIEWS, views$2.AGENDA, Agenda$2), _VIEWS);

	var _excluded$1$1 = ["action", "date", "today"];
	function moveDate(View, _ref) {
	  var action = _ref.action,
	    date = _ref.date,
	    today = _ref.today,
	    props = _objectWithoutProperties(_ref, _excluded$1$1);
	  View = typeof View === 'string' ? VIEWS$1[View] : View;
	  switch (action) {
	    case navigate$1.TODAY:
	      date = today || new Date();
	      break;
	    case navigate$1.DATE:
	      break;
	    default:
	      invariant$1(View && typeof View.navigate === 'function', 'Calendar View components must implement a static `.navigate(date, action)` method.s');
	      date = View.navigate(date, action, props);
	  }
	  return date;
	}

	var Toolbar = /*#__PURE__*/function (_React$Component) {
	  _inherits(Toolbar, _React$Component);
	  var _super = _createSuper(Toolbar);
	  function Toolbar() {
	    var _this;
	    _classCallCheck(this, Toolbar);
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(args));
	    _this.navigate = function (action) {
	      _this.props.onNavigate(action);
	    };
	    _this.view = function (view) {
	      _this.props.onView(view);
	    };
	    return _this;
	  }
	  _createClass$1(Toolbar, [{
	    key: "render",
	    value: function render() {
	      var _this$props = this.props,
	        messages = _this$props.localizer.messages,
	        label = _this$props.label;
	      return /*#__PURE__*/React$1.createElement("div", {
	        className: "rbc-toolbar"
	      }, /*#__PURE__*/React$1.createElement("span", {
	        className: "rbc-btn-group"
	      }, /*#__PURE__*/React$1.createElement("button", {
	        type: "button",
	        onClick: this.navigate.bind(null, navigate$1.TODAY)
	      }, messages.today), /*#__PURE__*/React$1.createElement("button", {
	        type: "button",
	        onClick: this.navigate.bind(null, navigate$1.PREVIOUS)
	      }, messages.previous), /*#__PURE__*/React$1.createElement("button", {
	        type: "button",
	        onClick: this.navigate.bind(null, navigate$1.NEXT)
	      }, messages.next)), /*#__PURE__*/React$1.createElement("span", {
	        className: "rbc-toolbar-label"
	      }, label), /*#__PURE__*/React$1.createElement("span", {
	        className: "rbc-btn-group"
	      }, this.viewNamesGroup(messages)));
	    }
	  }, {
	    key: "viewNamesGroup",
	    value: function viewNamesGroup(messages) {
	      var _this2 = this;
	      var viewNames = this.props.views;
	      var view = this.props.view;
	      if (viewNames.length > 1) {
	        return viewNames.map(function (name) {
	          return /*#__PURE__*/React$1.createElement("button", {
	            type: "button",
	            key: name,
	            className: clsx({
	              'rbc-active': view === name
	            }),
	            onClick: _this2.view.bind(null, name)
	          }, messages[name]);
	        });
	      }
	    }
	  }]);
	  return Toolbar;
	}(React$1.Component);

	/**
	 * Retrieve via an accessor-like property
	 *
	 *    accessor(obj, 'name')   // => retrieves obj['name']
	 *    accessor(data, func)    // => retrieves func(data)
	 *    ... otherwise null
	 */
	function accessor$1(data, field) {
	  var value = null;
	  if (typeof field === 'function') value = field(data);else if (typeof field === 'string' && _typeof$1(data) === 'object' && data != null && field in data) value = data[field];
	  return value;
	}
	var wrapAccessor = function wrapAccessor(acc) {
	  return function (data) {
	    return accessor$1(data, acc);
	  };
	};

	var _excluded$b = ["view", "date", "getNow", "onNavigate"],
	  _excluded2$2 = ["view", "toolbar", "events", "backgroundEvents", "style", "className", "elementProps", "date", "getNow", "length", "showMultiDayTimes", "onShowMore", "doShowMoreDrillDown", "components", "formats", "messages", "culture"];
	function viewNames$2(_views) {
	  if (Array.isArray(_views)) {
	    return _views;
	  }
	  var views = [];
	  for (var _i = 0, _Object$entries = Object.entries(_views); _i < _Object$entries.length; _i++) {
	    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
	      key = _Object$entries$_i[0],
	      value = _Object$entries$_i[1];
	    if (value) {
	      views.push(key);
	    }
	  }
	  return views;
	}
	function isValidView(view, _ref) {
	  var _views = _ref.views;
	  var names = viewNames$2(_views);
	  return names.indexOf(view) !== -1;
	}
	var Calendar = /*#__PURE__*/function (_React$Component) {
	  _inherits(Calendar, _React$Component);
	  var _super = _createSuper(Calendar);
	  function Calendar() {
	    var _this;
	    _classCallCheck(this, Calendar);
	    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
	      _args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(_args));
	    _this.getViews = function () {
	      var views = _this.props.views;
	      if (Array.isArray(views)) {
	        return transform(views, function (obj, name) {
	          return obj[name] = VIEWS$1[name];
	        }, {});
	      }
	      if (_typeof$1(views) === 'object') {
	        return mapValues(views, function (value, key) {
	          if (value === true) {
	            return VIEWS$1[key];
	          }
	          return value;
	        });
	      }
	      return VIEWS$1;
	    };
	    _this.getView = function () {
	      var views = _this.getViews();
	      return views[_this.props.view];
	    };
	    _this.getDrilldownView = function (date) {
	      var _this$props = _this.props,
	        view = _this$props.view,
	        drilldownView = _this$props.drilldownView,
	        getDrilldownView = _this$props.getDrilldownView;
	      if (!getDrilldownView) return drilldownView;
	      return getDrilldownView(date, view, Object.keys(_this.getViews()));
	    };
	    _this.handleRangeChange = function (date, viewComponent, view) {
	      var _this$props2 = _this.props,
	        onRangeChange = _this$props2.onRangeChange,
	        localizer = _this$props2.localizer;
	      if (onRangeChange) {
	        if (viewComponent.range) {
	          onRangeChange(viewComponent.range(date, {
	            localizer: localizer
	          }), view);
	        }
	      }
	    };
	    _this.handleNavigate = function (action, newDate) {
	      var _this$props3 = _this.props,
	        view = _this$props3.view,
	        date = _this$props3.date,
	        getNow = _this$props3.getNow,
	        onNavigate = _this$props3.onNavigate,
	        props = _objectWithoutProperties(_this$props3, _excluded$b);
	      var ViewComponent = _this.getView();
	      var today = getNow();
	      date = moveDate(ViewComponent, _objectSpread2$8(_objectSpread2$8({}, props), {}, {
	        action: action,
	        date: newDate || date || today,
	        today: today
	      }));
	      onNavigate(date, view, action);
	      _this.handleRangeChange(date, ViewComponent);
	    };
	    _this.handleViewChange = function (view) {
	      if (view !== _this.props.view && isValidView(view, _this.props)) {
	        _this.props.onView(view);
	      }
	      var views = _this.getViews();
	      _this.handleRangeChange(_this.props.date || _this.props.getNow(), views[view], view);
	    };
	    _this.handleSelectEvent = function () {
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	      notify$1(_this.props.onSelectEvent, args);
	    };
	    _this.handleDoubleClickEvent = function () {
	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }
	      notify$1(_this.props.onDoubleClickEvent, args);
	    };
	    _this.handleKeyPressEvent = function () {
	      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	        args[_key4] = arguments[_key4];
	      }
	      notify$1(_this.props.onKeyPressEvent, args);
	    };
	    _this.handleSelectSlot = function (slotInfo) {
	      notify$1(_this.props.onSelectSlot, slotInfo);
	    };
	    _this.handleDrillDown = function (date, view) {
	      var onDrillDown = _this.props.onDrillDown;
	      if (onDrillDown) {
	        onDrillDown(date, view, _this.drilldownView);
	        return;
	      }
	      if (view) _this.handleViewChange(view);
	      _this.handleNavigate(navigate$1.DATE, date);
	    };
	    _this.state = {
	      context: Calendar.getContext(_this.props)
	    };
	    return _this;
	  }
	  _createClass$1(Calendar, [{
	    key: "render",
	    value: function render() {
	      var _this$props4 = this.props,
	        view = _this$props4.view,
	        toolbar = _this$props4.toolbar,
	        events = _this$props4.events,
	        backgroundEvents = _this$props4.backgroundEvents,
	        style = _this$props4.style,
	        className = _this$props4.className,
	        elementProps = _this$props4.elementProps,
	        current = _this$props4.date,
	        getNow = _this$props4.getNow,
	        length = _this$props4.length,
	        showMultiDayTimes = _this$props4.showMultiDayTimes,
	        onShowMore = _this$props4.onShowMore,
	        doShowMoreDrillDown = _this$props4.doShowMoreDrillDown;
	        _this$props4.components;
	        _this$props4.formats;
	        _this$props4.messages;
	        _this$props4.culture;
	        var props = _objectWithoutProperties(_this$props4, _excluded2$2);
	      current = current || getNow();
	      var View = this.getView();
	      var _this$state$context = this.state.context,
	        accessors = _this$state$context.accessors,
	        components = _this$state$context.components,
	        getters = _this$state$context.getters,
	        localizer = _this$state$context.localizer,
	        viewNames = _this$state$context.viewNames;
	      var CalToolbar = components.toolbar || Toolbar;
	      var label = View.title(current, {
	        localizer: localizer,
	        length: length
	      });
	      return /*#__PURE__*/React$1.createElement("div", Object.assign({}, elementProps, {
	        className: clsx(className, 'rbc-calendar', props.rtl && 'rbc-rtl'),
	        style: style
	      }), toolbar && /*#__PURE__*/React$1.createElement(CalToolbar, {
	        date: current,
	        view: view,
	        views: viewNames,
	        label: label,
	        onView: this.handleViewChange,
	        onNavigate: this.handleNavigate,
	        localizer: localizer
	      }), /*#__PURE__*/React$1.createElement(View, Object.assign({}, props, {
	        events: events,
	        backgroundEvents: backgroundEvents,
	        date: current,
	        getNow: getNow,
	        length: length,
	        localizer: localizer,
	        getters: getters,
	        components: components,
	        accessors: accessors,
	        showMultiDayTimes: showMultiDayTimes,
	        getDrilldownView: this.getDrilldownView,
	        onNavigate: this.handleNavigate,
	        onDrillDown: this.handleDrillDown,
	        onSelectEvent: this.handleSelectEvent,
	        onDoubleClickEvent: this.handleDoubleClickEvent,
	        onKeyPressEvent: this.handleKeyPressEvent,
	        onSelectSlot: this.handleSelectSlot,
	        onShowMore: onShowMore,
	        doShowMoreDrillDown: doShowMoreDrillDown
	      })));
	    }

	    /**
	     *
	     * @param date
	     * @param viewComponent
	     * @param {'month'|'week'|'work_week'|'day'|'agenda'} [view] - optional
	     * parameter. It appears when range change on view changing. It could be handy
	     * when you need to have both: range and view type at once, i.e. for manage rbc
	     * state via url
	     */
	  }], [{
	    key: "getDerivedStateFromProps",
	    value: function getDerivedStateFromProps(nextProps) {
	      return {
	        context: Calendar.getContext(nextProps)
	      };
	    }
	  }, {
	    key: "getContext",
	    value: function getContext(_ref2) {
	      var startAccessor = _ref2.startAccessor,
	        endAccessor = _ref2.endAccessor,
	        allDayAccessor = _ref2.allDayAccessor,
	        tooltipAccessor = _ref2.tooltipAccessor,
	        titleAccessor = _ref2.titleAccessor,
	        resourceAccessor = _ref2.resourceAccessor,
	        resourceIdAccessor = _ref2.resourceIdAccessor,
	        resourceTitleAccessor = _ref2.resourceTitleAccessor,
	        eventPropGetter = _ref2.eventPropGetter,
	        backgroundEventPropGetter = _ref2.backgroundEventPropGetter,
	        slotPropGetter = _ref2.slotPropGetter,
	        slotGroupPropGetter = _ref2.slotGroupPropGetter,
	        dayPropGetter = _ref2.dayPropGetter,
	        view = _ref2.view,
	        views = _ref2.views,
	        localizer = _ref2.localizer,
	        culture = _ref2.culture,
	        _ref2$messages = _ref2.messages,
	        messages$1 = _ref2$messages === void 0 ? {} : _ref2$messages,
	        _ref2$components = _ref2.components,
	        components = _ref2$components === void 0 ? {} : _ref2$components,
	        _ref2$formats = _ref2.formats,
	        formats = _ref2$formats === void 0 ? {} : _ref2$formats;
	      var names = viewNames$2(views);
	      var msgs = messages(messages$1);
	      return {
	        viewNames: names,
	        localizer: mergeWithDefaults(localizer, culture, formats, msgs),
	        getters: {
	          eventProp: function eventProp() {
	            return eventPropGetter && eventPropGetter.apply(void 0, arguments) || {};
	          },
	          backgroundEventProp: function backgroundEventProp() {
	            return backgroundEventPropGetter && backgroundEventPropGetter.apply(void 0, arguments) || {};
	          },
	          slotProp: function slotProp() {
	            return slotPropGetter && slotPropGetter.apply(void 0, arguments) || {};
	          },
	          slotGroupProp: function slotGroupProp() {
	            return slotGroupPropGetter && slotGroupPropGetter.apply(void 0, arguments) || {};
	          },
	          dayProp: function dayProp() {
	            return dayPropGetter && dayPropGetter.apply(void 0, arguments) || {};
	          }
	        },
	        components: defaults$1(components[view] || {}, omit$1(components, names), {
	          eventWrapper: NoopWrapper$2,
	          backgroundEventWrapper: NoopWrapper$2,
	          eventContainerWrapper: NoopWrapper$2,
	          dateCellWrapper: NoopWrapper$2,
	          weekWrapper: NoopWrapper$2,
	          timeSlotWrapper: NoopWrapper$2,
	          timeGutterWrapper: NoopWrapper$2
	        }),
	        accessors: {
	          start: wrapAccessor(startAccessor),
	          end: wrapAccessor(endAccessor),
	          allDay: wrapAccessor(allDayAccessor),
	          tooltip: wrapAccessor(tooltipAccessor),
	          title: wrapAccessor(titleAccessor),
	          resource: wrapAccessor(resourceAccessor),
	          resourceId: wrapAccessor(resourceIdAccessor),
	          resourceTitle: wrapAccessor(resourceTitleAccessor)
	        }
	      };
	    }
	  }]);
	  return Calendar;
	}(React$1.Component);
	Calendar.defaultProps = {
	  events: [],
	  backgroundEvents: [],
	  elementProps: {},
	  popup: false,
	  toolbar: true,
	  view: views$2.MONTH,
	  views: [views$2.MONTH, views$2.WEEK, views$2.DAY, views$2.AGENDA],
	  step: 30,
	  length: 30,
	  allDayMaxRows: Infinity,
	  doShowMoreDrillDown: true,
	  drilldownView: views$2.DAY,
	  titleAccessor: 'title',
	  tooltipAccessor: 'title',
	  allDayAccessor: 'allDay',
	  startAccessor: 'start',
	  endAccessor: 'end',
	  resourceAccessor: 'resourceId',
	  resourceIdAccessor: 'id',
	  resourceTitleAccessor: 'title',
	  longPressThreshold: 250,
	  getNow: function getNow() {
	    return new Date();
	  },
	  dayLayoutAlgorithm: 'overlap'
	};
	var Calendar$1 = uncontrollable(Calendar, {
	  view: 'onView',
	  date: 'onNavigate',
	  selected: 'onSelectEvent'
	});

	var weekRangeFormat$5 = function weekRangeFormat(_ref, culture, local) {
	  var start = _ref.start,
	    end = _ref.end;
	  return local.format(start, 'MMMM DD', culture) + '  ' +
	  // updated to use this localizer 'eq()' method
	  local.format(end, local.eq(start, end, 'month') ? 'DD' : 'MMMM DD', culture);
	};
	var dateRangeFormat$5 = function dateRangeFormat(_ref2, culture, local) {
	  var start = _ref2.start,
	    end = _ref2.end;
	  return local.format(start, 'L', culture) + '  ' + local.format(end, 'L', culture);
	};
	var timeRangeFormat$5 = function timeRangeFormat(_ref3, culture, local) {
	  var start = _ref3.start,
	    end = _ref3.end;
	  return local.format(start, 'LT', culture) + '  ' + local.format(end, 'LT', culture);
	};
	var timeRangeStartFormat$5 = function timeRangeStartFormat(_ref4, culture, local) {
	  var start = _ref4.start;
	  return local.format(start, 'LT', culture) + '  ';
	};
	var timeRangeEndFormat$5 = function timeRangeEndFormat(_ref5, culture, local) {
	  var end = _ref5.end;
	  return '  ' + local.format(end, 'LT', culture);
	};
	var formats$5 = {
	  dateFormat: 'DD',
	  dayFormat: 'DD ddd',
	  weekdayFormat: 'ddd',
	  selectRangeFormat: timeRangeFormat$5,
	  eventTimeRangeFormat: timeRangeFormat$5,
	  eventTimeRangeStartFormat: timeRangeStartFormat$5,
	  eventTimeRangeEndFormat: timeRangeEndFormat$5,
	  timeGutterFormat: 'LT',
	  monthHeaderFormat: 'MMMM YYYY',
	  dayHeaderFormat: 'dddd MMM DD',
	  dayRangeHeaderFormat: weekRangeFormat$5,
	  agendaHeaderFormat: dateRangeFormat$5,
	  agendaDateFormat: 'ddd MMM DD',
	  agendaTimeFormat: 'LT',
	  agendaTimeRangeFormat: timeRangeFormat$5
	};
	function fixUnit$2(unit) {
	  var datePart = unit ? unit.toLowerCase() : unit;
	  if (datePart === 'FullYear') {
	    datePart = 'year';
	  } else if (!datePart) {
	    datePart = undefined;
	  }
	  return datePart;
	}
	function moment (moment) {
	  var locale = function locale(m, c) {
	    return c ? m.locale(c) : m;
	  };
	  function getTimezoneOffset(date) {
	    // ensures this gets cast to timezone
	    return moment(date).toDate().getTimezoneOffset();
	  }
	  function getDstOffset(start, end) {
	    var _st$_z$name, _st$_z;
	    // convert to moment, in case
	    // Calculate the offset in the timezone of the Events (local)
	    // not in the timezone of the calendar (moment.tz)
	    var st = moment(start).local();
	    var ed = moment(end).local();
	    // if not using moment timezone
	    if (!moment.tz) {
	      return st.toDate().getTimezoneOffset() - ed.toDate().getTimezoneOffset();
	    }
	    /**
	     * If using moment-timezone, and a timezone has been applied, then
	     * use this to get the proper timezone offset, otherwise default
	     * the timezone to the browser local
	     */
	    var tzName = (_st$_z$name = st === null || st === void 0 ? void 0 : (_st$_z = st._z) === null || _st$_z === void 0 ? void 0 : _st$_z.name) !== null && _st$_z$name !== void 0 ? _st$_z$name : moment.tz.guess();
	    var startOffset = moment.tz.zone(tzName).utcOffset(+st);
	    var endOffset = moment.tz.zone(tzName).utcOffset(+ed);
	    return startOffset - endOffset;
	  }
	  function getDayStartDstOffset(start) {
	    var dayStart = moment(start).startOf('day');
	    return getDstOffset(dayStart, start);
	  }

	  /*** BEGIN localized date arithmetic methods with moment ***/
	  function defineComparators(a, b, unit) {
	    var datePart = fixUnit$2(unit);
	    var dtA = datePart ? moment(a).startOf(datePart) : moment(a);
	    var dtB = datePart ? moment(b).startOf(datePart) : moment(b);
	    return [dtA, dtB, datePart];
	  }
	  function startOf() {
	    var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var unit = arguments.length > 1 ? arguments[1] : undefined;
	    var datePart = fixUnit$2(unit);
	    if (datePart) {
	      return moment(date).startOf(datePart).toDate();
	    }
	    return moment(date).toDate();
	  }
	  function endOf() {
	    var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var unit = arguments.length > 1 ? arguments[1] : undefined;
	    var datePart = fixUnit$2(unit);
	    if (datePart) {
	      return moment(date).endOf(datePart).toDate();
	    }
	    return moment(date).toDate();
	  }

	  // moment comparison operations *always* convert both sides to moment objects
	  // prior to running the comparisons
	  function eq(a, b, unit) {
	    var _defineComparators = defineComparators(a, b, unit),
	      _defineComparators2 = _slicedToArray(_defineComparators, 3),
	      dtA = _defineComparators2[0],
	      dtB = _defineComparators2[1],
	      datePart = _defineComparators2[2];
	    return dtA.isSame(dtB, datePart);
	  }
	  function neq(a, b, unit) {
	    return !eq(a, b, unit);
	  }
	  function gt(a, b, unit) {
	    var _defineComparators3 = defineComparators(a, b, unit),
	      _defineComparators4 = _slicedToArray(_defineComparators3, 3),
	      dtA = _defineComparators4[0],
	      dtB = _defineComparators4[1],
	      datePart = _defineComparators4[2];
	    return dtA.isAfter(dtB, datePart);
	  }
	  function lt(a, b, unit) {
	    var _defineComparators5 = defineComparators(a, b, unit),
	      _defineComparators6 = _slicedToArray(_defineComparators5, 3),
	      dtA = _defineComparators6[0],
	      dtB = _defineComparators6[1],
	      datePart = _defineComparators6[2];
	    return dtA.isBefore(dtB, datePart);
	  }
	  function gte(a, b, unit) {
	    var _defineComparators7 = defineComparators(a, b, unit),
	      _defineComparators8 = _slicedToArray(_defineComparators7, 3),
	      dtA = _defineComparators8[0],
	      dtB = _defineComparators8[1],
	      datePart = _defineComparators8[2];
	    return dtA.isSameOrBefore(dtB, datePart);
	  }
	  function lte(a, b, unit) {
	    var _defineComparators9 = defineComparators(a, b, unit),
	      _defineComparators10 = _slicedToArray(_defineComparators9, 3),
	      dtA = _defineComparators10[0],
	      dtB = _defineComparators10[1],
	      datePart = _defineComparators10[2];
	    return dtA.isSameOrBefore(dtB, datePart);
	  }
	  function inRange(day, min, max) {
	    var unit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'day';
	    var datePart = fixUnit$2(unit);
	    var mDay = moment(day);
	    var mMin = moment(min);
	    var mMax = moment(max);
	    return mDay.isBetween(mMin, mMax, datePart, '[]');
	  }
	  function min(dateA, dateB) {
	    var dtA = moment(dateA);
	    var dtB = moment(dateB);
	    var minDt = moment.min(dtA, dtB);
	    return minDt.toDate();
	  }
	  function max(dateA, dateB) {
	    var dtA = moment(dateA);
	    var dtB = moment(dateB);
	    var maxDt = moment.max(dtA, dtB);
	    return maxDt.toDate();
	  }
	  function merge(date, time) {
	    if (!date && !time) return null;
	    var tm = moment(time).format('HH:mm:ss');
	    var dt = moment(date).startOf('day').format('MM/DD/YYYY');
	    // We do it this way to avoid issues when timezone switching
	    return moment("".concat(dt, " ").concat(tm), 'MM/DD/YYYY HH:mm:ss').toDate();
	  }
	  function add(date, adder, unit) {
	    var datePart = fixUnit$2(unit);
	    return moment(date).add(adder, datePart).toDate();
	  }
	  function range(start, end) {
	    var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'day';
	    var datePart = fixUnit$2(unit);
	    // because the add method will put these in tz, we have to start that way
	    var current = moment(start).toDate();
	    var days = [];
	    while (lte(current, end)) {
	      days.push(current);
	      current = add(current, 1, datePart);
	    }
	    return days;
	  }
	  function ceil(date, unit) {
	    var datePart = fixUnit$2(unit);
	    var floor = startOf(date, datePart);
	    return eq(floor, date) ? floor : add(floor, 1, datePart);
	  }
	  function diff(a, b) {
	    var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'day';
	    var datePart = fixUnit$2(unit);
	    // don't use 'defineComparators' here, as we don't want to mutate the values
	    var dtA = moment(a);
	    var dtB = moment(b);
	    return dtB.diff(dtA, datePart);
	  }
	  function minutes(date) {
	    var dt = moment(date);
	    return dt.minutes();
	  }
	  function firstOfWeek(culture) {
	    var data = culture ? moment.localeData(culture) : moment.localeData();
	    return data ? data.firstDayOfWeek() : 0;
	  }
	  function firstVisibleDay(date) {
	    return moment(date).startOf('month').startOf('week').toDate();
	  }
	  function lastVisibleDay(date) {
	    return moment(date).endOf('month').endOf('week').toDate();
	  }
	  function visibleDays(date) {
	    var current = firstVisibleDay(date);
	    var last = lastVisibleDay(date);
	    var days = [];
	    while (lte(current, last)) {
	      days.push(current);
	      current = add(current, 1, 'd');
	    }
	    return days;
	  }
	  /*** END localized date arithmetic methods with moment ***/

	  /**
	   * Moved from TimeSlots.js, this method overrides the method of the same name
	   * in the localizer.js, using moment to construct the js Date
	   * @param {Date} dt - date to start with
	   * @param {Number} minutesFromMidnight
	   * @param {Number} offset
	   * @returns {Date}
	   */
	  function getSlotDate(dt, minutesFromMidnight, offset) {
	    return moment(dt).startOf('day').minute(minutesFromMidnight + offset).toDate();
	  }

	  // moment will automatically handle DST differences in it's calculations
	  function getTotalMin(start, end) {
	    return diff(start, end, 'minutes');
	  }
	  function getMinutesFromMidnight(start) {
	    var dayStart = moment(start).startOf('day');
	    var day = moment(start);
	    return day.diff(dayStart, 'minutes') + getDayStartDstOffset(start);
	  }

	  // These two are used by DateSlotMetrics
	  function continuesPrior(start, first) {
	    var mStart = moment(start);
	    var mFirst = moment(first);
	    return mStart.isBefore(mFirst, 'day');
	  }
	  function continuesAfter(start, end, last) {
	    var mEnd = moment(end);
	    var mLast = moment(last);
	    return mEnd.isSameOrAfter(mLast, 'minutes');
	  }

	  // These two are used by eventLevels
	  function sortEvents(_ref6) {
	    var _ref6$evtA = _ref6.evtA,
	      aStart = _ref6$evtA.start,
	      aEnd = _ref6$evtA.end,
	      aAllDay = _ref6$evtA.allDay,
	      _ref6$evtB = _ref6.evtB,
	      bStart = _ref6$evtB.start,
	      bEnd = _ref6$evtB.end,
	      bAllDay = _ref6$evtB.allDay;
	    var startSort = +startOf(aStart, 'day') - +startOf(bStart, 'day');
	    var durA = diff(aStart, ceil(aEnd, 'day'), 'day');
	    var durB = diff(bStart, ceil(bEnd, 'day'), 'day');
	    return startSort ||
	    // sort by start Day first
	    Math.max(durB, 1) - Math.max(durA, 1) ||
	    // events spanning multiple days go first
	    !!bAllDay - !!aAllDay ||
	    // then allDay single day events
	    +aStart - +bStart ||
	    // then sort by start time *don't need moment conversion here
	    +aEnd - +bEnd // then sort by end time *don't need moment conversion here either
	    ;
	  }

	  function inEventRange(_ref7) {
	    var _ref7$event = _ref7.event,
	      start = _ref7$event.start,
	      end = _ref7$event.end,
	      _ref7$range = _ref7.range,
	      rangeStart = _ref7$range.start,
	      rangeEnd = _ref7$range.end;
	    var startOfDay = moment(start).startOf('day');
	    var eEnd = moment(end);
	    var rStart = moment(rangeStart);
	    var rEnd = moment(rangeEnd);
	    var startsBeforeEnd = startOfDay.isSameOrBefore(rEnd, 'day');
	    // when the event is zero duration we need to handle a bit differently
	    var sameMin = !startOfDay.isSame(eEnd, 'minutes');
	    var endsAfterStart = sameMin ? eEnd.isAfter(rStart, 'minutes') : eEnd.isSameOrAfter(rStart, 'minutes');
	    return startsBeforeEnd && endsAfterStart;
	  }
	  function isSameDate(date1, date2) {
	    var dt = moment(date1);
	    var dt2 = moment(date2);
	    return dt.isSame(dt2, 'day');
	  }

	  /**
	   * This method, called once in the localizer constructor, is used by eventLevels
	   * 'eventSegments()' to assist in determining the 'span' of the event in the display,
	   * specifically when using a timezone that is greater than the browser native timezone.
	   * @returns number
	   */
	  function browserTZOffset() {
	    /**
	     * Date.prototype.getTimezoneOffset horrifically flips the positive/negative from
	     * what you see in it's string, so we have to jump through some hoops to get a value
	     * we can actually compare.
	     */
	    var dt = new Date();
	    var neg = /-/.test(dt.toString()) ? '-' : '';
	    var dtOffset = dt.getTimezoneOffset();
	    var comparator = Number("".concat(neg).concat(Math.abs(dtOffset)));
	    // moment correctly provides positive/negative offset, as expected
	    var mtOffset = moment().utcOffset();
	    return mtOffset > comparator ? 1 : 0;
	  }
	  return new DateLocalizer({
	    formats: formats$5,
	    firstOfWeek: firstOfWeek,
	    firstVisibleDay: firstVisibleDay,
	    lastVisibleDay: lastVisibleDay,
	    visibleDays: visibleDays,
	    format: function format(value, _format, culture) {
	      return locale(moment(value), culture).format(_format);
	    },
	    lt: lt,
	    lte: lte,
	    gt: gt,
	    gte: gte,
	    eq: eq,
	    neq: neq,
	    merge: merge,
	    inRange: inRange,
	    startOf: startOf,
	    endOf: endOf,
	    range: range,
	    add: add,
	    diff: diff,
	    ceil: ceil,
	    min: min,
	    max: max,
	    minutes: minutes,
	    getSlotDate: getSlotDate,
	    getTimezoneOffset: getTimezoneOffset,
	    getDstOffset: getDstOffset,
	    getTotalMin: getTotalMin,
	    getMinutesFromMidnight: getMinutesFromMidnight,
	    continuesPrior: continuesPrior,
	    continuesAfter: continuesAfter,
	    sortEvents: sortEvents,
	    inEventRange: inEventRange,
	    isSameDate: isSameDate,
	    browserTZOffset: browserTZOffset
	  });
	}

	function die(error) {
	  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }
	  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
	}

	var mockGlobal = {};
	function getGlobal() {
	  if (typeof globalThis !== "undefined") {
	    return globalThis;
	  }
	  if (typeof window !== "undefined") {
	    return window;
	  }
	  if (typeof global$1 !== "undefined") {
	    return global$1;
	  }
	  if (typeof self !== "undefined") {
	    return self;
	  }
	  return mockGlobal;
	}

	// We shorten anything used > 5 times
	var assign$1 = Object.assign;
	var getDescriptor = Object.getOwnPropertyDescriptor;
	var defineProperty$3 = Object.defineProperty;
	var objectPrototype = Object.prototype;
	var EMPTY_ARRAY = [];
	Object.freeze(EMPTY_ARRAY);
	var EMPTY_OBJECT = {};
	Object.freeze(EMPTY_OBJECT);
	var hasProxy = typeof Proxy !== "undefined";
	var plainObjectString = /*#__PURE__*/Object.toString();
	function assertProxies() {
	  if (!hasProxy) {
	    die("Proxy not available");
	  }
	}
	/**
	 * Makes sure that the provided function is invoked at most once.
	 */
	function once(func) {
	  var invoked = false;
	  return function () {
	    if (invoked) {
	      return;
	    }
	    invoked = true;
	    return func.apply(this, arguments);
	  };
	}
	var noop$1 = function noop() {};
	function isFunction$4(fn) {
	  return typeof fn === "function";
	}
	function isStringish(value) {
	  var t = typeof value;
	  switch (t) {
	    case "string":
	    case "symbol":
	    case "number":
	      return true;
	  }
	  return false;
	}
	function isObject$6(value) {
	  return value !== null && typeof value === "object";
	}
	function isPlainObject(value) {
	  if (!isObject$6(value)) {
	    return false;
	  }
	  var proto = Object.getPrototypeOf(value);
	  if (proto == null) {
	    return true;
	  }
	  var protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
	  return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
	}
	// https://stackoverflow.com/a/37865170
	function isGenerator(obj) {
	  var constructor = obj == null ? void 0 : obj.constructor;
	  if (!constructor) {
	    return false;
	  }
	  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) {
	    return true;
	  }
	  return false;
	}
	function addHiddenProp(object, propName, value) {
	  defineProperty$3(object, propName, {
	    enumerable: false,
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}
	function addHiddenFinalProp(object, propName, value) {
	  defineProperty$3(object, propName, {
	    enumerable: false,
	    writable: false,
	    configurable: true,
	    value: value
	  });
	}
	function createInstanceofPredicate(name, theClass) {
	  var propName = "isMobX" + name;
	  theClass.prototype[propName] = true;
	  return function (x) {
	    return isObject$6(x) && x[propName] === true;
	  };
	}
	function isES6Map(thing) {
	  return thing instanceof Map;
	}
	function isES6Set(thing) {
	  return thing instanceof Set;
	}
	var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
	/**
	 * Returns the following: own enumerable keys and symbols.
	 */
	function getPlainObjectKeys(object) {
	  var keys = Object.keys(object);
	  // Not supported in IE, so there are not going to be symbol props anyway...
	  if (!hasGetOwnPropertySymbols) {
	    return keys;
	  }
	  var symbols = Object.getOwnPropertySymbols(object);
	  if (!symbols.length) {
	    return keys;
	  }
	  return [].concat(keys, symbols.filter(function (s) {
	    return objectPrototype.propertyIsEnumerable.call(object, s);
	  }));
	}
	// From Immer utils
	// Returns all own keys, including non-enumerable and symbolic
	var ownKeys$1 = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function (obj) {
	  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
	} : /* istanbul ignore next */Object.getOwnPropertyNames;
	function toPrimitive$1(value) {
	  return value === null ? null : typeof value === "object" ? "" + value : value;
	}
	function hasProp(target, prop) {
	  return objectPrototype.hasOwnProperty.call(target, prop);
	}
	// From Immer utils
	var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
	  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
	  var res = {};
	  // Note: without polyfill for ownKeys, symbols won't be picked up
	  ownKeys$1(target).forEach(function (key) {
	    res[key] = getDescriptor(target, key);
	  });
	  return res;
	};

	function _defineProperties$1(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
	  }
	}
	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties$1(Constructor, staticProps);
	  Object.defineProperty(Constructor, "prototype", {
	    writable: false
	  });
	  return Constructor;
	}
	function _extends() {
	  _extends = Object.assign ? Object.assign.bind() : function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends.apply(this, arguments);
	}
	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  _setPrototypeOf(subClass, superClass);
	}
	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };
	  return _setPrototypeOf(o, p);
	}
	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	  return self;
	}
	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}
	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;
	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	  return arr2;
	}
	function _createForOfIteratorHelperLoose(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
	  if (it) return (it = it.call(o)).next.bind(it);
	  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	    if (it) o = it;
	    var i = 0;
	    return function () {
	      if (i >= o.length) return {
	        done: true
	      };
	      return {
	        done: false,
	        value: o[i++]
	      };
	    };
	  }
	  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	function _toPrimitive(input, hint) {
	  if (typeof input !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];
	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (typeof res !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (hint === "string" ? String : Number)(input);
	}
	function _toPropertyKey(arg) {
	  var key = _toPrimitive(arg, "string");
	  return typeof key === "symbol" ? key : String(key);
	}

	var storedAnnotationsSymbol = /*#__PURE__*/Symbol("mobx-stored-annotations");
	/**
	 * Creates a function that acts as
	 * - decorator
	 * - annotation object
	 */
	function createDecoratorAnnotation(annotation) {
	  function decorator(target, property) {
	    storeAnnotation(target, property, annotation);
	  }
	  return Object.assign(decorator, annotation);
	}
	/**
	 * Stores annotation to prototype,
	 * so it can be inspected later by `makeObservable` called from constructor
	 */
	function storeAnnotation(prototype, key, annotation) {
	  if (!hasProp(prototype, storedAnnotationsSymbol)) {
	    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
	  }
	  // Ignore override
	  if (!isOverride(annotation)) {
	    prototype[storedAnnotationsSymbol][key] = annotation;
	  }
	}
	/**
	 * Collects annotations from prototypes and stores them on target (instance)
	 */
	function collectStoredAnnotations(target) {
	  if (!hasProp(target, storedAnnotationsSymbol)) {
	    // We need a copy as we will remove annotation from the list once it's applied.
	    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
	  }
	  return target[storedAnnotationsSymbol];
	}

	var $mobx = /*#__PURE__*/Symbol("mobx administration");
	var Atom = /*#__PURE__*/function () {
	  // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed

	  /**
	   * Create a new atom. For debugging purposes it is recommended to give it a name.
	   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
	   */
	  function Atom(name_) {
	    if (name_ === void 0) {
	      name_ = "Atom";
	    }
	    this.name_ = void 0;
	    this.isPendingUnobservation_ = false;
	    this.isBeingObserved_ = false;
	    this.observers_ = new Set();
	    this.diffValue_ = 0;
	    this.lastAccessedBy_ = 0;
	    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
	    this.onBOL = void 0;
	    this.onBUOL = void 0;
	    this.name_ = name_;
	  }
	  // onBecomeObservedListeners
	  var _proto = Atom.prototype;
	  _proto.onBO = function onBO() {
	    if (this.onBOL) {
	      this.onBOL.forEach(function (listener) {
	        return listener();
	      });
	    }
	  };
	  _proto.onBUO = function onBUO() {
	    if (this.onBUOL) {
	      this.onBUOL.forEach(function (listener) {
	        return listener();
	      });
	    }
	  }
	  /**
	   * Invoke this method to notify mobx that your atom has been used somehow.
	   * Returns true if there is currently a reactive context.
	   */;
	  _proto.reportObserved = function reportObserved$1() {
	    return reportObserved(this);
	  }
	  /**
	   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
	   */;
	  _proto.reportChanged = function reportChanged() {
	    startBatch();
	    propagateChanged(this);
	    // We could update state version only at the end of batch,
	    // but we would still have to switch some global flag here to signal a change.
	    globalState.stateVersion = globalState.stateVersion < Number.MAX_SAFE_INTEGER ? globalState.stateVersion + 1 : Number.MIN_SAFE_INTEGER;
	    endBatch();
	  };
	  _proto.toString = function toString() {
	    return this.name_;
	  };
	  return Atom;
	}();
	var isAtom = /*#__PURE__*/createInstanceofPredicate("Atom", Atom);
	function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
	  if (onBecomeObservedHandler === void 0) {
	    onBecomeObservedHandler = noop$1;
	  }
	  if (onBecomeUnobservedHandler === void 0) {
	    onBecomeUnobservedHandler = noop$1;
	  }
	  var atom = new Atom(name);
	  // default `noop` listener will not initialize the hook Set
	  if (onBecomeObservedHandler !== noop$1) {
	    onBecomeObserved(atom, onBecomeObservedHandler);
	  }
	  if (onBecomeUnobservedHandler !== noop$1) {
	    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
	  }
	  return atom;
	}

	function identityComparer(a, b) {
	  return a === b;
	}
	function structuralComparer(a, b) {
	  return deepEqual(a, b);
	}
	function shallowComparer(a, b) {
	  return deepEqual(a, b, 1);
	}
	function defaultComparer(a, b) {
	  if (Object.is) {
	    return Object.is(a, b);
	  }
	  return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;
	}
	var comparer = {
	  identity: identityComparer,
	  structural: structuralComparer,
	  "default": defaultComparer,
	  shallow: shallowComparer
	};

	function deepEnhancer(v, _, name) {
	  // it is an observable already, done
	  if (isObservable(v)) {
	    return v;
	  }
	  // something that can be converted and mutated?
	  if (Array.isArray(v)) {
	    return observable.array(v, {
	      name: name
	    });
	  }
	  if (isPlainObject(v)) {
	    return observable.object(v, undefined, {
	      name: name
	    });
	  }
	  if (isES6Map(v)) {
	    return observable.map(v, {
	      name: name
	    });
	  }
	  if (isES6Set(v)) {
	    return observable.set(v, {
	      name: name
	    });
	  }
	  if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
	    if (isGenerator(v)) {
	      return flow(v);
	    } else {
	      return autoAction(name, v);
	    }
	  }
	  return v;
	}
	function shallowEnhancer(v, _, name) {
	  if (v === undefined || v === null) {
	    return v;
	  }
	  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {
	    return v;
	  }
	  if (Array.isArray(v)) {
	    return observable.array(v, {
	      name: name,
	      deep: false
	    });
	  }
	  if (isPlainObject(v)) {
	    return observable.object(v, undefined, {
	      name: name,
	      deep: false
	    });
	  }
	  if (isES6Map(v)) {
	    return observable.map(v, {
	      name: name,
	      deep: false
	    });
	  }
	  if (isES6Set(v)) {
	    return observable.set(v, {
	      name: name,
	      deep: false
	    });
	  }
	}
	function referenceEnhancer(newValue) {
	  // never turn into an observable
	  return newValue;
	}
	function refStructEnhancer(v, oldValue) {
	  if (deepEqual(v, oldValue)) {
	    return oldValue;
	  }
	  return v;
	}

	var OVERRIDE = "override";
	function isOverride(annotation) {
	  return annotation.annotationType_ === OVERRIDE;
	}

	function createActionAnnotation(name, options) {
	  return {
	    annotationType_: name,
	    options_: options,
	    make_: make_$1,
	    extend_: extend_$1
	  };
	}
	function make_$1(adm, key, descriptor, source) {
	  var _this$options_;
	  // bound
	  if ((_this$options_ = this.options_) != null && _this$options_.bound) {
	    return this.extend_(adm, key, descriptor, false) === null ? 0 /* Cancel */ : 1 /* Break */;
	  }
	  // own
	  if (source === adm.target_) {
	    return this.extend_(adm, key, descriptor, false) === null ? 0 /* Cancel */ : 2 /* Continue */;
	  }
	  // prototype
	  if (isAction(descriptor.value)) {
	    // A prototype could have been annotated already by other constructor,
	    // rest of the proto chain must be annotated already
	    return 1 /* Break */;
	  }

	  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
	  defineProperty$3(source, key, actionDescriptor);
	  return 2 /* Continue */;
	}

	function extend_$1(adm, key, descriptor, proxyTrap) {
	  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
	  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
	}
	function assertActionDescriptor(adm, _ref, key, _ref2) {
	  _ref.annotationType_;
	  _ref2.value;
	}
	function createActionDescriptor(adm, annotation, key, descriptor,
	// provides ability to disable safeDescriptors for prototypes
	safeDescriptors) {
	  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
	  if (safeDescriptors === void 0) {
	    safeDescriptors = globalState.safeDescriptors;
	  }
	  assertActionDescriptor(adm, annotation, key, descriptor);
	  var value = descriptor.value;
	  if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
	    var _adm$proxy_;
	    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
	  }
	  return {
	    value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false,
	    // https://github.com/mobxjs/mobx/discussions/3140
	    (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : undefined),
	    // Non-configurable for classes
	    // prevents accidental field redefinition in subclass
	    configurable: safeDescriptors ? adm.isPlainObject_ : true,
	    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
	    enumerable: false,
	    // Non-obsevable, therefore non-writable
	    // Also prevents rewriting in subclass constructor
	    writable: safeDescriptors ? false : true
	  };
	}

	function createFlowAnnotation(name, options) {
	  return {
	    annotationType_: name,
	    options_: options,
	    make_: make_$2,
	    extend_: extend_$2
	  };
	}
	function make_$2(adm, key, descriptor, source) {
	  var _this$options_;
	  // own
	  if (source === adm.target_) {
	    return this.extend_(adm, key, descriptor, false) === null ? 0 /* Cancel */ : 2 /* Continue */;
	  }
	  // prototype
	  // bound - must annotate protos to support super.flow()
	  if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
	    if (this.extend_(adm, key, descriptor, false) === null) {
	      return 0 /* Cancel */;
	    }
	  }

	  if (isFlow(descriptor.value)) {
	    // A prototype could have been annotated already by other constructor,
	    // rest of the proto chain must be annotated already
	    return 1 /* Break */;
	  }

	  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
	  defineProperty$3(source, key, flowDescriptor);
	  return 2 /* Continue */;
	}

	function extend_$2(adm, key, descriptor, proxyTrap) {
	  var _this$options_2;
	  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
	  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
	}
	function assertFlowDescriptor(adm, _ref, key, _ref2) {
	  _ref.annotationType_;
	  _ref2.value;
	}
	function createFlowDescriptor(adm, annotation, key, descriptor, bound,
	// provides ability to disable safeDescriptors for prototypes
	safeDescriptors) {
	  if (safeDescriptors === void 0) {
	    safeDescriptors = globalState.safeDescriptors;
	  }
	  assertFlowDescriptor(adm, annotation, key, descriptor);
	  var value = descriptor.value;
	  // In case of flow.bound, the descriptor can be from already annotated prototype
	  if (!isFlow(value)) {
	    value = flow(value);
	  }
	  if (bound) {
	    var _adm$proxy_;
	    // We do not keep original function around, so we bind the existing flow
	    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
	    // This is normally set by `flow`, but `bind` returns new function...
	    value.isMobXFlow = true;
	  }
	  return {
	    value: value,
	    // Non-configurable for classes
	    // prevents accidental field redefinition in subclass
	    configurable: safeDescriptors ? adm.isPlainObject_ : true,
	    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
	    enumerable: false,
	    // Non-obsevable, therefore non-writable
	    // Also prevents rewriting in subclass constructor
	    writable: safeDescriptors ? false : true
	  };
	}

	function createComputedAnnotation(name, options) {
	  return {
	    annotationType_: name,
	    options_: options,
	    make_: make_$3,
	    extend_: extend_$3
	  };
	}
	function make_$3(adm, key, descriptor) {
	  return this.extend_(adm, key, descriptor, false) === null ? 0 /* Cancel */ : 1 /* Break */;
	}

	function extend_$3(adm, key, descriptor, proxyTrap) {
	  assertComputedDescriptor(adm, this, key, descriptor);
	  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
	    get: descriptor.get,
	    set: descriptor.set
	  }), proxyTrap);
	}
	function assertComputedDescriptor(adm, _ref, key, _ref2) {
	  _ref.annotationType_;
	  _ref2.get;
	}

	function createObservableAnnotation(name, options) {
	  return {
	    annotationType_: name,
	    options_: options,
	    make_: make_$4,
	    extend_: extend_$4
	  };
	}
	function make_$4(adm, key, descriptor) {
	  return this.extend_(adm, key, descriptor, false) === null ? 0 /* Cancel */ : 1 /* Break */;
	}

	function extend_$4(adm, key, descriptor, proxyTrap) {
	  var _this$options_$enhanc, _this$options_;
	  assertObservableDescriptor(adm, this);
	  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
	}
	function assertObservableDescriptor(adm, _ref, key, descriptor) {
	  _ref.annotationType_;
	}

	var AUTO = "true";
	var autoAnnotation = /*#__PURE__*/createAutoAnnotation();
	function createAutoAnnotation(options) {
	  return {
	    annotationType_: AUTO,
	    options_: options,
	    make_: make_$5,
	    extend_: extend_$5
	  };
	}
	function make_$5(adm, key, descriptor, source) {
	  var _this$options_3, _this$options_4;
	  // getter -> computed
	  if (descriptor.get) {
	    return computed.make_(adm, key, descriptor, source);
	  }
	  // lone setter -> action setter
	  if (descriptor.set) {
	    // TODO make action applicable to setter and delegate to action.make_
	    var set = createAction(key.toString(), descriptor.set);
	    // own
	    if (source === adm.target_) {
	      return adm.defineProperty_(key, {
	        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
	        set: set
	      }) === null ? 0 /* Cancel */ : 2 /* Continue */;
	    }
	    // proto
	    defineProperty$3(source, key, {
	      configurable: true,
	      set: set
	    });
	    return 2 /* Continue */;
	  }
	  // function on proto -> autoAction/flow
	  if (source !== adm.target_ && typeof descriptor.value === "function") {
	    var _this$options_2;
	    if (isGenerator(descriptor.value)) {
	      var _this$options_;
	      var flowAnnotation = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
	      return flowAnnotation.make_(adm, key, descriptor, source);
	    }
	    var actionAnnotation = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
	    return actionAnnotation.make_(adm, key, descriptor, source);
	  }
	  // other -> observable
	  // Copy props from proto as well, see test:
	  // "decorate should work with Object.create"
	  var observableAnnotation = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
	  // if function respect autoBind option
	  if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
	    var _adm$proxy_;
	    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
	  }
	  return observableAnnotation.make_(adm, key, descriptor, source);
	}
	function extend_$5(adm, key, descriptor, proxyTrap) {
	  var _this$options_5, _this$options_6;
	  // getter -> computed
	  if (descriptor.get) {
	    return computed.extend_(adm, key, descriptor, proxyTrap);
	  }
	  // lone setter -> action setter
	  if (descriptor.set) {
	    // TODO make action applicable to setter and delegate to action.extend_
	    return adm.defineProperty_(key, {
	      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
	      set: createAction(key.toString(), descriptor.set)
	    }, proxyTrap);
	  }
	  // other -> observable
	  // if function respect autoBind option
	  if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
	    var _adm$proxy_2;
	    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
	  }
	  var observableAnnotation = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
	  return observableAnnotation.extend_(adm, key, descriptor, proxyTrap);
	}

	var OBSERVABLE = "observable";
	var OBSERVABLE_REF = "observable.ref";
	var OBSERVABLE_SHALLOW = "observable.shallow";
	var OBSERVABLE_STRUCT = "observable.struct";
	// Predefined bags of create observable options, to avoid allocating temporarily option objects
	// in the majority of cases
	var defaultCreateObservableOptions = {
	  deep: true,
	  name: undefined,
	  defaultDecorator: undefined,
	  proxy: true
	};
	Object.freeze(defaultCreateObservableOptions);
	function asCreateObservableOptions(thing) {
	  return thing || defaultCreateObservableOptions;
	}
	var observableAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE);
	var observableRefAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_REF, {
	  enhancer: referenceEnhancer
	});
	var observableShallowAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_SHALLOW, {
	  enhancer: shallowEnhancer
	});
	var observableStructAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_STRUCT, {
	  enhancer: refStructEnhancer
	});
	var observableDecoratorAnnotation = /*#__PURE__*/createDecoratorAnnotation(observableAnnotation);
	function getEnhancerFromOptions(options) {
	  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
	}
	function getAnnotationFromOptions(options) {
	  var _options$defaultDecor;
	  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : undefined;
	}
	function getEnhancerFromAnnotation(annotation) {
	  var _annotation$options_$, _annotation$options_;
	  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
	}
	/**
	 * Turns an object, array or function into a reactive structure.
	 * @param v the value which should become observable.
	 */
	function createObservable(v, arg2, arg3) {
	  // @observable someProp;
	  if (isStringish(arg2)) {
	    storeAnnotation(v, arg2, observableAnnotation);
	    return;
	  }
	  // already observable - ignore
	  if (isObservable(v)) {
	    return v;
	  }
	  // plain object
	  if (isPlainObject(v)) {
	    return observable.object(v, arg2, arg3);
	  }
	  // Array
	  if (Array.isArray(v)) {
	    return observable.array(v, arg2);
	  }
	  // Map
	  if (isES6Map(v)) {
	    return observable.map(v, arg2);
	  }
	  // Set
	  if (isES6Set(v)) {
	    return observable.set(v, arg2);
	  }
	  // other object - ignore
	  if (typeof v === "object" && v !== null) {
	    return v;
	  }
	  // anything else
	  return observable.box(v, arg2);
	}
	assign$1(createObservable, observableDecoratorAnnotation);
	var observableFactories = {
	  box: function box(value, options) {
	    var o = asCreateObservableOptions(options);
	    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
	  },
	  array: function array(initialValues, options) {
	    var o = asCreateObservableOptions(options);
	    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
	  },
	  map: function map(initialValues, options) {
	    var o = asCreateObservableOptions(options);
	    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
	  },
	  set: function set(initialValues, options) {
	    var o = asCreateObservableOptions(options);
	    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
	  },
	  object: function object(props, decorators, options) {
	    return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
	  },
	  ref: /*#__PURE__*/createDecoratorAnnotation(observableRefAnnotation),
	  shallow: /*#__PURE__*/createDecoratorAnnotation(observableShallowAnnotation),
	  deep: observableDecoratorAnnotation,
	  struct: /*#__PURE__*/createDecoratorAnnotation(observableStructAnnotation)
	};
	// eslint-disable-next-line
	var observable = /*#__PURE__*/assign$1(createObservable, observableFactories);

	var COMPUTED = "computed";
	var COMPUTED_STRUCT = "computed.struct";
	var computedAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED);
	var computedStructAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED_STRUCT, {
	  equals: comparer.structural
	});
	/**
	 * Decorator for class properties: @computed get value() { return expr; }.
	 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
	 */
	var computed = function computed(arg1, arg2) {
	  if (isStringish(arg2)) {
	    // @computed
	    return storeAnnotation(arg1, arg2, computedAnnotation);
	  }
	  if (isPlainObject(arg1)) {
	    // @computed({ options })
	    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
	  }
	  var opts = isPlainObject(arg2) ? arg2 : {};
	  opts.get = arg1;
	  opts.name || (opts.name = arg1.name || ""); /* for generated name */
	  return new ComputedValue(opts);
	};
	Object.assign(computed, computedAnnotation);
	computed.struct = /*#__PURE__*/createDecoratorAnnotation(computedStructAnnotation);

	var _getDescriptor$config, _getDescriptor;
	// we don't use globalState for these in order to avoid possible issues with multiple
	// mobx versions
	var currentActionId = 0;
	var nextActionId = 1;
	var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /*#__PURE__*/getDescriptor(function () {}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
	// we can safely recycle this object
	var tmpNameDescriptor = {
	  value: "action",
	  configurable: true,
	  writable: false,
	  enumerable: false
	};
	function createAction(actionName, fn, autoAction, ref) {
	  if (autoAction === void 0) {
	    autoAction = false;
	  }
	  function res() {
	    return executeAction(actionName, autoAction, fn, ref || this, arguments);
	  }
	  res.isMobxAction = true;
	  if (isFunctionNameConfigurable) {
	    tmpNameDescriptor.value = actionName;
	    defineProperty$3(res, "name", tmpNameDescriptor);
	  }
	  return res;
	}
	function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
	  var runInfo = _startAction(actionName, canRunAsDerivation);
	  try {
	    return fn.apply(scope, args);
	  } catch (err) {
	    runInfo.error_ = err;
	    throw err;
	  } finally {
	    _endAction(runInfo);
	  }
	}
	function _startAction(actionName, canRunAsDerivation,
	// true for autoAction
	scope, args) {
	  var notifySpy_ = "production" !== "production"  ;
	  var startTime_ = 0;
	  var prevDerivation_ = globalState.trackingDerivation;
	  var runAsAction = !canRunAsDerivation || !prevDerivation_;
	  startBatch();
	  var prevAllowStateChanges_ = globalState.allowStateChanges; // by default preserve previous allow
	  if (runAsAction) {
	    untrackedStart();
	    prevAllowStateChanges_ = allowStateChangesStart(true);
	  }
	  var prevAllowStateReads_ = allowStateReadsStart(true);
	  var runInfo = {
	    runAsAction_: runAsAction,
	    prevDerivation_: prevDerivation_,
	    prevAllowStateChanges_: prevAllowStateChanges_,
	    prevAllowStateReads_: prevAllowStateReads_,
	    notifySpy_: notifySpy_,
	    startTime_: startTime_,
	    actionId_: nextActionId++,
	    parentActionId_: currentActionId
	  };
	  currentActionId = runInfo.actionId_;
	  return runInfo;
	}
	function _endAction(runInfo) {
	  if (currentActionId !== runInfo.actionId_) {
	    die(30);
	  }
	  currentActionId = runInfo.parentActionId_;
	  if (runInfo.error_ !== undefined) {
	    globalState.suppressReactionErrors = true;
	  }
	  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
	  allowStateReadsEnd(runInfo.prevAllowStateReads_);
	  endBatch();
	  if (runInfo.runAsAction_) {
	    untrackedEnd(runInfo.prevDerivation_);
	  }
	  globalState.suppressReactionErrors = false;
	}
	function allowStateChanges(allowStateChanges, func) {
	  var prev = allowStateChangesStart(allowStateChanges);
	  try {
	    return func();
	  } finally {
	    allowStateChangesEnd(prev);
	  }
	}
	function allowStateChangesStart(allowStateChanges) {
	  var prev = globalState.allowStateChanges;
	  globalState.allowStateChanges = allowStateChanges;
	  return prev;
	}
	function allowStateChangesEnd(prev) {
	  globalState.allowStateChanges = prev;
	}

	var _Symbol$toPrimitive;
	_Symbol$toPrimitive = Symbol.toPrimitive;
	var ObservableValue = /*#__PURE__*/function (_Atom) {
	  _inheritsLoose(ObservableValue, _Atom);
	  function ObservableValue(value, enhancer, name_, notifySpy, equals) {
	    var _this;
	    if (name_ === void 0) {
	      name_ = "ObservableValue";
	    }
	    if (equals === void 0) {
	      equals = comparer["default"];
	    }
	    _this = _Atom.call(this, name_) || this;
	    _this.enhancer = void 0;
	    _this.name_ = void 0;
	    _this.equals = void 0;
	    _this.hasUnreportedChange_ = false;
	    _this.interceptors_ = void 0;
	    _this.changeListeners_ = void 0;
	    _this.value_ = void 0;
	    _this.dehancer = void 0;
	    _this.enhancer = enhancer;
	    _this.name_ = name_;
	    _this.equals = equals;
	    _this.value_ = enhancer(value, undefined, name_);
	    return _this;
	  }
	  var _proto = ObservableValue.prototype;
	  _proto.dehanceValue = function dehanceValue(value) {
	    if (this.dehancer !== undefined) {
	      return this.dehancer(value);
	    }
	    return value;
	  };
	  _proto.set = function set(newValue) {
	    this.value_;
	    newValue = this.prepareNewValue_(newValue);
	    if (newValue !== globalState.UNCHANGED) {
	      this.setNewValue_(newValue);
	    }
	  };
	  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
	    if (hasInterceptors(this)) {
	      var change = interceptChange(this, {
	        object: this,
	        type: UPDATE,
	        newValue: newValue
	      });
	      if (!change) {
	        return globalState.UNCHANGED;
	      }
	      newValue = change.newValue;
	    }
	    // apply modifier
	    newValue = this.enhancer(newValue, this.value_, this.name_);
	    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
	  };
	  _proto.setNewValue_ = function setNewValue_(newValue) {
	    var oldValue = this.value_;
	    this.value_ = newValue;
	    this.reportChanged();
	    if (hasListeners(this)) {
	      notifyListeners(this, {
	        type: UPDATE,
	        object: this,
	        newValue: newValue,
	        oldValue: oldValue
	      });
	    }
	  };
	  _proto.get = function get() {
	    this.reportObserved();
	    return this.dehanceValue(this.value_);
	  };
	  _proto.intercept_ = function intercept_(handler) {
	    return registerInterceptor(this, handler);
	  };
	  _proto.observe_ = function observe_(listener, fireImmediately) {
	    if (fireImmediately) {
	      listener({
	        observableKind: "value",
	        debugObjectName: this.name_,
	        object: this,
	        type: UPDATE,
	        newValue: this.value_,
	        oldValue: undefined
	      });
	    }
	    return registerListener(this, listener);
	  };
	  _proto.raw = function raw() {
	    // used by MST ot get undehanced value
	    return this.value_;
	  };
	  _proto.toJSON = function toJSON() {
	    return this.get();
	  };
	  _proto.toString = function toString() {
	    return this.name_ + "[" + this.value_ + "]";
	  };
	  _proto.valueOf = function valueOf() {
	    return toPrimitive$1(this.get());
	  };
	  _proto[_Symbol$toPrimitive] = function () {
	    return this.valueOf();
	  };
	  return ObservableValue;
	}(Atom);
	var isObservableValue = /*#__PURE__*/createInstanceofPredicate("ObservableValue", ObservableValue);

	var _Symbol$toPrimitive$1;
	/**
	 * A node in the state dependency root that observes other nodes, and can be observed itself.
	 *
	 * ComputedValue will remember the result of the computation for the duration of the batch, or
	 * while being observed.
	 *
	 * During this time it will recompute only when one of its direct dependencies changed,
	 * but only when it is being accessed with `ComputedValue.get()`.
	 *
	 * Implementation description:
	 * 1. First time it's being accessed it will compute and remember result
	 *    give back remembered result until 2. happens
	 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
	 * 3. When it's being accessed, recompute if any shallow dependency changed.
	 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
	 *    go to step 2. either way
	 *
	 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
	 */
	_Symbol$toPrimitive$1 = Symbol.toPrimitive;
	var ComputedValue = /*#__PURE__*/function () {
	  // nodes we are looking at. Our value depends on these nodes
	  // during tracking it's an array with new observed observers

	  // to check for cycles

	  // N.B: unminified as it is used by MST

	  /**
	   * Create a new computed value based on a function expression.
	   *
	   * The `name` property is for debug purposes only.
	   *
	   * The `equals` property specifies the comparer function to use to determine if a newly produced
	   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
	   * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.
	   * Structural comparison can be convenient if you always produce a new aggregated object and
	   * don't want to notify observers if it is structurally the same.
	   * This is useful for working with vectors, mouse coordinates etc.
	   */
	  function ComputedValue(options) {
	    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
	    this.observing_ = [];
	    this.newObserving_ = null;
	    this.isBeingObserved_ = false;
	    this.isPendingUnobservation_ = false;
	    this.observers_ = new Set();
	    this.diffValue_ = 0;
	    this.runId_ = 0;
	    this.lastAccessedBy_ = 0;
	    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
	    this.unboundDepsCount_ = 0;
	    this.value_ = new CaughtException(null);
	    this.name_ = void 0;
	    this.triggeredBy_ = void 0;
	    this.isComputing_ = false;
	    this.isRunningSetter_ = false;
	    this.derivation = void 0;
	    this.setter_ = void 0;
	    this.isTracing_ = TraceMode.NONE;
	    this.scope_ = void 0;
	    this.equals_ = void 0;
	    this.requiresReaction_ = void 0;
	    this.keepAlive_ = void 0;
	    this.onBOL = void 0;
	    this.onBUOL = void 0;
	    if (!options.get) {
	      die(31);
	    }
	    this.derivation = options.get;
	    this.name_ = options.name || ("ComputedValue");
	    if (options.set) {
	      this.setter_ = createAction("ComputedValue-setter", options.set);
	    }
	    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
	    this.scope_ = options.context;
	    this.requiresReaction_ = options.requiresReaction;
	    this.keepAlive_ = !!options.keepAlive;
	  }
	  var _proto = ComputedValue.prototype;
	  _proto.onBecomeStale_ = function onBecomeStale_() {
	    propagateMaybeChanged(this);
	  };
	  _proto.onBO = function onBO() {
	    if (this.onBOL) {
	      this.onBOL.forEach(function (listener) {
	        return listener();
	      });
	    }
	  };
	  _proto.onBUO = function onBUO() {
	    if (this.onBUOL) {
	      this.onBUOL.forEach(function (listener) {
	        return listener();
	      });
	    }
	  }
	  /**
	   * Returns the current value of this computed value.
	   * Will evaluate its computation first if needed.
	   */;
	  _proto.get = function get() {
	    if (this.isComputing_) {
	      die(32, this.name_, this.derivation);
	    }
	    if (globalState.inBatch === 0 &&
	    // !globalState.trackingDerivatpion &&
	    this.observers_.size === 0 && !this.keepAlive_) {
	      if (shouldCompute(this)) {
	        this.warnAboutUntrackedRead_();
	        startBatch(); // See perf test 'computed memoization'
	        this.value_ = this.computeValue_(false);
	        endBatch();
	      }
	    } else {
	      reportObserved(this);
	      if (shouldCompute(this)) {
	        var prevTrackingContext = globalState.trackingContext;
	        if (this.keepAlive_ && !prevTrackingContext) {
	          globalState.trackingContext = this;
	        }
	        if (this.trackAndCompute()) {
	          propagateChangeConfirmed(this);
	        }
	        globalState.trackingContext = prevTrackingContext;
	      }
	    }
	    var result = this.value_;
	    if (isCaughtException(result)) {
	      throw result.cause;
	    }
	    return result;
	  };
	  _proto.set = function set(value) {
	    if (this.setter_) {
	      if (this.isRunningSetter_) {
	        die(33, this.name_);
	      }
	      this.isRunningSetter_ = true;
	      try {
	        this.setter_.call(this.scope_, value);
	      } finally {
	        this.isRunningSetter_ = false;
	      }
	    } else {
	      die(34, this.name_);
	    }
	  };
	  _proto.trackAndCompute = function trackAndCompute() {
	    // N.B: unminified as it is used by MST
	    var oldValue = this.value_;
	    var wasSuspended = /* see #1208 */this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
	    var newValue = this.computeValue_(true);
	    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
	    if (changed) {
	      this.value_ = newValue;
	    }
	    return changed;
	  };
	  _proto.computeValue_ = function computeValue_(track) {
	    this.isComputing_ = true;
	    // don't allow state changes during computation
	    var prev = allowStateChangesStart(false);
	    var res;
	    if (track) {
	      res = trackDerivedFunction(this, this.derivation, this.scope_);
	    } else {
	      if (globalState.disableErrorBoundaries === true) {
	        res = this.derivation.call(this.scope_);
	      } else {
	        try {
	          res = this.derivation.call(this.scope_);
	        } catch (e) {
	          res = new CaughtException(e);
	        }
	      }
	    }
	    allowStateChangesEnd(prev);
	    this.isComputing_ = false;
	    return res;
	  };
	  _proto.suspend_ = function suspend_() {
	    if (!this.keepAlive_) {
	      clearObserving(this);
	      this.value_ = undefined; // don't hold on to computed value!
	    }
	  };
	  _proto.observe_ = function observe_(listener, fireImmediately) {
	    var _this = this;
	    var firstTime = true;
	    var prevValue = undefined;
	    return autorun(function () {
	      // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place
	      var newValue = _this.get();
	      if (!firstTime || fireImmediately) {
	        var prevU = untrackedStart();
	        listener({
	          observableKind: "computed",
	          debugObjectName: _this.name_,
	          type: UPDATE,
	          object: _this,
	          newValue: newValue,
	          oldValue: prevValue
	        });
	        untrackedEnd(prevU);
	      }
	      firstTime = false;
	      prevValue = newValue;
	    });
	  };
	  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
	    {
	      return;
	    }
	  };
	  _proto.toString = function toString() {
	    return this.name_ + "[" + this.derivation.toString() + "]";
	  };
	  _proto.valueOf = function valueOf() {
	    return toPrimitive$1(this.get());
	  };
	  _proto[_Symbol$toPrimitive$1] = function () {
	    return this.valueOf();
	  };
	  return ComputedValue;
	}();
	var isComputedValue = /*#__PURE__*/createInstanceofPredicate("ComputedValue", ComputedValue);

	var IDerivationState_;
	(function (IDerivationState_) {
	  // before being run or (outside batch and not being observed)
	  // at this point derivation is not holding any data about dependency tree
	  IDerivationState_[IDerivationState_["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
	  // no shallow dependency changed since last computation
	  // won't recalculate derivation
	  // this is what makes mobx fast
	  IDerivationState_[IDerivationState_["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
	  // some deep dependency changed, but don't know if shallow dependency changed
	  // will require to check first if UP_TO_DATE or POSSIBLY_STALE
	  // currently only ComputedValue will propagate POSSIBLY_STALE
	  //
	  // having this state is second big optimization:
	  // don't have to recompute on every dependency change, but only when it's needed
	  IDerivationState_[IDerivationState_["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
	  // A shallow dependency has changed since last computation and the derivation
	  // will need to recompute when it's needed next.
	  IDerivationState_[IDerivationState_["STALE_"] = 2] = "STALE_";
	})(IDerivationState_ || (IDerivationState_ = {}));
	var TraceMode;
	(function (TraceMode) {
	  TraceMode[TraceMode["NONE"] = 0] = "NONE";
	  TraceMode[TraceMode["LOG"] = 1] = "LOG";
	  TraceMode[TraceMode["BREAK"] = 2] = "BREAK";
	})(TraceMode || (TraceMode = {}));
	var CaughtException = function CaughtException(cause) {
	  this.cause = void 0;
	  this.cause = cause;
	  // Empty
	};

	function isCaughtException(e) {
	  return e instanceof CaughtException;
	}
	/**
	 * Finds out whether any dependency of the derivation has actually changed.
	 * If dependenciesState is 1 then it will recalculate dependencies,
	 * if any dependency changed it will propagate it by changing dependenciesState to 2.
	 *
	 * By iterating over the dependencies in the same order that they were reported and
	 * stopping on the first change, all the recalculations are only called for ComputedValues
	 * that will be tracked by derivation. That is because we assume that if the first x
	 * dependencies of the derivation doesn't change then the derivation should run the same way
	 * up until accessing x-th dependency.
	 */
	function shouldCompute(derivation) {
	  switch (derivation.dependenciesState_) {
	    case IDerivationState_.UP_TO_DATE_:
	      return false;
	    case IDerivationState_.NOT_TRACKING_:
	    case IDerivationState_.STALE_:
	      return true;
	    case IDerivationState_.POSSIBLY_STALE_:
	      {
	        // state propagation can occur outside of action/reactive context #2195
	        var prevAllowStateReads = allowStateReadsStart(true);
	        var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.
	        var obs = derivation.observing_,
	          l = obs.length;
	        for (var i = 0; i < l; i++) {
	          var obj = obs[i];
	          if (isComputedValue(obj)) {
	            if (globalState.disableErrorBoundaries) {
	              obj.get();
	            } else {
	              try {
	                obj.get();
	              } catch (e) {
	                // we are not interested in the value *or* exception at this moment, but if there is one, notify all
	                untrackedEnd(prevUntracked);
	                allowStateReadsEnd(prevAllowStateReads);
	                return true;
	              }
	            }
	            // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
	            // and `derivation` is an observer of `obj`
	            // invariantShouldCompute(derivation)
	            if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
	              untrackedEnd(prevUntracked);
	              allowStateReadsEnd(prevAllowStateReads);
	              return true;
	            }
	          }
	        }
	        changeDependenciesStateTo0(derivation);
	        untrackedEnd(prevUntracked);
	        allowStateReadsEnd(prevAllowStateReads);
	        return false;
	      }
	  }
	}

	function checkIfStateModificationsAreAllowed(atom) {
	  {
	    return;
	  }
	}
	/**
	 * Executes the provided function `f` and tracks which observables are being accessed.
	 * The tracking information is stored on the `derivation` object and the derivation is registered
	 * as observer of any of the accessed observables.
	 */
	function trackDerivedFunction(derivation, f, context) {
	  var prevAllowStateReads = allowStateReadsStart(true);
	  // pre allocate array allocation + room for variation in deps
	  // array will be trimmed by bindDependencies
	  changeDependenciesStateTo0(derivation);
	  derivation.newObserving_ = new Array(derivation.observing_.length + 100);
	  derivation.unboundDepsCount_ = 0;
	  derivation.runId_ = ++globalState.runId;
	  var prevTracking = globalState.trackingDerivation;
	  globalState.trackingDerivation = derivation;
	  globalState.inBatch++;
	  var result;
	  if (globalState.disableErrorBoundaries === true) {
	    result = f.call(context);
	  } else {
	    try {
	      result = f.call(context);
	    } catch (e) {
	      result = new CaughtException(e);
	    }
	  }
	  globalState.inBatch--;
	  globalState.trackingDerivation = prevTracking;
	  bindDependencies(derivation);
	  allowStateReadsEnd(prevAllowStateReads);
	  return result;
	}
	/**
	 * diffs newObserving with observing.
	 * update observing to be newObserving with unique observables
	 * notify observers that become observed/unobserved
	 */
	function bindDependencies(derivation) {
	  // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
	  var prevObserving = derivation.observing_;
	  var observing = derivation.observing_ = derivation.newObserving_;
	  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
	  // Go through all new observables and check diffValue: (this list can contain duplicates):
	  //   0: first occurrence, change to 1 and keep it
	  //   1: extra occurrence, drop it
	  var i0 = 0,
	    l = derivation.unboundDepsCount_;
	  for (var i = 0; i < l; i++) {
	    var dep = observing[i];
	    if (dep.diffValue_ === 0) {
	      dep.diffValue_ = 1;
	      if (i0 !== i) {
	        observing[i0] = dep;
	      }
	      i0++;
	    }
	    // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
	    // not hitting the condition
	    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
	      lowestNewObservingDerivationState = dep.dependenciesState_;
	    }
	  }
	  observing.length = i0;
	  derivation.newObserving_ = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)
	  // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
	  //   0: it's not in new observables, unobserve it
	  //   1: it keeps being observed, don't want to notify it. change to 0
	  l = prevObserving.length;
	  while (l--) {
	    var _dep = prevObserving[l];
	    if (_dep.diffValue_ === 0) {
	      removeObserver(_dep, derivation);
	    }
	    _dep.diffValue_ = 0;
	  }
	  // Go through all new observables and check diffValue: (now it should be unique)
	  //   0: it was set to 0 in last loop. don't need to do anything.
	  //   1: it wasn't observed, let's observe it. set back to 0
	  while (i0--) {
	    var _dep2 = observing[i0];
	    if (_dep2.diffValue_ === 1) {
	      _dep2.diffValue_ = 0;
	      addObserver(_dep2, derivation);
	    }
	  }
	  // Some new observed derivations may become stale during this derivation computation
	  // so they have had no chance to propagate staleness (#916)
	  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
	    derivation.dependenciesState_ = lowestNewObservingDerivationState;
	    derivation.onBecomeStale_();
	  }
	}
	function clearObserving(derivation) {
	  // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
	  var obs = derivation.observing_;
	  derivation.observing_ = [];
	  var i = obs.length;
	  while (i--) {
	    removeObserver(obs[i], derivation);
	  }
	  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
	}
	function untracked(action) {
	  var prev = untrackedStart();
	  try {
	    return action();
	  } finally {
	    untrackedEnd(prev);
	  }
	}
	function untrackedStart() {
	  var prev = globalState.trackingDerivation;
	  globalState.trackingDerivation = null;
	  return prev;
	}
	function untrackedEnd(prev) {
	  globalState.trackingDerivation = prev;
	}
	function allowStateReadsStart(allowStateReads) {
	  var prev = globalState.allowStateReads;
	  globalState.allowStateReads = allowStateReads;
	  return prev;
	}
	function allowStateReadsEnd(prev) {
	  globalState.allowStateReads = prev;
	}
	/**
	 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
	 *
	 */
	function changeDependenciesStateTo0(derivation) {
	  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
	    return;
	  }
	  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
	  var obs = derivation.observing_;
	  var i = obs.length;
	  while (i--) {
	    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
	  }
	}
	var MobXGlobals = function MobXGlobals() {
	  this.version = 6;
	  this.UNCHANGED = {};
	  this.trackingDerivation = null;
	  this.trackingContext = null;
	  this.runId = 0;
	  this.mobxGuid = 0;
	  this.inBatch = 0;
	  this.pendingUnobservations = [];
	  this.pendingReactions = [];
	  this.isRunningReactions = false;
	  this.allowStateChanges = false;
	  this.allowStateReads = true;
	  this.enforceActions = true;
	  this.spyListeners = [];
	  this.globalReactionErrorHandlers = [];
	  this.computedRequiresReaction = false;
	  this.reactionRequiresObservable = false;
	  this.observableRequiresReaction = false;
	  this.disableErrorBoundaries = false;
	  this.suppressReactionErrors = false;
	  this.useProxies = true;
	  this.verifyProxies = false;
	  this.safeDescriptors = true;
	  this.stateVersion = Number.MIN_SAFE_INTEGER;
	};
	var canMergeGlobalState = true;
	var isolateCalled = false;
	var globalState = /*#__PURE__*/function () {
	  var global = /*#__PURE__*/getGlobal();
	  if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals) {
	    canMergeGlobalState = false;
	  }
	  if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version) {
	    canMergeGlobalState = false;
	  }
	  if (!canMergeGlobalState) {
	    // Because this is a IIFE we need to let isolateCalled a chance to change
	    // so we run it after the event loop completed at least 1 iteration
	    setTimeout(function () {
	      if (!isolateCalled) {
	        die(35);
	      }
	    }, 1);
	    return new MobXGlobals();
	  } else if (global.__mobxGlobals) {
	    global.__mobxInstanceCount += 1;
	    if (!global.__mobxGlobals.UNCHANGED) {
	      global.__mobxGlobals.UNCHANGED = {};
	    } // make merge backward compatible
	    return global.__mobxGlobals;
	  } else {
	    global.__mobxInstanceCount = 1;
	    return global.__mobxGlobals = /*#__PURE__*/new MobXGlobals();
	  }
	}();
	function isolateGlobalState() {
	  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {
	    die(36);
	  }
	  isolateCalled = true;
	  if (canMergeGlobalState) {
	    var global = getGlobal();
	    if (--global.__mobxInstanceCount === 0) {
	      global.__mobxGlobals = undefined;
	    }
	    globalState = new MobXGlobals();
	  }
	}
	// function invariantObservers(observable: IObservable) {
	//     const list = observable.observers
	//     const map = observable.observersIndexes
	//     const l = list.length
	//     for (let i = 0; i < l; i++) {
	//         const id = list[i].__mapid
	//         if (i) {
	//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance
	//         } else {
	//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance
	//         }
	//     }
	//     invariant(
	//         list.length === 0 || Object.keys(map).length === list.length - 1,
	//         "INTERNAL ERROR there is no junk in map"
	//     )
	// }
	function addObserver(observable, node) {
	  // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
	  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
	  // invariantObservers(observable);
	  observable.observers_.add(node);
	  if (observable.lowestObserverState_ > node.dependenciesState_) {
	    observable.lowestObserverState_ = node.dependenciesState_;
	  }
	  // invariantObservers(observable);
	  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
	}

	function removeObserver(observable, node) {
	  // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
	  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
	  // invariantObservers(observable);
	  observable.observers_["delete"](node);
	  if (observable.observers_.size === 0) {
	    // deleting last observer
	    queueForUnobservation(observable);
	  }
	  // invariantObservers(observable);
	  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");
	}

	function queueForUnobservation(observable) {
	  if (observable.isPendingUnobservation_ === false) {
	    // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
	    observable.isPendingUnobservation_ = true;
	    globalState.pendingUnobservations.push(observable);
	  }
	}
	/**
	 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
	 * During a batch `onBecomeUnobserved` will be called at most once per observable.
	 * Avoids unnecessary recalculations.
	 */
	function startBatch() {
	  globalState.inBatch++;
	}
	function endBatch() {
	  if (--globalState.inBatch === 0) {
	    runReactions();
	    // the batch is actually about to finish, all unobserving should happen here.
	    var list = globalState.pendingUnobservations;
	    for (var i = 0; i < list.length; i++) {
	      var observable = list[i];
	      observable.isPendingUnobservation_ = false;
	      if (observable.observers_.size === 0) {
	        if (observable.isBeingObserved_) {
	          // if this observable had reactive observers, trigger the hooks
	          observable.isBeingObserved_ = false;
	          observable.onBUO();
	        }
	        if (observable instanceof ComputedValue) {
	          // computed values are automatically teared down when the last observer leaves
	          // this process happens recursively, this computed might be the last observabe of another, etc..
	          observable.suspend_();
	        }
	      }
	    }
	    globalState.pendingUnobservations = [];
	  }
	}
	function reportObserved(observable) {
	  var derivation = globalState.trackingDerivation;
	  if (derivation !== null) {
	    /**
	     * Simple optimization, give each derivation run an unique id (runId)
	     * Check if last time this observable was accessed the same runId is used
	     * if this is the case, the relation is already known
	     */
	    if (derivation.runId_ !== observable.lastAccessedBy_) {
	      observable.lastAccessedBy_ = derivation.runId_;
	      // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...
	      derivation.newObserving_[derivation.unboundDepsCount_++] = observable;
	      if (!observable.isBeingObserved_ && globalState.trackingContext) {
	        observable.isBeingObserved_ = true;
	        observable.onBO();
	      }
	    }
	    return observable.isBeingObserved_;
	  } else if (observable.observers_.size === 0 && globalState.inBatch > 0) {
	    queueForUnobservation(observable);
	  }
	  return false;
	}
	// function invariantLOS(observable: IObservable, msg: string) {
	//     // it's expensive so better not run it in produciton. but temporarily helpful for testing
	//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)
	//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`
	//     throw new Error(
	//         "lowestObserverState is wrong for " +
	//             msg +
	//             " because " +
	//             min +
	//             " < " +
	//             observable.lowestObserverState
	//     )
	// }
	/**
	 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
	 * It will propagate changes to observers from previous run
	 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
	 * Hopefully self reruning autoruns aren't a feature people should depend on
	 * Also most basic use cases should be ok
	 */
	// Called by Atom when its value changes
	function propagateChanged(observable) {
	  // invariantLOS(observable, "changed start");
	  if (observable.lowestObserverState_ === IDerivationState_.STALE_) {
	    return;
	  }
	  observable.lowestObserverState_ = IDerivationState_.STALE_;
	  // Ideally we use for..of here, but the downcompiled version is really slow...
	  observable.observers_.forEach(function (d) {
	    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
	      d.onBecomeStale_();
	    }
	    d.dependenciesState_ = IDerivationState_.STALE_;
	  });
	  // invariantLOS(observable, "changed end");
	}
	// Called by ComputedValue when it recalculate and its value changed
	function propagateChangeConfirmed(observable) {
	  // invariantLOS(observable, "confirmed start");
	  if (observable.lowestObserverState_ === IDerivationState_.STALE_) {
	    return;
	  }
	  observable.lowestObserverState_ = IDerivationState_.STALE_;
	  observable.observers_.forEach(function (d) {
	    if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
	      d.dependenciesState_ = IDerivationState_.STALE_;
	    } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.
	    ) {
	      observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
	    }
	  });
	  // invariantLOS(observable, "confirmed end");
	}
	// Used by computed when its dependency changed, but we don't wan't to immediately recompute.
	function propagateMaybeChanged(observable) {
	  // invariantLOS(observable, "maybe start");
	  if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
	    return;
	  }
	  observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
	  observable.observers_.forEach(function (d) {
	    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
	      d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
	      d.onBecomeStale_();
	    }
	  });
	  // invariantLOS(observable, "maybe end");
	}

	var Reaction = /*#__PURE__*/function () {
	  // nodes we are looking at. Our value depends on these nodes

	  function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {
	    if (name_ === void 0) {
	      name_ = "Reaction";
	    }
	    this.name_ = void 0;
	    this.onInvalidate_ = void 0;
	    this.errorHandler_ = void 0;
	    this.requiresObservable_ = void 0;
	    this.observing_ = [];
	    this.newObserving_ = [];
	    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
	    this.diffValue_ = 0;
	    this.runId_ = 0;
	    this.unboundDepsCount_ = 0;
	    this.isDisposed_ = false;
	    this.isScheduled_ = false;
	    this.isTrackPending_ = false;
	    this.isRunning_ = false;
	    this.isTracing_ = TraceMode.NONE;
	    this.name_ = name_;
	    this.onInvalidate_ = onInvalidate_;
	    this.errorHandler_ = errorHandler_;
	    this.requiresObservable_ = requiresObservable_;
	  }
	  var _proto = Reaction.prototype;
	  _proto.onBecomeStale_ = function onBecomeStale_() {
	    this.schedule_();
	  };
	  _proto.schedule_ = function schedule_() {
	    if (!this.isScheduled_) {
	      this.isScheduled_ = true;
	      globalState.pendingReactions.push(this);
	      runReactions();
	    }
	  };
	  _proto.isScheduled = function isScheduled() {
	    return this.isScheduled_;
	  }
	  /**
	   * internal, use schedule() if you intend to kick off a reaction
	   */;
	  _proto.runReaction_ = function runReaction_() {
	    if (!this.isDisposed_) {
	      startBatch();
	      this.isScheduled_ = false;
	      var prev = globalState.trackingContext;
	      globalState.trackingContext = this;
	      if (shouldCompute(this)) {
	        this.isTrackPending_ = true;
	        try {
	          this.onInvalidate_();
	          if ("production" !== "production" && this.isTrackPending_ && isSpyEnabled()) ;
	        } catch (e) {
	          this.reportExceptionInDerivation_(e);
	        }
	      }
	      globalState.trackingContext = prev;
	      endBatch();
	    }
	  };
	  _proto.track = function track(fn) {
	    if (this.isDisposed_) {
	      return;
	      // console.warn("Reaction already disposed") // Note: Not a warning / error in mobx 4 either
	    }

	    startBatch();
	    this.isRunning_ = true;
	    var prevReaction = globalState.trackingContext; // reactions could create reactions...
	    globalState.trackingContext = this;
	    var result = trackDerivedFunction(this, fn, undefined);
	    globalState.trackingContext = prevReaction;
	    this.isRunning_ = false;
	    this.isTrackPending_ = false;
	    if (this.isDisposed_) {
	      // disposed during last run. Clean up everything that was bound after the dispose call.
	      clearObserving(this);
	    }
	    if (isCaughtException(result)) {
	      this.reportExceptionInDerivation_(result.cause);
	    }
	    endBatch();
	  };
	  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
	    var _this = this;
	    if (this.errorHandler_) {
	      this.errorHandler_(error, this);
	      return;
	    }
	    if (globalState.disableErrorBoundaries) {
	      throw error;
	    }
	    var message = "[mobx] uncaught error in '" + this + "'";
	    if (!globalState.suppressReactionErrors) {
	      console.error(message, error);
	      /** If debugging brought you here, please, read the above message :-). Tnx! */
	    } // prettier-ignore
	    globalState.globalReactionErrorHandlers.forEach(function (f) {
	      return f(error, _this);
	    });
	  };
	  _proto.dispose = function dispose() {
	    if (!this.isDisposed_) {
	      this.isDisposed_ = true;
	      if (!this.isRunning_) {
	        // if disposed while running, clean up later. Maybe not optimal, but rare case
	        startBatch();
	        clearObserving(this);
	        endBatch();
	      }
	    }
	  };
	  _proto.getDisposer_ = function getDisposer_() {
	    var r = this.dispose.bind(this);
	    r[$mobx] = this;
	    return r;
	  };
	  _proto.toString = function toString() {
	    return "Reaction[" + this.name_ + "]";
	  };
	  _proto.trace = function trace$1(enterBreakPoint) {
	    if (enterBreakPoint === void 0) {
	      enterBreakPoint = false;
	    }
	    trace(this, enterBreakPoint);
	  };
	  return Reaction;
	}();
	/**
	 * Magic number alert!
	 * Defines within how many times a reaction is allowed to re-trigger itself
	 * until it is assumed that this is gonna be a never ending loop...
	 */
	var MAX_REACTION_ITERATIONS = 100;
	var reactionScheduler = function reactionScheduler(f) {
	  return f();
	};
	function runReactions() {
	  // Trampolining, if runReactions are already running, new reactions will be picked up
	  if (globalState.inBatch > 0 || globalState.isRunningReactions) {
	    return;
	  }
	  reactionScheduler(runReactionsHelper);
	}
	function runReactionsHelper() {
	  globalState.isRunningReactions = true;
	  var allReactions = globalState.pendingReactions;
	  var iterations = 0;
	  // While running reactions, new reactions might be triggered.
	  // Hence we work with two variables and check whether
	  // we converge to no remaining reactions after a while.
	  while (allReactions.length > 0) {
	    if (++iterations === MAX_REACTION_ITERATIONS) {
	      console.error("[mobx] cycle in reaction: " + allReactions[0]);
	      allReactions.splice(0); // clear reactions
	    }

	    var remainingReactions = allReactions.splice(0);
	    for (var i = 0, l = remainingReactions.length; i < l; i++) {
	      remainingReactions[i].runReaction_();
	    }
	  }
	  globalState.isRunningReactions = false;
	}
	var isReaction = /*#__PURE__*/createInstanceofPredicate("Reaction", Reaction);
	function setReactionScheduler(fn) {
	  var baseScheduler = reactionScheduler;
	  reactionScheduler = function reactionScheduler(f) {
	    return fn(function () {
	      return baseScheduler(f);
	    });
	  };
	}

	function isSpyEnabled() {
	  return "production" !== "production" ;
	}
	function spyReport(event) {
	  {
	    return;
	  } // dead code elimination can do the rest
	}
	function spyReportStart(event) {
	  {
	    return;
	  }
	}
	function spyReportEnd(change) {
	  {
	    return;
	  }
	}
	function spy(listener) {
	  {
	    console.warn("[mobx.spy] Is a no-op in production builds");
	    return function () {};
	  }
	}

	var ACTION = "action";
	var ACTION_BOUND = "action.bound";
	var AUTOACTION = "autoAction";
	var AUTOACTION_BOUND = "autoAction.bound";
	var DEFAULT_ACTION_NAME = "<unnamed action>";
	var actionAnnotation = /*#__PURE__*/createActionAnnotation(ACTION);
	var actionBoundAnnotation = /*#__PURE__*/createActionAnnotation(ACTION_BOUND, {
	  bound: true
	});
	var autoActionAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION, {
	  autoAction: true
	});
	var autoActionBoundAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION_BOUND, {
	  autoAction: true,
	  bound: true
	});
	function createActionFactory(autoAction) {
	  var res = function action(arg1, arg2) {
	    // action(fn() {})
	    if (isFunction$4(arg1)) {
	      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction);
	    }
	    // action("name", fn() {})
	    if (isFunction$4(arg2)) {
	      return createAction(arg1, arg2, autoAction);
	    }
	    // @action
	    if (isStringish(arg2)) {
	      return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);
	    }
	    // action("name") & @action("name")
	    if (isStringish(arg1)) {
	      return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {
	        name: arg1,
	        autoAction: autoAction
	      }));
	    }
	  };
	  return res;
	}
	var action = /*#__PURE__*/createActionFactory(false);
	Object.assign(action, actionAnnotation);
	var autoAction = /*#__PURE__*/createActionFactory(true);
	Object.assign(autoAction, autoActionAnnotation);
	action.bound = /*#__PURE__*/createDecoratorAnnotation(actionBoundAnnotation);
	autoAction.bound = /*#__PURE__*/createDecoratorAnnotation(autoActionBoundAnnotation);
	function runInAction(fn) {
	  return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);
	}
	function isAction(thing) {
	  return isFunction$4(thing) && thing.isMobxAction === true;
	}

	/**
	 * Creates a named reactive view and keeps it alive, so that the view is always
	 * updated if one of the dependencies changes, even when the view is not further used by something else.
	 * @param view The reactive view
	 * @returns disposer function, which can be used to stop the view from being updated in the future.
	 */
	function autorun(view, opts) {
	  var _opts$name, _opts;
	  if (opts === void 0) {
	    opts = EMPTY_OBJECT;
	  }
	  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : "Autorun";
	  var runSync = !opts.scheduler && !opts.delay;
	  var reaction;
	  if (runSync) {
	    // normal autorun
	    reaction = new Reaction(name, function () {
	      this.track(reactionRunner);
	    }, opts.onError, opts.requiresObservable);
	  } else {
	    var scheduler = createSchedulerFromOptions(opts);
	    // debounced autorun
	    var isScheduled = false;
	    reaction = new Reaction(name, function () {
	      if (!isScheduled) {
	        isScheduled = true;
	        scheduler(function () {
	          isScheduled = false;
	          if (!reaction.isDisposed_) {
	            reaction.track(reactionRunner);
	          }
	        });
	      }
	    }, opts.onError, opts.requiresObservable);
	  }
	  function reactionRunner() {
	    view(reaction);
	  }
	  reaction.schedule_();
	  return reaction.getDisposer_();
	}
	var run = function run(f) {
	  return f();
	};
	function createSchedulerFromOptions(opts) {
	  return opts.scheduler ? opts.scheduler : opts.delay ? function (f) {
	    return setTimeout(f, opts.delay);
	  } : run;
	}

	var ON_BECOME_OBSERVED = "onBO";
	var ON_BECOME_UNOBSERVED = "onBUO";
	function onBecomeObserved(thing, arg2, arg3) {
	  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
	}
	function onBecomeUnobserved(thing, arg2, arg3) {
	  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
	}
	function interceptHook(hook, thing, arg2, arg3) {
	  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
	  var cb = isFunction$4(arg3) ? arg3 : arg2;
	  var listenersKey = hook + "L";
	  if (atom[listenersKey]) {
	    atom[listenersKey].add(cb);
	  } else {
	    atom[listenersKey] = new Set([cb]);
	  }
	  return function () {
	    var hookListeners = atom[listenersKey];
	    if (hookListeners) {
	      hookListeners["delete"](cb);
	      if (hookListeners.size === 0) {
	        delete atom[listenersKey];
	      }
	    }
	  };
	}

	var NEVER = "never";
	var ALWAYS = "always";
	var OBSERVED = "observed";
	// const IF_AVAILABLE = "ifavailable"
	function configure(options) {
	  if (options.isolateGlobalState === true) {
	    isolateGlobalState();
	  }
	  var useProxies = options.useProxies,
	    enforceActions = options.enforceActions;
	  if (useProxies !== undefined) {
	    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
	  }
	  if (useProxies === "ifavailable") {
	    globalState.verifyProxies = true;
	  }
	  if (enforceActions !== undefined) {
	    var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
	    globalState.enforceActions = ea;
	    globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
	  }
	  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function (key) {
	    if (key in options) {
	      globalState[key] = !!options[key];
	    }
	  });
	  globalState.allowStateReads = !globalState.observableRequiresReaction;
	  if (options.reactionScheduler) {
	    setReactionScheduler(options.reactionScheduler);
	  }
	}

	function extendObservable(target, properties, annotations, options) {
	  // Pull descriptors first, so we don't have to deal with props added by administration ($mobx)
	  var descriptors = getOwnPropertyDescriptors(properties);
	  var adm = asObservableObject(target, options)[$mobx];
	  startBatch();
	  try {
	    ownKeys$1(descriptors).forEach(function (key) {
	      adm.extend_(key, descriptors[key],
	      // must pass "undefined" for { key: undefined }
	      !annotations ? true : key in annotations ? annotations[key] : true);
	    });
	  } finally {
	    endBatch();
	  }
	  return target;
	}

	function getDependencyTree(thing, property) {
	  return nodeToDependencyTree(getAtom(thing, property));
	}
	function nodeToDependencyTree(node) {
	  var result = {
	    name: node.name_
	  };
	  if (node.observing_ && node.observing_.length > 0) {
	    result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
	  }
	  return result;
	}
	function unique(list) {
	  return Array.from(new Set(list));
	}

	var generatorId = 0;
	function FlowCancellationError() {
	  this.message = "FLOW_CANCELLED";
	}
	FlowCancellationError.prototype = /*#__PURE__*/Object.create(Error.prototype);
	var flowAnnotation = /*#__PURE__*/createFlowAnnotation("flow");
	var flowBoundAnnotation = /*#__PURE__*/createFlowAnnotation("flow.bound", {
	  bound: true
	});
	var flow = /*#__PURE__*/Object.assign(function flow(arg1, arg2) {
	  // @flow
	  if (isStringish(arg2)) {
	    return storeAnnotation(arg1, arg2, flowAnnotation);
	  }
	  var generator = arg1;
	  var name = generator.name || "<unnamed flow>";
	  // Implementation based on https://github.com/tj/co/blob/master/index.js
	  var res = function res() {
	    var ctx = this;
	    var args = arguments;
	    var runId = ++generatorId;
	    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
	    var rejector;
	    var pendingPromise = undefined;
	    var promise = new Promise(function (resolve, reject) {
	      var stepId = 0;
	      rejector = reject;
	      function onFulfilled(res) {
	        pendingPromise = undefined;
	        var ret;
	        try {
	          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res);
	        } catch (e) {
	          return reject(e);
	        }
	        next(ret);
	      }
	      function onRejected(err) {
	        pendingPromise = undefined;
	        var ret;
	        try {
	          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
	        } catch (e) {
	          return reject(e);
	        }
	        next(ret);
	      }
	      function next(ret) {
	        if (isFunction$4(ret == null ? void 0 : ret.then)) {
	          // an async iterator
	          ret.then(next, reject);
	          return;
	        }
	        if (ret.done) {
	          return resolve(ret.value);
	        }
	        pendingPromise = Promise.resolve(ret.value);
	        return pendingPromise.then(onFulfilled, onRejected);
	      }
	      onFulfilled(undefined); // kick off the process
	    });

	    promise.cancel = action(name + " - runid: " + runId + " - cancel", function () {
	      try {
	        if (pendingPromise) {
	          cancelPromise(pendingPromise);
	        }
	        // Finally block can return (or yield) stuff..
	        var _res = gen["return"](undefined);
	        // eat anything that promise would do, it's cancelled!
	        var yieldedPromise = Promise.resolve(_res.value);
	        yieldedPromise.then(noop$1, noop$1);
	        cancelPromise(yieldedPromise); // maybe it can be cancelled :)
	        // reject our original promise
	        rejector(new FlowCancellationError());
	      } catch (e) {
	        rejector(e); // there could be a throwing finally block
	      }
	    });

	    return promise;
	  };
	  res.isMobXFlow = true;
	  return res;
	}, flowAnnotation);
	flow.bound = /*#__PURE__*/createDecoratorAnnotation(flowBoundAnnotation);
	function cancelPromise(promise) {
	  if (isFunction$4(promise.cancel)) {
	    promise.cancel();
	  }
	}

	function isFlow(fn) {
	  return (fn == null ? void 0 : fn.isMobXFlow) === true;
	}

	function _isObservable(value, property) {
	  if (!value) {
	    return false;
	  }
	  if (property !== undefined) {
	    if (isObservableObject(value)) {
	      return value[$mobx].values_.has(property);
	    }
	    return false;
	  }
	  // For first check, see #701
	  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
	}
	function isObservable(value) {
	  return _isObservable(value);
	}
	function apiOwnKeys(obj) {
	  if (isObservableObject(obj)) {
	    return obj[$mobx].ownKeys_();
	  }
	  die(38);
	}

	function cache(map, key, value) {
	  map.set(key, value);
	  return value;
	}
	function toJSHelper(source, __alreadySeen) {
	  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) {
	    return source;
	  }
	  if (isObservableValue(source) || isComputedValue(source)) {
	    return toJSHelper(source.get(), __alreadySeen);
	  }
	  if (__alreadySeen.has(source)) {
	    return __alreadySeen.get(source);
	  }
	  if (isObservableArray(source)) {
	    var res = cache(__alreadySeen, source, new Array(source.length));
	    source.forEach(function (value, idx) {
	      res[idx] = toJSHelper(value, __alreadySeen);
	    });
	    return res;
	  }
	  if (isObservableSet(source)) {
	    var _res = cache(__alreadySeen, source, new Set());
	    source.forEach(function (value) {
	      _res.add(toJSHelper(value, __alreadySeen));
	    });
	    return _res;
	  }
	  if (isObservableMap(source)) {
	    var _res2 = cache(__alreadySeen, source, new Map());
	    source.forEach(function (value, key) {
	      _res2.set(key, toJSHelper(value, __alreadySeen));
	    });
	    return _res2;
	  } else {
	    // must be observable object
	    var _res3 = cache(__alreadySeen, source, {});
	    apiOwnKeys(source).forEach(function (key) {
	      if (objectPrototype.propertyIsEnumerable.call(source, key)) {
	        _res3[key] = toJSHelper(source[key], __alreadySeen);
	      }
	    });
	    return _res3;
	  }
	}
	/**
	 * Recursively converts an observable to it's non-observable native counterpart.
	 * It does NOT recurse into non-observables, these are left as they are, even if they contain observables.
	 * Computed and other non-enumerable properties are completely ignored.
	 * Complex scenarios require custom solution, eg implementing `toJSON` or using `serializr` lib.
	 */
	function toJS(source, options) {
	  return toJSHelper(source, new Map());
	}

	function trace() {
	  {
	    die("trace() is not available in production builds");
	  }
	  var enterBreakPoint = false;
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	  if (typeof args[args.length - 1] === "boolean") {
	    enterBreakPoint = args.pop();
	  }
	  var derivation = getAtomFromArgs(args);
	  if (!derivation) {
	    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
	  }
	  if (derivation.isTracing_ === TraceMode.NONE) {
	    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
	  }
	  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
	}
	function getAtomFromArgs(args) {
	  switch (args.length) {
	    case 0:
	      return globalState.trackingDerivation;
	    case 1:
	      return getAtom(args[0]);
	    case 2:
	      return getAtom(args[0], args[1]);
	  }
	}

	/**
	 * During a transaction no views are updated until the end of the transaction.
	 * The transaction will be run synchronously nonetheless.
	 *
	 * @param action a function that updates some reactive state
	 * @returns any value that was returned by the 'action' parameter.
	 */
	function transaction(action, thisArg) {
	  if (thisArg === void 0) {
	    thisArg = undefined;
	  }
	  startBatch();
	  try {
	    return action.apply(thisArg);
	  } finally {
	    endBatch();
	  }
	}

	function getAdm(target) {
	  return target[$mobx];
	}
	// Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,
	// and skip either the internal values map, or the base object with its property descriptors!
	var objectProxyTraps = {
	  has: function has(target, name) {
	    return getAdm(target).has_(name);
	  },
	  get: function get(target, name) {
	    return getAdm(target).get_(name);
	  },
	  set: function set(target, name, value) {
	    var _getAdm$set_;
	    if (!isStringish(name)) {
	      return false;
	    }
	    // null (intercepted) -> true (success)
	    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
	  },
	  deleteProperty: function deleteProperty(target, name) {
	    var _getAdm$delete_;
	    if (!isStringish(name)) {
	      return false;
	    }
	    // null (intercepted) -> true (success)
	    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
	  },
	  defineProperty: function defineProperty(target, name, descriptor) {
	    var _getAdm$definePropert;
	    // null (intercepted) -> true (success)
	    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
	  },
	  ownKeys: function ownKeys(target) {
	    return getAdm(target).ownKeys_();
	  },
	  preventExtensions: function preventExtensions(target) {
	    die(13);
	  }
	};
	function asDynamicObservableObject(target, options) {
	  var _target$$mobx, _target$$mobx$proxy_;
	  assertProxies();
	  target = asObservableObject(target, options);
	  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
	}

	function hasInterceptors(interceptable) {
	  return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;
	}
	function registerInterceptor(interceptable, handler) {
	  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
	  interceptors.push(handler);
	  return once(function () {
	    var idx = interceptors.indexOf(handler);
	    if (idx !== -1) {
	      interceptors.splice(idx, 1);
	    }
	  });
	}
	function interceptChange(interceptable, change) {
	  var prevU = untrackedStart();
	  try {
	    // Interceptor can modify the array, copy it to avoid concurrent modification, see #1950
	    var interceptors = [].concat(interceptable.interceptors_ || []);
	    for (var i = 0, l = interceptors.length; i < l; i++) {
	      change = interceptors[i](change);
	      if (change && !change.type) {
	        die(14);
	      }
	      if (!change) {
	        break;
	      }
	    }
	    return change;
	  } finally {
	    untrackedEnd(prevU);
	  }
	}

	function hasListeners(listenable) {
	  return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;
	}
	function registerListener(listenable, handler) {
	  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
	  listeners.push(handler);
	  return once(function () {
	    var idx = listeners.indexOf(handler);
	    if (idx !== -1) {
	      listeners.splice(idx, 1);
	    }
	  });
	}
	function notifyListeners(listenable, change) {
	  var prevU = untrackedStart();
	  var listeners = listenable.changeListeners_;
	  if (!listeners) {
	    return;
	  }
	  listeners = listeners.slice();
	  for (var i = 0, l = listeners.length; i < l; i++) {
	    listeners[i](change);
	  }
	  untrackedEnd(prevU);
	}

	function makeObservable(target, annotations, options) {
	  var adm = asObservableObject(target, options)[$mobx];
	  startBatch();
	  try {
	    var _annotations;
	    if ("production" !== "production" && annotations && target[storedAnnotationsSymbol]) ;
	    // Default to decorators
	    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
	    // Annotate
	    ownKeys$1(annotations).forEach(function (key) {
	      return adm.make_(key, annotations[key]);
	    });
	  } finally {
	    endBatch();
	  }
	  return target;
	}
	// proto[keysSymbol] = new Set<PropertyKey>()
	var keysSymbol = /*#__PURE__*/Symbol("mobx-keys");
	function makeAutoObservable(target, overrides, options) {
	  // Optimization: avoid visiting protos
	  // Assumes that annotation.make_/.extend_ works the same for plain objects
	  if (isPlainObject(target)) {
	    return extendObservable(target, target, overrides, options);
	  }
	  var adm = asObservableObject(target, options)[$mobx];
	  // Optimization: cache keys on proto
	  // Assumes makeAutoObservable can be called only once per object and can't be used in subclass
	  if (!target[keysSymbol]) {
	    var proto = Object.getPrototypeOf(target);
	    var keys = new Set([].concat(ownKeys$1(target), ownKeys$1(proto)));
	    keys["delete"]("constructor");
	    keys["delete"]($mobx);
	    addHiddenProp(proto, keysSymbol, keys);
	  }
	  startBatch();
	  try {
	    target[keysSymbol].forEach(function (key) {
	      return adm.make_(key,
	      // must pass "undefined" for { key: undefined }
	      !overrides ? true : key in overrides ? overrides[key] : true);
	    });
	  } finally {
	    endBatch();
	  }
	  return target;
	}

	var SPLICE = "splice";
	var UPDATE = "update";
	var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859
	var arrayTraps = {
	  get: function get(target, name) {
	    var adm = target[$mobx];
	    if (name === $mobx) {
	      return adm;
	    }
	    if (name === "length") {
	      return adm.getArrayLength_();
	    }
	    if (typeof name === "string" && !isNaN(name)) {
	      return adm.get_(parseInt(name));
	    }
	    if (hasProp(arrayExtensions, name)) {
	      return arrayExtensions[name];
	    }
	    return target[name];
	  },
	  set: function set(target, name, value) {
	    var adm = target[$mobx];
	    if (name === "length") {
	      adm.setArrayLength_(value);
	    }
	    if (typeof name === "symbol" || isNaN(name)) {
	      target[name] = value;
	    } else {
	      // numeric string
	      adm.set_(parseInt(name), value);
	    }
	    return true;
	  },
	  preventExtensions: function preventExtensions() {
	    die(15);
	  }
	};
	var ObservableArrayAdministration = /*#__PURE__*/function () {
	  // this is the prop that gets proxied, so can't replace it!

	  function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {
	    if (name === void 0) {
	      name = "ObservableArray";
	    }
	    this.owned_ = void 0;
	    this.legacyMode_ = void 0;
	    this.atom_ = void 0;
	    this.values_ = [];
	    this.interceptors_ = void 0;
	    this.changeListeners_ = void 0;
	    this.enhancer_ = void 0;
	    this.dehancer = void 0;
	    this.proxy_ = void 0;
	    this.lastKnownLength_ = 0;
	    this.owned_ = owned_;
	    this.legacyMode_ = legacyMode_;
	    this.atom_ = new Atom(name);
	    this.enhancer_ = function (newV, oldV) {
	      return enhancer(newV, oldV, "ObservableArray[..]");
	    };
	  }
	  var _proto = ObservableArrayAdministration.prototype;
	  _proto.dehanceValue_ = function dehanceValue_(value) {
	    if (this.dehancer !== undefined) {
	      return this.dehancer(value);
	    }
	    return value;
	  };
	  _proto.dehanceValues_ = function dehanceValues_(values) {
	    if (this.dehancer !== undefined && values.length > 0) {
	      return values.map(this.dehancer);
	    }
	    return values;
	  };
	  _proto.intercept_ = function intercept_(handler) {
	    return registerInterceptor(this, handler);
	  };
	  _proto.observe_ = function observe_(listener, fireImmediately) {
	    if (fireImmediately === void 0) {
	      fireImmediately = false;
	    }
	    if (fireImmediately) {
	      listener({
	        observableKind: "array",
	        object: this.proxy_,
	        debugObjectName: this.atom_.name_,
	        type: "splice",
	        index: 0,
	        added: this.values_.slice(),
	        addedCount: this.values_.length,
	        removed: [],
	        removedCount: 0
	      });
	    }
	    return registerListener(this, listener);
	  };
	  _proto.getArrayLength_ = function getArrayLength_() {
	    this.atom_.reportObserved();
	    return this.values_.length;
	  };
	  _proto.setArrayLength_ = function setArrayLength_(newLength) {
	    if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
	      die("Out of range: " + newLength);
	    }
	    var currentLength = this.values_.length;
	    if (newLength === currentLength) {
	      return;
	    } else if (newLength > currentLength) {
	      var newItems = new Array(newLength - currentLength);
	      for (var i = 0; i < newLength - currentLength; i++) {
	        newItems[i] = undefined;
	      } // No Array.fill everywhere...
	      this.spliceWithArray_(currentLength, 0, newItems);
	    } else {
	      this.spliceWithArray_(newLength, currentLength - newLength);
	    }
	  };
	  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
	    if (oldLength !== this.lastKnownLength_) {
	      die(16);
	    }
	    this.lastKnownLength_ += delta;
	    if (this.legacyMode_ && delta > 0) {
	      reserveArrayBuffer(oldLength + delta + 1);
	    }
	  };
	  _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
	    var _this = this;
	    checkIfStateModificationsAreAllowed(this.atom_);
	    var length = this.values_.length;
	    if (index === undefined) {
	      index = 0;
	    } else if (index > length) {
	      index = length;
	    } else if (index < 0) {
	      index = Math.max(0, length + index);
	    }
	    if (arguments.length === 1) {
	      deleteCount = length - index;
	    } else if (deleteCount === undefined || deleteCount === null) {
	      deleteCount = 0;
	    } else {
	      deleteCount = Math.max(0, Math.min(deleteCount, length - index));
	    }
	    if (newItems === undefined) {
	      newItems = EMPTY_ARRAY;
	    }
	    if (hasInterceptors(this)) {
	      var change = interceptChange(this, {
	        object: this.proxy_,
	        type: SPLICE,
	        index: index,
	        removedCount: deleteCount,
	        added: newItems
	      });
	      if (!change) {
	        return EMPTY_ARRAY;
	      }
	      deleteCount = change.removedCount;
	      newItems = change.added;
	    }
	    newItems = newItems.length === 0 ? newItems : newItems.map(function (v) {
	      return _this.enhancer_(v, undefined);
	    });
	    if (this.legacyMode_ || "production" !== "production") {
	      var lengthDelta = newItems.length - deleteCount;
	      this.updateArrayLength_(length, lengthDelta); // checks if internal array wasn't modified
	    }

	    var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
	    if (deleteCount !== 0 || newItems.length !== 0) {
	      this.notifyArraySplice_(index, newItems, res);
	    }
	    return this.dehanceValues_(res);
	  };
	  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
	    if (newItems.length < MAX_SPLICE_SIZE) {
	      var _this$values_;
	      return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));
	    } else {
	      // The items removed by the splice
	      var res = this.values_.slice(index, index + deleteCount);
	      // The items that that should remain at the end of the array
	      var oldItems = this.values_.slice(index + deleteCount);
	      // New length is the previous length + addition count - deletion count
	      this.values_.length += newItems.length - deleteCount;
	      for (var i = 0; i < newItems.length; i++) {
	        this.values_[index + i] = newItems[i];
	      }
	      for (var _i = 0; _i < oldItems.length; _i++) {
	        this.values_[index + newItems.length + _i] = oldItems[_i];
	      }
	      return res;
	    }
	  };
	  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
	    var notifySpy = !this.owned_ && isSpyEnabled();
	    var notify = hasListeners(this);
	    var change = notify || notifySpy ? {
	      observableKind: "array",
	      object: this.proxy_,
	      type: UPDATE,
	      debugObjectName: this.atom_.name_,
	      index: index,
	      newValue: newValue,
	      oldValue: oldValue
	    } : null;
	    this.atom_.reportChanged();
	    if (notify) {
	      notifyListeners(this, change);
	    }
	  };
	  _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
	    var notifySpy = !this.owned_ && isSpyEnabled();
	    var notify = hasListeners(this);
	    var change = notify || notifySpy ? {
	      observableKind: "array",
	      object: this.proxy_,
	      debugObjectName: this.atom_.name_,
	      type: SPLICE,
	      index: index,
	      removed: removed,
	      added: added,
	      removedCount: removed.length,
	      addedCount: added.length
	    } : null;
	    this.atom_.reportChanged();
	    // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
	    if (notify) {
	      notifyListeners(this, change);
	    }
	  };
	  _proto.get_ = function get_(index) {
	    if (this.legacyMode_ && index >= this.values_.length) {
	      console.warn("[mobx] Out of bounds read: " + index);
	      return undefined;
	    }
	    this.atom_.reportObserved();
	    return this.dehanceValue_(this.values_[index]);
	  };
	  _proto.set_ = function set_(index, newValue) {
	    var values = this.values_;
	    if (this.legacyMode_ && index > values.length) {
	      // out of bounds
	      die(17, index, values.length);
	    }
	    if (index < values.length) {
	      // update at index in range
	      checkIfStateModificationsAreAllowed(this.atom_);
	      var oldValue = values[index];
	      if (hasInterceptors(this)) {
	        var change = interceptChange(this, {
	          type: UPDATE,
	          object: this.proxy_,
	          index: index,
	          newValue: newValue
	        });
	        if (!change) {
	          return;
	        }
	        newValue = change.newValue;
	      }
	      newValue = this.enhancer_(newValue, oldValue);
	      var changed = newValue !== oldValue;
	      if (changed) {
	        values[index] = newValue;
	        this.notifyArrayChildUpdate_(index, newValue, oldValue);
	      }
	    } else {
	      // For out of bound index, we don't create an actual sparse array,
	      // but rather fill the holes with undefined (same as setArrayLength_).
	      // This could be considered a bug.
	      var newItems = new Array(index + 1 - values.length);
	      for (var i = 0; i < newItems.length - 1; i++) {
	        newItems[i] = undefined;
	      } // No Array.fill everywhere...
	      newItems[newItems.length - 1] = newValue;
	      this.spliceWithArray_(values.length, 0, newItems);
	    }
	  };
	  return ObservableArrayAdministration;
	}();
	function createObservableArray(initialValues, enhancer, name, owned) {
	  if (name === void 0) {
	    name = "ObservableArray";
	  }
	  if (owned === void 0) {
	    owned = false;
	  }
	  assertProxies();
	  var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
	  addHiddenFinalProp(adm.values_, $mobx, adm);
	  var proxy = new Proxy(adm.values_, arrayTraps);
	  adm.proxy_ = proxy;
	  if (initialValues && initialValues.length) {
	    var prev = allowStateChangesStart(true);
	    adm.spliceWithArray_(0, 0, initialValues);
	    allowStateChangesEnd(prev);
	  }
	  return proxy;
	}
	// eslint-disable-next-line
	var arrayExtensions = {
	  clear: function clear() {
	    return this.splice(0);
	  },
	  replace: function replace(newItems) {
	    var adm = this[$mobx];
	    return adm.spliceWithArray_(0, adm.values_.length, newItems);
	  },
	  // Used by JSON.stringify
	  toJSON: function toJSON() {
	    return this.slice();
	  },
	  /*
	   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
	   * since these functions alter the inner structure of the array, the have side effects.
	   * Because the have side effects, they should not be used in computed function,
	   * and for that reason the do not call dependencyState.notifyObserved
	   */
	  splice: function splice(index, deleteCount) {
	    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      newItems[_key - 2] = arguments[_key];
	    }
	    var adm = this[$mobx];
	    switch (arguments.length) {
	      case 0:
	        return [];
	      case 1:
	        return adm.spliceWithArray_(index);
	      case 2:
	        return adm.spliceWithArray_(index, deleteCount);
	    }
	    return adm.spliceWithArray_(index, deleteCount, newItems);
	  },
	  spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
	    return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
	  },
	  push: function push() {
	    var adm = this[$mobx];
	    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      items[_key2] = arguments[_key2];
	    }
	    adm.spliceWithArray_(adm.values_.length, 0, items);
	    return adm.values_.length;
	  },
	  pop: function pop() {
	    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
	  },
	  shift: function shift() {
	    return this.splice(0, 1)[0];
	  },
	  unshift: function unshift() {
	    var adm = this[$mobx];
	    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	      items[_key3] = arguments[_key3];
	    }
	    adm.spliceWithArray_(0, 0, items);
	    return adm.values_.length;
	  },
	  reverse: function reverse() {
	    // reverse by default mutates in place before returning the result
	    // which makes it both a 'derivation' and a 'mutation'.
	    if (globalState.trackingDerivation) {
	      die(37, "reverse");
	    }
	    this.replace(this.slice().reverse());
	    return this;
	  },
	  sort: function sort() {
	    // sort by default mutates in place before returning the result
	    // which goes against all good practices. Let's not change the array in place!
	    if (globalState.trackingDerivation) {
	      die(37, "sort");
	    }
	    var copy = this.slice();
	    copy.sort.apply(copy, arguments);
	    this.replace(copy);
	    return this;
	  },
	  remove: function remove(value) {
	    var adm = this[$mobx];
	    var idx = adm.dehanceValues_(adm.values_).indexOf(value);
	    if (idx > -1) {
	      this.splice(idx, 1);
	      return true;
	    }
	    return false;
	  }
	};
	/**
	 * Wrap function from prototype
	 * Without this, everything works as well, but this works
	 * faster as everything works on unproxied values
	 */
	addArrayExtension("concat", simpleFunc);
	addArrayExtension("flat", simpleFunc);
	addArrayExtension("includes", simpleFunc);
	addArrayExtension("indexOf", simpleFunc);
	addArrayExtension("join", simpleFunc);
	addArrayExtension("lastIndexOf", simpleFunc);
	addArrayExtension("slice", simpleFunc);
	addArrayExtension("toString", simpleFunc);
	addArrayExtension("toLocaleString", simpleFunc);
	// map
	addArrayExtension("every", mapLikeFunc);
	addArrayExtension("filter", mapLikeFunc);
	addArrayExtension("find", mapLikeFunc);
	addArrayExtension("findIndex", mapLikeFunc);
	addArrayExtension("flatMap", mapLikeFunc);
	addArrayExtension("forEach", mapLikeFunc);
	addArrayExtension("map", mapLikeFunc);
	addArrayExtension("some", mapLikeFunc);
	// reduce
	addArrayExtension("reduce", reduceLikeFunc);
	addArrayExtension("reduceRight", reduceLikeFunc);
	function addArrayExtension(funcName, funcFactory) {
	  if (typeof Array.prototype[funcName] === "function") {
	    arrayExtensions[funcName] = funcFactory(funcName);
	  }
	}
	// Report and delegate to dehanced array
	function simpleFunc(funcName) {
	  return function () {
	    var adm = this[$mobx];
	    adm.atom_.reportObserved();
	    var dehancedValues = adm.dehanceValues_(adm.values_);
	    return dehancedValues[funcName].apply(dehancedValues, arguments);
	  };
	}
	// Make sure callbacks recieve correct array arg #2326
	function mapLikeFunc(funcName) {
	  return function (callback, thisArg) {
	    var _this2 = this;
	    var adm = this[$mobx];
	    adm.atom_.reportObserved();
	    var dehancedValues = adm.dehanceValues_(adm.values_);
	    return dehancedValues[funcName](function (element, index) {
	      return callback.call(thisArg, element, index, _this2);
	    });
	  };
	}
	// Make sure callbacks recieve correct array arg #2326
	function reduceLikeFunc(funcName) {
	  return function () {
	    var _this3 = this;
	    var adm = this[$mobx];
	    adm.atom_.reportObserved();
	    var dehancedValues = adm.dehanceValues_(adm.values_);
	    // #2432 - reduce behavior depends on arguments.length
	    var callback = arguments[0];
	    arguments[0] = function (accumulator, currentValue, index) {
	      return callback(accumulator, currentValue, index, _this3);
	    };
	    return dehancedValues[funcName].apply(dehancedValues, arguments);
	  };
	}
	var isObservableArrayAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
	function isObservableArray(thing) {
	  return isObject$6(thing) && isObservableArrayAdministration(thing[$mobx]);
	}

	var _Symbol$iterator, _Symbol$toStringTag;
	var ObservableMapMarker = {};
	var ADD = "add";
	var DELETE = "delete";
	// just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54
	// But: https://github.com/mobxjs/mobx/issues/1556
	_Symbol$iterator = Symbol.iterator;
	_Symbol$toStringTag = Symbol.toStringTag;
	var ObservableMap = /*#__PURE__*/function () {
	  // hasMap, not hashMap >-).

	  function ObservableMap(initialData, enhancer_, name_) {
	    var _this = this;
	    if (enhancer_ === void 0) {
	      enhancer_ = deepEnhancer;
	    }
	    if (name_ === void 0) {
	      name_ = "ObservableMap";
	    }
	    this.enhancer_ = void 0;
	    this.name_ = void 0;
	    this[$mobx] = ObservableMapMarker;
	    this.data_ = void 0;
	    this.hasMap_ = void 0;
	    this.keysAtom_ = void 0;
	    this.interceptors_ = void 0;
	    this.changeListeners_ = void 0;
	    this.dehancer = void 0;
	    this.enhancer_ = enhancer_;
	    this.name_ = name_;
	    if (!isFunction$4(Map)) {
	      die(18);
	    }
	    this.keysAtom_ = createAtom("ObservableMap.keys()");
	    this.data_ = new Map();
	    this.hasMap_ = new Map();
	    allowStateChanges(true, function () {
	      _this.merge(initialData);
	    });
	  }
	  var _proto = ObservableMap.prototype;
	  _proto.has_ = function has_(key) {
	    return this.data_.has(key);
	  };
	  _proto.has = function has(key) {
	    var _this2 = this;
	    if (!globalState.trackingDerivation) {
	      return this.has_(key);
	    }
	    var entry = this.hasMap_.get(key);
	    if (!entry) {
	      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, "ObservableMap.key?", false);
	      this.hasMap_.set(key, newEntry);
	      onBecomeUnobserved(newEntry, function () {
	        return _this2.hasMap_["delete"](key);
	      });
	    }
	    return entry.get();
	  };
	  _proto.set = function set(key, value) {
	    var hasKey = this.has_(key);
	    if (hasInterceptors(this)) {
	      var change = interceptChange(this, {
	        type: hasKey ? UPDATE : ADD,
	        object: this,
	        newValue: value,
	        name: key
	      });
	      if (!change) {
	        return this;
	      }
	      value = change.newValue;
	    }
	    if (hasKey) {
	      this.updateValue_(key, value);
	    } else {
	      this.addValue_(key, value);
	    }
	    return this;
	  };
	  _proto["delete"] = function _delete(key) {
	    var _this3 = this;
	    checkIfStateModificationsAreAllowed(this.keysAtom_);
	    if (hasInterceptors(this)) {
	      var change = interceptChange(this, {
	        type: DELETE,
	        object: this,
	        name: key
	      });
	      if (!change) {
	        return false;
	      }
	    }
	    if (this.has_(key)) {
	      var notifySpy = isSpyEnabled();
	      var notify = hasListeners(this);
	      var _change = notify || notifySpy ? {
	        observableKind: "map",
	        debugObjectName: this.name_,
	        type: DELETE,
	        object: this,
	        oldValue: this.data_.get(key).value_,
	        name: key
	      } : null;
	      transaction(function () {
	        var _this3$hasMap_$get;
	        _this3.keysAtom_.reportChanged();
	        (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(false);
	        var observable = _this3.data_.get(key);
	        observable.setNewValue_(undefined);
	        _this3.data_["delete"](key);
	      });
	      if (notify) {
	        notifyListeners(this, _change);
	      }
	      return true;
	    }
	    return false;
	  };
	  _proto.updateValue_ = function updateValue_(key, newValue) {
	    var observable = this.data_.get(key);
	    newValue = observable.prepareNewValue_(newValue);
	    if (newValue !== globalState.UNCHANGED) {
	      var notifySpy = isSpyEnabled();
	      var notify = hasListeners(this);
	      var change = notify || notifySpy ? {
	        observableKind: "map",
	        debugObjectName: this.name_,
	        type: UPDATE,
	        object: this,
	        oldValue: observable.value_,
	        name: key,
	        newValue: newValue
	      } : null;
	      observable.setNewValue_(newValue);
	      if (notify) {
	        notifyListeners(this, change);
	      }
	    }
	  };
	  _proto.addValue_ = function addValue_(key, newValue) {
	    var _this4 = this;
	    checkIfStateModificationsAreAllowed(this.keysAtom_);
	    transaction(function () {
	      var _this4$hasMap_$get;
	      var observable = new ObservableValue(newValue, _this4.enhancer_, "ObservableMap.key", false);
	      _this4.data_.set(key, observable);
	      newValue = observable.value_; // value might have been changed
	      (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null ? void 0 : _this4$hasMap_$get.setNewValue_(true);
	      _this4.keysAtom_.reportChanged();
	    });
	    var notifySpy = isSpyEnabled();
	    var notify = hasListeners(this);
	    var change = notify || notifySpy ? {
	      observableKind: "map",
	      debugObjectName: this.name_,
	      type: ADD,
	      object: this,
	      name: key,
	      newValue: newValue
	    } : null;
	    if (notify) {
	      notifyListeners(this, change);
	    }
	  };
	  _proto.get = function get(key) {
	    if (this.has(key)) {
	      return this.dehanceValue_(this.data_.get(key).get());
	    }
	    return this.dehanceValue_(undefined);
	  };
	  _proto.dehanceValue_ = function dehanceValue_(value) {
	    if (this.dehancer !== undefined) {
	      return this.dehancer(value);
	    }
	    return value;
	  };
	  _proto.keys = function keys() {
	    this.keysAtom_.reportObserved();
	    return this.data_.keys();
	  };
	  _proto.values = function values() {
	    var self = this;
	    var keys = this.keys();
	    return makeIterable({
	      next: function next() {
	        var _keys$next = keys.next(),
	          done = _keys$next.done,
	          value = _keys$next.value;
	        return {
	          done: done,
	          value: done ? undefined : self.get(value)
	        };
	      }
	    });
	  };
	  _proto.entries = function entries() {
	    var self = this;
	    var keys = this.keys();
	    return makeIterable({
	      next: function next() {
	        var _keys$next2 = keys.next(),
	          done = _keys$next2.done,
	          value = _keys$next2.value;
	        return {
	          done: done,
	          value: done ? undefined : [value, self.get(value)]
	        };
	      }
	    });
	  };
	  _proto[_Symbol$iterator] = function () {
	    return this.entries();
	  };
	  _proto.forEach = function forEach(callback, thisArg) {
	    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done;) {
	      var _step$value = _step.value,
	        key = _step$value[0],
	        value = _step$value[1];
	      callback.call(thisArg, value, key, this);
	    }
	  }
	  /** Merge another object into this object, returns this. */;
	  _proto.merge = function merge(other) {
	    var _this5 = this;
	    if (isObservableMap(other)) {
	      other = new Map(other);
	    }
	    transaction(function () {
	      if (isPlainObject(other)) {
	        getPlainObjectKeys(other).forEach(function (key) {
	          return _this5.set(key, other[key]);
	        });
	      } else if (Array.isArray(other)) {
	        other.forEach(function (_ref) {
	          var key = _ref[0],
	            value = _ref[1];
	          return _this5.set(key, value);
	        });
	      } else if (isES6Map(other)) {
	        if (other.constructor !== Map) {
	          die(19, other);
	        }
	        other.forEach(function (value, key) {
	          return _this5.set(key, value);
	        });
	      } else if (other !== null && other !== undefined) {
	        die(20, other);
	      }
	    });
	    return this;
	  };
	  _proto.clear = function clear() {
	    var _this6 = this;
	    transaction(function () {
	      untracked(function () {
	        for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done;) {
	          var key = _step2.value;
	          _this6["delete"](key);
	        }
	      });
	    });
	  };
	  _proto.replace = function replace(values) {
	    var _this7 = this;
	    // Implementation requirements:
	    // - respect ordering of replacement map
	    // - allow interceptors to run and potentially prevent individual operations
	    // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)
	    // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)
	    // - note that result map may differ from replacement map due to the interceptors
	    transaction(function () {
	      // Convert to map so we can do quick key lookups
	      var replacementMap = convertToMap(values);
	      var orderedData = new Map();
	      // Used for optimization
	      var keysReportChangedCalled = false;
	      // Delete keys that don't exist in replacement map
	      // if the key deletion is prevented by interceptor
	      // add entry at the beginning of the result map
	      for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done;) {
	        var key = _step3.value;
	        // Concurrently iterating/deleting keys
	        // iterator should handle this correctly
	        if (!replacementMap.has(key)) {
	          var deleted = _this7["delete"](key);
	          // Was the key removed?
	          if (deleted) {
	            // _keysAtom.reportChanged() was already called
	            keysReportChangedCalled = true;
	          } else {
	            // Delete prevented by interceptor
	            var value = _this7.data_.get(key);
	            orderedData.set(key, value);
	          }
	        }
	      }
	      // Merge entries
	      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done;) {
	        var _step4$value = _step4.value,
	          _key = _step4$value[0],
	          _value = _step4$value[1];
	        // We will want to know whether a new key is added
	        var keyExisted = _this7.data_.has(_key);
	        // Add or update value
	        _this7.set(_key, _value);
	        // The addition could have been prevent by interceptor
	        if (_this7.data_.has(_key)) {
	          // The update could have been prevented by interceptor
	          // and also we want to preserve existing values
	          // so use value from _data map (instead of replacement map)
	          var _value2 = _this7.data_.get(_key);
	          orderedData.set(_key, _value2);
	          // Was a new key added?
	          if (!keyExisted) {
	            // _keysAtom.reportChanged() was already called
	            keysReportChangedCalled = true;
	          }
	        }
	      }
	      // Check for possible key order change
	      if (!keysReportChangedCalled) {
	        if (_this7.data_.size !== orderedData.size) {
	          // If size differs, keys are definitely modified
	          _this7.keysAtom_.reportChanged();
	        } else {
	          var iter1 = _this7.data_.keys();
	          var iter2 = orderedData.keys();
	          var next1 = iter1.next();
	          var next2 = iter2.next();
	          while (!next1.done) {
	            if (next1.value !== next2.value) {
	              _this7.keysAtom_.reportChanged();
	              break;
	            }
	            next1 = iter1.next();
	            next2 = iter2.next();
	          }
	        }
	      }
	      // Use correctly ordered map
	      _this7.data_ = orderedData;
	    });
	    return this;
	  };
	  _proto.toString = function toString() {
	    return "[object ObservableMap]";
	  };
	  _proto.toJSON = function toJSON() {
	    return Array.from(this);
	  };
	  /**
	   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
	   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
	   * for callback details
	   */
	  _proto.observe_ = function observe_(listener, fireImmediately) {
	    return registerListener(this, listener);
	  };
	  _proto.intercept_ = function intercept_(handler) {
	    return registerInterceptor(this, handler);
	  };
	  _createClass(ObservableMap, [{
	    key: "size",
	    get: function get() {
	      this.keysAtom_.reportObserved();
	      return this.data_.size;
	    }
	  }, {
	    key: _Symbol$toStringTag,
	    get: function get() {
	      return "Map";
	    }
	  }]);
	  return ObservableMap;
	}();
	// eslint-disable-next-line
	var isObservableMap = /*#__PURE__*/createInstanceofPredicate("ObservableMap", ObservableMap);
	function convertToMap(dataStructure) {
	  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
	    return dataStructure;
	  } else if (Array.isArray(dataStructure)) {
	    return new Map(dataStructure);
	  } else if (isPlainObject(dataStructure)) {
	    var map = new Map();
	    for (var key in dataStructure) {
	      map.set(key, dataStructure[key]);
	    }
	    return map;
	  } else {
	    return die(21, dataStructure);
	  }
	}

	var _Symbol$iterator$1, _Symbol$toStringTag$1;
	var ObservableSetMarker = {};
	_Symbol$iterator$1 = Symbol.iterator;
	_Symbol$toStringTag$1 = Symbol.toStringTag;
	var ObservableSet = /*#__PURE__*/function () {
	  function ObservableSet(initialData, enhancer, name_) {
	    if (enhancer === void 0) {
	      enhancer = deepEnhancer;
	    }
	    if (name_ === void 0) {
	      name_ = "ObservableSet";
	    }
	    this.name_ = void 0;
	    this[$mobx] = ObservableSetMarker;
	    this.data_ = new Set();
	    this.atom_ = void 0;
	    this.changeListeners_ = void 0;
	    this.interceptors_ = void 0;
	    this.dehancer = void 0;
	    this.enhancer_ = void 0;
	    this.name_ = name_;
	    if (!isFunction$4(Set)) {
	      die(22);
	    }
	    this.atom_ = createAtom(this.name_);
	    this.enhancer_ = function (newV, oldV) {
	      return enhancer(newV, oldV, name_);
	    };
	    if (initialData) {
	      this.replace(initialData);
	    }
	  }
	  var _proto = ObservableSet.prototype;
	  _proto.dehanceValue_ = function dehanceValue_(value) {
	    if (this.dehancer !== undefined) {
	      return this.dehancer(value);
	    }
	    return value;
	  };
	  _proto.clear = function clear() {
	    var _this = this;
	    transaction(function () {
	      untracked(function () {
	        for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done;) {
	          var value = _step.value;
	          _this["delete"](value);
	        }
	      });
	    });
	  };
	  _proto.forEach = function forEach(callbackFn, thisArg) {
	    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done;) {
	      var value = _step2.value;
	      callbackFn.call(thisArg, value, value, this);
	    }
	  };
	  _proto.add = function add(value) {
	    var _this2 = this;
	    checkIfStateModificationsAreAllowed(this.atom_);
	    if (hasInterceptors(this)) {
	      var change = interceptChange(this, {
	        type: ADD,
	        object: this,
	        newValue: value
	      });
	      if (!change) {
	        return this;
	      }
	      // ideally, value = change.value would be done here, so that values can be
	      // changed by interceptor. Same applies for other Set and Map api's.
	    }

	    if (!this.has(value)) {
	      transaction(function () {
	        _this2.data_.add(_this2.enhancer_(value, undefined));
	        _this2.atom_.reportChanged();
	      });
	      var notifySpy = "production" !== "production" ;
	      var notify = hasListeners(this);
	      var _change = notify || notifySpy ? {
	        observableKind: "set",
	        debugObjectName: this.name_,
	        type: ADD,
	        object: this,
	        newValue: value
	      } : null;
	      if (notify) {
	        notifyListeners(this, _change);
	      }
	    }
	    return this;
	  };
	  _proto["delete"] = function _delete(value) {
	    var _this3 = this;
	    if (hasInterceptors(this)) {
	      var change = interceptChange(this, {
	        type: DELETE,
	        object: this,
	        oldValue: value
	      });
	      if (!change) {
	        return false;
	      }
	    }
	    if (this.has(value)) {
	      var notifySpy = "production" !== "production" ;
	      var notify = hasListeners(this);
	      var _change2 = notify || notifySpy ? {
	        observableKind: "set",
	        debugObjectName: this.name_,
	        type: DELETE,
	        object: this,
	        oldValue: value
	      } : null;
	      transaction(function () {
	        _this3.atom_.reportChanged();
	        _this3.data_["delete"](value);
	      });
	      if (notify) {
	        notifyListeners(this, _change2);
	      }
	      return true;
	    }
	    return false;
	  };
	  _proto.has = function has(value) {
	    this.atom_.reportObserved();
	    return this.data_.has(this.dehanceValue_(value));
	  };
	  _proto.entries = function entries() {
	    var nextIndex = 0;
	    var keys = Array.from(this.keys());
	    var values = Array.from(this.values());
	    return makeIterable({
	      next: function next() {
	        var index = nextIndex;
	        nextIndex += 1;
	        return index < values.length ? {
	          value: [keys[index], values[index]],
	          done: false
	        } : {
	          done: true
	        };
	      }
	    });
	  };
	  _proto.keys = function keys() {
	    return this.values();
	  };
	  _proto.values = function values() {
	    this.atom_.reportObserved();
	    var self = this;
	    var nextIndex = 0;
	    var observableValues = Array.from(this.data_.values());
	    return makeIterable({
	      next: function next() {
	        return nextIndex < observableValues.length ? {
	          value: self.dehanceValue_(observableValues[nextIndex++]),
	          done: false
	        } : {
	          done: true
	        };
	      }
	    });
	  };
	  _proto.replace = function replace(other) {
	    var _this4 = this;
	    if (isObservableSet(other)) {
	      other = new Set(other);
	    }
	    transaction(function () {
	      if (Array.isArray(other)) {
	        _this4.clear();
	        other.forEach(function (value) {
	          return _this4.add(value);
	        });
	      } else if (isES6Set(other)) {
	        _this4.clear();
	        other.forEach(function (value) {
	          return _this4.add(value);
	        });
	      } else if (other !== null && other !== undefined) {
	        die("Cannot initialize set from " + other);
	      }
	    });
	    return this;
	  };
	  _proto.observe_ = function observe_(listener, fireImmediately) {
	    return registerListener(this, listener);
	  };
	  _proto.intercept_ = function intercept_(handler) {
	    return registerInterceptor(this, handler);
	  };
	  _proto.toJSON = function toJSON() {
	    return Array.from(this);
	  };
	  _proto.toString = function toString() {
	    return "[object ObservableSet]";
	  };
	  _proto[_Symbol$iterator$1] = function () {
	    return this.values();
	  };
	  _createClass(ObservableSet, [{
	    key: "size",
	    get: function get() {
	      this.atom_.reportObserved();
	      return this.data_.size;
	    }
	  }, {
	    key: _Symbol$toStringTag$1,
	    get: function get() {
	      return "Set";
	    }
	  }]);
	  return ObservableSet;
	}();
	// eslint-disable-next-line
	var isObservableSet = /*#__PURE__*/createInstanceofPredicate("ObservableSet", ObservableSet);

	var descriptorCache = /*#__PURE__*/Object.create(null);
	var REMOVE = "remove";
	var ObservableObjectAdministration = /*#__PURE__*/function () {
	  function ObservableObjectAdministration(target_, values_, name_,
	  // Used anytime annotation is not explicitely provided
	  defaultAnnotation_) {
	    if (values_ === void 0) {
	      values_ = new Map();
	    }
	    if (defaultAnnotation_ === void 0) {
	      defaultAnnotation_ = autoAnnotation;
	    }
	    this.target_ = void 0;
	    this.values_ = void 0;
	    this.name_ = void 0;
	    this.defaultAnnotation_ = void 0;
	    this.keysAtom_ = void 0;
	    this.changeListeners_ = void 0;
	    this.interceptors_ = void 0;
	    this.proxy_ = void 0;
	    this.isPlainObject_ = void 0;
	    this.appliedAnnotations_ = void 0;
	    this.pendingKeys_ = void 0;
	    this.target_ = target_;
	    this.values_ = values_;
	    this.name_ = name_;
	    this.defaultAnnotation_ = defaultAnnotation_;
	    this.keysAtom_ = new Atom("ObservableObject.keys");
	    // Optimization: we use this frequently
	    this.isPlainObject_ = isPlainObject(this.target_);
	  }
	  var _proto = ObservableObjectAdministration.prototype;
	  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
	    return this.values_.get(key).get();
	  };
	  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
	    var observable = this.values_.get(key);
	    if (observable instanceof ComputedValue) {
	      observable.set(newValue);
	      return true;
	    }
	    // intercept
	    if (hasInterceptors(this)) {
	      var change = interceptChange(this, {
	        type: UPDATE,
	        object: this.proxy_ || this.target_,
	        name: key,
	        newValue: newValue
	      });
	      if (!change) {
	        return null;
	      }
	      newValue = change.newValue;
	    }
	    newValue = observable.prepareNewValue_(newValue);
	    // notify spy & observers
	    if (newValue !== globalState.UNCHANGED) {
	      var notify = hasListeners(this);
	      var notifySpy = "production" !== "production" ;
	      var _change = notify || notifySpy ? {
	        type: UPDATE,
	        observableKind: "object",
	        debugObjectName: this.name_,
	        object: this.proxy_ || this.target_,
	        oldValue: observable.value_,
	        name: key,
	        newValue: newValue
	      } : null;
	      observable.setNewValue_(newValue);
	      if (notify) {
	        notifyListeners(this, _change);
	      }
	    }
	    return true;
	  };
	  _proto.get_ = function get_(key) {
	    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
	      // Key doesn't exist yet, subscribe for it in case it's added later
	      this.has_(key);
	    }
	    return this.target_[key];
	  }
	  /**
	   * @param {PropertyKey} key
	   * @param {any} value
	   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
	   * @param {boolean} proxyTrap whether it's called from proxy trap
	   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
	   */;
	  _proto.set_ = function set_(key, value, proxyTrap) {
	    if (proxyTrap === void 0) {
	      proxyTrap = false;
	    }
	    // Don't use .has(key) - we care about own
	    if (hasProp(this.target_, key)) {
	      // Existing prop
	      if (this.values_.has(key)) {
	        // Observable (can be intercepted)
	        return this.setObservablePropValue_(key, value);
	      } else if (proxyTrap) {
	        // Non-observable - proxy
	        return Reflect.set(this.target_, key, value);
	      } else {
	        // Non-observable
	        this.target_[key] = value;
	        return true;
	      }
	    } else {
	      // New prop
	      return this.extend_(key, {
	        value: value,
	        enumerable: true,
	        writable: true,
	        configurable: true
	      }, this.defaultAnnotation_, proxyTrap);
	    }
	  }
	  // Trap for "in"
	  ;
	  _proto.has_ = function has_(key) {
	    if (!globalState.trackingDerivation) {
	      // Skip key subscription outside derivation
	      return key in this.target_;
	    }
	    this.pendingKeys_ || (this.pendingKeys_ = new Map());
	    var entry = this.pendingKeys_.get(key);
	    if (!entry) {
	      entry = new ObservableValue(key in this.target_, referenceEnhancer, "ObservableObject.key?", false);
	      this.pendingKeys_.set(key, entry);
	    }
	    return entry.get();
	  }
	  /**
	   * @param {PropertyKey} key
	   * @param {Annotation|boolean} annotation true - use default annotation, false - ignore prop
	   */;
	  _proto.make_ = function make_(key, annotation) {
	    if (annotation === true) {
	      annotation = this.defaultAnnotation_;
	    }
	    if (annotation === false) {
	      return;
	    }
	    if (!(key in this.target_)) {
	      var _this$target_$storedA;
	      // Throw on missing key, except for decorators:
	      // Decorator annotations are collected from whole prototype chain.
	      // When called from super() some props may not exist yet.
	      // However we don't have to worry about missing prop,
	      // because the decorator must have been applied to something.
	      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
	        return; // will be annotated by subclass constructor
	      } else {
	        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
	      }
	    }
	    var source = this.target_;
	    while (source && source !== objectPrototype) {
	      var descriptor = getDescriptor(source, key);
	      if (descriptor) {
	        var outcome = annotation.make_(this, key, descriptor, source);
	        if (outcome === 0 /* Cancel */) {
	          return;
	        }
	        if (outcome === 1 /* Break */) {
	          break;
	        }
	      }
	      source = Object.getPrototypeOf(source);
	    }
	    recordAnnotationApplied(this, annotation, key);
	  }
	  /**
	   * @param {PropertyKey} key
	   * @param {PropertyDescriptor} descriptor
	   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
	   * @param {boolean} proxyTrap whether it's called from proxy trap
	   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
	   */;
	  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
	    if (proxyTrap === void 0) {
	      proxyTrap = false;
	    }
	    if (annotation === true) {
	      annotation = this.defaultAnnotation_;
	    }
	    if (annotation === false) {
	      return this.defineProperty_(key, descriptor, proxyTrap);
	    }
	    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
	    if (outcome) {
	      recordAnnotationApplied(this, annotation, key);
	    }
	    return outcome;
	  }
	  /**
	   * @param {PropertyKey} key
	   * @param {PropertyDescriptor} descriptor
	   * @param {boolean} proxyTrap whether it's called from proxy trap
	   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
	   */;
	  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
	    if (proxyTrap === void 0) {
	      proxyTrap = false;
	    }
	    try {
	      startBatch();
	      // Delete
	      var deleteOutcome = this.delete_(key);
	      if (!deleteOutcome) {
	        // Failure or intercepted
	        return deleteOutcome;
	      }
	      // ADD interceptor
	      if (hasInterceptors(this)) {
	        var change = interceptChange(this, {
	          object: this.proxy_ || this.target_,
	          name: key,
	          type: ADD,
	          newValue: descriptor.value
	        });
	        if (!change) {
	          return null;
	        }
	        var newValue = change.newValue;
	        if (descriptor.value !== newValue) {
	          descriptor = _extends({}, descriptor, {
	            value: newValue
	          });
	        }
	      }
	      // Define
	      if (proxyTrap) {
	        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
	          return false;
	        }
	      } else {
	        defineProperty$3(this.target_, key, descriptor);
	      }
	      // Notify
	      this.notifyPropertyAddition_(key, descriptor.value);
	    } finally {
	      endBatch();
	    }
	    return true;
	  }
	  // If original descriptor becomes relevant, move this to annotation directly
	  ;
	  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
	    if (proxyTrap === void 0) {
	      proxyTrap = false;
	    }
	    try {
	      startBatch();
	      // Delete
	      var deleteOutcome = this.delete_(key);
	      if (!deleteOutcome) {
	        // Failure or intercepted
	        return deleteOutcome;
	      }
	      // ADD interceptor
	      if (hasInterceptors(this)) {
	        var change = interceptChange(this, {
	          object: this.proxy_ || this.target_,
	          name: key,
	          type: ADD,
	          newValue: value
	        });
	        if (!change) {
	          return null;
	        }
	        value = change.newValue;
	      }
	      var cachedDescriptor = getCachedObservablePropDescriptor(key);
	      var descriptor = {
	        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
	        enumerable: true,
	        get: cachedDescriptor.get,
	        set: cachedDescriptor.set
	      };
	      // Define
	      if (proxyTrap) {
	        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
	          return false;
	        }
	      } else {
	        defineProperty$3(this.target_, key, descriptor);
	      }
	      var observable = new ObservableValue(value, enhancer, "production" !== "production" ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
	      this.values_.set(key, observable);
	      // Notify (value possibly changed by ObservableValue)
	      this.notifyPropertyAddition_(key, observable.value_);
	    } finally {
	      endBatch();
	    }
	    return true;
	  }
	  // If original descriptor becomes relevant, move this to annotation directly
	  ;
	  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
	    if (proxyTrap === void 0) {
	      proxyTrap = false;
	    }
	    try {
	      startBatch();
	      // Delete
	      var deleteOutcome = this.delete_(key);
	      if (!deleteOutcome) {
	        // Failure or intercepted
	        return deleteOutcome;
	      }
	      // ADD interceptor
	      if (hasInterceptors(this)) {
	        var change = interceptChange(this, {
	          object: this.proxy_ || this.target_,
	          name: key,
	          type: ADD,
	          newValue: undefined
	        });
	        if (!change) {
	          return null;
	        }
	      }
	      options.name || (options.name = "production" !== "production" ? this.name_ + "." + key.toString() : "ObservableObject.key");
	      options.context = this.proxy_ || this.target_;
	      var cachedDescriptor = getCachedObservablePropDescriptor(key);
	      var descriptor = {
	        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
	        enumerable: false,
	        get: cachedDescriptor.get,
	        set: cachedDescriptor.set
	      };
	      // Define
	      if (proxyTrap) {
	        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
	          return false;
	        }
	      } else {
	        defineProperty$3(this.target_, key, descriptor);
	      }
	      this.values_.set(key, new ComputedValue(options));
	      // Notify
	      this.notifyPropertyAddition_(key, undefined);
	    } finally {
	      endBatch();
	    }
	    return true;
	  }
	  /**
	   * @param {PropertyKey} key
	   * @param {PropertyDescriptor} descriptor
	   * @param {boolean} proxyTrap whether it's called from proxy trap
	   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
	   */;
	  _proto.delete_ = function delete_(key, proxyTrap) {
	    if (proxyTrap === void 0) {
	      proxyTrap = false;
	    }
	    // No such prop
	    if (!hasProp(this.target_, key)) {
	      return true;
	    }
	    // Intercept
	    if (hasInterceptors(this)) {
	      var change = interceptChange(this, {
	        object: this.proxy_ || this.target_,
	        name: key,
	        type: REMOVE
	      });
	      // Cancelled
	      if (!change) {
	        return null;
	      }
	    }
	    // Delete
	    try {
	      var _this$pendingKeys_, _this$pendingKeys_$ge;
	      startBatch();
	      var notify = hasListeners(this);
	      var notifySpy = "production" !== "production" && isSpyEnabled();
	      var observable = this.values_.get(key);
	      // Value needed for spies/listeners
	      var value = undefined;
	      // Optimization: don't pull the value unless we will need it
	      if (!observable && (notify || notifySpy)) {
	        var _getDescriptor;
	        value = (_getDescriptor = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor.value;
	      }
	      // delete prop (do first, may fail)
	      if (proxyTrap) {
	        if (!Reflect.deleteProperty(this.target_, key)) {
	          return false;
	        }
	      } else {
	        delete this.target_[key];
	      }
	      // Allow re-annotating this field
	      if ("production" !== "production") ;
	      // Clear observable
	      if (observable) {
	        this.values_["delete"](key);
	        // for computed, value is undefined
	        if (observable instanceof ObservableValue) {
	          value = observable.value_;
	        }
	        // Notify: autorun(() => obj[key]), see #1796
	        propagateChanged(observable);
	      }
	      // Notify "keys/entries/values" observers
	      this.keysAtom_.reportChanged();
	      // Notify "has" observers
	      // "in" as it may still exist in proto
	      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_);
	      // Notify spies/listeners
	      if (notify || notifySpy) {
	        var _change2 = {
	          type: REMOVE,
	          observableKind: "object",
	          object: this.proxy_ || this.target_,
	          debugObjectName: this.name_,
	          oldValue: value,
	          name: key
	        };
	        if ("production" !== "production" && notifySpy) ;
	        if (notify) {
	          notifyListeners(this, _change2);
	        }
	        if ("production" !== "production" && notifySpy) ;
	      }
	    } finally {
	      endBatch();
	    }
	    return true;
	  }
	  /**
	   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
	   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
	   * for callback details
	   */;
	  _proto.observe_ = function observe_(callback, fireImmediately) {
	    return registerListener(this, callback);
	  };
	  _proto.intercept_ = function intercept_(handler) {
	    return registerInterceptor(this, handler);
	  };
	  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
	    var _this$pendingKeys_2, _this$pendingKeys_2$g;
	    var notify = hasListeners(this);
	    var notifySpy = "production" !== "production" ;
	    if (notify || notifySpy) {
	      var change = notify || notifySpy ? {
	        type: ADD,
	        observableKind: "object",
	        debugObjectName: this.name_,
	        object: this.proxy_ || this.target_,
	        name: key,
	        newValue: value
	      } : null;
	      if (notify) {
	        notifyListeners(this, change);
	      }
	    }
	    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true);
	    // Notify "keys/entries/values" observers
	    this.keysAtom_.reportChanged();
	  };
	  _proto.ownKeys_ = function ownKeys_() {
	    this.keysAtom_.reportObserved();
	    return ownKeys$1(this.target_);
	  };
	  _proto.keys_ = function keys_() {
	    // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.
	    // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.
	    // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)
	    // We choose to over-report in Object.keys(object), because:
	    // - typically it's used with simple data objects
	    // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected
	    this.keysAtom_.reportObserved();
	    return Object.keys(this.target_);
	  };
	  return ObservableObjectAdministration;
	}();
	function asObservableObject(target, options) {
	  var _options$name;
	  if (hasProp(target, $mobx)) {
	    return target;
	  }
	  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name : "ObservableObject";
	  var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options));
	  addHiddenProp(target, $mobx, adm);
	  return target;
	}
	var isObservableObjectAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
	function getCachedObservablePropDescriptor(key) {
	  return descriptorCache[key] || (descriptorCache[key] = {
	    get: function get() {
	      return this[$mobx].getObservablePropValue_(key);
	    },
	    set: function set(value) {
	      return this[$mobx].setObservablePropValue_(key, value);
	    }
	  });
	}
	function isObservableObject(thing) {
	  if (isObject$6(thing)) {
	    return isObservableObjectAdministration(thing[$mobx]);
	  }
	  return false;
	}
	function recordAnnotationApplied(adm, annotation, key) {
	  var _adm$target_$storedAn;
	  // Remove applied decorator annotation so we don't try to apply it again in subclass constructor
	  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
	}

	// Bug in safari 9.* (or iOS 9 safari mobile). See #364
	var ENTRY_0 = /*#__PURE__*/createArrayEntryDescriptor(0);
	/**
	 * This array buffer contains two lists of properties, so that all arrays
	 * can recycle their property definitions, which significantly improves performance of creating
	 * properties on the fly.
	 */
	var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
	// Typescript workaround to make sure ObservableArray extends Array
	var StubArray = function StubArray() {};
	function inherit(ctor, proto) {
	  if (Object.setPrototypeOf) {
	    Object.setPrototypeOf(ctor.prototype, proto);
	  } else if (ctor.prototype.__proto__ !== undefined) {
	    ctor.prototype.__proto__ = proto;
	  } else {
	    ctor.prototype = proto;
	  }
	}
	inherit(StubArray, Array.prototype);
	// Weex proto freeze protection was here,
	// but it is unclear why the hack is need as MobX never changed the prototype
	// anyway, so removed it in V6
	var LegacyObservableArray = /*#__PURE__*/function (_StubArray, _Symbol$toStringTag, _Symbol$iterator) {
	  _inheritsLoose(LegacyObservableArray, _StubArray);
	  function LegacyObservableArray(initialValues, enhancer, name, owned) {
	    var _this;
	    if (name === void 0) {
	      name = "ObservableArray";
	    }
	    if (owned === void 0) {
	      owned = false;
	    }
	    _this = _StubArray.call(this) || this;
	    var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
	    adm.proxy_ = _assertThisInitialized(_this);
	    addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);
	    if (initialValues && initialValues.length) {
	      var prev = allowStateChangesStart(true);
	      // @ts-ignore
	      _this.spliceWithArray(0, 0, initialValues);
	      allowStateChangesEnd(prev);
	    }
	    {
	      // Seems that Safari won't use numeric prototype setter untill any * numeric property is
	      // defined on the instance. After that it works fine, even if this property is deleted.
	      Object.defineProperty(_assertThisInitialized(_this), "0", ENTRY_0);
	    }
	    return _this;
	  }
	  var _proto = LegacyObservableArray.prototype;
	  _proto.concat = function concat() {
	    this[$mobx].atom_.reportObserved();
	    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
	      arrays[_key] = arguments[_key];
	    }
	    return Array.prototype.concat.apply(this.slice(),
	    //@ts-ignore
	    arrays.map(function (a) {
	      return isObservableArray(a) ? a.slice() : a;
	    }));
	  };
	  _proto[_Symbol$iterator] = function () {
	    var self = this;
	    var nextIndex = 0;
	    return makeIterable({
	      next: function next() {
	        return nextIndex < self.length ? {
	          value: self[nextIndex++],
	          done: false
	        } : {
	          done: true,
	          value: undefined
	        };
	      }
	    });
	  };
	  _createClass(LegacyObservableArray, [{
	    key: "length",
	    get: function get() {
	      return this[$mobx].getArrayLength_();
	    },
	    set: function set(newLength) {
	      this[$mobx].setArrayLength_(newLength);
	    }
	  }, {
	    key: _Symbol$toStringTag,
	    get: function get() {
	      return "Array";
	    }
	  }]);
	  return LegacyObservableArray;
	}(StubArray, Symbol.toStringTag, Symbol.iterator);
	Object.entries(arrayExtensions).forEach(function (_ref) {
	  var prop = _ref[0],
	    fn = _ref[1];
	  if (prop !== "concat") {
	    addHiddenProp(LegacyObservableArray.prototype, prop, fn);
	  }
	});
	function createArrayEntryDescriptor(index) {
	  return {
	    enumerable: false,
	    configurable: true,
	    get: function get() {
	      return this[$mobx].get_(index);
	    },
	    set: function set(value) {
	      this[$mobx].set_(index, value);
	    }
	  };
	}
	function createArrayBufferItem(index) {
	  defineProperty$3(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
	}
	function reserveArrayBuffer(max) {
	  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
	    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {
	      createArrayBufferItem(index);
	    }
	    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
	  }
	}
	reserveArrayBuffer(1000);
	function createLegacyArray(initialValues, enhancer, name) {
	  return new LegacyObservableArray(initialValues, enhancer, name);
	}

	function getAtom(thing, property) {
	  if (typeof thing === "object" && thing !== null) {
	    if (isObservableArray(thing)) {
	      if (property !== undefined) {
	        die(23);
	      }
	      return thing[$mobx].atom_;
	    }
	    if (isObservableSet(thing)) {
	      return thing.atom_;
	    }
	    if (isObservableMap(thing)) {
	      if (property === undefined) {
	        return thing.keysAtom_;
	      }
	      var observable = thing.data_.get(property) || thing.hasMap_.get(property);
	      if (!observable) {
	        die(25, property, getDebugName(thing));
	      }
	      return observable;
	    }
	    if (isObservableObject(thing)) {
	      if (!property) {
	        return die(26);
	      }
	      var _observable = thing[$mobx].values_.get(property);
	      if (!_observable) {
	        die(27, property, getDebugName(thing));
	      }
	      return _observable;
	    }
	    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
	      return thing;
	    }
	  } else if (isFunction$4(thing)) {
	    if (isReaction(thing[$mobx])) {
	      // disposer function
	      return thing[$mobx];
	    }
	  }
	  die(28);
	}
	function getAdministration(thing, property) {
	  if (!thing) {
	    die(29);
	  }
	  if (property !== undefined) {
	    return getAdministration(getAtom(thing, property));
	  }
	  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
	    return thing;
	  }
	  if (isObservableMap(thing) || isObservableSet(thing)) {
	    return thing;
	  }
	  if (thing[$mobx]) {
	    return thing[$mobx];
	  }
	  die(24, thing);
	}
	function getDebugName(thing, property) {
	  var named;
	  if (property !== undefined) {
	    named = getAtom(thing, property);
	  } else if (isAction(thing)) {
	    return thing.name;
	  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
	    named = getAdministration(thing);
	  } else {
	    // valid for arrays as well
	    named = getAtom(thing);
	  }
	  return named.name_;
	}

	var toString$2 = objectPrototype.toString;
	function deepEqual(a, b, depth) {
	  if (depth === void 0) {
	    depth = -1;
	  }
	  return eq$4(a, b, depth);
	}
	// Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289
	// Internal recursive comparison function for `isEqual`.
	function eq$4(a, b, depth, aStack, bStack) {
	  // Identical objects are equal. `0 === -0`, but they aren't identical.
	  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	  if (a === b) {
	    return a !== 0 || 1 / a === 1 / b;
	  }
	  // `null` or `undefined` only equal to itself (strict comparison).
	  if (a == null || b == null) {
	    return false;
	  }
	  // `NaN`s are equivalent, but non-reflexive.
	  if (a !== a) {
	    return b !== b;
	  }
	  // Exhaust primitive checks
	  var type = typeof a;
	  if (type !== "function" && type !== "object" && typeof b != "object") {
	    return false;
	  }
	  // Compare `[[Class]]` names.
	  var className = toString$2.call(a);
	  if (className !== toString$2.call(b)) {
	    return false;
	  }
	  switch (className) {
	    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	    case "[object RegExp]":
	    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	    case "[object String]":
	      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	      // equivalent to `new String("5")`.
	      return "" + a === "" + b;
	    case "[object Number]":
	      // `NaN`s are equivalent, but non-reflexive.
	      // Object(NaN) is equivalent to NaN.
	      if (+a !== +a) {
	        return +b !== +b;
	      }
	      // An `egal` comparison is performed for other numeric values.
	      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	    case "[object Date]":
	    case "[object Boolean]":
	      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	      // millisecond representations. Note that invalid dates with millisecond representations
	      // of `NaN` are not equivalent.
	      return +a === +b;
	    case "[object Symbol]":
	      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);
	    case "[object Map]":
	    case "[object Set]":
	      // Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.
	      // Hide this extra level by increasing the depth.
	      if (depth >= 0) {
	        depth++;
	      }
	      break;
	  }
	  // Unwrap any wrapped objects.
	  a = unwrap(a);
	  b = unwrap(b);
	  var areArrays = className === "[object Array]";
	  if (!areArrays) {
	    if (typeof a != "object" || typeof b != "object") {
	      return false;
	    }
	    // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	    // from different frames are.
	    var aCtor = a.constructor,
	      bCtor = b.constructor;
	    if (aCtor !== bCtor && !(isFunction$4(aCtor) && aCtor instanceof aCtor && isFunction$4(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
	      return false;
	    }
	  }
	  if (depth === 0) {
	    return false;
	  } else if (depth < 0) {
	    depth = -1;
	  }
	  // Assume equality for cyclic structures. The algorithm for detecting cyclic
	  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
	  // Initializing stack of traversed objects.
	  // It's done here since we only need them for objects and arrays comparison.
	  aStack = aStack || [];
	  bStack = bStack || [];
	  var length = aStack.length;
	  while (length--) {
	    // Linear search. Performance is inversely proportional to the number of
	    // unique nested structures.
	    if (aStack[length] === a) {
	      return bStack[length] === b;
	    }
	  }
	  // Add the first object to the stack of traversed objects.
	  aStack.push(a);
	  bStack.push(b);
	  // Recursively compare objects and arrays.
	  if (areArrays) {
	    // Compare array lengths to determine if a deep comparison is necessary.
	    length = a.length;
	    if (length !== b.length) {
	      return false;
	    }
	    // Deep compare the contents, ignoring non-numeric properties.
	    while (length--) {
	      if (!eq$4(a[length], b[length], depth - 1, aStack, bStack)) {
	        return false;
	      }
	    }
	  } else {
	    // Deep compare objects.
	    var keys = Object.keys(a);
	    var key;
	    length = keys.length;
	    // Ensure that both objects contain the same number of properties before comparing deep equality.
	    if (Object.keys(b).length !== length) {
	      return false;
	    }
	    while (length--) {
	      // Deep compare each member
	      key = keys[length];
	      if (!(hasProp(b, key) && eq$4(a[key], b[key], depth - 1, aStack, bStack))) {
	        return false;
	      }
	    }
	  }
	  // Remove the first object from the stack of traversed objects.
	  aStack.pop();
	  bStack.pop();
	  return true;
	}
	function unwrap(a) {
	  if (isObservableArray(a)) {
	    return a.slice();
	  }
	  if (isES6Map(a) || isObservableMap(a)) {
	    return Array.from(a.entries());
	  }
	  if (isES6Set(a) || isObservableSet(a)) {
	    return Array.from(a.entries());
	  }
	  return a;
	}

	function makeIterable(iterator) {
	  iterator[Symbol.iterator] = getSelf;
	  return iterator;
	}
	function getSelf() {
	  return this;
	}

	/**
	 * (c) Michel Weststrate 2015 - 2020
	 * MIT Licensed
	 *
	 * Welcome to the mobx sources! To get a global overview of how MobX internally works,
	 * this is a good place to start:
	 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
	 *
	 * Source folders:
	 * ===============
	 *
	 * - api/     Most of the public static methods exposed by the module can be found here.
	 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
	 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
	 * - utils/   Utility stuff.
	 *
	 */
	["Symbol", "Map", "Set"].forEach(function (m) {
	  var g = getGlobal();
	  if (typeof g[m] === "undefined") {
	    die("MobX requires global '" + m + "' to be available or polyfilled");
	  }
	});
	if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
	  // See: https://github.com/andykog/mobx-devtools/
	  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
	    spy: spy,
	    extras: {
	      getDebugName: getDebugName
	    },
	    $mobx: $mobx
	  });
	}

	if (!React$1.useState) {
	    throw new Error("mobx-react-lite requires React with Hooks support");
	}
	if (!makeObservable) {
	    throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
	}

	function defaultNoopBatch(callback) {
	    callback();
	}
	function observerBatching(reactionScheduler) {
	    if (!reactionScheduler) {
	        reactionScheduler = defaultNoopBatch;
	    }
	    configure({ reactionScheduler: reactionScheduler });
	}

	function printDebugValue(v) {
	    return getDependencyTree(v);
	}

	var REGISTRY_FINALIZE_AFTER = 10000;
	var REGISTRY_SWEEP_INTERVAL = 10000;
	var TimerBasedFinalizationRegistry = /** @class */ (function () {
	    function TimerBasedFinalizationRegistry(finalize) {
	        var _this = this;
	        Object.defineProperty(this, "finalize", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: finalize
	        });
	        Object.defineProperty(this, "registrations", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: new Map()
	        });
	        Object.defineProperty(this, "sweepTimeout", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        // Bound so it can be used directly as setTimeout callback.
	        Object.defineProperty(this, "sweep", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: function (maxAge) {
	                if (maxAge === void 0) { maxAge = REGISTRY_FINALIZE_AFTER; }
	                // cancel timeout so we can force sweep anytime
	                clearTimeout(_this.sweepTimeout);
	                _this.sweepTimeout = undefined;
	                var now = Date.now();
	                _this.registrations.forEach(function (registration, token) {
	                    if (now - registration.registeredAt >= maxAge) {
	                        _this.finalize(registration.value);
	                        _this.registrations.delete(token);
	                    }
	                });
	                if (_this.registrations.size > 0) {
	                    _this.scheduleSweep();
	                }
	            }
	        });
	        // Bound so it can be exported directly as clearTimers test utility.
	        Object.defineProperty(this, "finalizeAllImmediately", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: function () {
	                _this.sweep(0);
	            }
	        });
	    }
	    // Token is actually required with this impl
	    Object.defineProperty(TimerBasedFinalizationRegistry.prototype, "register", {
	        enumerable: false,
	        configurable: true,
	        writable: true,
	        value: function (target, value, token) {
	            this.registrations.set(token, {
	                value: value,
	                registeredAt: Date.now()
	            });
	            this.scheduleSweep();
	        }
	    });
	    Object.defineProperty(TimerBasedFinalizationRegistry.prototype, "unregister", {
	        enumerable: false,
	        configurable: true,
	        writable: true,
	        value: function (token) {
	            this.registrations.delete(token);
	        }
	    });
	    Object.defineProperty(TimerBasedFinalizationRegistry.prototype, "scheduleSweep", {
	        enumerable: false,
	        configurable: true,
	        writable: true,
	        value: function () {
	            if (this.sweepTimeout === undefined) {
	                this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL);
	            }
	        }
	    });
	    return TimerBasedFinalizationRegistry;
	}());
	var UniversalFinalizationRegistry = typeof FinalizationRegistry !== "undefined"
	    ? FinalizationRegistry
	    : TimerBasedFinalizationRegistry;

	var observerFinalizationRegistry = new UniversalFinalizationRegistry(function (adm) {
	    var _a;
	    (_a = adm.reaction) === null || _a === void 0 ? void 0 : _a.dispose();
	    adm.reaction = null;
	});

	var __read = (undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	function observerComponentNameFor(baseComponentName) {
	    return "observer".concat(baseComponentName);
	}
	/**
	 * We use class to make it easier to detect in heap snapshots by name
	 */
	var ObjectToBeRetainedByReact = /** @class */ (function () {
	    function ObjectToBeRetainedByReact() {
	    }
	    return ObjectToBeRetainedByReact;
	}());
	function objectToBeRetainedByReactFactory() {
	    return new ObjectToBeRetainedByReact();
	}
	function useObserver(fn, baseComponentName) {
	    if (baseComponentName === void 0) { baseComponentName = "observed"; }
	    var _a = __read(React$1.useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a[0];
	    // Force update, see #2982
	    var _b = __read(React$1.useState(), 2), setState = _b[1];
	    var forceUpdate = function () { return setState([]); };
	    // StrictMode/ConcurrentMode/Suspense may mean that our component is
	    // rendered and abandoned multiple times, so we need to track leaked
	    // Reactions.
	    var admRef = React$1.useRef(null);
	    if (!admRef.current) {
	        // First render
	        admRef.current = {
	            reaction: null,
	            mounted: false,
	            changedBeforeMount: false
	        };
	    }
	    var adm = admRef.current;
	    if (!adm.reaction) {
	        // First render or component was not committed and reaction was disposed by registry
	        adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function () {
	            // Observable has changed, meaning we want to re-render
	            // BUT if we're a component that hasn't yet got to the useEffect()
	            // stage, we might be a component that _started_ to render, but
	            // got dropped, and we don't want to make state changes then.
	            // (It triggers warnings in StrictMode, for a start.)
	            if (adm.mounted) {
	                // We have reached useEffect(), so we're mounted, and can trigger an update
	                forceUpdate();
	            }
	            else {
	                // We haven't yet reached useEffect(), so we'll need to trigger a re-render
	                // when (and if) useEffect() arrives.
	                adm.changedBeforeMount = true;
	            }
	        });
	        observerFinalizationRegistry.register(objectRetainedByReact, adm, adm);
	    }
	    React$1.useDebugValue(adm.reaction, printDebugValue);
	    React$1.useEffect(function () {
	        observerFinalizationRegistry.unregister(adm);
	        adm.mounted = true;
	        if (adm.reaction) {
	            if (adm.changedBeforeMount) {
	                // Got a change before mount, force an update
	                adm.changedBeforeMount = false;
	                forceUpdate();
	            }
	        }
	        else {
	            // The reaction we set up in our render has been disposed.
	            // This can be due to bad timings of renderings, e.g. our
	            // component was paused for a _very_ long time, and our
	            // reaction got cleaned up
	            // Re-create the reaction
	            adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function () {
	                // We've definitely already been mounted at this point
	                forceUpdate();
	            });
	            forceUpdate();
	        }
	        return function () {
	            adm.reaction.dispose();
	            adm.reaction = null;
	            adm.mounted = false;
	            adm.changedBeforeMount = false;
	        };
	    }, []);
	    // render the original component, but have the
	    // reaction track the observables, so that rendering
	    // can be invalidated (see above) once a dependency changes
	    var rendering;
	    var exception;
	    adm.reaction.track(function () {
	        try {
	            rendering = fn();
	        }
	        catch (e) {
	            exception = e;
	        }
	    });
	    if (exception) {
	        throw exception; // re-throw any exceptions caught during rendering
	    }
	    return rendering;
	}

	var hasSymbol = typeof Symbol === "function" && Symbol.for;
	// Using react-is had some issues (and operates on elements, not on types), see #608 / #609
	hasSymbol
	    ? Symbol.for("react.forward_ref")
	    : typeof React$1.forwardRef === "function" && React$1.forwardRef(function (props) { return null; })["$$typeof"];
	hasSymbol
	    ? Symbol.for("react.memo")
	    : typeof React$1.memo === "function" && React$1.memo(function (props) { return null; })["$$typeof"];

	function ObserverComponent(_a) {
	    var children = _a.children, render = _a.render;
	    var component = children || render;
	    if (typeof component !== "function") {
	        return null;
	    }
	    return useObserver(component);
	}
	ObserverComponent.displayName = "Observer";

	(undefined && undefined.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};

	var _a;
	observerBatching(ReactDOM.unstable_batchedUpdates);
	(_a = observerFinalizationRegistry["finalizeAllImmediately"]) !== null && _a !== void 0 ? _a : (function () { });

	/**
	 * Actions represent the type of change to a location value.
	 *
	 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action
	 */
	var Action;

	(function (Action) {
	  /**
	   * A POP indicates a change to an arbitrary index in the history stack, such
	   * as a back or forward navigation. It does not describe the direction of the
	   * navigation, only that the current index changed.
	   *
	   * Note: This is the default action for newly created history objects.
	   */
	  Action["Pop"] = "POP";
	  /**
	   * A PUSH indicates a new entry being added to the history stack, such as when
	   * a link is clicked and a new page loads. When this happens, all subsequent
	   * entries in the stack are lost.
	   */

	  Action["Push"] = "PUSH";
	  /**
	   * A REPLACE indicates the entry at the current index in the history stack
	   * being replaced by a new one.
	   */

	  Action["Replace"] = "REPLACE";
	})(Action || (Action = {}));

	var readOnly = function (obj) {
	  return obj;
	};

	var BeforeUnloadEventType = 'beforeunload';
	var PopStateEventType = 'popstate';
	/**
	 * Browser history stores the location in regular URLs. This is the standard for
	 * most web apps, but it requires some configuration on the server to ensure you
	 * serve the same app at multiple URLs.
	 *
	 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
	 */

	function createBrowserHistory(options) {
	  if (options === void 0) {
	    options = {};
	  }

	  var _options = options,
	      _options$window = _options.window,
	      window = _options$window === void 0 ? document.defaultView : _options$window;
	  var globalHistory = window.history;

	  function getIndexAndLocation() {
	    var _window$location = window.location,
	        pathname = _window$location.pathname,
	        search = _window$location.search,
	        hash = _window$location.hash;
	    var state = globalHistory.state || {};
	    return [state.idx, readOnly({
	      pathname: pathname,
	      search: search,
	      hash: hash,
	      state: state.usr || null,
	      key: state.key || 'default'
	    })];
	  }

	  var blockedPopTx = null;

	  function handlePop() {
	    if (blockedPopTx) {
	      blockers.call(blockedPopTx);
	      blockedPopTx = null;
	    } else {
	      var nextAction = Action.Pop;

	      var _getIndexAndLocation = getIndexAndLocation(),
	          nextIndex = _getIndexAndLocation[0],
	          nextLocation = _getIndexAndLocation[1];

	      if (blockers.length) {
	        if (nextIndex != null) {
	          var delta = index - nextIndex;

	          if (delta) {
	            // Revert the POP
	            blockedPopTx = {
	              action: nextAction,
	              location: nextLocation,
	              retry: function retry() {
	                go(delta * -1);
	              }
	            };
	            go(delta);
	          }
	        }
	      } else {
	        applyTx(nextAction);
	      }
	    }
	  }

	  window.addEventListener(PopStateEventType, handlePop);
	  var action = Action.Pop;

	  var _getIndexAndLocation2 = getIndexAndLocation(),
	      index = _getIndexAndLocation2[0],
	      location = _getIndexAndLocation2[1];

	  var listeners = createEvents();
	  var blockers = createEvents();

	  if (index == null) {
	    index = 0;
	    globalHistory.replaceState(_extends$1({}, globalHistory.state, {
	      idx: index
	    }), '');
	  }

	  function createHref(to) {
	    return typeof to === 'string' ? to : createPath(to);
	  } // state defaults to `null` because `window.history.state` does


	  function getNextLocation(to, state) {
	    if (state === void 0) {
	      state = null;
	    }

	    return readOnly(_extends$1({
	      pathname: location.pathname,
	      hash: '',
	      search: ''
	    }, typeof to === 'string' ? parsePath(to) : to, {
	      state: state,
	      key: createKey()
	    }));
	  }

	  function getHistoryStateAndUrl(nextLocation, index) {
	    return [{
	      usr: nextLocation.state,
	      key: nextLocation.key,
	      idx: index
	    }, createHref(nextLocation)];
	  }

	  function allowTx(action, location, retry) {
	    return !blockers.length || (blockers.call({
	      action: action,
	      location: location,
	      retry: retry
	    }), false);
	  }

	  function applyTx(nextAction) {
	    action = nextAction;

	    var _getIndexAndLocation3 = getIndexAndLocation();

	    index = _getIndexAndLocation3[0];
	    location = _getIndexAndLocation3[1];
	    listeners.call({
	      action: action,
	      location: location
	    });
	  }

	  function push(to, state) {
	    var nextAction = Action.Push;
	    var nextLocation = getNextLocation(to, state);

	    function retry() {
	      push(to, state);
	    }

	    if (allowTx(nextAction, nextLocation, retry)) {
	      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),
	          historyState = _getHistoryStateAndUr[0],
	          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading
	      // try...catch because iOS limits us to 100 pushState calls :/


	      try {
	        globalHistory.pushState(historyState, '', url);
	      } catch (error) {
	        // They are going to lose state here, but there is no real
	        // way to warn them about it since the page will refresh...
	        window.location.assign(url);
	      }

	      applyTx(nextAction);
	    }
	  }

	  function replace(to, state) {
	    var nextAction = Action.Replace;
	    var nextLocation = getNextLocation(to, state);

	    function retry() {
	      replace(to, state);
	    }

	    if (allowTx(nextAction, nextLocation, retry)) {
	      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),
	          historyState = _getHistoryStateAndUr2[0],
	          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading


	      globalHistory.replaceState(historyState, '', url);
	      applyTx(nextAction);
	    }
	  }

	  function go(delta) {
	    globalHistory.go(delta);
	  }

	  var history = {
	    get action() {
	      return action;
	    },

	    get location() {
	      return location;
	    },

	    createHref: createHref,
	    push: push,
	    replace: replace,
	    go: go,
	    back: function back() {
	      go(-1);
	    },
	    forward: function forward() {
	      go(1);
	    },
	    listen: function listen(listener) {
	      return listeners.push(listener);
	    },
	    block: function block(blocker) {
	      var unblock = blockers.push(blocker);

	      if (blockers.length === 1) {
	        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
	      }

	      return function () {
	        unblock(); // Remove the beforeunload listener so the document may
	        // still be salvageable in the pagehide event.
	        // See https://html.spec.whatwg.org/#unloading-documents

	        if (!blockers.length) {
	          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
	        }
	      };
	    }
	  };
	  return history;
	}

	function promptBeforeUnload(event) {
	  // Cancel the event.
	  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.

	  event.returnValue = '';
	}

	function createEvents() {
	  var handlers = [];
	  return {
	    get length() {
	      return handlers.length;
	    },

	    push: function push(fn) {
	      handlers.push(fn);
	      return function () {
	        handlers = handlers.filter(function (handler) {
	          return handler !== fn;
	        });
	      };
	    },
	    call: function call(arg) {
	      handlers.forEach(function (fn) {
	        return fn && fn(arg);
	      });
	    }
	  };
	}

	function createKey() {
	  return Math.random().toString(36).substr(2, 8);
	}
	/**
	 * Creates a string URL path from the given pathname, search, and hash components.
	 *
	 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath
	 */


	function createPath(_ref) {
	  var _ref$pathname = _ref.pathname,
	      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,
	      _ref$search = _ref.search,
	      search = _ref$search === void 0 ? '' : _ref$search,
	      _ref$hash = _ref.hash,
	      hash = _ref$hash === void 0 ? '' : _ref$hash;
	  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;
	  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;
	  return pathname;
	}
	/**
	 * Parses a string URL path into its separate pathname, search, and hash components.
	 *
	 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath
	 */

	function parsePath(path) {
	  var parsedPath = {};

	  if (path) {
	    var hashIndex = path.indexOf('#');

	    if (hashIndex >= 0) {
	      parsedPath.hash = path.substr(hashIndex);
	      path = path.substr(0, hashIndex);
	    }

	    var searchIndex = path.indexOf('?');

	    if (searchIndex >= 0) {
	      parsedPath.search = path.substr(searchIndex);
	      path = path.substr(0, searchIndex);
	    }

	    if (path) {
	      parsedPath.pathname = path;
	    }
	  }

	  return parsedPath;
	}

	/* eslint-disable */

	function _defineProperty$1(obj, key, value) {
	  return key in obj ? Object.defineProperty(obj, key, {
	    value,
	    enumerable: !0,
	    configurable: !0,
	    writable: !0
	  }) : obj[key] = value, obj;
	}

	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);
	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    enumerableOnly && (symbols = symbols.filter((function(sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    }))), keys.push.apply(keys, symbols);
	  }
	  return keys;
	}

	function _objectSpread2$7(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = null != arguments[i] ? arguments[i] : {};
	    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
	      _defineProperty$1(target, key, source[key]);
	    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
	      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	    }));
	  }
	  return target;
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
	    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	/**
	 * Parse a string for the raw tokens.
	 */
	function parse$1(str, options) {
	  void 0 === options && (options = {});
	  for (var tokens = 
	  /**
	 * Tokenize input string.
	 */
	  function(str) {
	    for (var tokens = [], i = 0; i < str.length; ) {
	      var char = str[i];
	      if ("*" !== char && "+" !== char && "?" !== char) if ("\\" !== char) if ("{" !== char) if ("}" !== char) if (":" !== char) if ("(" !== char) tokens.push({
	        type: "CHAR",
	        index: i,
	        value: str[i++]
	      }); else {
	        var count = 1, pattern = "";
	        if ("?" === str[j = i + 1]) throw new TypeError('Pattern cannot start with "?" at ' + j);
	        for (;j < str.length; ) if ("\\" !== str[j]) {
	          if (")" === str[j]) {
	            if (0 == --count) {
	              j++;
	              break;
	            }
	          } else if ("(" === str[j] && (count++, "?" !== str[j + 1])) throw new TypeError("Capturing groups are not allowed at " + j);
	          pattern += str[j++];
	        } else pattern += str[j++] + str[j++];
	        if (count) throw new TypeError("Unbalanced pattern at " + i);
	        if (!pattern) throw new TypeError("Missing pattern at " + i);
	        tokens.push({
	          type: "PATTERN",
	          index: i,
	          value: pattern
	        }), i = j;
	      } else {
	        for (var name = "", j = i + 1; j < str.length; ) {
	          var code = str.charCodeAt(j);
	          if (
	          // `0-9`
	          !(code >= 48 && code <= 57 || 
	          // `A-Z`
	          code >= 65 && code <= 90 || 
	          // `a-z`
	          code >= 97 && code <= 122 || 
	          // `_`
	          95 === code)) break;
	          name += str[j++];
	        }
	        if (!name) throw new TypeError("Missing parameter name at " + i);
	        tokens.push({
	          type: "NAME",
	          index: i,
	          value: name
	        }), i = j;
	      } else tokens.push({
	        type: "CLOSE",
	        index: i,
	        value: str[i++]
	      }); else tokens.push({
	        type: "OPEN",
	        index: i,
	        value: str[i++]
	      }); else tokens.push({
	        type: "ESCAPED_CHAR",
	        index: i++,
	        value: str[i++]
	      }); else tokens.push({
	        type: "MODIFIER",
	        index: i,
	        value: str[i++]
	      });
	    }
	    return tokens.push({
	      type: "END",
	      index: i,
	      value: ""
	    }), tokens;
	  }(str), _a = options.prefixes, prefixes = void 0 === _a ? "./" : _a, defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?", result = [], key = 0, i = 0, path = "", tryConsume = function(type) {
	    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;
	  }, mustConsume = function(type) {
	    var value = tryConsume(type);
	    if (void 0 !== value) return value;
	    var _a = tokens[i], nextType = _a.type, index = _a.index;
	    throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
	  }, consumeText = function() {
	    // tslint:disable-next-line
	    for (var value, result = ""; value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"); ) result += value;
	    return result;
	  }; i < tokens.length; ) {
	    var char = tryConsume("CHAR"), name = tryConsume("NAME"), pattern = tryConsume("PATTERN");
	    if (name || pattern) {
	      var prefix = char || "";
	      -1 === prefixes.indexOf(prefix) && (path += prefix, prefix = ""), path && (result.push(path), 
	      path = ""), result.push({
	        name: name || key++,
	        prefix,
	        suffix: "",
	        pattern: pattern || defaultPattern,
	        modifier: tryConsume("MODIFIER") || ""
	      });
	    } else {
	      var value = char || tryConsume("ESCAPED_CHAR");
	      if (value) path += value; else if (path && (result.push(path), path = ""), tryConsume("OPEN")) {
	        prefix = consumeText();
	        var name_1 = tryConsume("NAME") || "", pattern_1 = tryConsume("PATTERN") || "", suffix = consumeText();
	        mustConsume("CLOSE"), result.push({
	          name: name_1 || (pattern_1 ? key++ : ""),
	          pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
	          prefix,
	          suffix,
	          modifier: tryConsume("MODIFIER") || ""
	        });
	      } else mustConsume("END");
	    }
	  }
	  return result;
	}

	/**
	 * Create path match function from `path-to-regexp` spec.
	 */ function match$1(str, options) {
	  var keys = [];
	  /**
	 * Create a path match function from `path-to-regexp` output.
	 */
	  return function(re, keys, options) {
	    void 0 === options && (options = {});
	    var _a = options.decode, decode = void 0 === _a ? function(x) {
	      return x;
	    } : _a;
	    return function(pathname) {
	      var m = re.exec(pathname);
	      if (!m) return !1;
	      for (var path = m[0], index = m.index, params = Object.create(null), _loop_1 = function(i) {
	        // tslint:disable-next-line
	        if (void 0 === m[i]) return "continue";
	        var key = keys[i - 1];
	        "*" === key.modifier || "+" === key.modifier ? params[key.name] = m[i].split(key.prefix + key.suffix).map((function(value) {
	          return decode(value, key);
	        })) : params[key.name] = decode(m[i], key);
	      }, i = 1; i < m.length; i++) _loop_1(i);
	      return {
	        path,
	        index,
	        params
	      };
	    };
	  }
	  /**
	 * Escape a regular expression string.
	 */ (pathToRegexp(str, keys, options), keys, options);
	}

	function escapeString(str) {
	  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
	}

	/**
	 * Get the flags for a regexp from the options.
	 */ function flags(options) {
	  return options && options.sensitive ? "" : "i";
	}

	/**
	 * Pull out keys from a regexp.
	 */
	/**
	 * Create a path regexp from string input.
	 */
	function stringToRegexp(path, keys, options) {
	  /**
	 * Expose a function for taking tokens and returning a RegExp.
	 */
	  return function(tokens, keys, options) {
	    void 0 === options && (options = {});
	    // Iterate over the tokens and create our regexp string.
	    for (var _a = options.strict, strict = void 0 !== _a && _a, _b = options.start, start = void 0 === _b || _b, _c = options.end, end = void 0 === _c || _c, _d = options.encode, encode = void 0 === _d ? function(x) {
	      return x;
	    } : _d, endsWith = "[" + escapeString(options.endsWith || "") + "]|$", delimiter = "[" + escapeString(options.delimiter || "/#?") + "]", route = start ? "^" : "", _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
	      var token = tokens_1[_i];
	      if ("string" == typeof token) route += escapeString(encode(token)); else {
	        var prefix = escapeString(encode(token.prefix)), suffix = escapeString(encode(token.suffix));
	        if (token.pattern) if (keys && keys.push(token), prefix || suffix) if ("+" === token.modifier || "*" === token.modifier) {
	          var mod = "*" === token.modifier ? "?" : "";
	          route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
	        } else route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier; else route += "(" + token.pattern + ")" + token.modifier; else route += "(?:" + prefix + suffix + ")" + token.modifier;
	      }
	    }
	    if (end) strict || (route += delimiter + "?"), route += options.endsWith ? "(?=" + endsWith + ")" : "$"; else {
	      var endToken = tokens[tokens.length - 1], isEndDelimited = "string" == typeof endToken ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : // tslint:disable-next-line
	      void 0 === endToken;
	      strict || (route += "(?:" + delimiter + "(?=" + endsWith + "))?"), isEndDelimited || (route += "(?=" + delimiter + "|" + endsWith + ")");
	    }
	    return new RegExp(route, flags(options));
	  }
	  /**
	 * Normalize the given path string, returning a regular expression.
	 *
	 * An empty array can be passed in for the keys, which will hold the
	 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
	 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
	 */ (parse$1(path, options), keys, options);
	}

	function pathToRegexp(path, keys, options) {
	  return path instanceof RegExp ? function(path, keys) {
	    if (!keys) return path;
	    for (var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g, index = 0, execResult = groupsRegex.exec(path.source); execResult; ) keys.push({
	      // Use parenthesized substring match if available, index otherwise
	      name: execResult[1] || index++,
	      prefix: "",
	      suffix: "",
	      modifier: "",
	      pattern: ""
	    }), execResult = groupsRegex.exec(path.source);
	    return path;
	  }
	  /**
	 * Transform an array into a regexp.
	 */ (path, keys) : Array.isArray(path) ? function(paths, keys, options) {
	    var parts = paths.map((function(path) {
	      return pathToRegexp(path, keys, options).source;
	    }));
	    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
	  }(path, keys, options) : stringToRegexp(path, keys, options);
	}

	var RouterStore =  function() {
	  function RouterStore(history) {
	    var _this = this;
	    !function(instance, Constructor) {
	      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
	    }(this, RouterStore), this.pathList = [], this.history = void 0, this.state = {
	      action: Action.Pop,
	      location: {
	        key: "default",
	        pathname: "",
	        search: "",
	        state: {},
	        hash: ""
	      }
	    }, this.updateState = action((function(newState) {
	      _this.state = {
	        action: newState.action,
	        location: _objectSpread2$7({}, newState.location)
	      };
	    })), this.push = void 0, this.replace = void 0, this.go = void 0, this.back = void 0, 
	    this.forward = void 0, this.goBack = void 0, this.goForward = void 0, this.subscribe = void 0, 
	    this.stopSyncWithHistory = void 0, this.history = history, this.push = history.push.bind(history), 
	    this.replace = history.replace.bind(history), this.go = history.go.bind(history);
	    // compatible with old history api
	    var back = history.back.bind(history), forward = history.forward.bind(history);
	    this.back = back, this.forward = forward, makeObservable(this, {
	      state: observable,
	      location: computed,
	      query: computed,
	      pathList: observable,
	      hashValue: computed,
	      pathValue: computed,
	      appendPathList: action,
	      prependPathList: action
	    }), 
	    /**
	     * Listen for changes to location state in store
	     * and run listener at once
	     */
	    this.subscribe = function(listener) {
	      var unlisten = history.listen(listener);
	      return listener({
	        action: history.action,
	        location: history.location
	      }), unlisten;
	    }, this.stopSyncWithHistory = this.subscribe(this.updateState);
	  }
	  var Constructor, protoProps;
	  return Constructor = RouterStore, protoProps = [ {
	    key: "location",
	    get: 
	    /** @readonly */
	    function() {
	      return this.state.location;
	    }
	  }, {
	    key: "query",
	    get: 
	    /**
	     * get query format from location.search
	     * @readonly
	     * */
	    function() {
	      var search = this.location.search, query = {};
	      return search && new URLSearchParams(search).forEach((function(value, name) {
	        query[name] ? Array.isArray(query[name]) ? query[name].push(value) : query[name] = [ query[name], value ] : query[name] = value;
	      })), query;
	    }
	    /**
	     * get hash, not include '#'
	     * @readonly
	     * */  }, {
	    key: "hashValue",
	    get: function() {
	      var hash = this.location.hash;
	      return hash ? hash.slice(1) : "";
	    }
	    /**
	     * get path variable value, example:
	     * /path/:name => /path/abc
	     * router.pathValue.name => ac
	     *
	     * @readonly
	     * */  }, {
	    key: "pathValue",
	    get: function() {
	      var pathname = this.location.pathname, param = {}, hasPathValue = !1;
	      return this.pathList.find((function(path) {
	        var matchResult = match$1(path, {
	          decode: decodeURIComponent
	        })(pathname);
	        return matchResult && matchResult && (param = matchResult.params, hasPathValue = !0), 
	        hasPathValue;
	      })), param;
	    }
	    /**
	     * append new path to router.pathList, like '/abc/:name'
	     * Note: the pathList order will affect pathValue
	     * */  }, {
	    key: "appendPathList",
	    value: function() {
	      var _this$pathList;
	      (_this$pathList = this.pathList).push.apply(_this$pathList, arguments);
	    }
	    /**
	     * preppend new path to router.pathList, like '/abc/:name'
	     * Note: the pathList order will affect pathValue
	     * */  }, {
	    key: "prependPathList",
	    value: function() {
	      var _this$pathList2;
	      (_this$pathList2 = this.pathList).unshift.apply(_this$pathList2, arguments);
	    }
	    /*
	     * History methods
	     */  } ], protoProps && _defineProperties(Constructor.prototype, protoProps), 
	  RouterStore;
	}();

	var Month = {};

	var interopRequireDefault = {exports: {}};

	(function (module) {
		function _interopRequireDefault(obj) {
		  return obj && obj.__esModule ? obj : {
		    "default": obj
		  };
		}
		module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (interopRequireDefault));

	var interopRequireDefaultExports = interopRequireDefault.exports;

	var interopRequireWildcard = {exports: {}};

	var _typeof = {exports: {}};

	(function (module) {
		function _typeof(obj) {
		  "@babel/helpers - typeof";

		  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
		    return typeof obj;
		  } : function (obj) {
		    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
		  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
		}
		module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (_typeof));

	var _typeofExports = _typeof.exports;

	(function (module) {
		var _typeof = _typeofExports["default"];
		function _getRequireWildcardCache(nodeInterop) {
		  if (typeof WeakMap !== "function") return null;
		  var cacheBabelInterop = new WeakMap();
		  var cacheNodeInterop = new WeakMap();
		  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
		    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
		  })(nodeInterop);
		}
		function _interopRequireWildcard(obj, nodeInterop) {
		  if (!nodeInterop && obj && obj.__esModule) {
		    return obj;
		  }
		  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
		    return {
		      "default": obj
		    };
		  }
		  var cache = _getRequireWildcardCache(nodeInterop);
		  if (cache && cache.has(obj)) {
		    return cache.get(obj);
		  }
		  var newObj = {};
		  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
		  for (var key in obj) {
		    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
		      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
		      if (desc && (desc.get || desc.set)) {
		        Object.defineProperty(newObj, key, desc);
		      } else {
		        newObj[key] = obj[key];
		      }
		    }
		  }
		  newObj["default"] = obj;
		  if (cache) {
		    cache.set(obj, newObj);
		  }
		  return newObj;
		}
		module.exports = _interopRequireWildcard, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (interopRequireWildcard));

	var interopRequireWildcardExports = interopRequireWildcard.exports;

	var objectWithoutProperties = {exports: {}};

	var objectWithoutPropertiesLoose = {exports: {}};

	(function (module) {
		function _objectWithoutPropertiesLoose(source, excluded) {
		  if (source == null) return {};
		  var target = {};
		  var sourceKeys = Object.keys(source);
		  var key, i;
		  for (i = 0; i < sourceKeys.length; i++) {
		    key = sourceKeys[i];
		    if (excluded.indexOf(key) >= 0) continue;
		    target[key] = source[key];
		  }
		  return target;
		}
		module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (objectWithoutPropertiesLoose));

	var objectWithoutPropertiesLooseExports = objectWithoutPropertiesLoose.exports;

	(function (module) {
		var objectWithoutPropertiesLoose = objectWithoutPropertiesLooseExports;
		function _objectWithoutProperties(source, excluded) {
		  if (source == null) return {};
		  var target = objectWithoutPropertiesLoose(source, excluded);
		  var key, i;
		  if (Object.getOwnPropertySymbols) {
		    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		    for (i = 0; i < sourceSymbolKeys.length; i++) {
		      key = sourceSymbolKeys[i];
		      if (excluded.indexOf(key) >= 0) continue;
		      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
		      target[key] = source[key];
		    }
		  }
		  return target;
		}
		module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (objectWithoutProperties));

	var objectWithoutPropertiesExports = objectWithoutProperties.exports;

	var toConsumableArray = {exports: {}};

	var arrayWithoutHoles = {exports: {}};

	var arrayLikeToArray = {exports: {}};

	(function (module) {
		function _arrayLikeToArray(arr, len) {
		  if (len == null || len > arr.length) len = arr.length;
		  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
		  return arr2;
		}
		module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (arrayLikeToArray));

	var arrayLikeToArrayExports = arrayLikeToArray.exports;

	(function (module) {
		var arrayLikeToArray = arrayLikeToArrayExports;
		function _arrayWithoutHoles(arr) {
		  if (Array.isArray(arr)) return arrayLikeToArray(arr);
		}
		module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (arrayWithoutHoles));

	var arrayWithoutHolesExports = arrayWithoutHoles.exports;

	var iterableToArray = {exports: {}};

	(function (module) {
		function _iterableToArray(iter) {
		  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
		}
		module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (iterableToArray));

	var iterableToArrayExports = iterableToArray.exports;

	var unsupportedIterableToArray = {exports: {}};

	(function (module) {
		var arrayLikeToArray = arrayLikeToArrayExports;
		function _unsupportedIterableToArray(o, minLen) {
		  if (!o) return;
		  if (typeof o === "string") return arrayLikeToArray(o, minLen);
		  var n = Object.prototype.toString.call(o).slice(8, -1);
		  if (n === "Object" && o.constructor) n = o.constructor.name;
		  if (n === "Map" || n === "Set") return Array.from(o);
		  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
		}
		module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (unsupportedIterableToArray));

	var unsupportedIterableToArrayExports = unsupportedIterableToArray.exports;

	var nonIterableSpread = {exports: {}};

	(function (module) {
		function _nonIterableSpread() {
		  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
		}
		module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (nonIterableSpread));

	var nonIterableSpreadExports = nonIterableSpread.exports;

	(function (module) {
		var arrayWithoutHoles = arrayWithoutHolesExports;
		var iterableToArray = iterableToArrayExports;
		var unsupportedIterableToArray = unsupportedIterableToArrayExports;
		var nonIterableSpread = nonIterableSpreadExports;
		function _toConsumableArray(arr) {
		  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
		}
		module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (toConsumableArray));

	var toConsumableArrayExports = toConsumableArray.exports;

	var classCallCheck = {exports: {}};

	(function (module) {
		function _classCallCheck(instance, Constructor) {
		  if (!(instance instanceof Constructor)) {
		    throw new TypeError("Cannot call a class as a function");
		  }
		}
		module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (classCallCheck));

	var classCallCheckExports = classCallCheck.exports;

	var createClass = {exports: {}};

	var toPropertyKey = {exports: {}};

	var toPrimitive = {exports: {}};

	(function (module) {
		var _typeof = _typeofExports["default"];
		function _toPrimitive(input, hint) {
		  if (_typeof(input) !== "object" || input === null) return input;
		  var prim = input[Symbol.toPrimitive];
		  if (prim !== undefined) {
		    var res = prim.call(input, hint || "default");
		    if (_typeof(res) !== "object") return res;
		    throw new TypeError("@@toPrimitive must return a primitive value.");
		  }
		  return (hint === "string" ? String : Number)(input);
		}
		module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (toPrimitive));

	var toPrimitiveExports = toPrimitive.exports;

	(function (module) {
		var _typeof = _typeofExports["default"];
		var toPrimitive = toPrimitiveExports;
		function _toPropertyKey(arg) {
		  var key = toPrimitive(arg, "string");
		  return _typeof(key) === "symbol" ? key : String(key);
		}
		module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (toPropertyKey));

	var toPropertyKeyExports = toPropertyKey.exports;

	(function (module) {
		var toPropertyKey = toPropertyKeyExports;
		function _defineProperties(target, props) {
		  for (var i = 0; i < props.length; i++) {
		    var descriptor = props[i];
		    descriptor.enumerable = descriptor.enumerable || false;
		    descriptor.configurable = true;
		    if ("value" in descriptor) descriptor.writable = true;
		    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
		  }
		}
		function _createClass(Constructor, protoProps, staticProps) {
		  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		  if (staticProps) _defineProperties(Constructor, staticProps);
		  Object.defineProperty(Constructor, "prototype", {
		    writable: false
		  });
		  return Constructor;
		}
		module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (createClass));

	var createClassExports = createClass.exports;

	var inherits = {exports: {}};

	var setPrototypeOf = {exports: {}};

	(function (module) {
		function _setPrototypeOf(o, p) {
		  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
		    o.__proto__ = p;
		    return o;
		  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
		  return _setPrototypeOf(o, p);
		}
		module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (setPrototypeOf));

	var setPrototypeOfExports = setPrototypeOf.exports;

	(function (module) {
		var setPrototypeOf = setPrototypeOfExports;
		function _inherits(subClass, superClass) {
		  if (typeof superClass !== "function" && superClass !== null) {
		    throw new TypeError("Super expression must either be null or a function");
		  }
		  subClass.prototype = Object.create(superClass && superClass.prototype, {
		    constructor: {
		      value: subClass,
		      writable: true,
		      configurable: true
		    }
		  });
		  Object.defineProperty(subClass, "prototype", {
		    writable: false
		  });
		  if (superClass) setPrototypeOf(subClass, superClass);
		}
		module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (inherits));

	var inheritsExports = inherits.exports;

	var createSuper = {exports: {}};

	var getPrototypeOf = {exports: {}};

	(function (module) {
		function _getPrototypeOf(o) {
		  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
		    return o.__proto__ || Object.getPrototypeOf(o);
		  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
		  return _getPrototypeOf(o);
		}
		module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (getPrototypeOf));

	var getPrototypeOfExports = getPrototypeOf.exports;

	var isNativeReflectConstruct = {exports: {}};

	(function (module) {
		function _isNativeReflectConstruct() {
		  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
		  if (Reflect.construct.sham) return false;
		  if (typeof Proxy === "function") return true;
		  try {
		    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
		    return true;
		  } catch (e) {
		    return false;
		  }
		}
		module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (isNativeReflectConstruct));

	var isNativeReflectConstructExports = isNativeReflectConstruct.exports;

	var possibleConstructorReturn = {exports: {}};

	var assertThisInitialized = {exports: {}};

	(function (module) {
		function _assertThisInitialized(self) {
		  if (self === void 0) {
		    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		  }
		  return self;
		}
		module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (assertThisInitialized));

	var assertThisInitializedExports = assertThisInitialized.exports;

	(function (module) {
		var _typeof = _typeofExports["default"];
		var assertThisInitialized = assertThisInitializedExports;
		function _possibleConstructorReturn(self, call) {
		  if (call && (_typeof(call) === "object" || typeof call === "function")) {
		    return call;
		  } else if (call !== void 0) {
		    throw new TypeError("Derived constructors may only return object or undefined");
		  }
		  return assertThisInitialized(self);
		}
		module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (possibleConstructorReturn));

	var possibleConstructorReturnExports = possibleConstructorReturn.exports;

	(function (module) {
		var getPrototypeOf = getPrototypeOfExports;
		var isNativeReflectConstruct = isNativeReflectConstructExports;
		var possibleConstructorReturn = possibleConstructorReturnExports;
		function _createSuper(Derived) {
		  var hasNativeReflectConstruct = isNativeReflectConstruct();
		  return function _createSuperInternal() {
		    var Super = getPrototypeOf(Derived),
		      result;
		    if (hasNativeReflectConstruct) {
		      var NewTarget = getPrototypeOf(this).constructor;
		      result = Reflect.construct(Super, arguments, NewTarget);
		    } else {
		      result = Super.apply(this, arguments);
		    }
		    return possibleConstructorReturn(this, result);
		  };
		}
		module.exports = _createSuper, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (createSuper));

	var createSuperExports = createSuper.exports;

	var require$$9$1 = /*@__PURE__*/getAugmentedNamespace(clsx_m);

	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */

	function baseSlice$1(array, start, end) {
	  var index = -1,
	      length = array.length;

	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = end > length ? length : end;
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;

	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}

	var _baseSlice = baseSlice$1;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */

	function eq$3(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq$3;

	/** Detect free variable `global` from Node.js. */

	var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal$1;

	var freeGlobal = _freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root$8 = freeGlobal || freeSelf || Function('return this')();

	var _root = root$8;

	var root$7 = _root;

	/** Built-in value references. */
	var Symbol$6 = root$7.Symbol;

	var _Symbol = Symbol$6;

	var Symbol$5 = _Symbol;

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$b.toString;

	/** Built-in value references. */
	var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag$1(value) {
	  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1),
	      tag = value[symToStringTag$1];

	  try {
	    value[symToStringTag$1] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString$1.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$1] = tag;
	    } else {
	      delete value[symToStringTag$1];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag$1;

	/** Used for built-in method references. */

	var objectProto$a = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto$a.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString$1(value) {
	  return nativeObjectToString.call(value);
	}

	var _objectToString = objectToString$1;

	var Symbol$4 = _Symbol,
	    getRawTag = _getRawTag,
	    objectToString = _objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag$5(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	var _baseGetTag = baseGetTag$5;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */

	function isObject$5(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject$5;

	var baseGetTag$4 = _baseGetTag,
	    isObject$4 = isObject_1;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag$1 = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction$3(value) {
	  if (!isObject$4(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag$4(value);
	  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction$3;

	/** Used as references for various `Number` constants. */

	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength$3(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
	}

	var isLength_1 = isLength$3;

	var isFunction$2 = isFunction_1,
	    isLength$2 = isLength_1;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike$4(value) {
	  return value != null && isLength$2(value.length) && !isFunction$2(value);
	}

	var isArrayLike_1 = isArrayLike$4;

	/** Used as references for various `Number` constants. */

	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex$3(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	var _isIndex = isIndex$3;

	var eq$2 = eq_1,
	    isArrayLike$3 = isArrayLike_1,
	    isIndex$2 = _isIndex,
	    isObject$3 = isObject_1;

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall$3(value, index, object) {
	  if (!isObject$3(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike$3(object) && isIndex$2(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq$2(object[index], value);
	  }
	  return false;
	}

	var _isIterateeCall = isIterateeCall$3;

	/** Used to match a single whitespace character. */

	var reWhitespace = /\s/;

	/**
	 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
	 * character of `string`.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {number} Returns the index of the last non-whitespace character.
	 */
	function trimmedEndIndex$1(string) {
	  var index = string.length;

	  while (index-- && reWhitespace.test(string.charAt(index))) {}
	  return index;
	}

	var _trimmedEndIndex = trimmedEndIndex$1;

	var trimmedEndIndex = _trimmedEndIndex;

	/** Used to match leading whitespace. */
	var reTrimStart = /^\s+/;

	/**
	 * The base implementation of `_.trim`.
	 *
	 * @private
	 * @param {string} string The string to trim.
	 * @returns {string} Returns the trimmed string.
	 */
	function baseTrim$1(string) {
	  return string
	    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
	    : string;
	}

	var _baseTrim = baseTrim$1;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */

	function isObjectLike$5(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike$5;

	var baseGetTag$3 = _baseGetTag,
	    isObjectLike$4 = isObjectLike_1;

	/** `Object#toString` result references. */
	var symbolTag$1 = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol$5(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike$4(value) && baseGetTag$3(value) == symbolTag$1);
	}

	var isSymbol_1 = isSymbol$5;

	var baseTrim = _baseTrim,
	    isObject$2 = isObject_1,
	    isSymbol$4 = isSymbol_1;

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber$1(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol$4(value)) {
	    return NAN;
	  }
	  if (isObject$2(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject$2(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = baseTrim(value);
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	var toNumber_1 = toNumber$1;

	var toNumber = toNumber_1;

	/** Used as references for various `Number` constants. */
	var INFINITY$2 = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite$2(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY$2 || value === -INFINITY$2) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	var toFinite_1 = toFinite$2;

	var toFinite$1 = toFinite_1;

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger$2(value) {
	  var result = toFinite$1(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	var toInteger_1 = toInteger$2;

	var baseSlice = _baseSlice,
	    isIterateeCall$2 = _isIterateeCall,
	    toInteger$1 = toInteger_1;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil$1 = Math.ceil,
	    nativeMax$3 = Math.max;

	/**
	 * Creates an array of elements split into groups the length of `size`.
	 * If `array` can't be split evenly, the final chunk will be the remaining
	 * elements.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to process.
	 * @param {number} [size=1] The length of each chunk
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the new array of chunks.
	 * @example
	 *
	 * _.chunk(['a', 'b', 'c', 'd'], 2);
	 * // => [['a', 'b'], ['c', 'd']]
	 *
	 * _.chunk(['a', 'b', 'c', 'd'], 3);
	 * // => [['a', 'b', 'c'], ['d']]
	 */
	function chunk(array, size, guard) {
	  if ((guard ? isIterateeCall$2(array, size, guard) : size === undefined)) {
	    size = 1;
	  } else {
	    size = nativeMax$3(toInteger$1(size), 0);
	  }
	  var length = array == null ? 0 : array.length;
	  if (!length || size < 1) {
	    return [];
	  }
	  var index = 0,
	      resIndex = 0,
	      result = Array(nativeCeil$1(length / size));

	  while (index < length) {
	    result[resIndex++] = baseSlice(array, index, (index += size));
	  }
	  return result;
	}

	var chunk_1 = chunk;

	var constants = {};

	Object.defineProperty(constants, "__esModule", {
	  value: true
	});
	constants.views = constants.navigate = void 0;
	var navigate = {
	  PREVIOUS: 'PREV',
	  NEXT: 'NEXT',
	  TODAY: 'TODAY',
	  DATE: 'DATE'
	};
	constants.navigate = navigate;
	var views$1 = {
	  MONTH: 'month',
	  WEEK: 'week',
	  WORK_WEEK: 'work_week',
	  DAY: 'day',
	  AGENDA: 'agenda'
	};
	constants.views = views$1;

	var helpers = {};

	Object.defineProperty(helpers, "__esModule", {
	  value: true
	});
	helpers.instanceId = instanceId$1;
	helpers.isFirstFocusedRender = isFirstFocusedRender;
	helpers.notify = notify;
	var idCount = 0;
	function uniqueId(prefix) {
	  return '' + ((prefix == null ? '' : prefix) + ++idCount);
	}
	function notify(handler, args) {
	  handler && handler.apply(null, [].concat(args));
	}
	function instanceId$1(component) {
	  var suffix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	  component.__id || (component.__id = uniqueId('rw_'));
	  return (component.props.id || component.__id) + suffix;
	}
	function isFirstFocusedRender(component) {
	  return component._firstFocus || component.state.focused && (component._firstFocus = true);
	}

	var require$$17 = /*@__PURE__*/getAugmentedNamespace(position$2);

	var require$$10 = /*@__PURE__*/getAugmentedNamespace(animationFrame$2);

	var PopOverlay$1 = {};

	var require$$4$3 = /*@__PURE__*/getAugmentedNamespace(esm);

	var Popup$1 = {};

	var require$$4$2 = /*@__PURE__*/getAugmentedNamespace(offset$3);

	var useClickOutside$1 = {};

	Object.defineProperty(useClickOutside$1, "__esModule", {
	  value: true
	});
	useClickOutside$1.default = useClickOutside;
	var _react$n = React$1;
	function useClickOutside(_ref) {
	  var ref = _ref.ref,
	    callback = _ref.callback;
	  (0, _react$n.useEffect)(function () {
	    var handleClickOutside = function handleClickOutside(e) {
	      if (ref.current && !ref.current.contains(e.target)) {
	        callback();
	      }
	    };
	    document.addEventListener('mousedown', handleClickOutside);
	    return function () {
	      document.removeEventListener('mousedown', handleClickOutside);
	    };
	  }, [ref, callback]);
	}

	var EventCell$1 = {};

	var objectSpread2 = {exports: {}};

	var defineProperty$2 = {exports: {}};

	(function (module) {
		var toPropertyKey = toPropertyKeyExports;
		function _defineProperty(obj, key, value) {
		  key = toPropertyKey(key);
		  if (key in obj) {
		    Object.defineProperty(obj, key, {
		      value: value,
		      enumerable: true,
		      configurable: true,
		      writable: true
		    });
		  } else {
		    obj[key] = value;
		  }
		  return obj;
		}
		module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (defineProperty$2));

	var definePropertyExports = defineProperty$2.exports;

	(function (module) {
		var defineProperty = definePropertyExports;
		function ownKeys(object, enumerableOnly) {
		  var keys = Object.keys(object);
		  if (Object.getOwnPropertySymbols) {
		    var symbols = Object.getOwnPropertySymbols(object);
		    enumerableOnly && (symbols = symbols.filter(function (sym) {
		      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
		    })), keys.push.apply(keys, symbols);
		  }
		  return keys;
		}
		function _objectSpread2(target) {
		  for (var i = 1; i < arguments.length; i++) {
		    var source = null != arguments[i] ? arguments[i] : {};
		    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
		      defineProperty(target, key, source[key]);
		    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
		      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
		    });
		  }
		  return target;
		}
		module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (objectSpread2));

	var objectSpread2Exports = objectSpread2.exports;

	var _interopRequireDefault$v = interopRequireDefaultExports.default;
	Object.defineProperty(EventCell$1, "__esModule", {
	  value: true
	});
	EventCell$1.default = void 0;
	var _objectSpread2$6 = _interopRequireDefault$v(objectSpread2Exports);
	var _objectWithoutProperties2$4 = _interopRequireDefault$v(objectWithoutPropertiesExports);
	var _classCallCheck2$d = _interopRequireDefault$v(classCallCheckExports);
	var _createClass2$d = _interopRequireDefault$v(createClassExports);
	var _inherits2$b = _interopRequireDefault$v(inheritsExports);
	var _createSuper2$b = _interopRequireDefault$v(createSuperExports);
	var _react$m = _interopRequireDefault$v(React$1);
	var _clsx$b = _interopRequireDefault$v(require$$9$1);
	var _excluded$a = ["style", "className", "event", "selected", "isAllDay", "onSelect", "onDoubleClick", "onKeyPress", "localizer", "continuesPrior", "continuesAfter", "accessors", "getters", "children", "components", "slotStart", "slotEnd"];
	var EventCell = /*#__PURE__*/function (_React$Component) {
	  (0, _inherits2$b.default)(EventCell, _React$Component);
	  var _super = (0, _createSuper2$b.default)(EventCell);
	  function EventCell() {
	    (0, _classCallCheck2$d.default)(this, EventCell);
	    return _super.apply(this, arguments);
	  }
	  (0, _createClass2$d.default)(EventCell, [{
	    key: "render",
	    value: function render() {
	      var _this$props = this.props,
	        style = _this$props.style,
	        className = _this$props.className,
	        event = _this$props.event,
	        selected = _this$props.selected,
	        isAllDay = _this$props.isAllDay,
	        onSelect = _this$props.onSelect,
	        _onDoubleClick = _this$props.onDoubleClick,
	        _onKeyPress = _this$props.onKeyPress,
	        localizer = _this$props.localizer,
	        continuesPrior = _this$props.continuesPrior,
	        continuesAfter = _this$props.continuesAfter,
	        accessors = _this$props.accessors,
	        getters = _this$props.getters,
	        children = _this$props.children,
	        _this$props$component = _this$props.components,
	        Event = _this$props$component.event,
	        EventWrapper = _this$props$component.eventWrapper,
	        slotStart = _this$props.slotStart,
	        slotEnd = _this$props.slotEnd,
	        props = (0, _objectWithoutProperties2$4.default)(_this$props, _excluded$a);
	      delete props.resizable;
	      var title = accessors.title(event);
	      var tooltip = accessors.tooltip(event);
	      var end = accessors.end(event);
	      var start = accessors.start(event);
	      var allDay = accessors.allDay(event);
	      var showAsAllDay = isAllDay || allDay || localizer.diff(start, localizer.ceil(end, 'day'), 'day') > 1;
	      var userProps = getters.eventProp(event, start, end, selected);
	      var content = /*#__PURE__*/_react$m.default.createElement("div", {
	        className: "rbc-event-content",
	        title: tooltip || undefined
	      }, Event ? /*#__PURE__*/_react$m.default.createElement(Event, {
	        event: event,
	        continuesPrior: continuesPrior,
	        continuesAfter: continuesAfter,
	        title: title,
	        isAllDay: allDay,
	        localizer: localizer,
	        slotStart: slotStart,
	        slotEnd: slotEnd
	      }) : title);
	      return /*#__PURE__*/_react$m.default.createElement(EventWrapper, Object.assign({}, this.props, {
	        type: "date"
	      }), /*#__PURE__*/_react$m.default.createElement("div", Object.assign({}, props, {
	        tabIndex: 0,
	        style: (0, _objectSpread2$6.default)((0, _objectSpread2$6.default)({}, userProps.style), style),
	        className: (0, _clsx$b.default)('rbc-event', className, userProps.className, {
	          'rbc-selected': selected,
	          'rbc-event-allday': showAsAllDay,
	          'rbc-event-continues-prior': continuesPrior,
	          'rbc-event-continues-after': continuesAfter
	        }),
	        onClick: function onClick(e) {
	          return onSelect && onSelect(event, e);
	        },
	        onDoubleClick: function onDoubleClick(e) {
	          return _onDoubleClick && _onDoubleClick(event, e);
	        },
	        onKeyPress: function onKeyPress(e) {
	          return _onKeyPress && _onKeyPress(event, e);
	        }
	      }), typeof children === 'function' ? children(content) : content));
	    }
	  }]);
	  return EventCell;
	}(_react$m.default.Component);
	var _default$o = EventCell;
	EventCell$1.default = _default$o;

	var selection = {};

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */

	function listCacheClear$1() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear$1;

	var eq$1 = eq_1;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf$4(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq$1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf$4;

	var assocIndexOf$3 = _assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete$1(key) {
	  var data = this.__data__,
	      index = assocIndexOf$3(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete$1;

	var assocIndexOf$2 = _assocIndexOf;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet$1(key) {
	  var data = this.__data__,
	      index = assocIndexOf$2(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet$1;

	var assocIndexOf$1 = _assocIndexOf;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas$1(key) {
	  return assocIndexOf$1(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas$1;

	var assocIndexOf = _assocIndexOf;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet$1(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet$1;

	var listCacheClear = _listCacheClear,
	    listCacheDelete = _listCacheDelete,
	    listCacheGet = _listCacheGet,
	    listCacheHas = _listCacheHas,
	    listCacheSet = _listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache$4(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache$4.prototype.clear = listCacheClear;
	ListCache$4.prototype['delete'] = listCacheDelete;
	ListCache$4.prototype.get = listCacheGet;
	ListCache$4.prototype.has = listCacheHas;
	ListCache$4.prototype.set = listCacheSet;

	var _ListCache = ListCache$4;

	var ListCache$3 = _ListCache;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear$1() {
	  this.__data__ = new ListCache$3;
	  this.size = 0;
	}

	var _stackClear = stackClear$1;

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */

	function stackDelete$1(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	var _stackDelete = stackDelete$1;

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */

	function stackGet$1(key) {
	  return this.__data__.get(key);
	}

	var _stackGet = stackGet$1;

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */

	function stackHas$1(key) {
	  return this.__data__.has(key);
	}

	var _stackHas = stackHas$1;

	var root$6 = _root;

	/** Used to detect overreaching core-js shims. */
	var coreJsData$1 = root$6['__core-js_shared__'];

	var _coreJsData = coreJsData$1;

	var coreJsData = _coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked$1(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked$1;

	/** Used for built-in method references. */

	var funcProto$1 = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource$2(func) {
	  if (func != null) {
	    try {
	      return funcToString$1.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource$2;

	var isFunction$1 = isFunction_1,
	    isMasked = _isMasked,
	    isObject$1 = isObject_1,
	    toSource$1 = _toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto$9 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty$8).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative$1(value) {
	  if (!isObject$1(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource$1(value));
	}

	var _baseIsNative = baseIsNative$1;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */

	function getValue$1(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue$1;

	var baseIsNative = _baseIsNative,
	    getValue = _getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative$7(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative$7;

	var getNative$6 = _getNative,
	    root$5 = _root;

	/* Built-in method references that are verified to be native. */
	var Map$4 = getNative$6(root$5, 'Map');

	var _Map = Map$4;

	var getNative$5 = _getNative;

	/* Built-in method references that are verified to be native. */
	var nativeCreate$4 = getNative$5(Object, 'create');

	var _nativeCreate = nativeCreate$4;

	var nativeCreate$3 = _nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear$1() {
	  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear$1;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */

	function hashDelete$1(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete$1;

	var nativeCreate$2 = _nativeCreate;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet$1(key) {
	  var data = this.__data__;
	  if (nativeCreate$2) {
	    var result = data[key];
	    return result === HASH_UNDEFINED$2 ? undefined : result;
	  }
	  return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet$1;

	var nativeCreate$1 = _nativeCreate;

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas$1(key) {
	  var data = this.__data__;
	  return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$6.call(data, key);
	}

	var _hashHas = hashHas$1;

	var nativeCreate = _nativeCreate;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet$1(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet$1;

	var hashClear = _hashClear,
	    hashDelete = _hashDelete,
	    hashGet = _hashGet,
	    hashHas = _hashHas,
	    hashSet = _hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash$1(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash$1.prototype.clear = hashClear;
	Hash$1.prototype['delete'] = hashDelete;
	Hash$1.prototype.get = hashGet;
	Hash$1.prototype.has = hashHas;
	Hash$1.prototype.set = hashSet;

	var _Hash = Hash$1;

	var Hash = _Hash,
	    ListCache$2 = _ListCache,
	    Map$3 = _Map;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear$1() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map$3 || ListCache$2),
	    'string': new Hash
	  };
	}

	var _mapCacheClear = mapCacheClear$1;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */

	function isKeyable$1(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable$1;

	var isKeyable = _isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData$4(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData$4;

	var getMapData$3 = _getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete$1(key) {
	  var result = getMapData$3(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete$1;

	var getMapData$2 = _getMapData;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet$1(key) {
	  return getMapData$2(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet$1;

	var getMapData$1 = _getMapData;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas$1(key) {
	  return getMapData$1(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas$1;

	var getMapData = _getMapData;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet$1(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet$1;

	var mapCacheClear = _mapCacheClear,
	    mapCacheDelete = _mapCacheDelete,
	    mapCacheGet = _mapCacheGet,
	    mapCacheHas = _mapCacheHas,
	    mapCacheSet = _mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache$3(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache$3.prototype.clear = mapCacheClear;
	MapCache$3.prototype['delete'] = mapCacheDelete;
	MapCache$3.prototype.get = mapCacheGet;
	MapCache$3.prototype.has = mapCacheHas;
	MapCache$3.prototype.set = mapCacheSet;

	var _MapCache = MapCache$3;

	var ListCache$1 = _ListCache,
	    Map$2 = _Map,
	    MapCache$2 = _MapCache;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet$1(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache$1) {
	    var pairs = data.__data__;
	    if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache$2(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	var _stackSet = stackSet$1;

	var ListCache = _ListCache,
	    stackClear = _stackClear,
	    stackDelete = _stackDelete,
	    stackGet = _stackGet,
	    stackHas = _stackHas,
	    stackSet = _stackSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack$2(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack$2.prototype.clear = stackClear;
	Stack$2.prototype['delete'] = stackDelete;
	Stack$2.prototype.get = stackGet;
	Stack$2.prototype.has = stackHas;
	Stack$2.prototype.set = stackSet;

	var _Stack = Stack$2;

	/** Used to stand-in for `undefined` hash values. */

	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd$1(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	var _setCacheAdd = setCacheAdd$1;

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */

	function setCacheHas$1(value) {
	  return this.__data__.has(value);
	}

	var _setCacheHas = setCacheHas$1;

	var MapCache$1 = _MapCache,
	    setCacheAdd = _setCacheAdd,
	    setCacheHas = _setCacheHas;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache$1(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache$1;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
	SetCache$1.prototype.has = setCacheHas;

	var _SetCache = SetCache$1;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */

	function arraySome$1(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	var _arraySome = arraySome$1;

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */

	function cacheHas$1(cache, key) {
	  return cache.has(key);
	}

	var _cacheHas = cacheHas$1;

	var SetCache = _SetCache,
	    arraySome = _arraySome,
	    cacheHas = _cacheHas;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$5 = 1,
	    COMPARE_UNORDERED_FLAG$3 = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Check that cyclic values are equal.
	  var arrStacked = stack.get(array);
	  var othStacked = stack.get(other);
	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	var _equalArrays = equalArrays$2;

	var root$4 = _root;

	/** Built-in value references. */
	var Uint8Array$1 = root$4.Uint8Array;

	var _Uint8Array = Uint8Array$1;

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */

	function mapToArray$1(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	var _mapToArray = mapToArray$1;

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */

	function setToArray$1(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	var _setToArray = setToArray$1;

	var Symbol$3 = _Symbol,
	    Uint8Array = _Uint8Array,
	    eq = eq_1,
	    equalArrays$1 = _equalArrays,
	    mapToArray = _mapToArray,
	    setToArray = _setToArray;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$4 = 1,
	    COMPARE_UNORDERED_FLAG$2 = 2;

	/** `Object#toString` result references. */
	var boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    mapTag$2 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$2 = '[object Set]',
	    stringTag$1 = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$2 = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : undefined,
	    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag$2:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag$1:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag$1:
	    case dateTag$1:
	    case numberTag$1:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag$1:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag$1:
	    case stringTag$1:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag$2:
	      var convert = mapToArray;

	    case setTag$2:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG$2;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	var _equalByTag = equalByTag$1;

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */

	function arrayPush$2(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	var _arrayPush = arrayPush$2;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */

	var isArray$b = Array.isArray;

	var isArray_1 = isArray$b;

	var arrayPush$1 = _arrayPush,
	    isArray$a = isArray_1;

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray$a(object) ? result : arrayPush$1(result, symbolsFunc(object));
	}

	var _baseGetAllKeys = baseGetAllKeys$1;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */

	function arrayFilter$1(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	var _arrayFilter = arrayFilter$1;

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */

	function stubArray$1() {
	  return [];
	}

	var stubArray_1 = stubArray$1;

	var arrayFilter = _arrayFilter,
	    stubArray = stubArray_1;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable$1.call(object, symbol);
	  });
	};

	var _getSymbols = getSymbols$1;

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */

	function baseTimes$1(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	var _baseTimes = baseTimes$1;

	var baseGetTag$2 = _baseGetTag,
	    isObjectLike$3 = isObjectLike_1;

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments$1(value) {
	  return isObjectLike$3(value) && baseGetTag$2(value) == argsTag$2;
	}

	var _baseIsArguments = baseIsArguments$1;

	var baseIsArguments = _baseIsArguments,
	    isObjectLike$2 = isObjectLike_1;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments$3 = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike$2(value) && hasOwnProperty$5.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	var isArguments_1 = isArguments$3;

	var isBuffer$2 = {exports: {}};

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */

	function stubFalse() {
	  return false;
	}

	var stubFalse_1 = stubFalse;

	isBuffer$2.exports;

	(function (module, exports) {
		var root = _root,
		    stubFalse = stubFalse_1;

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined;

		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

		/**
		 * Checks if `value` is a buffer.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		 * @example
		 *
		 * _.isBuffer(new Buffer(2));
		 * // => true
		 *
		 * _.isBuffer(new Uint8Array(2));
		 * // => false
		 */
		var isBuffer = nativeIsBuffer || stubFalse;

		module.exports = isBuffer; 
	} (isBuffer$2, isBuffer$2.exports));

	var isBufferExports = isBuffer$2.exports;

	var baseGetTag$1 = _baseGetTag,
	    isLength$1 = isLength_1,
	    isObjectLike$1 = isObjectLike_1;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag$1 = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag$2 = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag$1 = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag$1 = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag$1 = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag$1] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag$1] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag$1] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray$1(value) {
	  return isObjectLike$1(value) &&
	    isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
	}

	var _baseIsTypedArray = baseIsTypedArray$1;

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */

	function baseUnary$2(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	var _baseUnary = baseUnary$2;

	var _nodeUtil = {exports: {}};

	_nodeUtil.exports;

	(function (module, exports) {
		var freeGlobal = _freeGlobal;

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Detect free variable `process` from Node.js. */
		var freeProcess = moduleExports && freeGlobal.process;

		/** Used to access faster Node.js helpers. */
		var nodeUtil = (function() {
		  try {
		    // Use `util.types` for Node.js 10+.
		    var types = freeModule && freeModule.require && freeModule.require('util').types;

		    if (types) {
		      return types;
		    }

		    // Legacy `process.binding('util')` for Node.js < 10.
		    return freeProcess && freeProcess.binding && freeProcess.binding('util');
		  } catch (e) {}
		}());

		module.exports = nodeUtil; 
	} (_nodeUtil, _nodeUtil.exports));

	var _nodeUtilExports = _nodeUtil.exports;

	var baseIsTypedArray = _baseIsTypedArray,
	    baseUnary$1 = _baseUnary,
	    nodeUtil = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray$2 = nodeIsTypedArray ? baseUnary$1(nodeIsTypedArray) : baseIsTypedArray;

	var isTypedArray_1 = isTypedArray$2;

	var baseTimes = _baseTimes,
	    isArguments$2 = isArguments_1,
	    isArray$9 = isArray_1,
	    isBuffer$1 = isBufferExports,
	    isIndex$1 = _isIndex,
	    isTypedArray$1 = isTypedArray_1;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys$1(value, inherited) {
	  var isArr = isArray$9(value),
	      isArg = !isArr && isArguments$2(value),
	      isBuff = !isArr && !isArg && isBuffer$1(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$4.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex$1(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _arrayLikeKeys = arrayLikeKeys$1;

	/** Used for built-in method references. */

	var objectProto$3 = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype$1(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$3;

	  return value === proto;
	}

	var _isPrototype = isPrototype$1;

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */

	function overArg$1(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	var _overArg = overArg$1;

	var overArg = _overArg;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys$1 = overArg(Object.keys, Object);

	var _nativeKeys = nativeKeys$1;

	var isPrototype = _isPrototype,
	    nativeKeys = _nativeKeys;

	/** Used for built-in method references. */
	var objectProto$2 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$2.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys$1(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeys = baseKeys$1;

	var arrayLikeKeys = _arrayLikeKeys,
	    baseKeys = _baseKeys,
	    isArrayLike$2 = isArrayLike_1;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys$3(object) {
	  return isArrayLike$2(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	var keys_1 = keys$3;

	var baseGetAllKeys = _baseGetAllKeys,
	    getSymbols = _getSymbols,
	    keys$2 = keys_1;

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys$1(object) {
	  return baseGetAllKeys(object, keys$2, getSymbols);
	}

	var _getAllKeys = getAllKeys$1;

	var getAllKeys = _getAllKeys;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$3 = 1;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$1.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
	      return false;
	    }
	  }
	  // Check that cyclic values are equal.
	  var objStacked = stack.get(object);
	  var othStacked = stack.get(other);
	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	var _equalObjects = equalObjects$1;

	var getNative$4 = _getNative,
	    root$3 = _root;

	/* Built-in method references that are verified to be native. */
	var DataView$1 = getNative$4(root$3, 'DataView');

	var _DataView = DataView$1;

	var getNative$3 = _getNative,
	    root$2 = _root;

	/* Built-in method references that are verified to be native. */
	var Promise$2 = getNative$3(root$2, 'Promise');

	var _Promise = Promise$2;

	var getNative$2 = _getNative,
	    root$1 = _root;

	/* Built-in method references that are verified to be native. */
	var Set$2 = getNative$2(root$1, 'Set');

	var _Set = Set$2;

	var getNative$1 = _getNative,
	    root = _root;

	/* Built-in method references that are verified to be native. */
	var WeakMap$2 = getNative$1(root, 'WeakMap');

	var _WeakMap = WeakMap$2;

	var DataView = _DataView,
	    Map$1 = _Map,
	    Promise$1 = _Promise,
	    Set$1 = _Set,
	    WeakMap$1 = _WeakMap,
	    baseGetTag = _baseGetTag,
	    toSource = _toSource;

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag$1 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map$1),
	    promiseCtorString = toSource(Promise$1),
	    setCtorString = toSource(Set$1),
	    weakMapCtorString = toSource(WeakMap$1);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag$1 = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map$1 && getTag$1(new Map$1) != mapTag) ||
	    (Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag) ||
	    (Set$1 && getTag$1(new Set$1) != setTag) ||
	    (WeakMap$1 && getTag$1(new WeakMap$1) != weakMapTag)) {
	  getTag$1 = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag$1 ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	var _getTag = getTag$1;

	var Stack$1 = _Stack,
	    equalArrays = _equalArrays,
	    equalByTag = _equalByTag,
	    equalObjects = _equalObjects,
	    getTag = _getTag,
	    isArray$8 = isArray_1,
	    isBuffer = isBufferExports,
	    isTypedArray = isTypedArray_1;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$2 = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray$8(object),
	      othIsArr = isArray$8(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack$1);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
	    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty$1.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack$1);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack$1);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	var _baseIsEqualDeep = baseIsEqualDeep$1;

	var baseIsEqualDeep = _baseIsEqualDeep,
	    isObjectLike = isObjectLike_1;

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual$3(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);
	}

	var _baseIsEqual = baseIsEqual$3;

	var baseIsEqual$2 = _baseIsEqual;

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual$1(value, other) {
	  return baseIsEqual$2(value, other);
	}

	var isEqual_1 = isEqual$1;

	var _interopRequireDefault$u = interopRequireDefaultExports.default;
	Object.defineProperty(selection, "__esModule", {
	  value: true
	});
	selection.dateCellSelection = dateCellSelection;
	selection.getSlotAtX = getSlotAtX;
	selection.isSelected = isSelected;
	selection.pointInBox = pointInBox;
	selection.slotWidth = slotWidth;
	var _isEqual = _interopRequireDefault$u(isEqual_1);
	function isSelected(event, selected) {
	  if (!event || selected == null) return false;
	  return (0, _isEqual.default)(event, selected);
	}
	function slotWidth(rowBox, slots) {
	  var rowWidth = rowBox.right - rowBox.left;
	  var cellWidth = rowWidth / slots;
	  return cellWidth;
	}
	function getSlotAtX(rowBox, x, rtl, slots) {
	  var cellWidth = slotWidth(rowBox, slots);
	  return rtl ? slots - 1 - Math.floor((x - rowBox.left) / cellWidth) : Math.floor((x - rowBox.left) / cellWidth);
	}
	function pointInBox(box, _ref) {
	  var x = _ref.x,
	    y = _ref.y;
	  return y >= box.top && y <= box.bottom && x >= box.left && x <= box.right;
	}
	function dateCellSelection(start, rowBox, box, slots, rtl) {
	  var startIdx = -1;
	  var endIdx = -1;
	  var lastSlotIdx = slots - 1;
	  var cellWidth = slotWidth(rowBox, slots);

	  // cell under the mouse
	  var currentSlot = getSlotAtX(rowBox, box.x, rtl, slots);

	  // Identify row as either the initial row
	  // or the row under the current mouse point
	  var isCurrentRow = rowBox.top < box.y && rowBox.bottom > box.y;
	  var isStartRow = rowBox.top < start.y && rowBox.bottom > start.y;

	  // this row's position relative to the start point
	  var isAboveStart = start.y > rowBox.bottom;
	  var isBelowStart = rowBox.top > start.y;
	  var isBetween = box.top < rowBox.top && box.bottom > rowBox.bottom;

	  // this row is between the current and start rows, so entirely selected
	  if (isBetween) {
	    startIdx = 0;
	    endIdx = lastSlotIdx;
	  }
	  if (isCurrentRow) {
	    if (isBelowStart) {
	      startIdx = 0;
	      endIdx = currentSlot;
	    } else if (isAboveStart) {
	      startIdx = currentSlot;
	      endIdx = lastSlotIdx;
	    }
	  }
	  if (isStartRow) {
	    // select the cell under the initial point
	    startIdx = endIdx = rtl ? lastSlotIdx - Math.floor((start.x - rowBox.left) / cellWidth) : Math.floor((start.x - rowBox.left) / cellWidth);
	    if (isCurrentRow) {
	      if (currentSlot < startIdx) startIdx = currentSlot;else endIdx = currentSlot; //select current range
	    } else if (start.y < box.y) {
	      // the current row is below start row
	      // select cells to the right of the start cell
	      endIdx = lastSlotIdx;
	    } else {
	      // select cells to the left of the start cell
	      startIdx = 0;
	    }
	  }
	  return {
	    startIdx: startIdx,
	    endIdx: endIdx
	  };
	}

	var _interopRequireDefault$t = interopRequireDefaultExports.default;
	var _interopRequireWildcard$9 = interopRequireWildcardExports.default;
	Object.defineProperty(Popup$1, "__esModule", {
	  value: true
	});
	Popup$1.default = void 0;
	var _react$l = _interopRequireWildcard$9(React$1);
	var _propTypes$3 = _interopRequireDefault$t(propTypesExports);
	var _offset = _interopRequireDefault$t(require$$4$2);
	var _useClickOutside = _interopRequireDefault$t(useClickOutside$1);
	var _EventCell$1 = _interopRequireDefault$t(EventCell$1);
	var _selection$4 = selection;
	/**
	 * Changes to react-overlays cause issue with auto positioning,
	 * so we need to manually calculate the position of the popper,
	 * and constrain it to the Month container.
	 */
	function getPosition(_ref) {
	  var target = _ref.target,
	    offset = _ref.offset,
	    container = _ref.container,
	    box = _ref.box;
	  var _getOffset = (0, _offset.default)(target),
	    top = _getOffset.top,
	    left = _getOffset.left,
	    width = _getOffset.width,
	    height = _getOffset.height;
	  var _getOffset2 = (0, _offset.default)(container),
	    cTop = _getOffset2.top,
	    cLeft = _getOffset2.left,
	    cWidth = _getOffset2.width,
	    cHeight = _getOffset2.height;
	  var _getOffset3 = (0, _offset.default)(box),
	    bWidth = _getOffset3.width,
	    bHeight = _getOffset3.height;
	  var viewBottom = cTop + cHeight;
	  var viewRight = cLeft + cWidth;
	  var bottom = top + bHeight;
	  var right = left + bWidth;
	  var x = offset.x,
	    y = offset.y;
	  var topOffset = bottom > viewBottom ? top - bHeight - y : top + y + height;
	  var leftOffset = right > viewRight ? left + x - bWidth + width : left + x;
	  return {
	    topOffset: topOffset,
	    leftOffset: leftOffset
	  };
	}
	function Pop(_ref2) {
	  var containerRef = _ref2.containerRef,
	    accessors = _ref2.accessors,
	    getters = _ref2.getters,
	    selected = _ref2.selected,
	    components = _ref2.components,
	    localizer = _ref2.localizer,
	    position = _ref2.position,
	    show = _ref2.show,
	    events = _ref2.events,
	    slotStart = _ref2.slotStart,
	    slotEnd = _ref2.slotEnd,
	    onSelect = _ref2.onSelect,
	    onDoubleClick = _ref2.onDoubleClick,
	    onKeyPress = _ref2.onKeyPress,
	    handleDragStart = _ref2.handleDragStart,
	    popperRef = _ref2.popperRef,
	    target = _ref2.target,
	    offset = _ref2.offset;
	  (0, _useClickOutside.default)({
	    ref: popperRef,
	    callback: show
	  });
	  (0, _react$l.useLayoutEffect)(function () {
	    var _getPosition = getPosition({
	        target: target,
	        offset: offset,
	        container: containerRef.current,
	        box: popperRef.current
	      }),
	      topOffset = _getPosition.topOffset,
	      leftOffset = _getPosition.leftOffset;
	    popperRef.current.style.top = "".concat(topOffset, "px");
	    popperRef.current.style.left = "".concat(leftOffset, "px");
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	  }, [offset.x, offset.y, target]);
	  var width = position.width;
	  var style = {
	    minWidth: width + width / 2
	  };
	  return /*#__PURE__*/_react$l.default.createElement("div", {
	    style: style,
	    className: "rbc-overlay",
	    ref: popperRef
	  }, /*#__PURE__*/_react$l.default.createElement("div", {
	    className: "rbc-overlay-header"
	  }, localizer.format(slotStart, 'dayHeaderFormat')), events.map(function (event, idx) {
	    return /*#__PURE__*/_react$l.default.createElement(_EventCell$1.default, {
	      key: idx,
	      type: "popup",
	      localizer: localizer,
	      event: event,
	      getters: getters,
	      onSelect: onSelect,
	      accessors: accessors,
	      components: components,
	      onDoubleClick: onDoubleClick,
	      onKeyPress: onKeyPress,
	      continuesPrior: localizer.lt(accessors.end(event), slotStart, 'day'),
	      continuesAfter: localizer.gte(accessors.start(event), slotEnd, 'day'),
	      slotStart: slotStart,
	      slotEnd: slotEnd,
	      selected: (0, _selection$4.isSelected)(event, selected),
	      draggable: true,
	      onDragStart: function onDragStart() {
	        return handleDragStart(event);
	      },
	      onDragEnd: function onDragEnd() {
	        return show();
	      }
	    });
	  }));
	}
	var Popup = /*#__PURE__*/_react$l.default.forwardRef(function (props, ref) {
	  return /*#__PURE__*/_react$l.default.createElement(Pop, Object.assign({}, props, {
	    popperRef: ref
	  }));
	});
	Popup.propTypes = {
	  accessors: _propTypes$3.default.object.isRequired,
	  getters: _propTypes$3.default.object.isRequired,
	  selected: _propTypes$3.default.object,
	  components: _propTypes$3.default.object.isRequired,
	  localizer: _propTypes$3.default.object.isRequired,
	  position: _propTypes$3.default.object.isRequired,
	  show: _propTypes$3.default.func.isRequired,
	  events: _propTypes$3.default.array.isRequired,
	  slotStart: _propTypes$3.default.instanceOf(Date).isRequired,
	  slotEnd: _propTypes$3.default.instanceOf(Date),
	  onSelect: _propTypes$3.default.func,
	  onDoubleClick: _propTypes$3.default.func,
	  onKeyPress: _propTypes$3.default.func,
	  handleDragStart: _propTypes$3.default.func,
	  style: _propTypes$3.default.object,
	  offset: _propTypes$3.default.shape({
	    x: _propTypes$3.default.number,
	    y: _propTypes$3.default.number
	  })
	};
	var _default$n = Popup;
	Popup$1.default = _default$n;

	var _interopRequireDefault$s = interopRequireDefaultExports.default;
	var _interopRequireWildcard$8 = interopRequireWildcardExports.default;
	Object.defineProperty(PopOverlay$1, "__esModule", {
	  value: true
	});
	PopOverlay$1.default = void 0;
	var _react$k = _interopRequireWildcard$8(React$1);
	var _propTypes$2 = _interopRequireDefault$s(propTypesExports);
	var _reactOverlays = require$$4$3;
	var _Popup = _interopRequireDefault$s(Popup$1);
	function CalOverlay(_ref) {
	  var containerRef = _ref.containerRef,
	    _ref$popupOffset = _ref.popupOffset,
	    popupOffset = _ref$popupOffset === void 0 ? 5 : _ref$popupOffset,
	    overlay = _ref.overlay,
	    accessors = _ref.accessors,
	    localizer = _ref.localizer,
	    components = _ref.components,
	    getters = _ref.getters,
	    selected = _ref.selected,
	    handleSelectEvent = _ref.handleSelectEvent,
	    handleDoubleClickEvent = _ref.handleDoubleClickEvent,
	    handleKeyPressEvent = _ref.handleKeyPressEvent,
	    handleDragStart = _ref.handleDragStart,
	    onHide = _ref.onHide,
	    overlayDisplay = _ref.overlayDisplay;
	  var popperRef = (0, _react$k.useRef)(null);
	  if (!overlay.position) return null;
	  var offset = popupOffset;
	  if (!isNaN(popupOffset)) {
	    offset = {
	      x: popupOffset,
	      y: popupOffset
	    };
	  }
	  var position = overlay.position,
	    events = overlay.events,
	    date = overlay.date,
	    end = overlay.end;
	  return /*#__PURE__*/_react$k.default.createElement(_reactOverlays.Overlay, {
	    rootClose: true,
	    flip: true,
	    show: true,
	    placement: "bottom",
	    onHide: onHide,
	    target: overlay.target
	  }, function (_ref2) {
	    var props = _ref2.props;
	    return /*#__PURE__*/_react$k.default.createElement(_Popup.default, Object.assign({}, props, {
	      containerRef: containerRef,
	      ref: popperRef,
	      target: overlay.target,
	      offset: offset,
	      accessors: accessors,
	      getters: getters,
	      selected: selected,
	      components: components,
	      localizer: localizer,
	      position: position,
	      show: overlayDisplay,
	      events: events,
	      slotStart: date,
	      slotEnd: end,
	      onSelect: handleSelectEvent,
	      onDoubleClick: handleDoubleClickEvent,
	      onKeyPress: handleKeyPressEvent,
	      handleDragStart: handleDragStart
	    }));
	  });
	}
	var PopOverlay = /*#__PURE__*/_react$k.default.forwardRef(function (props, ref) {
	  return /*#__PURE__*/_react$k.default.createElement(CalOverlay, Object.assign({}, props, {
	    containerRef: ref
	  }));
	});
	PopOverlay.propTypes = {
	  popupOffset: _propTypes$2.default.oneOfType([_propTypes$2.default.number, _propTypes$2.default.shape({
	    x: _propTypes$2.default.number,
	    y: _propTypes$2.default.number
	  })]),
	  overlay: _propTypes$2.default.shape({
	    position: _propTypes$2.default.object,
	    events: _propTypes$2.default.array,
	    date: _propTypes$2.default.instanceOf(Date),
	    end: _propTypes$2.default.instanceOf(Date)
	  }),
	  accessors: _propTypes$2.default.object.isRequired,
	  localizer: _propTypes$2.default.object.isRequired,
	  components: _propTypes$2.default.object.isRequired,
	  getters: _propTypes$2.default.object.isRequired,
	  selected: _propTypes$2.default.object,
	  handleSelectEvent: _propTypes$2.default.func,
	  handleDoubleClickEvent: _propTypes$2.default.func,
	  handleKeyPressEvent: _propTypes$2.default.func,
	  handleDragStart: _propTypes$2.default.func,
	  onHide: _propTypes$2.default.func,
	  overlayDisplay: _propTypes$2.default.func
	};
	var _default$m = PopOverlay;
	PopOverlay$1.default = _default$m;

	var DateContentRow$1 = {};

	var require$$8 = /*@__PURE__*/getAugmentedNamespace(height$1);

	var require$$9 = /*@__PURE__*/getAugmentedNamespace(querySelectorAll);

	var BackgroundCells$1 = {};

	var Selection$1 = {};

	var require$$4$1 = /*@__PURE__*/getAugmentedNamespace(contains$2);

	var require$$5$1 = /*@__PURE__*/getAugmentedNamespace(closest$1);

	var require$$6$1 = /*@__PURE__*/getAugmentedNamespace(listen$1);

	var _interopRequireDefault$r = interopRequireDefaultExports.default;
	Object.defineProperty(Selection$1, "__esModule", {
	  value: true
	});
	Selection$1.default = void 0;
	Selection$1.getBoundsForNode = getBoundsForNode;
	Selection$1.getEventNodeFromPoint = getEventNodeFromPoint;
	Selection$1.getShowMoreNodeFromPoint = getShowMoreNodeFromPoint;
	Selection$1.isEvent = isEvent;
	Selection$1.isShowMore = isShowMore;
	Selection$1.objectsCollide = objectsCollide;
	var _typeof2 = _interopRequireDefault$r(_typeofExports);
	var _classCallCheck2$c = _interopRequireDefault$r(classCallCheckExports);
	var _createClass2$c = _interopRequireDefault$r(createClassExports);
	var _contains = _interopRequireDefault$r(require$$4$1);
	var _closest = _interopRequireDefault$r(require$$5$1);
	var _listen = _interopRequireDefault$r(require$$6$1);
	function addEventListener(type, handler) {
	  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
	  return (0, _listen.default)(target, type, handler, {
	    passive: false
	  });
	}
	function isOverContainer(container, x, y) {
	  return !container || (0, _contains.default)(container, document.elementFromPoint(x, y));
	}
	function getEventNodeFromPoint(node, _ref) {
	  var clientX = _ref.clientX,
	    clientY = _ref.clientY;
	  var target = document.elementFromPoint(clientX, clientY);
	  return (0, _closest.default)(target, '.rbc-event', node);
	}
	function getShowMoreNodeFromPoint(node, _ref2) {
	  var clientX = _ref2.clientX,
	    clientY = _ref2.clientY;
	  var target = document.elementFromPoint(clientX, clientY);
	  return (0, _closest.default)(target, '.rbc-show-more', node);
	}
	function isEvent(node, bounds) {
	  return !!getEventNodeFromPoint(node, bounds);
	}
	function isShowMore(node, bounds) {
	  return !!getShowMoreNodeFromPoint(node, bounds);
	}
	function getEventCoordinates(e) {
	  var target = e;
	  if (e.touches && e.touches.length) {
	    target = e.touches[0];
	  }
	  return {
	    clientX: target.clientX,
	    clientY: target.clientY,
	    pageX: target.pageX,
	    pageY: target.pageY
	  };
	}
	var clickTolerance = 5;
	var clickInterval = 250;
	var Selection = /*#__PURE__*/function () {
	  function Selection(node) {
	    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref3$global = _ref3.global,
	      global = _ref3$global === void 0 ? false : _ref3$global,
	      _ref3$longPressThresh = _ref3.longPressThreshold,
	      longPressThreshold = _ref3$longPressThresh === void 0 ? 250 : _ref3$longPressThresh,
	      _ref3$validContainers = _ref3.validContainers,
	      validContainers = _ref3$validContainers === void 0 ? [] : _ref3$validContainers;
	    (0, _classCallCheck2$c.default)(this, Selection);
	    this.isDetached = false;
	    this.container = node;
	    this.globalMouse = !node || global;
	    this.longPressThreshold = longPressThreshold;
	    this.validContainers = validContainers;
	    this._listeners = Object.create(null);
	    this._handleInitialEvent = this._handleInitialEvent.bind(this);
	    this._handleMoveEvent = this._handleMoveEvent.bind(this);
	    this._handleTerminatingEvent = this._handleTerminatingEvent.bind(this);
	    this._keyListener = this._keyListener.bind(this);
	    this._dropFromOutsideListener = this._dropFromOutsideListener.bind(this);
	    this._dragOverFromOutsideListener = this._dragOverFromOutsideListener.bind(this);

	    // Fixes an iOS 10 bug where scrolling could not be prevented on the window.
	    // https://github.com/metafizzy/flickity/issues/457#issuecomment-254501356
	    this._removeTouchMoveWindowListener = addEventListener('touchmove', function () {}, window);
	    this._removeKeyDownListener = addEventListener('keydown', this._keyListener);
	    this._removeKeyUpListener = addEventListener('keyup', this._keyListener);
	    this._removeDropFromOutsideListener = addEventListener('drop', this._dropFromOutsideListener);
	    this._removeDragOverFromOutsideListener = addEventListener('dragover', this._dragOverFromOutsideListener);
	    this._addInitialEventListener();
	  }
	  (0, _createClass2$c.default)(Selection, [{
	    key: "on",
	    value: function on(type, handler) {
	      var handlers = this._listeners[type] || (this._listeners[type] = []);
	      handlers.push(handler);
	      return {
	        remove: function remove() {
	          var idx = handlers.indexOf(handler);
	          if (idx !== -1) handlers.splice(idx, 1);
	        }
	      };
	    }
	  }, {
	    key: "emit",
	    value: function emit(type) {
	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	      var result;
	      var handlers = this._listeners[type] || [];
	      handlers.forEach(function (fn) {
	        if (result === undefined) result = fn.apply(void 0, args);
	      });
	      return result;
	    }
	  }, {
	    key: "teardown",
	    value: function teardown() {
	      this.isDetached = true;
	      this._listeners = Object.create(null);
	      this._removeTouchMoveWindowListener && this._removeTouchMoveWindowListener();
	      this._removeInitialEventListener && this._removeInitialEventListener();
	      this._removeEndListener && this._removeEndListener();
	      this._onEscListener && this._onEscListener();
	      this._removeMoveListener && this._removeMoveListener();
	      this._removeKeyUpListener && this._removeKeyUpListener();
	      this._removeKeyDownListener && this._removeKeyDownListener();
	      this._removeDropFromOutsideListener && this._removeDropFromOutsideListener();
	      this._removeDragOverFromOutsideListener && this._removeDragOverFromOutsideListener();
	    }
	  }, {
	    key: "isSelected",
	    value: function isSelected(node) {
	      var box = this._selectRect;
	      if (!box || !this.selecting) return false;
	      return objectsCollide(box, getBoundsForNode(node));
	    }
	  }, {
	    key: "filter",
	    value: function filter(items) {
	      var box = this._selectRect;

	      //not selecting
	      if (!box || !this.selecting) return [];
	      return items.filter(this.isSelected, this);
	    }

	    // Adds a listener that will call the handler only after the user has pressed on the screen
	    // without moving their finger for 250ms.
	  }, {
	    key: "_addLongPressListener",
	    value: function _addLongPressListener(handler, initialEvent) {
	      var _this = this;
	      var timer = null;
	      var removeTouchMoveListener = null;
	      var removeTouchEndListener = null;
	      var handleTouchStart = function handleTouchStart(initialEvent) {
	        timer = setTimeout(function () {
	          cleanup();
	          handler(initialEvent);
	        }, _this.longPressThreshold);
	        removeTouchMoveListener = addEventListener('touchmove', function () {
	          return cleanup();
	        });
	        removeTouchEndListener = addEventListener('touchend', function () {
	          return cleanup();
	        });
	      };
	      var removeTouchStartListener = addEventListener('touchstart', handleTouchStart);
	      var cleanup = function cleanup() {
	        if (timer) {
	          clearTimeout(timer);
	        }
	        if (removeTouchMoveListener) {
	          removeTouchMoveListener();
	        }
	        if (removeTouchEndListener) {
	          removeTouchEndListener();
	        }
	        timer = null;
	        removeTouchMoveListener = null;
	        removeTouchEndListener = null;
	      };
	      if (initialEvent) {
	        handleTouchStart(initialEvent);
	      }
	      return function () {
	        cleanup();
	        removeTouchStartListener();
	      };
	    }

	    // Listen for mousedown and touchstart events. When one is received, disable the other and setup
	    // future event handling based on the type of event.
	  }, {
	    key: "_addInitialEventListener",
	    value: function _addInitialEventListener() {
	      var _this2 = this;
	      var removeMouseDownListener = addEventListener('mousedown', function (e) {
	        _this2._removeInitialEventListener();
	        _this2._handleInitialEvent(e);
	        _this2._removeInitialEventListener = addEventListener('mousedown', _this2._handleInitialEvent);
	      });
	      var removeTouchStartListener = addEventListener('touchstart', function (e) {
	        _this2._removeInitialEventListener();
	        _this2._removeInitialEventListener = _this2._addLongPressListener(_this2._handleInitialEvent, e);
	      });
	      this._removeInitialEventListener = function () {
	        removeMouseDownListener();
	        removeTouchStartListener();
	      };
	    }
	  }, {
	    key: "_dropFromOutsideListener",
	    value: function _dropFromOutsideListener(e) {
	      var _getEventCoordinates = getEventCoordinates(e),
	        pageX = _getEventCoordinates.pageX,
	        pageY = _getEventCoordinates.pageY,
	        clientX = _getEventCoordinates.clientX,
	        clientY = _getEventCoordinates.clientY;
	      this.emit('dropFromOutside', {
	        x: pageX,
	        y: pageY,
	        clientX: clientX,
	        clientY: clientY
	      });
	      e.preventDefault();
	    }
	  }, {
	    key: "_dragOverFromOutsideListener",
	    value: function _dragOverFromOutsideListener(e) {
	      var _getEventCoordinates2 = getEventCoordinates(e),
	        pageX = _getEventCoordinates2.pageX,
	        pageY = _getEventCoordinates2.pageY,
	        clientX = _getEventCoordinates2.clientX,
	        clientY = _getEventCoordinates2.clientY;
	      this.emit('dragOverFromOutside', {
	        x: pageX,
	        y: pageY,
	        clientX: clientX,
	        clientY: clientY
	      });
	      e.preventDefault();
	    }
	  }, {
	    key: "_handleInitialEvent",
	    value: function _handleInitialEvent(e) {
	      if (this.isDetached) {
	        return;
	      }
	      var _getEventCoordinates3 = getEventCoordinates(e),
	        clientX = _getEventCoordinates3.clientX,
	        clientY = _getEventCoordinates3.clientY,
	        pageX = _getEventCoordinates3.pageX,
	        pageY = _getEventCoordinates3.pageY;
	      var node = this.container(),
	        collides,
	        offsetData;

	      // Right clicks
	      if (e.which === 3 || e.button === 2 || !isOverContainer(node, clientX, clientY)) return;
	      if (!this.globalMouse && node && !(0, _contains.default)(node, e.target)) {
	        var _normalizeDistance = normalizeDistance(0),
	          top = _normalizeDistance.top,
	          left = _normalizeDistance.left,
	          bottom = _normalizeDistance.bottom,
	          right = _normalizeDistance.right;
	        offsetData = getBoundsForNode(node);
	        collides = objectsCollide({
	          top: offsetData.top - top,
	          left: offsetData.left - left,
	          bottom: offsetData.bottom + bottom,
	          right: offsetData.right + right
	        }, {
	          top: pageY,
	          left: pageX
	        });
	        if (!collides) return;
	      }
	      var result = this.emit('beforeSelect', this._initialEventData = {
	        isTouch: /^touch/.test(e.type),
	        x: pageX,
	        y: pageY,
	        clientX: clientX,
	        clientY: clientY
	      });
	      if (result === false) return;
	      switch (e.type) {
	        case 'mousedown':
	          this._removeEndListener = addEventListener('mouseup', this._handleTerminatingEvent);
	          this._onEscListener = addEventListener('keydown', this._handleTerminatingEvent);
	          this._removeMoveListener = addEventListener('mousemove', this._handleMoveEvent);
	          break;
	        case 'touchstart':
	          this._handleMoveEvent(e);
	          this._removeEndListener = addEventListener('touchend', this._handleTerminatingEvent);
	          this._removeMoveListener = addEventListener('touchmove', this._handleMoveEvent);
	          break;
	      }
	    }

	    // Check whether provided event target element
	    // - is contained within a valid container
	  }, {
	    key: "_isWithinValidContainer",
	    value: function _isWithinValidContainer(e) {
	      var eventTarget = e.target;
	      var containers = this.validContainers;
	      if (!containers || !containers.length || !eventTarget) {
	        return true;
	      }
	      return containers.some(function (target) {
	        return !!eventTarget.closest(target);
	      });
	    }
	  }, {
	    key: "_handleTerminatingEvent",
	    value: function _handleTerminatingEvent(e) {
	      var _getEventCoordinates4 = getEventCoordinates(e),
	        pageX = _getEventCoordinates4.pageX,
	        pageY = _getEventCoordinates4.pageY;
	      this.selecting = false;
	      this._removeEndListener && this._removeEndListener();
	      this._removeMoveListener && this._removeMoveListener();
	      if (!this._initialEventData) return;
	      var inRoot = !this.container || (0, _contains.default)(this.container(), e.target);
	      var isWithinValidContainer = this._isWithinValidContainer(e);
	      var bounds = this._selectRect;
	      var click = this.isClick(pageX, pageY);
	      this._initialEventData = null;
	      if (e.key === 'Escape' || !isWithinValidContainer) {
	        return this.emit('reset');
	      }
	      if (click && inRoot) {
	        return this._handleClickEvent(e);
	      }

	      // User drag-clicked in the Selectable area
	      if (!click) return this.emit('select', bounds);
	      return this.emit('reset');
	    }
	  }, {
	    key: "_handleClickEvent",
	    value: function _handleClickEvent(e) {
	      var _getEventCoordinates5 = getEventCoordinates(e),
	        pageX = _getEventCoordinates5.pageX,
	        pageY = _getEventCoordinates5.pageY,
	        clientX = _getEventCoordinates5.clientX,
	        clientY = _getEventCoordinates5.clientY;
	      var now = new Date().getTime();
	      if (this._lastClickData && now - this._lastClickData.timestamp < clickInterval) {
	        // Double click event
	        this._lastClickData = null;
	        return this.emit('doubleClick', {
	          x: pageX,
	          y: pageY,
	          clientX: clientX,
	          clientY: clientY
	        });
	      }

	      // Click event
	      this._lastClickData = {
	        timestamp: now
	      };
	      return this.emit('click', {
	        x: pageX,
	        y: pageY,
	        clientX: clientX,
	        clientY: clientY
	      });
	    }
	  }, {
	    key: "_handleMoveEvent",
	    value: function _handleMoveEvent(e) {
	      if (this._initialEventData === null || this.isDetached) {
	        return;
	      }
	      var _this$_initialEventDa = this._initialEventData,
	        x = _this$_initialEventDa.x,
	        y = _this$_initialEventDa.y;
	      var _getEventCoordinates6 = getEventCoordinates(e),
	        pageX = _getEventCoordinates6.pageX,
	        pageY = _getEventCoordinates6.pageY;
	      var w = Math.abs(x - pageX);
	      var h = Math.abs(y - pageY);
	      var left = Math.min(pageX, x),
	        top = Math.min(pageY, y),
	        old = this.selecting;

	      // Prevent emitting selectStart event until mouse is moved.
	      // in Chrome on Windows, mouseMove event may be fired just after mouseDown event.
	      if (this.isClick(pageX, pageY) && !old && !(w || h)) {
	        return;
	      }
	      this.selecting = true;
	      this._selectRect = {
	        top: top,
	        left: left,
	        x: pageX,
	        y: pageY,
	        right: left + w,
	        bottom: top + h
	      };
	      if (!old) {
	        this.emit('selectStart', this._initialEventData);
	      }
	      if (!this.isClick(pageX, pageY)) this.emit('selecting', this._selectRect);
	      e.preventDefault();
	    }
	  }, {
	    key: "_keyListener",
	    value: function _keyListener(e) {
	      this.ctrl = e.metaKey || e.ctrlKey;
	    }
	  }, {
	    key: "isClick",
	    value: function isClick(pageX, pageY) {
	      var _this$_initialEventDa2 = this._initialEventData,
	        x = _this$_initialEventDa2.x,
	        y = _this$_initialEventDa2.y,
	        isTouch = _this$_initialEventDa2.isTouch;
	      return !isTouch && Math.abs(pageX - x) <= clickTolerance && Math.abs(pageY - y) <= clickTolerance;
	    }
	  }]);
	  return Selection;
	}();
	/**
	 * Resolve the disance prop from either an Int or an Object
	 * @return {Object}
	 */
	function normalizeDistance() {
	  var distance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	  if ((0, _typeof2.default)(distance) !== 'object') distance = {
	    top: distance,
	    left: distance,
	    right: distance,
	    bottom: distance
	  };
	  return distance;
	}

	/**
	 * Given two objects containing "top", "left", "offsetWidth" and "offsetHeight"
	 * properties, determine if they collide.
	 * @param  {Object|HTMLElement} a
	 * @param  {Object|HTMLElement} b
	 * @return {bool}
	 */
	function objectsCollide(nodeA, nodeB) {
	  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	  var _getBoundsForNode = getBoundsForNode(nodeA),
	    aTop = _getBoundsForNode.top,
	    aLeft = _getBoundsForNode.left,
	    _getBoundsForNode$rig = _getBoundsForNode.right,
	    aRight = _getBoundsForNode$rig === void 0 ? aLeft : _getBoundsForNode$rig,
	    _getBoundsForNode$bot = _getBoundsForNode.bottom,
	    aBottom = _getBoundsForNode$bot === void 0 ? aTop : _getBoundsForNode$bot;
	  var _getBoundsForNode2 = getBoundsForNode(nodeB),
	    bTop = _getBoundsForNode2.top,
	    bLeft = _getBoundsForNode2.left,
	    _getBoundsForNode2$ri = _getBoundsForNode2.right,
	    bRight = _getBoundsForNode2$ri === void 0 ? bLeft : _getBoundsForNode2$ri,
	    _getBoundsForNode2$bo = _getBoundsForNode2.bottom,
	    bBottom = _getBoundsForNode2$bo === void 0 ? bTop : _getBoundsForNode2$bo;
	  return !(
	  // 'a' bottom doesn't touch 'b' top

	  aBottom - tolerance < bTop ||
	  // 'a' top doesn't touch 'b' bottom
	  aTop + tolerance > bBottom ||
	  // 'a' right doesn't touch 'b' left
	  aRight - tolerance < bLeft ||
	  // 'a' left doesn't touch 'b' right
	  aLeft + tolerance > bRight);
	}

	/**
	 * Given a node, get everything needed to calculate its boundaries
	 * @param  {HTMLElement} node
	 * @return {Object}
	 */
	function getBoundsForNode(node) {
	  if (!node.getBoundingClientRect) return node;
	  var rect = node.getBoundingClientRect(),
	    left = rect.left + pageOffset('left'),
	    top = rect.top + pageOffset('top');
	  return {
	    top: top,
	    left: left,
	    right: (node.offsetWidth || 0) + left,
	    bottom: (node.offsetHeight || 0) + top
	  };
	}
	function pageOffset(dir) {
	  if (dir === 'left') return window.pageXOffset || document.body.scrollLeft || 0;
	  if (dir === 'top') return window.pageYOffset || document.body.scrollTop || 0;
	}
	var _default$l = Selection;
	Selection$1.default = _default$l;

	var _interopRequireWildcard$7 = interopRequireWildcardExports.default;
	var _interopRequireDefault$q = interopRequireDefaultExports.default;
	Object.defineProperty(BackgroundCells$1, "__esModule", {
	  value: true
	});
	BackgroundCells$1.default = void 0;
	var _objectSpread2$5 = _interopRequireDefault$q(objectSpread2Exports);
	var _classCallCheck2$b = _interopRequireDefault$q(classCallCheckExports);
	var _createClass2$b = _interopRequireDefault$q(createClassExports);
	var _inherits2$a = _interopRequireDefault$q(inheritsExports);
	var _createSuper2$a = _interopRequireDefault$q(createSuperExports);
	var _react$j = _interopRequireWildcard$7(React$1);
	var _clsx$a = _interopRequireDefault$q(require$$9$1);
	var _helpers$4 = helpers;
	var _selection$3 = selection;
	var _Selection$1 = _interopRequireWildcard$7(Selection$1);
	var BackgroundCells = /*#__PURE__*/function (_React$Component) {
	  (0, _inherits2$a.default)(BackgroundCells, _React$Component);
	  var _super = (0, _createSuper2$a.default)(BackgroundCells);
	  function BackgroundCells(props, context) {
	    var _this;
	    (0, _classCallCheck2$b.default)(this, BackgroundCells);
	    _this = _super.call(this, props, context);
	    _this.state = {
	      selecting: false
	    };
	    _this.containerRef = /*#__PURE__*/(0, _react$j.createRef)();
	    return _this;
	  }
	  (0, _createClass2$b.default)(BackgroundCells, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      this.props.selectable && this._selectable();
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      this._teardownSelectable();
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate(prevProps) {
	      if (!prevProps.selectable && this.props.selectable) this._selectable();
	      if (prevProps.selectable && !this.props.selectable) this._teardownSelectable();
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this$props = this.props,
	        range = _this$props.range,
	        getNow = _this$props.getNow,
	        getters = _this$props.getters,
	        currentDate = _this$props.date,
	        Wrapper = _this$props.components.dateCellWrapper,
	        localizer = _this$props.localizer;
	      var _this$state = this.state,
	        selecting = _this$state.selecting,
	        startIdx = _this$state.startIdx,
	        endIdx = _this$state.endIdx;
	      var current = getNow();
	      return /*#__PURE__*/_react$j.default.createElement("div", {
	        className: "rbc-row-bg",
	        ref: this.containerRef
	      }, range.map(function (date, index) {
	        var selected = selecting && index >= startIdx && index <= endIdx;
	        var _getters$dayProp = getters.dayProp(date),
	          className = _getters$dayProp.className,
	          style = _getters$dayProp.style;
	        return /*#__PURE__*/_react$j.default.createElement(Wrapper, {
	          key: index,
	          value: date,
	          range: range
	        }, /*#__PURE__*/_react$j.default.createElement("div", {
	          style: style,
	          className: (0, _clsx$a.default)('rbc-day-bg', className, selected && 'rbc-selected-cell', localizer.isSameDate(date, current) && 'rbc-today', currentDate && localizer.neq(currentDate, date, 'month') && 'rbc-off-range-bg')
	        }));
	      }));
	    }
	  }, {
	    key: "_selectable",
	    value: function _selectable() {
	      var _this2 = this;
	      var node = this.containerRef.current;
	      var selector = this._selector = new _Selection$1.default(this.props.container, {
	        longPressThreshold: this.props.longPressThreshold
	      });
	      var selectorClicksHandler = function selectorClicksHandler(point, actionType) {
	        if (!(0, _Selection$1.isEvent)(node, point) && !(0, _Selection$1.isShowMore)(node, point)) {
	          var rowBox = (0, _Selection$1.getBoundsForNode)(node);
	          var _this2$props = _this2.props,
	            range = _this2$props.range,
	            rtl = _this2$props.rtl;
	          if ((0, _selection$3.pointInBox)(rowBox, point)) {
	            var currentCell = (0, _selection$3.getSlotAtX)(rowBox, point.x, rtl, range.length);
	            _this2._selectSlot({
	              startIdx: currentCell,
	              endIdx: currentCell,
	              action: actionType,
	              box: point
	            });
	          }
	        }
	        _this2._initial = {};
	        _this2.setState({
	          selecting: false
	        });
	      };
	      selector.on('selecting', function (box) {
	        var _this2$props2 = _this2.props,
	          range = _this2$props2.range,
	          rtl = _this2$props2.rtl;
	        var startIdx = -1;
	        var endIdx = -1;
	        if (!_this2.state.selecting) {
	          (0, _helpers$4.notify)(_this2.props.onSelectStart, [box]);
	          _this2._initial = {
	            x: box.x,
	            y: box.y
	          };
	        }
	        if (selector.isSelected(node)) {
	          var nodeBox = (0, _Selection$1.getBoundsForNode)(node);
	          var _dateCellSelection = (0, _selection$3.dateCellSelection)(_this2._initial, nodeBox, box, range.length, rtl);
	          startIdx = _dateCellSelection.startIdx;
	          endIdx = _dateCellSelection.endIdx;
	        }
	        _this2.setState({
	          selecting: true,
	          startIdx: startIdx,
	          endIdx: endIdx
	        });
	      });
	      selector.on('beforeSelect', function (box) {
	        if (_this2.props.selectable !== 'ignoreEvents') return;
	        return !(0, _Selection$1.isEvent)(_this2.containerRef.current, box);
	      });
	      selector.on('click', function (point) {
	        return selectorClicksHandler(point, 'click');
	      });
	      selector.on('doubleClick', function (point) {
	        return selectorClicksHandler(point, 'doubleClick');
	      });
	      selector.on('select', function (bounds) {
	        _this2._selectSlot((0, _objectSpread2$5.default)((0, _objectSpread2$5.default)({}, _this2.state), {}, {
	          action: 'select',
	          bounds: bounds
	        }));
	        _this2._initial = {};
	        _this2.setState({
	          selecting: false
	        });
	        (0, _helpers$4.notify)(_this2.props.onSelectEnd, [_this2.state]);
	      });
	    }
	  }, {
	    key: "_teardownSelectable",
	    value: function _teardownSelectable() {
	      if (!this._selector) return;
	      this._selector.teardown();
	      this._selector = null;
	    }
	  }, {
	    key: "_selectSlot",
	    value: function _selectSlot(_ref) {
	      var endIdx = _ref.endIdx,
	        startIdx = _ref.startIdx,
	        action = _ref.action,
	        bounds = _ref.bounds,
	        box = _ref.box;
	      if (endIdx !== -1 && startIdx !== -1) this.props.onSelectSlot && this.props.onSelectSlot({
	        start: startIdx,
	        end: endIdx,
	        action: action,
	        bounds: bounds,
	        box: box,
	        resourceId: this.props.resourceId
	      });
	    }
	  }]);
	  return BackgroundCells;
	}(_react$j.default.Component);
	var _default$k = BackgroundCells;
	BackgroundCells$1.default = _default$k;

	var EventRow$1 = {};

	var EventRowMixin = {};

	var _interopRequireDefault$p = interopRequireDefaultExports.default;
	Object.defineProperty(EventRowMixin, "__esModule", {
	  value: true
	});
	EventRowMixin.default = void 0;
	var _propTypes$1 = _interopRequireDefault$p(propTypesExports);
	var _react$i = _interopRequireDefault$p(React$1);
	var _EventCell = _interopRequireDefault$p(EventCell$1);
	var _selection$2 = selection;
	/* eslint-disable react/prop-types */
	var _default$j = {
	  propTypes: {
	    slotMetrics: _propTypes$1.default.object.isRequired,
	    selected: _propTypes$1.default.object,
	    isAllDay: _propTypes$1.default.bool,
	    accessors: _propTypes$1.default.object.isRequired,
	    localizer: _propTypes$1.default.object.isRequired,
	    components: _propTypes$1.default.object.isRequired,
	    getters: _propTypes$1.default.object.isRequired,
	    onSelect: _propTypes$1.default.func,
	    onDoubleClick: _propTypes$1.default.func,
	    onKeyPress: _propTypes$1.default.func
	  },
	  defaultProps: {
	    segments: [],
	    selected: {}
	  },
	  renderEvent: function renderEvent(props, event) {
	    var selected = props.selected;
	      props.isAllDay;
	      var accessors = props.accessors,
	      getters = props.getters,
	      onSelect = props.onSelect,
	      onDoubleClick = props.onDoubleClick,
	      onKeyPress = props.onKeyPress,
	      localizer = props.localizer,
	      slotMetrics = props.slotMetrics,
	      components = props.components,
	      resizable = props.resizable;
	    var continuesPrior = slotMetrics.continuesPrior(event);
	    var continuesAfter = slotMetrics.continuesAfter(event);
	    return /*#__PURE__*/_react$i.default.createElement(_EventCell.default, {
	      event: event,
	      getters: getters,
	      localizer: localizer,
	      accessors: accessors,
	      components: components,
	      onSelect: onSelect,
	      onDoubleClick: onDoubleClick,
	      onKeyPress: onKeyPress,
	      continuesPrior: continuesPrior,
	      continuesAfter: continuesAfter,
	      slotStart: slotMetrics.first,
	      slotEnd: slotMetrics.last,
	      selected: (0, _selection$2.isSelected)(event, selected),
	      resizable: resizable
	    });
	  },
	  renderSpan: function renderSpan(slots, len, key) {
	    var content = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ' ';
	    var per = Math.abs(len) / slots * 100 + '%';
	    return /*#__PURE__*/_react$i.default.createElement("div", {
	      key: key,
	      className: "rbc-row-segment"
	      // IE10/11 need max-width. flex-basis doesn't respect box-sizing
	      ,
	      style: {
	        WebkitFlexBasis: per,
	        flexBasis: per,
	        maxWidth: per
	      }
	    }, content);
	  }
	};
	EventRowMixin.default = _default$j;

	var _interopRequireDefault$o = interopRequireDefaultExports.default;
	Object.defineProperty(EventRow$1, "__esModule", {
	  value: true
	});
	EventRow$1.default = void 0;
	var _objectSpread2$4 = _interopRequireDefault$o(objectSpread2Exports);
	var _classCallCheck2$a = _interopRequireDefault$o(classCallCheckExports);
	var _createClass2$a = _interopRequireDefault$o(createClassExports);
	var _inherits2$9 = _interopRequireDefault$o(inheritsExports);
	var _createSuper2$9 = _interopRequireDefault$o(createSuperExports);
	var _clsx$9 = _interopRequireDefault$o(require$$9$1);
	var _react$h = _interopRequireDefault$o(React$1);
	var _EventRowMixin$1 = _interopRequireDefault$o(EventRowMixin);
	var EventRow = /*#__PURE__*/function (_React$Component) {
	  (0, _inherits2$9.default)(EventRow, _React$Component);
	  var _super = (0, _createSuper2$9.default)(EventRow);
	  function EventRow() {
	    (0, _classCallCheck2$a.default)(this, EventRow);
	    return _super.apply(this, arguments);
	  }
	  (0, _createClass2$a.default)(EventRow, [{
	    key: "render",
	    value: function render() {
	      var _this = this;
	      var _this$props = this.props,
	        segments = _this$props.segments,
	        slots = _this$props.slotMetrics.slots,
	        className = _this$props.className;
	      var lastEnd = 1;
	      return /*#__PURE__*/_react$h.default.createElement("div", {
	        className: (0, _clsx$9.default)(className, 'rbc-row')
	      }, segments.reduce(function (row, _ref, li) {
	        var event = _ref.event,
	          left = _ref.left,
	          right = _ref.right,
	          span = _ref.span;
	        var key = '_lvl_' + li;
	        var gap = left - lastEnd;
	        var content = _EventRowMixin$1.default.renderEvent(_this.props, event);
	        if (gap) row.push(_EventRowMixin$1.default.renderSpan(slots, gap, "".concat(key, "_gap")));
	        row.push(_EventRowMixin$1.default.renderSpan(slots, span, key, content));
	        lastEnd = right + 1;
	        return row;
	      }, []));
	    }
	  }]);
	  return EventRow;
	}(_react$h.default.Component);
	EventRow.defaultProps = (0, _objectSpread2$4.default)({}, _EventRowMixin$1.default.defaultProps);
	var _default$i = EventRow;
	EventRow$1.default = _default$i;

	var EventEndingRow$1 = {};

	var eventLevels$1 = {};

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */

	function baseFindIndex$1(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	var _baseFindIndex = baseFindIndex$1;

	var Stack = _Stack,
	    baseIsEqual$1 = _baseIsEqual;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$1 = 1,
	    COMPARE_UNORDERED_FLAG$1 = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch$1(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	var _baseIsMatch = baseIsMatch$1;

	var isObject = isObject_1;

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable$2(value) {
	  return value === value && !isObject(value);
	}

	var _isStrictComparable = isStrictComparable$2;

	var isStrictComparable$1 = _isStrictComparable,
	    keys$1 = keys_1;

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData$1(object) {
	  var result = keys$1(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable$1(value)];
	  }
	  return result;
	}

	var _getMatchData = getMatchData$1;

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */

	function matchesStrictComparable$2(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	var _matchesStrictComparable = matchesStrictComparable$2;

	var baseIsMatch = _baseIsMatch,
	    getMatchData = _getMatchData,
	    matchesStrictComparable$1 = _matchesStrictComparable;

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches$1(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	var _baseMatches = baseMatches$1;

	var isArray$7 = isArray_1,
	    isSymbol$3 = isSymbol_1;

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey$3(value, object) {
	  if (isArray$7(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol$3(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	var _isKey = isKey$3;

	var MapCache = _MapCache;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize$2(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize$2.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize$2.Cache = MapCache;

	var memoize_1 = memoize$2;

	var memoize$1 = memoize_1;

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped$1(func) {
	  var result = memoize$1(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	var _memoizeCapped = memoizeCapped$1;

	var memoizeCapped = _memoizeCapped;

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath$1 = memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	var _stringToPath = stringToPath$1;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */

	function arrayMap$2(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	var _arrayMap = arrayMap$2;

	var Symbol$2 = _Symbol,
	    arrayMap$1 = _arrayMap,
	    isArray$6 = isArray_1,
	    isSymbol$2 = isSymbol_1;

	/** Used as references for various `Number` constants. */
	var INFINITY$1 = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString$1(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray$6(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap$1(value, baseToString$1) + '';
	  }
	  if (isSymbol$2(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
	}

	var _baseToString = baseToString$1;

	var baseToString = _baseToString;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString$1(value) {
	  return value == null ? '' : baseToString(value);
	}

	var toString_1 = toString$1;

	var isArray$5 = isArray_1,
	    isKey$2 = _isKey,
	    stringToPath = _stringToPath,
	    toString = toString_1;

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath$2(value, object) {
	  if (isArray$5(value)) {
	    return value;
	  }
	  return isKey$2(value, object) ? [value] : stringToPath(toString(value));
	}

	var _castPath = castPath$2;

	var isSymbol$1 = isSymbol_1;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey$4(value) {
	  if (typeof value == 'string' || isSymbol$1(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	var _toKey = toKey$4;

	var castPath$1 = _castPath,
	    toKey$3 = _toKey;

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet$3(object, path) {
	  path = castPath$1(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey$3(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	var _baseGet = baseGet$3;

	var baseGet$2 = _baseGet;

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get$1(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet$2(object, path);
	  return result === undefined ? defaultValue : result;
	}

	var get_1 = get$1;

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */

	function baseHasIn$1(object, key) {
	  return object != null && key in Object(object);
	}

	var _baseHasIn = baseHasIn$1;

	var castPath = _castPath,
	    isArguments$1 = isArguments_1,
	    isArray$4 = isArray_1,
	    isIndex = _isIndex,
	    isLength = isLength_1,
	    toKey$2 = _toKey;

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath$1(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey$2(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray$4(object) || isArguments$1(object));
	}

	var _hasPath = hasPath$1;

	var baseHasIn = _baseHasIn,
	    hasPath = _hasPath;

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn$1(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	var hasIn_1 = hasIn$1;

	var baseIsEqual = _baseIsEqual,
	    get = get_1,
	    hasIn = hasIn_1,
	    isKey$1 = _isKey,
	    isStrictComparable = _isStrictComparable,
	    matchesStrictComparable = _matchesStrictComparable,
	    toKey$1 = _toKey;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty$1(path, srcValue) {
	  if (isKey$1(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey$1(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	var _baseMatchesProperty = baseMatchesProperty$1;

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */

	function identity$4(value) {
	  return value;
	}

	var identity_1 = identity$4;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */

	function baseProperty$1(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	var _baseProperty = baseProperty$1;

	var baseGet$1 = _baseGet;

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep$1(path) {
	  return function(object) {
	    return baseGet$1(object, path);
	  };
	}

	var _basePropertyDeep = basePropertyDeep$1;

	var baseProperty = _baseProperty,
	    basePropertyDeep = _basePropertyDeep,
	    isKey = _isKey,
	    toKey = _toKey;

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property$1(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	var property_1 = property$1;

	var baseMatches = _baseMatches,
	    baseMatchesProperty = _baseMatchesProperty,
	    identity$3 = identity_1,
	    isArray$3 = isArray_1,
	    property = property_1;

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee$2(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity$3;
	  }
	  if (typeof value == 'object') {
	    return isArray$3(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	var _baseIteratee = baseIteratee$2;

	var baseFindIndex = _baseFindIndex,
	    baseIteratee$1 = _baseIteratee,
	    toInteger = toInteger_1;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$2 = Math.max;

	/**
	 * This method is like `_.find` except that it returns the index of the first
	 * element `predicate` returns truthy for instead of the element itself.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {number} Returns the index of the found element, else `-1`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': false },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': true }
	 * ];
	 *
	 * _.findIndex(users, function(o) { return o.user == 'barney'; });
	 * // => 0
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findIndex(users, { 'user': 'fred', 'active': false });
	 * // => 1
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findIndex(users, ['active', false]);
	 * // => 0
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findIndex(users, 'active');
	 * // => 2
	 */
	function findIndex(array, predicate, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = fromIndex == null ? 0 : toInteger(fromIndex);
	  if (index < 0) {
	    index = nativeMax$2(length + index, 0);
	  }
	  return baseFindIndex(array, baseIteratee$1(predicate), index);
	}

	var findIndex_1 = findIndex;

	var _interopRequireDefault$n = interopRequireDefaultExports.default;
	Object.defineProperty(eventLevels$1, "__esModule", {
	  value: true
	});
	eventLevels$1.endOfRange = endOfRange;
	eventLevels$1.eventLevels = eventLevels;
	eventLevels$1.eventSegments = eventSegments;
	eventLevels$1.inRange = inRange;
	eventLevels$1.segsOverlap = segsOverlap;
	eventLevels$1.sortEvents = sortEvents;
	var _findIndex = _interopRequireDefault$n(findIndex_1);
	function endOfRange(_ref) {
	  var dateRange = _ref.dateRange,
	    _ref$unit = _ref.unit,
	    unit = _ref$unit === void 0 ? 'day' : _ref$unit,
	    localizer = _ref.localizer;
	  return {
	    first: dateRange[0],
	    last: localizer.add(dateRange[dateRange.length - 1], 1, unit)
	  };
	}

	// properly calculating segments requires working with dates in
	// the timezone we're working with, so we use the localizer
	function eventSegments(event, range, accessors, localizer) {
	  var _endOfRange = endOfRange({
	      dateRange: range,
	      localizer: localizer
	    }),
	    first = _endOfRange.first,
	    last = _endOfRange.last;
	  var slots = localizer.diff(first, last, 'day');
	  var start = localizer.max(localizer.startOf(accessors.start(event), 'day'), first);
	  var end = localizer.min(localizer.ceil(accessors.end(event), 'day'), last);
	  var padding = (0, _findIndex.default)(range, function (x) {
	    return localizer.isSameDate(x, start);
	  });
	  var span = localizer.diff(start, end, 'day');
	  span = Math.min(span, slots);
	  // The segmentOffset is necessary when adjusting for timezones
	  // ahead of the browser timezone
	  span = Math.max(span - localizer.segmentOffset, 1);
	  return {
	    event: event,
	    span: span,
	    left: padding + 1,
	    right: Math.max(padding + span, 1)
	  };
	}
	function eventLevels(rowSegments) {
	  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
	  var i,
	    j,
	    seg,
	    levels = [],
	    extra = [];
	  for (i = 0; i < rowSegments.length; i++) {
	    seg = rowSegments[i];
	    for (j = 0; j < levels.length; j++) if (!segsOverlap(seg, levels[j])) break;
	    if (j >= limit) {
	      extra.push(seg);
	    } else {
	      (levels[j] || (levels[j] = [])).push(seg);
	    }
	  }
	  for (i = 0; i < levels.length; i++) {
	    levels[i].sort(function (a, b) {
	      return a.left - b.left;
	    }); //eslint-disable-line
	  }

	  return {
	    levels: levels,
	    extra: extra
	  };
	}
	function inRange(e, start, end, accessors, localizer) {
	  var event = {
	    start: accessors.start(e),
	    end: accessors.end(e)
	  };
	  var range = {
	    start: start,
	    end: end
	  };
	  return localizer.inEventRange({
	    event: event,
	    range: range
	  });
	}
	function segsOverlap(seg, otherSegs) {
	  return otherSegs.some(function (otherSeg) {
	    return otherSeg.left <= seg.right && otherSeg.right >= seg.left;
	  });
	}
	function sortEvents(eventA, eventB, accessors, localizer) {
	  var evtA = {
	    start: accessors.start(eventA),
	    end: accessors.end(eventA),
	    allDay: accessors.allDay(eventA)
	  };
	  var evtB = {
	    start: accessors.start(eventB),
	    end: accessors.end(eventB),
	    allDay: accessors.allDay(eventB)
	  };
	  return localizer.sortEvents({
	    evtA: evtA,
	    evtB: evtB
	  });
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */

	var nativeCeil = Math.ceil,
	    nativeMax$1 = Math.max;

	/**
	 * The base implementation of `_.range` and `_.rangeRight` which doesn't
	 * coerce arguments.
	 *
	 * @private
	 * @param {number} start The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} step The value to increment or decrement by.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Array} Returns the range of numbers.
	 */
	function baseRange$1(start, end, step, fromRight) {
	  var index = -1,
	      length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0),
	      result = Array(length);

	  while (length--) {
	    result[fromRight ? length : ++index] = start;
	    start += step;
	  }
	  return result;
	}

	var _baseRange = baseRange$1;

	var baseRange = _baseRange,
	    isIterateeCall$1 = _isIterateeCall,
	    toFinite = toFinite_1;

	/**
	 * Creates a `_.range` or `_.rangeRight` function.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new range function.
	 */
	function createRange$1(fromRight) {
	  return function(start, end, step) {
	    if (step && typeof step != 'number' && isIterateeCall$1(start, end, step)) {
	      end = step = undefined;
	    }
	    // Ensure the sign of `-0` is preserved.
	    start = toFinite(start);
	    if (end === undefined) {
	      end = start;
	      start = 0;
	    } else {
	      end = toFinite(end);
	    }
	    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	    return baseRange(start, end, step, fromRight);
	  };
	}

	var _createRange = createRange$1;

	var createRange = _createRange;

	/**
	 * Creates an array of numbers (positive and/or negative) progressing from
	 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	 * `start` is specified without an `end` or `step`. If `end` is not specified,
	 * it's set to `start` with `start` then set to `0`.
	 *
	 * **Note:** JavaScript follows the IEEE-754 standard for resolving
	 * floating-point values which can produce unexpected results.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {number} [start=0] The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} [step=1] The value to increment or decrement by.
	 * @returns {Array} Returns the range of numbers.
	 * @see _.inRange, _.rangeRight
	 * @example
	 *
	 * _.range(4);
	 * // => [0, 1, 2, 3]
	 *
	 * _.range(-4);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 5);
	 * // => [1, 2, 3, 4]
	 *
	 * _.range(0, 20, 5);
	 * // => [0, 5, 10, 15]
	 *
	 * _.range(0, -4, -1);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 4, 0);
	 * // => [1, 1, 1]
	 *
	 * _.range(0);
	 * // => []
	 */
	var range = createRange();

	var range_1 = range;

	var _interopRequireDefault$m = interopRequireDefaultExports.default;
	Object.defineProperty(EventEndingRow$1, "__esModule", {
	  value: true
	});
	EventEndingRow$1.default = void 0;
	var _objectSpread2$3 = _interopRequireDefault$m(objectSpread2Exports);
	var _classCallCheck2$9 = _interopRequireDefault$m(classCallCheckExports);
	var _createClass2$9 = _interopRequireDefault$m(createClassExports);
	var _inherits2$8 = _interopRequireDefault$m(inheritsExports);
	var _createSuper2$8 = _interopRequireDefault$m(createSuperExports);
	var _react$g = _interopRequireDefault$m(React$1);
	var _clsx$8 = _interopRequireDefault$m(require$$9$1);
	var _EventRowMixin = _interopRequireDefault$m(EventRowMixin);
	var _eventLevels$3 = eventLevels$1;
	var _range = _interopRequireDefault$m(range_1);
	var isSegmentInSlot$1 = function isSegmentInSlot(seg, slot) {
	  return seg.left <= slot && seg.right >= slot;
	};
	var eventsInSlot = function eventsInSlot(segments, slot) {
	  return segments.filter(function (seg) {
	    return isSegmentInSlot$1(seg, slot);
	  }).length;
	};
	var EventEndingRow = /*#__PURE__*/function (_React$Component) {
	  (0, _inherits2$8.default)(EventEndingRow, _React$Component);
	  var _super = (0, _createSuper2$8.default)(EventEndingRow);
	  function EventEndingRow() {
	    (0, _classCallCheck2$9.default)(this, EventEndingRow);
	    return _super.apply(this, arguments);
	  }
	  (0, _createClass2$9.default)(EventEndingRow, [{
	    key: "render",
	    value: function render() {
	      var _this$props = this.props,
	        segments = _this$props.segments,
	        slots = _this$props.slotMetrics.slots;
	      var rowSegments = (0, _eventLevels$3.eventLevels)(segments).levels[0];
	      var current = 1,
	        lastEnd = 1,
	        row = [];
	      while (current <= slots) {
	        var key = '_lvl_' + current;
	        var _ref = rowSegments.filter(function (seg) {
	            return isSegmentInSlot$1(seg, current);
	          })[0] || {},
	          event = _ref.event,
	          left = _ref.left,
	          right = _ref.right,
	          span = _ref.span; //eslint-disable-line

	        if (!event) {
	          current++;
	          continue;
	        }
	        var gap = Math.max(0, left - lastEnd);
	        if (this.canRenderSlotEvent(left, span)) {
	          var content = _EventRowMixin.default.renderEvent(this.props, event);
	          if (gap) {
	            row.push(_EventRowMixin.default.renderSpan(slots, gap, key + '_gap'));
	          }
	          row.push(_EventRowMixin.default.renderSpan(slots, span, key, content));
	          lastEnd = current = right + 1;
	        } else {
	          if (gap) {
	            row.push(_EventRowMixin.default.renderSpan(slots, gap, key + '_gap'));
	          }
	          row.push(_EventRowMixin.default.renderSpan(slots, 1, key, this.renderShowMore(segments, current)));
	          lastEnd = current = current + 1;
	        }
	      }
	      return /*#__PURE__*/_react$g.default.createElement("div", {
	        className: "rbc-row"
	      }, row);
	    }
	  }, {
	    key: "canRenderSlotEvent",
	    value: function canRenderSlotEvent(slot, span) {
	      var segments = this.props.segments;
	      return (0, _range.default)(slot, slot + span).every(function (s) {
	        var count = eventsInSlot(segments, s);
	        return count === 1;
	      });
	    }
	  }, {
	    key: "renderShowMore",
	    value: function renderShowMore(segments, slot) {
	      var _this = this;
	      var localizer = this.props.localizer;
	      var count = eventsInSlot(segments, slot);
	      return count ? /*#__PURE__*/_react$g.default.createElement("button", {
	        type: "button",
	        key: 'sm_' + slot,
	        className: (0, _clsx$8.default)('rbc-button-link', 'rbc-show-more'),
	        onClick: function onClick(e) {
	          return _this.showMore(slot, e);
	        }
	      }, localizer.messages.showMore(count)) : false;
	    }
	  }, {
	    key: "showMore",
	    value: function showMore(slot, e) {
	      e.preventDefault();
	      e.stopPropagation();
	      this.props.onShowMore(slot, e.target);
	    }
	  }]);
	  return EventEndingRow;
	}(_react$g.default.Component);
	EventEndingRow.defaultProps = (0, _objectSpread2$3.default)({}, _EventRowMixin.default.defaultProps);
	var _default$h = EventEndingRow;
	EventEndingRow$1.default = _default$h;

	var NoopWrapper$1 = {};

	Object.defineProperty(NoopWrapper$1, "__esModule", {
	  value: true
	});
	NoopWrapper$1.default = void 0;
	function NoopWrapper(props) {
	  return props.children;
	}
	var _default$g = NoopWrapper;
	NoopWrapper$1.default = _default$g;

	var ScrollableWeekWrapper$1 = {};

	var _interopRequireDefault$l = interopRequireDefaultExports.default;
	Object.defineProperty(ScrollableWeekWrapper$1, "__esModule", {
	  value: true
	});
	ScrollableWeekWrapper$1.default = void 0;
	var _react$f = _interopRequireDefault$l(React$1);
	var ScrollableWeekWrapper = function ScrollableWeekWrapper(_ref) {
	  var children = _ref.children;
	  return /*#__PURE__*/_react$f.default.createElement("div", {
	    className: "rbc-row-content-scroll-container"
	  }, children);
	};
	var _default$f = ScrollableWeekWrapper;
	ScrollableWeekWrapper$1.default = _default$f;

	var DateSlotMetrics$1 = {};

	var require$$11 = /*@__PURE__*/getAugmentedNamespace(memoizeOne_esm);

	var _interopRequireDefault$k = interopRequireDefaultExports.default;
	Object.defineProperty(DateSlotMetrics$1, "__esModule", {
	  value: true
	});
	DateSlotMetrics$1.getSlotMetrics = getSlotMetrics$1;
	var _objectSpread2$2 = _interopRequireDefault$k(objectSpread2Exports);
	var _memoizeOne$1 = _interopRequireDefault$k(require$$11);
	var _eventLevels2 = eventLevels$1;
	var isSegmentInSlot = function isSegmentInSlot(seg, slot) {
	  return seg.left <= slot && seg.right >= slot;
	};
	var isEqual = function isEqual(a, b) {
	  return a[0].range === b[0].range && a[0].events === b[0].events;
	};
	function getSlotMetrics$1() {
	  return (0, _memoizeOne$1.default)(function (options) {
	    var range = options.range,
	      events = options.events,
	      maxRows = options.maxRows,
	      minRows = options.minRows,
	      accessors = options.accessors,
	      localizer = options.localizer;
	    var _endOfRange = (0, _eventLevels2.endOfRange)({
	        dateRange: range,
	        localizer: localizer
	      }),
	      first = _endOfRange.first,
	      last = _endOfRange.last;
	    var segments = events.map(function (evt) {
	      return (0, _eventLevels2.eventSegments)(evt, range, accessors, localizer);
	    });
	    var _eventLevels = (0, _eventLevels2.eventLevels)(segments, Math.max(maxRows - 1, 1)),
	      levels = _eventLevels.levels,
	      extra = _eventLevels.extra;
	    // Subtract 1 from minRows to not include showMore button row when
	    // it would be rendered
	    var minEventRows = extra.length > 0 ? minRows - 1 : minRows;
	    while (levels.length < minEventRows) levels.push([]);
	    return {
	      first: first,
	      last: last,
	      levels: levels,
	      extra: extra,
	      range: range,
	      slots: range.length,
	      clone: function clone(args) {
	        var metrics = getSlotMetrics$1();
	        return metrics((0, _objectSpread2$2.default)((0, _objectSpread2$2.default)({}, options), args));
	      },
	      getDateForSlot: function getDateForSlot(slotNumber) {
	        return range[slotNumber];
	      },
	      getSlotForDate: function getSlotForDate(date) {
	        return range.find(function (r) {
	          return localizer.isSameDate(r, date);
	        });
	      },
	      getEventsForSlot: function getEventsForSlot(slot) {
	        return segments.filter(function (seg) {
	          return isSegmentInSlot(seg, slot);
	        }).map(function (seg) {
	          return seg.event;
	        });
	      },
	      continuesPrior: function continuesPrior(event) {
	        return localizer.continuesPrior(accessors.start(event), first);
	      },
	      continuesAfter: function continuesAfter(event) {
	        var start = accessors.start(event);
	        var end = accessors.end(event);
	        return localizer.continuesAfter(start, end, last);
	      }
	    };
	  }, isEqual);
	}

	var _interopRequireWildcard$6 = interopRequireWildcardExports.default;
	var _interopRequireDefault$j = interopRequireDefaultExports.default;
	Object.defineProperty(DateContentRow$1, "__esModule", {
	  value: true
	});
	DateContentRow$1.default = void 0;
	var _classCallCheck2$8 = _interopRequireDefault$j(classCallCheckExports);
	var _createClass2$8 = _interopRequireDefault$j(createClassExports);
	var _inherits2$7 = _interopRequireDefault$j(inheritsExports);
	var _createSuper2$7 = _interopRequireDefault$j(createSuperExports);
	var _react$e = _interopRequireWildcard$6(React$1);
	var _clsx$7 = _interopRequireDefault$j(require$$9$1);
	var _height = _interopRequireDefault$j(require$$8);
	var _querySelectorAll = _interopRequireDefault$j(require$$9);
	var _BackgroundCells = _interopRequireDefault$j(BackgroundCells$1);
	var _EventRow = _interopRequireDefault$j(EventRow$1);
	var _EventEndingRow = _interopRequireDefault$j(EventEndingRow$1);
	var _NoopWrapper$1 = _interopRequireDefault$j(NoopWrapper$1);
	var _ScrollableWeekWrapper = _interopRequireDefault$j(ScrollableWeekWrapper$1);
	var DateSlotMetrics = _interopRequireWildcard$6(DateSlotMetrics$1);
	var DateContentRow = /*#__PURE__*/function (_React$Component) {
	  (0, _inherits2$7.default)(DateContentRow, _React$Component);
	  var _super = (0, _createSuper2$7.default)(DateContentRow);
	  function DateContentRow() {
	    var _this;
	    (0, _classCallCheck2$8.default)(this, DateContentRow);
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(args));
	    _this.handleSelectSlot = function (slot) {
	      var _this$props = _this.props,
	        range = _this$props.range,
	        onSelectSlot = _this$props.onSelectSlot;
	      onSelectSlot(range.slice(slot.start, slot.end + 1), slot);
	    };
	    _this.handleShowMore = function (slot, target) {
	      var _this$props2 = _this.props,
	        range = _this$props2.range,
	        onShowMore = _this$props2.onShowMore;
	      var metrics = _this.slotMetrics(_this.props);
	      var row = (0, _querySelectorAll.default)(_this.containerRef.current, '.rbc-row-bg')[0];
	      var cell;
	      if (row) cell = row.children[slot - 1];
	      var events = metrics.getEventsForSlot(slot);
	      onShowMore(events, range[slot - 1], cell, slot, target);
	    };
	    _this.getContainer = function () {
	      var container = _this.props.container;
	      return container ? container() : _this.containerRef.current;
	    };
	    _this.renderHeadingCell = function (date, index) {
	      var _this$props3 = _this.props,
	        renderHeader = _this$props3.renderHeader,
	        getNow = _this$props3.getNow,
	        localizer = _this$props3.localizer;
	      return renderHeader({
	        date: date,
	        key: "header_".concat(index),
	        className: (0, _clsx$7.default)('rbc-date-cell', localizer.isSameDate(date, getNow()) && 'rbc-now')
	      });
	    };
	    _this.renderDummy = function () {
	      var _this$props4 = _this.props,
	        className = _this$props4.className,
	        range = _this$props4.range,
	        renderHeader = _this$props4.renderHeader,
	        showAllEvents = _this$props4.showAllEvents;
	      return /*#__PURE__*/_react$e.default.createElement("div", {
	        className: className,
	        ref: _this.containerRef
	      }, /*#__PURE__*/_react$e.default.createElement("div", {
	        className: (0, _clsx$7.default)('rbc-row-content', showAllEvents && 'rbc-row-content-scrollable')
	      }, renderHeader && /*#__PURE__*/_react$e.default.createElement("div", {
	        className: "rbc-row",
	        ref: _this.headingRowRef
	      }, range.map(_this.renderHeadingCell)), /*#__PURE__*/_react$e.default.createElement("div", {
	        className: "rbc-row",
	        ref: _this.eventRowRef
	      }, /*#__PURE__*/_react$e.default.createElement("div", {
	        className: "rbc-row-segment"
	      }, /*#__PURE__*/_react$e.default.createElement("div", {
	        className: "rbc-event"
	      }, /*#__PURE__*/_react$e.default.createElement("div", {
	        className: "rbc-event-content"
	      }, "\xA0"))))));
	    };
	    _this.containerRef = /*#__PURE__*/(0, _react$e.createRef)();
	    _this.headingRowRef = /*#__PURE__*/(0, _react$e.createRef)();
	    _this.eventRowRef = /*#__PURE__*/(0, _react$e.createRef)();
	    _this.slotMetrics = DateSlotMetrics.getSlotMetrics();
	    return _this;
	  }
	  (0, _createClass2$8.default)(DateContentRow, [{
	    key: "getRowLimit",
	    value: function getRowLimit() {
	      var _this$headingRowRef;
	      /* Guessing this only gets called on the dummyRow */
	      var eventHeight = (0, _height.default)(this.eventRowRef.current);
	      var headingHeight = (_this$headingRowRef = this.headingRowRef) !== null && _this$headingRowRef !== void 0 && _this$headingRowRef.current ? (0, _height.default)(this.headingRowRef.current) : 0;
	      var eventSpace = (0, _height.default)(this.containerRef.current) - headingHeight;
	      return Math.max(Math.floor(eventSpace / eventHeight), 1);
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this$props5 = this.props,
	        date = _this$props5.date,
	        rtl = _this$props5.rtl,
	        range = _this$props5.range,
	        className = _this$props5.className,
	        selected = _this$props5.selected,
	        selectable = _this$props5.selectable,
	        renderForMeasure = _this$props5.renderForMeasure,
	        accessors = _this$props5.accessors,
	        getters = _this$props5.getters,
	        components = _this$props5.components,
	        getNow = _this$props5.getNow,
	        renderHeader = _this$props5.renderHeader,
	        onSelect = _this$props5.onSelect,
	        localizer = _this$props5.localizer,
	        onSelectStart = _this$props5.onSelectStart,
	        onSelectEnd = _this$props5.onSelectEnd,
	        onDoubleClick = _this$props5.onDoubleClick,
	        onKeyPress = _this$props5.onKeyPress,
	        resourceId = _this$props5.resourceId,
	        longPressThreshold = _this$props5.longPressThreshold,
	        isAllDay = _this$props5.isAllDay,
	        resizable = _this$props5.resizable,
	        showAllEvents = _this$props5.showAllEvents;
	      if (renderForMeasure) return this.renderDummy();
	      var metrics = this.slotMetrics(this.props);
	      var levels = metrics.levels,
	        extra = metrics.extra;
	      var ScrollableWeekComponent = showAllEvents ? _ScrollableWeekWrapper.default : _NoopWrapper$1.default;
	      var WeekWrapper = components.weekWrapper;
	      var eventRowProps = {
	        selected: selected,
	        accessors: accessors,
	        getters: getters,
	        localizer: localizer,
	        components: components,
	        onSelect: onSelect,
	        onDoubleClick: onDoubleClick,
	        onKeyPress: onKeyPress,
	        resourceId: resourceId,
	        slotMetrics: metrics,
	        resizable: resizable
	      };
	      return /*#__PURE__*/_react$e.default.createElement("div", {
	        className: className,
	        role: "rowgroup",
	        ref: this.containerRef
	      }, /*#__PURE__*/_react$e.default.createElement(_BackgroundCells.default, {
	        localizer: localizer,
	        date: date,
	        getNow: getNow,
	        rtl: rtl,
	        range: range,
	        selectable: selectable,
	        container: this.getContainer,
	        getters: getters,
	        onSelectStart: onSelectStart,
	        onSelectEnd: onSelectEnd,
	        onSelectSlot: this.handleSelectSlot,
	        components: components,
	        longPressThreshold: longPressThreshold,
	        resourceId: resourceId
	      }), /*#__PURE__*/_react$e.default.createElement("div", {
	        className: (0, _clsx$7.default)('rbc-row-content', showAllEvents && 'rbc-row-content-scrollable'),
	        role: "row"
	      }, renderHeader && /*#__PURE__*/_react$e.default.createElement("div", {
	        className: "rbc-row ",
	        ref: this.headingRowRef
	      }, range.map(this.renderHeadingCell)), /*#__PURE__*/_react$e.default.createElement(ScrollableWeekComponent, null, /*#__PURE__*/_react$e.default.createElement(WeekWrapper, Object.assign({
	        isAllDay: isAllDay
	      }, eventRowProps), levels.map(function (segs, idx) {
	        return /*#__PURE__*/_react$e.default.createElement(_EventRow.default, Object.assign({
	          key: idx,
	          segments: segs
	        }, eventRowProps));
	      }), !!extra.length && /*#__PURE__*/_react$e.default.createElement(_EventEndingRow.default, Object.assign({
	        segments: extra,
	        onShowMore: this.handleShowMore
	      }, eventRowProps))))));
	    }
	  }]);
	  return DateContentRow;
	}(_react$e.default.Component);
	DateContentRow.defaultProps = {
	  minRows: 0,
	  maxRows: Infinity
	};
	var _default$e = DateContentRow;
	DateContentRow$1.default = _default$e;

	var Header$1 = {};

	var _interopRequireDefault$i = interopRequireDefaultExports.default;
	Object.defineProperty(Header$1, "__esModule", {
	  value: true
	});
	Header$1.default = void 0;
	var _react$d = _interopRequireDefault$i(React$1);
	var Header = function Header(_ref) {
	  var label = _ref.label;
	  return /*#__PURE__*/_react$d.default.createElement("span", {
	    role: "columnheader",
	    "aria-sort": "none"
	  }, label);
	};
	var _default$d = Header;
	Header$1.default = _default$d;

	var DateHeader$1 = {};

	var _interopRequireDefault$h = interopRequireDefaultExports.default;
	Object.defineProperty(DateHeader$1, "__esModule", {
	  value: true
	});
	DateHeader$1.default = void 0;
	var _react$c = _interopRequireDefault$h(React$1);
	var DateHeader = function DateHeader(_ref) {
	  var label = _ref.label,
	    drilldownView = _ref.drilldownView,
	    onDrillDown = _ref.onDrillDown;
	  if (!drilldownView) {
	    return /*#__PURE__*/_react$c.default.createElement("span", null, label);
	  }
	  return /*#__PURE__*/_react$c.default.createElement("button", {
	    type: "button",
	    className: "rbc-button-link",
	    onClick: onDrillDown,
	    role: "cell"
	  }, label);
	};
	var _default$c = DateHeader;
	DateHeader$1.default = _default$c;

	var _interopRequireDefault$g = interopRequireDefaultExports.default;
	var _interopRequireWildcard$5 = interopRequireWildcardExports.default;
	Object.defineProperty(Month, "__esModule", {
	  value: true
	});
	var default_1$3 = Month.default = void 0;
	var _objectWithoutProperties2$3 = _interopRequireDefault$g(objectWithoutPropertiesExports);
	var _toConsumableArray2 = _interopRequireDefault$g(toConsumableArrayExports);
	var _classCallCheck2$7 = _interopRequireDefault$g(classCallCheckExports);
	var _createClass2$7 = _interopRequireDefault$g(createClassExports);
	var _inherits2$6 = _interopRequireDefault$g(inheritsExports);
	var _createSuper2$6 = _interopRequireDefault$g(createSuperExports);
	var _react$b = _interopRequireWildcard$5(React$1);
	var _clsx$6 = _interopRequireDefault$g(require$$9$1);
	var _chunk = _interopRequireDefault$g(chunk_1);
	var _constants$5 = constants;
	var _helpers$3 = helpers;
	var _position$1 = _interopRequireDefault$g(require$$17);
	var animationFrame$1 = _interopRequireWildcard$5(require$$10);
	var _PopOverlay$1 = _interopRequireDefault$g(PopOverlay$1);
	var _DateContentRow$1 = _interopRequireDefault$g(DateContentRow$1);
	var _Header$1 = _interopRequireDefault$g(Header$1);
	var _DateHeader = _interopRequireDefault$g(DateHeader$1);
	var _eventLevels$2 = eventLevels$1;
	var _excluded$9 = ["date", "className"];
	var eventsForWeek = function eventsForWeek(evts, start, end, accessors, localizer) {
	  return evts.filter(function (e) {
	    return (0, _eventLevels$2.inRange)(e, start, end, accessors, localizer);
	  });
	};
	var MonthView = /*#__PURE__*/function (_React$Component) {
	  (0, _inherits2$6.default)(MonthView, _React$Component);
	  var _super = (0, _createSuper2$6.default)(MonthView);
	  function MonthView() {
	    var _this;
	    (0, _classCallCheck2$7.default)(this, MonthView);
	    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
	      _args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(_args));
	    _this.getContainer = function () {
	      return _this.containerRef.current;
	    };
	    _this.renderWeek = function (week, weekIdx) {
	      var _this$props = _this.props,
	        events = _this$props.events,
	        components = _this$props.components,
	        selectable = _this$props.selectable,
	        getNow = _this$props.getNow,
	        selected = _this$props.selected,
	        date = _this$props.date,
	        localizer = _this$props.localizer,
	        longPressThreshold = _this$props.longPressThreshold,
	        accessors = _this$props.accessors,
	        getters = _this$props.getters,
	        showAllEvents = _this$props.showAllEvents;
	      var _this$state = _this.state,
	        needLimitMeasure = _this$state.needLimitMeasure,
	        rowLimit = _this$state.rowLimit;

	      // let's not mutate props
	      var weeksEvents = eventsForWeek((0, _toConsumableArray2.default)(events), week[0], week[week.length - 1], accessors, localizer);
	      weeksEvents.sort(function (a, b) {
	        return (0, _eventLevels$2.sortEvents)(a, b, accessors, localizer);
	      });
	      return /*#__PURE__*/_react$b.default.createElement(_DateContentRow$1.default, {
	        key: weekIdx,
	        ref: weekIdx === 0 ? _this.slotRowRef : undefined,
	        container: _this.getContainer,
	        className: "rbc-month-row",
	        getNow: getNow,
	        date: date,
	        range: week,
	        events: weeksEvents,
	        maxRows: showAllEvents ? Infinity : rowLimit,
	        selected: selected,
	        selectable: selectable,
	        components: components,
	        accessors: accessors,
	        getters: getters,
	        localizer: localizer,
	        renderHeader: _this.readerDateHeading,
	        renderForMeasure: needLimitMeasure,
	        onShowMore: _this.handleShowMore,
	        onSelect: _this.handleSelectEvent,
	        onDoubleClick: _this.handleDoubleClickEvent,
	        onKeyPress: _this.handleKeyPressEvent,
	        onSelectSlot: _this.handleSelectSlot,
	        longPressThreshold: longPressThreshold,
	        rtl: _this.props.rtl,
	        resizable: _this.props.resizable,
	        showAllEvents: showAllEvents
	      });
	    };
	    _this.readerDateHeading = function (_ref) {
	      var date = _ref.date,
	        className = _ref.className,
	        props = (0, _objectWithoutProperties2$3.default)(_ref, _excluded$9);
	      var _this$props2 = _this.props,
	        currentDate = _this$props2.date,
	        getDrilldownView = _this$props2.getDrilldownView,
	        localizer = _this$props2.localizer;
	      var isOffRange = localizer.neq(date, currentDate, 'month');
	      var isCurrent = localizer.isSameDate(date, currentDate);
	      var drilldownView = getDrilldownView(date);
	      var label = localizer.format(date, 'dateFormat');
	      var DateHeaderComponent = _this.props.components.dateHeader || _DateHeader.default;
	      return /*#__PURE__*/_react$b.default.createElement("div", Object.assign({}, props, {
	        className: (0, _clsx$6.default)(className, isOffRange && 'rbc-off-range', isCurrent && 'rbc-current'),
	        role: "cell"
	      }), /*#__PURE__*/_react$b.default.createElement(DateHeaderComponent, {
	        label: label,
	        date: date,
	        drilldownView: drilldownView,
	        isOffRange: isOffRange,
	        onDrillDown: function onDrillDown(e) {
	          return _this.handleHeadingClick(date, drilldownView, e);
	        }
	      }));
	    };
	    _this.handleSelectSlot = function (range, slotInfo) {
	      _this._pendingSelection = _this._pendingSelection.concat(range);
	      clearTimeout(_this._selectTimer);
	      _this._selectTimer = setTimeout(function () {
	        return _this.selectDates(slotInfo);
	      });
	    };
	    _this.handleHeadingClick = function (date, view, e) {
	      e.preventDefault();
	      _this.clearSelection();
	      (0, _helpers$3.notify)(_this.props.onDrillDown, [date, view]);
	    };
	    _this.handleSelectEvent = function () {
	      _this.clearSelection();
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	      (0, _helpers$3.notify)(_this.props.onSelectEvent, args);
	    };
	    _this.handleDoubleClickEvent = function () {
	      _this.clearSelection();
	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }
	      (0, _helpers$3.notify)(_this.props.onDoubleClickEvent, args);
	    };
	    _this.handleKeyPressEvent = function () {
	      _this.clearSelection();
	      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	        args[_key4] = arguments[_key4];
	      }
	      (0, _helpers$3.notify)(_this.props.onKeyPressEvent, args);
	    };
	    _this.handleShowMore = function (events, date, cell, slot, target) {
	      var _this$props3 = _this.props,
	        popup = _this$props3.popup,
	        onDrillDown = _this$props3.onDrillDown,
	        onShowMore = _this$props3.onShowMore,
	        getDrilldownView = _this$props3.getDrilldownView,
	        doShowMoreDrillDown = _this$props3.doShowMoreDrillDown;
	      //cancel any pending selections so only the event click goes through.
	      _this.clearSelection();
	      if (popup) {
	        var position = (0, _position$1.default)(cell, _this.containerRef.current);
	        _this.setState({
	          overlay: {
	            date: date,
	            events: events,
	            position: position,
	            target: target
	          }
	        });
	      } else if (doShowMoreDrillDown) {
	        (0, _helpers$3.notify)(onDrillDown, [date, getDrilldownView(date) || _constants$5.views.DAY]);
	      }
	      (0, _helpers$3.notify)(onShowMore, [events, date, slot]);
	    };
	    _this.overlayDisplay = function () {
	      _this.setState({
	        overlay: null
	      });
	    };
	    _this.state = {
	      rowLimit: 5,
	      needLimitMeasure: true,
	      date: null
	    };
	    _this.containerRef = /*#__PURE__*/(0, _react$b.createRef)();
	    _this.slotRowRef = /*#__PURE__*/(0, _react$b.createRef)();
	    _this._bgRows = [];
	    _this._pendingSelection = [];
	    return _this;
	  }
	  (0, _createClass2$7.default)(MonthView, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      var _this2 = this;
	      var running;
	      if (this.state.needLimitMeasure) this.measureRowLimit(this.props);
	      window.addEventListener('resize', this._resizeListener = function () {
	        if (!running) {
	          animationFrame$1.request(function () {
	            running = false;
	            _this2.setState({
	              needLimitMeasure: true
	            }); //eslint-disable-line
	          });
	        }
	      }, false);
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate() {
	      if (this.state.needLimitMeasure) this.measureRowLimit(this.props);
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      window.removeEventListener('resize', this._resizeListener, false);
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this$props4 = this.props,
	        date = _this$props4.date,
	        localizer = _this$props4.localizer,
	        className = _this$props4.className,
	        month = localizer.visibleDays(date, localizer),
	        weeks = (0, _chunk.default)(month, 7);
	      this._weekCount = weeks.length;
	      return /*#__PURE__*/_react$b.default.createElement("div", {
	        className: (0, _clsx$6.default)('rbc-month-view', className),
	        role: "table",
	        "aria-label": "Month View",
	        ref: this.containerRef
	      }, /*#__PURE__*/_react$b.default.createElement("div", {
	        className: "rbc-row rbc-month-header",
	        role: "row"
	      }, this.renderHeaders(weeks[0])), weeks.map(this.renderWeek), this.props.popup && this.renderOverlay());
	    }
	  }, {
	    key: "renderHeaders",
	    value: function renderHeaders(row) {
	      var _this$props5 = this.props,
	        localizer = _this$props5.localizer,
	        components = _this$props5.components;
	      var first = row[0];
	      var last = row[row.length - 1];
	      var HeaderComponent = components.header || _Header$1.default;
	      return localizer.range(first, last, 'day').map(function (day, idx) {
	        return /*#__PURE__*/_react$b.default.createElement("div", {
	          key: 'header_' + idx,
	          className: "rbc-header"
	        }, /*#__PURE__*/_react$b.default.createElement(HeaderComponent, {
	          date: day,
	          localizer: localizer,
	          label: localizer.format(day, 'weekdayFormat')
	        }));
	      });
	    }
	  }, {
	    key: "renderOverlay",
	    value: function renderOverlay() {
	      var _this$state$overlay,
	        _this$state2,
	        _this3 = this;
	      var overlay = (_this$state$overlay = (_this$state2 = this.state) === null || _this$state2 === void 0 ? void 0 : _this$state2.overlay) !== null && _this$state$overlay !== void 0 ? _this$state$overlay : {};
	      var _this$props6 = this.props,
	        accessors = _this$props6.accessors,
	        localizer = _this$props6.localizer,
	        components = _this$props6.components,
	        getters = _this$props6.getters,
	        selected = _this$props6.selected,
	        popupOffset = _this$props6.popupOffset,
	        handleDragStart = _this$props6.handleDragStart;
	      var onHide = function onHide() {
	        return _this3.setState({
	          overlay: null
	        });
	      };
	      return /*#__PURE__*/_react$b.default.createElement(_PopOverlay$1.default, {
	        overlay: overlay,
	        accessors: accessors,
	        localizer: localizer,
	        components: components,
	        getters: getters,
	        selected: selected,
	        popupOffset: popupOffset,
	        ref: this.containerRef,
	        handleKeyPressEvent: this.handleKeyPressEvent,
	        handleSelectEvent: this.handleSelectEvent,
	        handleDoubleClickEvent: this.handleDoubleClickEvent,
	        handleDragStart: handleDragStart,
	        show: !!overlay.position,
	        overlayDisplay: this.overlayDisplay,
	        onHide: onHide
	      });

	      /* return (
	        <Overlay
	          rootClose
	          placement="bottom"
	          show={!!overlay.position}
	          onHide={() => this.setState({ overlay: null })}
	          target={() => overlay.target}
	        >
	          {({ props }) => (
	            <Popup
	              {...props}
	              popupOffset={popupOffset}
	              accessors={accessors}
	              getters={getters}
	              selected={selected}
	              components={components}
	              localizer={localizer}
	              position={overlay.position}
	              show={this.overlayDisplay}
	              events={overlay.events}
	              slotStart={overlay.date}
	              slotEnd={overlay.end}
	              onSelect={this.handleSelectEvent}
	              onDoubleClick={this.handleDoubleClickEvent}
	              onKeyPress={this.handleKeyPressEvent}
	              handleDragStart={this.props.handleDragStart}
	            />
	          )}
	        </Overlay>
	      ) */
	    }
	  }, {
	    key: "measureRowLimit",
	    value: function measureRowLimit() {
	      this.setState({
	        needLimitMeasure: false,
	        rowLimit: this.slotRowRef.current.getRowLimit()
	      });
	    }
	  }, {
	    key: "selectDates",
	    value: function selectDates(slotInfo) {
	      var slots = this._pendingSelection.slice();
	      this._pendingSelection = [];
	      slots.sort(function (a, b) {
	        return +a - +b;
	      });
	      var start = new Date(slots[0]);
	      var end = new Date(slots[slots.length - 1]);
	      end.setDate(slots[slots.length - 1].getDate() + 1);
	      (0, _helpers$3.notify)(this.props.onSelectSlot, {
	        slots: slots,
	        start: start,
	        end: end,
	        action: slotInfo.action,
	        bounds: slotInfo.bounds,
	        box: slotInfo.box
	      });
	    }
	  }, {
	    key: "clearSelection",
	    value: function clearSelection() {
	      clearTimeout(this._selectTimer);
	      this._pendingSelection = [];
	    }
	  }], [{
	    key: "getDerivedStateFromProps",
	    value: function getDerivedStateFromProps(_ref2, state) {
	      var date = _ref2.date,
	        localizer = _ref2.localizer;
	      return {
	        date: date,
	        needLimitMeasure: localizer.neq(date, state.date, 'month')
	      };
	    }
	  }]);
	  return MonthView;
	}(_react$b.default.Component);
	MonthView.range = function (date, _ref3) {
	  var localizer = _ref3.localizer;
	  var start = localizer.firstVisibleDay(date, localizer);
	  var end = localizer.lastVisibleDay(date, localizer);
	  return {
	    start: start,
	    end: end
	  };
	};
	MonthView.navigate = function (date, action, _ref4) {
	  var localizer = _ref4.localizer;
	  switch (action) {
	    case _constants$5.navigate.PREVIOUS:
	      return localizer.add(date, -1, 'month');
	    case _constants$5.navigate.NEXT:
	      return localizer.add(date, 1, 'month');
	    default:
	      return date;
	  }
	};
	MonthView.title = function (date, _ref5) {
	  var localizer = _ref5.localizer;
	  return localizer.format(date, 'monthHeaderFormat');
	};
	var _default$b = MonthView;
	default_1$3 = Month.default = _default$b;

	const Preloader = React$1.memo(({
	  loading,
	  isOverlay = true,
	  children
	}) => {
	  const baseClass = "mpa-preloader";
	  const visibilityClass = loading ? "mpa-preloader--loading" : "";
	  const typeClass = isOverlay ? "mpa-preloader--overlay" : "";
	  const preloaderClass = `${baseClass} ${visibilityClass} ${typeClass}`;
	  if (!loading) {
	    return wp.element.createElement(React$1.Fragment, null, children);
	  }
	  return wp.element.createElement("div", {
	    className: preloaderClass
	  }, wp.element.createElement("div", {
	    className: "mpa-preloader__spinner"
	  }), children);
	});

	function withEventStore(Component) {
	  function WrappedComponent(props) {
	    const {
	      eventStore
	    } = useStores();
	    return wp.element.createElement(Component, _extends$1({}, props, {
	      eventStore: eventStore
	    }));
	  }
	  WrappedComponent.range = Component.range;
	  WrappedComponent.navigate = Component.navigate;
	  WrappedComponent.title = Component.title;
	  return WrappedComponent;
	}

	class MPAMonthBase extends default_1$3 {
	  render() {
	    const {
	      eventStore
	    } = this.props;
	    return wp.element.createElement("div", {
	      className: "mpa-timegrid-container mpa-timegrid-container__month"
	    }, wp.element.createElement(Preloader, {
	      loading: eventStore.loading,
	      isOverlay: false
	    }), super.render());
	  }
	}
	const MPAMonth = withEventStore(MPAMonthBase);

	var Week$1 = {};

	var toArray = {exports: {}};

	var arrayWithHoles = {exports: {}};

	(function (module) {
		function _arrayWithHoles(arr) {
		  if (Array.isArray(arr)) return arr;
		}
		module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (arrayWithHoles));

	var arrayWithHolesExports = arrayWithHoles.exports;

	var nonIterableRest = {exports: {}};

	(function (module) {
		function _nonIterableRest() {
		  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
		}
		module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (nonIterableRest));

	var nonIterableRestExports = nonIterableRest.exports;

	(function (module) {
		var arrayWithHoles = arrayWithHolesExports;
		var iterableToArray = iterableToArrayExports;
		var unsupportedIterableToArray = unsupportedIterableToArrayExports;
		var nonIterableRest = nonIterableRestExports;
		function _toArray(arr) {
		  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
		}
		module.exports = _toArray, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (toArray));

	var toArrayExports = toArray.exports;

	var propTypes$2 = {};

	var _interopRequireDefault$f = interopRequireDefaultExports.default;
	Object.defineProperty(propTypes$2, "__esModule", {
	  value: true
	});
	propTypes$2.views = propTypes$2.dateRangeFormat = propTypes$2.dateFormat = propTypes$2.accessor = propTypes$2.DayLayoutAlgorithmPropType = void 0;
	var _propTypes = _interopRequireDefault$f(propTypesExports);
	var _constants$4 = constants;
	var viewNames = Object.keys(_constants$4.views).map(function (k) {
	  return _constants$4.views[k];
	});
	var accessor = _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]);
	propTypes$2.accessor = accessor;
	var dateFormat = _propTypes.default.any;
	propTypes$2.dateFormat = dateFormat;
	var dateRangeFormat = _propTypes.default.func;

	/**
	 * accepts either an array of builtin view names:
	 *
	 * ```
	 * views={['month', 'day', 'agenda']}
	 * ```
	 *
	 * or an object hash of the view name and the component (or boolean for builtin)
	 *
	 * ```
	 * views={{
	 *   month: true,
	 *   week: false,
	 *   workweek: WorkWeekViewComponent,
	 * }}
	 * ```
	 */
	propTypes$2.dateRangeFormat = dateRangeFormat;
	var views = _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.oneOf(viewNames)), _propTypes.default.objectOf(function (prop, key) {
	  var isBuiltinView = viewNames.indexOf(key) !== -1 && typeof prop[key] === 'boolean';
	  if (isBuiltinView) {
	    return null;
	  } else {
	    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	    return _propTypes.default.elementType.apply(_propTypes.default, [prop, key].concat(args));
	  }
	})]);
	propTypes$2.views = views;
	var DayLayoutAlgorithmPropType = _propTypes.default.oneOfType([_propTypes.default.oneOf(['overlap', 'no-overlap']), _propTypes.default.func]);
	propTypes$2.DayLayoutAlgorithmPropType = DayLayoutAlgorithmPropType;

	var TimeGrid$1 = {};

	var slicedToArray = {exports: {}};

	var iterableToArrayLimit = {exports: {}};

	(function (module) {
		function _iterableToArrayLimit(arr, i) {
		  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
		  if (null != _i) {
		    var _s,
		      _e,
		      _x,
		      _r,
		      _arr = [],
		      _n = !0,
		      _d = !1;
		    try {
		      if (_x = (_i = _i.call(arr)).next, 0 === i) {
		        if (Object(_i) !== _i) return;
		        _n = !1;
		      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
		    } catch (err) {
		      _d = !0, _e = err;
		    } finally {
		      try {
		        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
		      } finally {
		        if (_d) throw _e;
		      }
		    }
		    return _arr;
		  }
		}
		module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (iterableToArrayLimit));

	var iterableToArrayLimitExports = iterableToArrayLimit.exports;

	(function (module) {
		var arrayWithHoles = arrayWithHolesExports;
		var iterableToArrayLimit = iterableToArrayLimitExports;
		var unsupportedIterableToArray = unsupportedIterableToArrayExports;
		var nonIterableRest = nonIterableRestExports;
		function _slicedToArray(arr, i) {
		  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
		}
		module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports; 
	} (slicedToArray));

	var slicedToArrayExports = slicedToArray.exports;

	var DayColumn$1 = {};

	var TimeSlots = {};

	Object.defineProperty(TimeSlots, "__esModule", {
	  value: true
	});
	TimeSlots.getSlotMetrics = getSlotMetrics;
	var getKey = function getKey(_ref) {
	  var min = _ref.min,
	    max = _ref.max,
	    step = _ref.step,
	    slots = _ref.slots,
	    localizer = _ref.localizer;
	  return "".concat(+localizer.startOf(min, 'minutes')) + "".concat(+localizer.startOf(max, 'minutes')) + "".concat(step, "-").concat(slots);
	};
	function getSlotMetrics(_ref2) {
	  var start = _ref2.min,
	    end = _ref2.max,
	    step = _ref2.step,
	    timeslots = _ref2.timeslots,
	    localizer = _ref2.localizer;
	  var key = getKey({
	    start: start,
	    end: end,
	    step: step,
	    timeslots: timeslots,
	    localizer: localizer
	  });

	  // DST differences are handled inside the localizer
	  var totalMin = 1 + localizer.getTotalMin(start, end);
	  var minutesFromMidnight = localizer.getMinutesFromMidnight(start);
	  var numGroups = Math.ceil((totalMin - 1) / (step * timeslots));
	  var numSlots = numGroups * timeslots;
	  var groups = new Array(numGroups);
	  var slots = new Array(numSlots);
	  // Each slot date is created from "zero", instead of adding `step` to
	  // the previous one, in order to avoid DST oddities
	  for (var grp = 0; grp < numGroups; grp++) {
	    groups[grp] = new Array(timeslots);
	    for (var slot = 0; slot < timeslots; slot++) {
	      var slotIdx = grp * timeslots + slot;
	      var minFromStart = slotIdx * step;
	      // A date with total minutes calculated from the start of the day
	      slots[slotIdx] = groups[grp][slot] = localizer.getSlotDate(start, minutesFromMidnight, minFromStart);
	    }
	  }

	  // Necessary to be able to select up until the last timeslot in a day
	  var lastSlotMinFromStart = slots.length * step;
	  slots.push(localizer.getSlotDate(start, minutesFromMidnight, lastSlotMinFromStart));
	  function positionFromDate(date) {
	    var diff = localizer.diff(start, date, 'minutes') + localizer.getDstOffset(start, date);
	    return Math.min(diff, totalMin);
	  }
	  return {
	    groups: groups,
	    update: function update(args) {
	      if (getKey(args) !== key) return getSlotMetrics(args);
	      return this;
	    },
	    dateIsInGroup: function dateIsInGroup(date, groupIndex) {
	      var nextGroup = groups[groupIndex + 1];
	      return localizer.inRange(date, groups[groupIndex][0], nextGroup ? nextGroup[0] : end, 'minutes');
	    },
	    nextSlot: function nextSlot(slot) {
	      var next = slots[Math.min(slots.indexOf(slot) + 1, slots.length - 1)];
	      // in the case of the last slot we won't a long enough range so manually get it
	      if (next === slot) next = localizer.add(slot, step, 'minutes');
	      return next;
	    },
	    closestSlotToPosition: function closestSlotToPosition(percent) {
	      var slot = Math.min(slots.length - 1, Math.max(0, Math.floor(percent * numSlots)));
	      return slots[slot];
	    },
	    closestSlotFromPoint: function closestSlotFromPoint(point, boundaryRect) {
	      var range = Math.abs(boundaryRect.top - boundaryRect.bottom);
	      return this.closestSlotToPosition((point.y - boundaryRect.top) / range);
	    },
	    closestSlotFromDate: function closestSlotFromDate(date) {
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      if (localizer.lt(date, start, 'minutes')) return slots[0];
	      if (localizer.gt(date, end, 'minutes')) return slots[slots.length - 1];
	      var diffMins = localizer.diff(start, date, 'minutes');
	      return slots[(diffMins - diffMins % step) / step + offset];
	    },
	    startsBeforeDay: function startsBeforeDay(date) {
	      return localizer.lt(date, start, 'day');
	    },
	    startsAfterDay: function startsAfterDay(date) {
	      return localizer.gt(date, end, 'day');
	    },
	    startsBefore: function startsBefore(date) {
	      return localizer.lt(localizer.merge(start, date), start, 'minutes');
	    },
	    startsAfter: function startsAfter(date) {
	      return localizer.gt(localizer.merge(end, date), end, 'minutes');
	    },
	    getRange: function getRange(rangeStart, rangeEnd, ignoreMin, ignoreMax) {
	      if (!ignoreMin) rangeStart = localizer.min(end, localizer.max(start, rangeStart));
	      if (!ignoreMax) rangeEnd = localizer.min(end, localizer.max(start, rangeEnd));
	      var rangeStartMin = positionFromDate(rangeStart);
	      var rangeEndMin = positionFromDate(rangeEnd);
	      var top = rangeEndMin > step * numSlots && !localizer.eq(end, rangeEnd) ? (rangeStartMin - step) / (step * numSlots) * 100 : rangeStartMin / (step * numSlots) * 100;
	      return {
	        top: top,
	        height: rangeEndMin / (step * numSlots) * 100 - top,
	        start: positionFromDate(rangeStart),
	        startDate: rangeStart,
	        end: positionFromDate(rangeEnd),
	        endDate: rangeEnd
	      };
	    },
	    getCurrentTimePosition: function getCurrentTimePosition(rangeStart) {
	      var rangeStartMin = positionFromDate(rangeStart);
	      var top = rangeStartMin / (step * numSlots) * 100;
	      return top;
	    }
	  };
	}

	var DayEventLayout$1 = {};

	var overlap = {};

	var Symbol$1 = _Symbol,
	    isArguments = isArguments_1,
	    isArray$2 = isArray_1;

	/** Built-in value references. */
	var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable$1(value) {
	  return isArray$2(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	var _isFlattenable = isFlattenable$1;

	var arrayPush = _arrayPush,
	    isFlattenable = _isFlattenable;

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten$1(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	var _baseFlatten = baseFlatten$1;

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */

	function createBaseFor$1(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	var _createBaseFor = createBaseFor$1;

	var createBaseFor = _createBaseFor;

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor$1 = createBaseFor();

	var _baseFor = baseFor$1;

	var baseFor = _baseFor,
	    keys = keys_1;

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn$1(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	var _baseForOwn = baseForOwn$1;

	var isArrayLike$1 = isArrayLike_1;

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach$1(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike$1(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	var _createBaseEach = createBaseEach$1;

	var baseForOwn = _baseForOwn,
	    createBaseEach = _createBaseEach;

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach$1 = createBaseEach(baseForOwn);

	var _baseEach = baseEach$1;

	var baseEach = _baseEach,
	    isArrayLike = isArrayLike_1;

	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap$1(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];

	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}

	var _baseMap = baseMap$1;

	/**
	 * The base implementation of `_.sortBy` which uses `comparer` to define the
	 * sort order of `array` and replaces criteria objects with their corresponding
	 * values.
	 *
	 * @private
	 * @param {Array} array The array to sort.
	 * @param {Function} comparer The function to define sort order.
	 * @returns {Array} Returns `array`.
	 */

	function baseSortBy$1(array, comparer) {
	  var length = array.length;

	  array.sort(comparer);
	  while (length--) {
	    array[length] = array[length].value;
	  }
	  return array;
	}

	var _baseSortBy = baseSortBy$1;

	var isSymbol = isSymbol_1;

	/**
	 * Compares values to sort them in ascending order.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {number} Returns the sort order indicator for `value`.
	 */
	function compareAscending$1(value, other) {
	  if (value !== other) {
	    var valIsDefined = value !== undefined,
	        valIsNull = value === null,
	        valIsReflexive = value === value,
	        valIsSymbol = isSymbol(value);

	    var othIsDefined = other !== undefined,
	        othIsNull = other === null,
	        othIsReflexive = other === other,
	        othIsSymbol = isSymbol(other);

	    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	        (valIsNull && othIsDefined && othIsReflexive) ||
	        (!valIsDefined && othIsReflexive) ||
	        !valIsReflexive) {
	      return 1;
	    }
	    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	        (othIsNull && valIsDefined && valIsReflexive) ||
	        (!othIsDefined && valIsReflexive) ||
	        !othIsReflexive) {
	      return -1;
	    }
	  }
	  return 0;
	}

	var _compareAscending = compareAscending$1;

	var compareAscending = _compareAscending;

	/**
	 * Used by `_.orderBy` to compare multiple properties of a value to another
	 * and stable sort them.
	 *
	 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	 * specify an order of "desc" for descending or "asc" for ascending sort order
	 * of corresponding values.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {boolean[]|string[]} orders The order to sort by for each property.
	 * @returns {number} Returns the sort order indicator for `object`.
	 */
	function compareMultiple$1(object, other, orders) {
	  var index = -1,
	      objCriteria = object.criteria,
	      othCriteria = other.criteria,
	      length = objCriteria.length,
	      ordersLength = orders.length;

	  while (++index < length) {
	    var result = compareAscending(objCriteria[index], othCriteria[index]);
	    if (result) {
	      if (index >= ordersLength) {
	        return result;
	      }
	      var order = orders[index];
	      return result * (order == 'desc' ? -1 : 1);
	    }
	  }
	  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	  // that causes it, under certain circumstances, to provide the same value for
	  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	  // for more details.
	  //
	  // This also ensures a stable sort in V8 and other engines.
	  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	  return object.index - other.index;
	}

	var _compareMultiple = compareMultiple$1;

	var arrayMap = _arrayMap,
	    baseGet = _baseGet,
	    baseIteratee = _baseIteratee,
	    baseMap = _baseMap,
	    baseSortBy = _baseSortBy,
	    baseUnary = _baseUnary,
	    compareMultiple = _compareMultiple,
	    identity$2 = identity_1,
	    isArray$1 = isArray_1;

	/**
	 * The base implementation of `_.orderBy` without param guards.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	 * @param {string[]} orders The sort orders of `iteratees`.
	 * @returns {Array} Returns the new sorted array.
	 */
	function baseOrderBy$1(collection, iteratees, orders) {
	  if (iteratees.length) {
	    iteratees = arrayMap(iteratees, function(iteratee) {
	      if (isArray$1(iteratee)) {
	        return function(value) {
	          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
	        }
	      }
	      return iteratee;
	    });
	  } else {
	    iteratees = [identity$2];
	  }

	  var index = -1;
	  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

	  var result = baseMap(collection, function(value, key, collection) {
	    var criteria = arrayMap(iteratees, function(iteratee) {
	      return iteratee(value);
	    });
	    return { 'criteria': criteria, 'index': ++index, 'value': value };
	  });

	  return baseSortBy(result, function(object, other) {
	    return compareMultiple(object, other, orders);
	  });
	}

	var _baseOrderBy = baseOrderBy$1;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */

	function apply$1(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	var _apply = apply$1;

	var apply = _apply;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest$1(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	var _overRest = overRest$1;

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */

	function constant$1(value) {
	  return function() {
	    return value;
	  };
	}

	var constant_1 = constant$1;

	var getNative = _getNative;

	var defineProperty$1 = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	var _defineProperty = defineProperty$1;

	var constant = constant_1,
	    defineProperty = _defineProperty,
	    identity$1 = identity_1;

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	var _baseSetToString = baseSetToString$1;

	/** Used to detect hot functions by number of calls within a span of milliseconds. */

	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut$1(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	var _shortOut = shortOut$1;

	var baseSetToString = _baseSetToString,
	    shortOut = _shortOut;

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString$1 = shortOut(baseSetToString);

	var _setToString = setToString$1;

	var identity = identity_1,
	    overRest = _overRest,
	    setToString = _setToString;

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest$1(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	var _baseRest = baseRest$1;

	var baseFlatten = _baseFlatten,
	    baseOrderBy = _baseOrderBy,
	    baseRest = _baseRest,
	    isIterateeCall = _isIterateeCall;

	/**
	 * Creates an array of elements, sorted in ascending order by the results of
	 * running each element in a collection thru each iteratee. This method
	 * performs a stable sort, that is, it preserves the original sort order of
	 * equal elements. The iteratees are invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {...(Function|Function[])} [iteratees=[_.identity]]
	 *  The iteratees to sort by.
	 * @returns {Array} Returns the new sorted array.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'fred',   'age': 48 },
	 *   { 'user': 'barney', 'age': 36 },
	 *   { 'user': 'fred',   'age': 30 },
	 *   { 'user': 'barney', 'age': 34 }
	 * ];
	 *
	 * _.sortBy(users, [function(o) { return o.user; }]);
	 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
	 *
	 * _.sortBy(users, ['user', 'age']);
	 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
	 */
	var sortBy = baseRest(function(collection, iteratees) {
	  if (collection == null) {
	    return [];
	  }
	  var length = iteratees.length;
	  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	    iteratees = [];
	  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	    iteratees = [iteratees[0]];
	  }
	  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	});

	var sortBy_1 = sortBy;

	var _interopRequireDefault$e = interopRequireDefaultExports.default;
	Object.defineProperty(overlap, "__esModule", {
	  value: true
	});
	overlap.default = getStyledEvents$1;
	var _classCallCheck2$6 = _interopRequireDefault$e(classCallCheckExports);
	var _createClass2$6 = _interopRequireDefault$e(createClassExports);
	var _sortBy = _interopRequireDefault$e(sortBy_1);
	var Event = /*#__PURE__*/function () {
	  function Event(data, _ref) {
	    var accessors = _ref.accessors,
	      slotMetrics = _ref.slotMetrics;
	    (0, _classCallCheck2$6.default)(this, Event);
	    var _slotMetrics$getRange = slotMetrics.getRange(accessors.start(data), accessors.end(data)),
	      start = _slotMetrics$getRange.start,
	      startDate = _slotMetrics$getRange.startDate,
	      end = _slotMetrics$getRange.end,
	      endDate = _slotMetrics$getRange.endDate,
	      top = _slotMetrics$getRange.top,
	      height = _slotMetrics$getRange.height;
	    this.start = start;
	    this.end = end;
	    this.startMs = +startDate;
	    this.endMs = +endDate;
	    this.top = top;
	    this.height = height;
	    this.data = data;
	  }

	  /**
	   * The event's width without any overlap.
	   */
	  (0, _createClass2$6.default)(Event, [{
	    key: "_width",
	    get: function get() {
	      // The container event's width is determined by the maximum number of
	      // events in any of its rows.
	      if (this.rows) {
	        var columns = this.rows.reduce(function (max, row) {
	          return Math.max(max, row.leaves.length + 1);
	        },
	        // add itself
	        0) + 1; // add the container

	        return 100 / columns;
	      }

	      // The row event's width is the space left by the container, divided
	      // among itself and its leaves.
	      if (this.leaves) {
	        var availableWidth = 100 - this.container._width;
	        return availableWidth / (this.leaves.length + 1);
	      }

	      // The leaf event's width is determined by its row's width
	      return this.row._width;
	    }

	    /**
	     * The event's calculated width, possibly with extra width added for
	     * overlapping effect.
	     */
	  }, {
	    key: "width",
	    get: function get() {
	      var noOverlap = this._width;
	      var overlap = Math.min(100, this._width * 1.7);

	      // Containers can always grow.
	      if (this.rows) {
	        return overlap;
	      }

	      // Rows can grow if they have leaves.
	      if (this.leaves) {
	        return this.leaves.length > 0 ? overlap : noOverlap;
	      }

	      // Leaves can grow unless they're the last item in a row.
	      var leaves = this.row.leaves;
	      var index = leaves.indexOf(this);
	      return index === leaves.length - 1 ? noOverlap : overlap;
	    }
	  }, {
	    key: "xOffset",
	    get: function get() {
	      // Containers have no offset.
	      if (this.rows) return 0;

	      // Rows always start where their container ends.
	      if (this.leaves) return this.container._width;

	      // Leaves are spread out evenly on the space left by its row.
	      var _this$row = this.row,
	        leaves = _this$row.leaves,
	        xOffset = _this$row.xOffset,
	        _width = _this$row._width;
	      var index = leaves.indexOf(this) + 1;
	      return xOffset + index * _width;
	    }
	  }]);
	  return Event;
	}();
	/**
	 * Return true if event a and b is considered to be on the same row.
	 */
	function onSameRow(a, b, minimumStartDifference) {
	  return (
	    // Occupies the same start slot.
	    Math.abs(b.start - a.start) < minimumStartDifference ||
	    // A's start slot overlaps with b's end slot.
	    b.start > a.start && b.start < a.end
	  );
	}
	function sortByRender(events) {
	  var sortedByTime = (0, _sortBy.default)(events, ['startMs', function (e) {
	    return -e.endMs;
	  }]);
	  var sorted = [];
	  while (sortedByTime.length > 0) {
	    var event = sortedByTime.shift();
	    sorted.push(event);
	    for (var i = 0; i < sortedByTime.length; i++) {
	      var test = sortedByTime[i];

	      // Still inside this event, look for next.
	      if (event.endMs > test.startMs) continue;

	      // We've found the first event of the next event group.
	      // If that event is not right next to our current event, we have to
	      // move it here.
	      if (i > 0) {
	        var _event = sortedByTime.splice(i, 1)[0];
	        sorted.push(_event);
	      }

	      // We've already found the next event group, so stop looking.
	      break;
	    }
	  }
	  return sorted;
	}
	function getStyledEvents$1(_ref2) {
	  var events = _ref2.events,
	    minimumStartDifference = _ref2.minimumStartDifference,
	    slotMetrics = _ref2.slotMetrics,
	    accessors = _ref2.accessors;
	  // Create proxy events and order them so that we don't have
	  // to fiddle with z-indexes.
	  var proxies = events.map(function (event) {
	    return new Event(event, {
	      slotMetrics: slotMetrics,
	      accessors: accessors
	    });
	  });
	  var eventsInRenderOrder = sortByRender(proxies);

	  // Group overlapping events, while keeping order.
	  // Every event is always one of: container, row or leaf.
	  // Containers can contain rows, and rows can contain leaves.
	  var containerEvents = [];
	  var _loop = function _loop() {
	    var event = eventsInRenderOrder[i];

	    // Check if this event can go into a container event.
	    var container = containerEvents.find(function (c) {
	      return c.end > event.start || Math.abs(event.start - c.start) < minimumStartDifference;
	    });

	    // Couldn't find a container  that means this event is a container.
	    if (!container) {
	      event.rows = [];
	      containerEvents.push(event);
	      return "continue";
	    }

	    // Found a container for the event.
	    event.container = container;

	    // Check if the event can be placed in an existing row.
	    // Start looking from behind.
	    var row = null;
	    for (var j = container.rows.length - 1; !row && j >= 0; j--) {
	      if (onSameRow(container.rows[j], event, minimumStartDifference)) {
	        row = container.rows[j];
	      }
	    }
	    if (row) {
	      // Found a row, so add it.
	      row.leaves.push(event);
	      event.row = row;
	    } else {
	      // Couldn't find a row  that means this event is a row.
	      event.leaves = [];
	      container.rows.push(event);
	    }
	  };
	  for (var i = 0; i < eventsInRenderOrder.length; i++) {
	    var _ret = _loop();
	    if (_ret === "continue") continue;
	  }

	  // Return the original events, along with their styles.
	  return eventsInRenderOrder.map(function (event) {
	    return {
	      event: event.data,
	      style: {
	        top: event.top,
	        height: event.height,
	        width: event.width,
	        xOffset: Math.max(0, event.xOffset)
	      }
	    };
	  });
	}

	var noOverlap = {};

	var _interopRequireDefault$d = interopRequireDefaultExports.default;
	Object.defineProperty(noOverlap, "__esModule", {
	  value: true
	});
	noOverlap.default = _default$a;
	var _overlap$1 = _interopRequireDefault$d(overlap);
	function getMaxIdxDFS(node, maxIdx, visited) {
	  for (var i = 0; i < node.friends.length; ++i) {
	    if (visited.indexOf(node.friends[i]) > -1) continue;
	    maxIdx = maxIdx > node.friends[i].idx ? maxIdx : node.friends[i].idx;
	    // TODO : trace it by not object but kinda index or something for performance
	    visited.push(node.friends[i]);
	    var newIdx = getMaxIdxDFS(node.friends[i], maxIdx, visited);
	    maxIdx = maxIdx > newIdx ? maxIdx : newIdx;
	  }
	  return maxIdx;
	}
	function _default$a(_ref) {
	  var events = _ref.events,
	    minimumStartDifference = _ref.minimumStartDifference,
	    slotMetrics = _ref.slotMetrics,
	    accessors = _ref.accessors;
	  var styledEvents = (0, _overlap$1.default)({
	    events: events,
	    minimumStartDifference: minimumStartDifference,
	    slotMetrics: slotMetrics,
	    accessors: accessors
	  });
	  styledEvents.sort(function (a, b) {
	    a = a.style;
	    b = b.style;
	    if (a.top !== b.top) return a.top > b.top ? 1 : -1;else return a.top + a.height < b.top + b.height ? 1 : -1;
	  });
	  for (var i = 0; i < styledEvents.length; ++i) {
	    styledEvents[i].friends = [];
	    delete styledEvents[i].style.left;
	    delete styledEvents[i].style.left;
	    delete styledEvents[i].idx;
	    delete styledEvents[i].size;
	  }
	  for (var _i2 = 0; _i2 < styledEvents.length - 1; ++_i2) {
	    var se1 = styledEvents[_i2];
	    var y1 = se1.style.top;
	    var y2 = se1.style.top + se1.style.height;
	    for (var j = _i2 + 1; j < styledEvents.length; ++j) {
	      var se2 = styledEvents[j];
	      var y3 = se2.style.top;
	      var y4 = se2.style.top + se2.style.height;
	      if (y3 >= y1 && y4 <= y2 || y4 > y1 && y4 <= y2 || y3 >= y1 && y3 < y2) {
	        // TODO : hashmap would be effective for performance
	        se1.friends.push(se2);
	        se2.friends.push(se1);
	      }
	    }
	  }
	  for (var _i4 = 0; _i4 < styledEvents.length; ++_i4) {
	    var se = styledEvents[_i4];
	    var bitmap = [];
	    for (var _j2 = 0; _j2 < 100; ++_j2) bitmap.push(1); // 1 means available

	    for (var _j4 = 0; _j4 < se.friends.length; ++_j4) if (se.friends[_j4].idx !== undefined) bitmap[se.friends[_j4].idx] = 0; // 0 means reserved

	    se.idx = bitmap.indexOf(1);
	  }
	  for (var _i6 = 0; _i6 < styledEvents.length; ++_i6) {
	    var size = 0;
	    if (styledEvents[_i6].size) continue;
	    var allFriends = [];
	    var maxIdx = getMaxIdxDFS(styledEvents[_i6], 0, allFriends);
	    size = 100 / (maxIdx + 1);
	    styledEvents[_i6].size = size;
	    for (var _j6 = 0; _j6 < allFriends.length; ++_j6) allFriends[_j6].size = size;
	  }
	  for (var _i8 = 0; _i8 < styledEvents.length; ++_i8) {
	    var e = styledEvents[_i8];
	    e.style.left = e.idx * e.size;

	    // stretch to maximum
	    var _maxIdx = 0;
	    for (var _j8 = 0; _j8 < e.friends.length; ++_j8) {
	      var idx = e.friends[_j8].idx;
	      _maxIdx = _maxIdx > idx ? _maxIdx : idx;
	    }
	    if (_maxIdx <= e.idx) e.size = 100 - e.idx * e.size;

	    // padding between events
	    // for this feature, `width` is not percentage based unit anymore
	    // it will be used with calc()
	    var padding = e.idx === 0 ? 0 : 3;
	    e.style.width = "calc(".concat(e.size, "% - ").concat(padding, "px)");
	    e.style.height = "calc(".concat(e.style.height, "% - 2px)");
	    e.style.xOffset = "calc(".concat(e.style.left, "% + ").concat(padding, "px)");
	  }
	  return styledEvents;
	}

	var _interopRequireDefault$c = interopRequireDefaultExports.default;
	Object.defineProperty(DayEventLayout$1, "__esModule", {
	  value: true
	});
	DayEventLayout$1.getStyledEvents = getStyledEvents;
	var _overlap = _interopRequireDefault$c(overlap);
	var _noOverlap = _interopRequireDefault$c(noOverlap);
	/*eslint no-unused-vars: "off"*/

	var DefaultAlgorithms = {
	  overlap: _overlap.default,
	  'no-overlap': _noOverlap.default
	};
	function isFunction(a) {
	  return !!(a && a.constructor && a.call && a.apply);
	}

	//
	function getStyledEvents(_ref) {
	  _ref.events;
	    _ref.minimumStartDifference;
	    _ref.slotMetrics;
	    _ref.accessors;
	    var dayLayoutAlgorithm = _ref.dayLayoutAlgorithm;
	  var algorithm = dayLayoutAlgorithm;
	  if (dayLayoutAlgorithm in DefaultAlgorithms) algorithm = DefaultAlgorithms[dayLayoutAlgorithm];
	  if (!isFunction(algorithm)) {
	    // invalid algorithm
	    return [];
	  }
	  return algorithm.apply(this, arguments);
	}

	var TimeSlotGroup$1 = {};

	var BackgroundWrapper = {};

	var _interopRequireDefault$b = interopRequireDefaultExports.default;
	Object.defineProperty(BackgroundWrapper, "__esModule", {
	  value: true
	});
	BackgroundWrapper.default = void 0;
	var _NoopWrapper = _interopRequireDefault$b(NoopWrapper$1);
	var _default$9 = _NoopWrapper.default;
	BackgroundWrapper.default = _default$9;

	var _interopRequireWildcard$4 = interopRequireWildcardExports.default;
	var _interopRequireDefault$a = interopRequireDefaultExports.default;
	Object.defineProperty(TimeSlotGroup$1, "__esModule", {
	  value: true
	});
	TimeSlotGroup$1.default = void 0;
	var _classCallCheck2$5 = _interopRequireDefault$a(classCallCheckExports);
	var _createClass2$5 = _interopRequireDefault$a(createClassExports);
	var _inherits2$5 = _interopRequireDefault$a(inheritsExports);
	var _createSuper2$5 = _interopRequireDefault$a(createSuperExports);
	var _clsx$5 = _interopRequireDefault$a(require$$9$1);
	var _react$a = _interopRequireWildcard$4(React$1);
	var _BackgroundWrapper = _interopRequireDefault$a(BackgroundWrapper);
	var TimeSlotGroup = /*#__PURE__*/function (_Component) {
	  (0, _inherits2$5.default)(TimeSlotGroup, _Component);
	  var _super = (0, _createSuper2$5.default)(TimeSlotGroup);
	  function TimeSlotGroup() {
	    (0, _classCallCheck2$5.default)(this, TimeSlotGroup);
	    return _super.apply(this, arguments);
	  }
	  (0, _createClass2$5.default)(TimeSlotGroup, [{
	    key: "render",
	    value: function render() {
	      var _this$props = this.props,
	        renderSlot = _this$props.renderSlot,
	        resource = _this$props.resource,
	        group = _this$props.group,
	        getters = _this$props.getters,
	        _this$props$component = _this$props.components,
	        _this$props$component2 = _this$props$component === void 0 ? {} : _this$props$component,
	        _this$props$component3 = _this$props$component2.timeSlotWrapper,
	        Wrapper = _this$props$component3 === void 0 ? _BackgroundWrapper.default : _this$props$component3;
	      var groupProps = getters ? getters.slotGroupProp(group) : {};
	      return /*#__PURE__*/_react$a.default.createElement("div", Object.assign({
	        className: "rbc-timeslot-group"
	      }, groupProps), group.map(function (value, idx) {
	        var slotProps = getters ? getters.slotProp(value, resource) : {};
	        return /*#__PURE__*/_react$a.default.createElement(Wrapper, {
	          key: idx,
	          value: value,
	          resource: resource
	        }, /*#__PURE__*/_react$a.default.createElement("div", Object.assign({}, slotProps, {
	          className: (0, _clsx$5.default)('rbc-time-slot', slotProps.className)
	        }), renderSlot && renderSlot(value, idx)));
	      }));
	    }
	  }]);
	  return TimeSlotGroup;
	}(_react$a.Component);
	TimeSlotGroup$1.default = TimeSlotGroup;

	var TimeGridEvent$1 = {};

	var _interopRequireDefault$9 = interopRequireDefaultExports.default;
	Object.defineProperty(TimeGridEvent$1, "__esModule", {
	  value: true
	});
	TimeGridEvent$1.default = void 0;
	var _defineProperty2 = _interopRequireDefault$9(definePropertyExports);
	var _objectSpread4 = _interopRequireDefault$9(objectSpread2Exports);
	var _clsx$4 = _interopRequireDefault$9(require$$9$1);
	var _react$9 = _interopRequireDefault$9(React$1);
	function stringifyPercent(v) {
	  return typeof v === 'string' ? v : v + '%';
	}

	/* eslint-disable react/prop-types */
	function TimeGridEvent(props) {
	  var style = props.style,
	    className = props.className,
	    event = props.event,
	    accessors = props.accessors,
	    rtl = props.rtl,
	    selected = props.selected,
	    label = props.label,
	    continuesPrior = props.continuesPrior,
	    continuesAfter = props.continuesAfter,
	    getters = props.getters,
	    onClick = props.onClick,
	    onDoubleClick = props.onDoubleClick,
	    isBackgroundEvent = props.isBackgroundEvent,
	    onKeyPress = props.onKeyPress,
	    _props$components = props.components,
	    Event = _props$components.event,
	    EventWrapper = _props$components.eventWrapper;
	  var title = accessors.title(event);
	  var tooltip = accessors.tooltip(event);
	  var end = accessors.end(event);
	  var start = accessors.start(event);
	  var userProps = getters.eventProp(event, start, end, selected);
	  var height = style.height,
	    top = style.top,
	    width = style.width,
	    xOffset = style.xOffset;
	  var inner = [/*#__PURE__*/_react$9.default.createElement("div", {
	    key: "1",
	    className: "rbc-event-label"
	  }, label), /*#__PURE__*/_react$9.default.createElement("div", {
	    key: "2",
	    className: "rbc-event-content"
	  }, Event ? /*#__PURE__*/_react$9.default.createElement(Event, {
	    event: event,
	    title: title
	  }) : title)];
	  var eventStyle = isBackgroundEvent ? (0, _objectSpread4.default)((0, _objectSpread4.default)({}, userProps.style), {}, (0, _defineProperty2.default)({
	    top: stringifyPercent(top),
	    height: stringifyPercent(height),
	    // Adding 10px to take events container right margin into account
	    width: "calc(".concat(width, " + 10px)")
	  }, rtl ? 'right' : 'left', stringifyPercent(Math.max(0, xOffset)))) : (0, _objectSpread4.default)((0, _objectSpread4.default)({}, userProps.style), {}, (0, _defineProperty2.default)({
	    top: stringifyPercent(top),
	    width: stringifyPercent(width),
	    height: stringifyPercent(height)
	  }, rtl ? 'right' : 'left', stringifyPercent(xOffset)));
	  return /*#__PURE__*/_react$9.default.createElement(EventWrapper, Object.assign({
	    type: "time"
	  }, props), /*#__PURE__*/_react$9.default.createElement("div", {
	    onClick: onClick,
	    onDoubleClick: onDoubleClick,
	    style: eventStyle,
	    onKeyPress: onKeyPress,
	    title: tooltip ? (typeof label === 'string' ? label + ': ' : '') + tooltip : undefined,
	    className: (0, _clsx$4.default)(isBackgroundEvent ? 'rbc-background-event' : 'rbc-event', className, userProps.className, {
	      'rbc-selected': selected,
	      'rbc-event-continues-earlier': continuesPrior,
	      'rbc-event-continues-later': continuesAfter
	    })
	  }, inner));
	}
	var _default$8 = TimeGridEvent;
	TimeGridEvent$1.default = _default$8;

	var DayColumnWrapper$1 = {};

	var _interopRequireDefault$8 = interopRequireDefaultExports.default;
	Object.defineProperty(DayColumnWrapper$1, "__esModule", {
	  value: true
	});
	DayColumnWrapper$1.default = void 0;
	var _react$8 = _interopRequireDefault$8(React$1);
	var DayColumnWrapper = function DayColumnWrapper(_ref) {
	  var children = _ref.children,
	    className = _ref.className,
	    style = _ref.style,
	    innerRef = _ref.innerRef;
	  return /*#__PURE__*/_react$8.default.createElement("div", {
	    className: className,
	    style: style,
	    ref: innerRef
	  }, children);
	};
	var _default$7 = /*#__PURE__*/_react$8.default.forwardRef(function (props, ref) {
	  return /*#__PURE__*/_react$8.default.createElement(DayColumnWrapper, Object.assign({}, props, {
	    innerRef: ref
	  }));
	});
	DayColumnWrapper$1.default = _default$7;

	var _interopRequireDefault$7 = interopRequireDefaultExports.default;
	var _interopRequireWildcard$3 = interopRequireWildcardExports.default;
	Object.defineProperty(DayColumn$1, "__esModule", {
	  value: true
	});
	DayColumn$1.default = void 0;
	var _objectWithoutProperties2$2 = _interopRequireDefault$7(objectWithoutPropertiesExports);
	var _objectSpread2$1 = _interopRequireDefault$7(objectSpread2Exports);
	var _classCallCheck2$4 = _interopRequireDefault$7(classCallCheckExports);
	var _createClass2$4 = _interopRequireDefault$7(createClassExports);
	var _assertThisInitialized2 = _interopRequireDefault$7(assertThisInitializedExports);
	var _inherits2$4 = _interopRequireDefault$7(inheritsExports);
	var _createSuper2$4 = _interopRequireDefault$7(createSuperExports);
	var _react$7 = _interopRequireWildcard$3(React$1);
	var _clsx$3 = _interopRequireDefault$7(require$$9$1);
	var _Selection = _interopRequireWildcard$3(Selection$1);
	var TimeSlotUtils = _interopRequireWildcard$3(TimeSlots);
	var _selection$1 = selection;
	var _helpers$2 = helpers;
	var DayEventLayout = _interopRequireWildcard$3(DayEventLayout$1);
	var _TimeSlotGroup$1 = _interopRequireDefault$7(TimeSlotGroup$1);
	var _TimeGridEvent = _interopRequireDefault$7(TimeGridEvent$1);
	var _DayColumnWrapper = _interopRequireDefault$7(DayColumnWrapper$1);
	var _excluded$8 = ["dayProp"],
	  _excluded2 = ["eventContainerWrapper"];
	var DayColumn = /*#__PURE__*/function (_React$Component) {
	  (0, _inherits2$4.default)(DayColumn, _React$Component);
	  var _super = (0, _createSuper2$4.default)(DayColumn);
	  function DayColumn() {
	    var _this;
	    (0, _classCallCheck2$4.default)(this, DayColumn);
	    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
	      _args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(_args));
	    _this.state = {
	      selecting: false,
	      timeIndicatorPosition: null
	    };
	    _this.intervalTriggered = false;
	    _this.renderEvents = function (_ref) {
	      var events = _ref.events,
	        isBackgroundEvent = _ref.isBackgroundEvent;
	      var _this$props = _this.props,
	        rtl = _this$props.rtl,
	        selected = _this$props.selected,
	        accessors = _this$props.accessors,
	        localizer = _this$props.localizer,
	        getters = _this$props.getters,
	        components = _this$props.components,
	        step = _this$props.step,
	        timeslots = _this$props.timeslots,
	        dayLayoutAlgorithm = _this$props.dayLayoutAlgorithm,
	        resizable = _this$props.resizable;
	      var _assertThisInitialize = (0, _assertThisInitialized2.default)(_this),
	        slotMetrics = _assertThisInitialize.slotMetrics;
	      var messages = localizer.messages;
	      var styledEvents = DayEventLayout.getStyledEvents({
	        events: events,
	        accessors: accessors,
	        slotMetrics: slotMetrics,
	        minimumStartDifference: Math.ceil(step * timeslots / 2),
	        dayLayoutAlgorithm: dayLayoutAlgorithm
	      });
	      return styledEvents.map(function (_ref2, idx) {
	        var event = _ref2.event,
	          style = _ref2.style;
	        var end = accessors.end(event);
	        var start = accessors.start(event);
	        var format = 'eventTimeRangeFormat';
	        var label;
	        var startsBeforeDay = slotMetrics.startsBeforeDay(start);
	        var startsAfterDay = slotMetrics.startsAfterDay(end);
	        if (startsBeforeDay) format = 'eventTimeRangeEndFormat';else if (startsAfterDay) format = 'eventTimeRangeStartFormat';
	        if (startsBeforeDay && startsAfterDay) label = messages.allDay;else label = localizer.format({
	          start: start,
	          end: end
	        }, format);
	        var continuesPrior = startsBeforeDay || slotMetrics.startsBefore(start);
	        var continuesAfter = startsAfterDay || slotMetrics.startsAfter(end);
	        return /*#__PURE__*/_react$7.default.createElement(_TimeGridEvent.default, {
	          style: style,
	          event: event,
	          label: label,
	          key: 'evt_' + idx,
	          getters: getters,
	          rtl: rtl,
	          components: components,
	          continuesPrior: continuesPrior,
	          continuesAfter: continuesAfter,
	          accessors: accessors,
	          resource: _this.props.resource,
	          selected: (0, _selection$1.isSelected)(event, selected),
	          onClick: function onClick(e) {
	            return _this._select((0, _objectSpread2$1.default)((0, _objectSpread2$1.default)({}, event), {}, {
	              sourceResource: _this.props.resource
	            }), e);
	          },
	          onDoubleClick: function onDoubleClick(e) {
	            return _this._doubleClick(event, e);
	          },
	          isBackgroundEvent: isBackgroundEvent,
	          onKeyPress: function onKeyPress(e) {
	            return _this._keyPress(event, e);
	          },
	          resizable: resizable
	        });
	      });
	    };
	    _this._selectable = function () {
	      var node = _this.containerRef.current;
	      var _this$props2 = _this.props,
	        longPressThreshold = _this$props2.longPressThreshold,
	        localizer = _this$props2.localizer;
	      var selector = _this._selector = new _Selection.default(function () {
	        return node;
	      }, {
	        longPressThreshold: longPressThreshold
	      });
	      var maybeSelect = function maybeSelect(box) {
	        var onSelecting = _this.props.onSelecting;
	        var current = _this.state || {};
	        var state = selectionState(box);
	        var start = state.startDate,
	          end = state.endDate;
	        if (onSelecting) {
	          if (localizer.eq(current.startDate, start, 'minutes') && localizer.eq(current.endDate, end, 'minutes') || onSelecting({
	            start: start,
	            end: end,
	            resourceId: _this.props.resource
	          }) === false) return;
	        }
	        if (_this.state.start !== state.start || _this.state.end !== state.end || _this.state.selecting !== state.selecting) {
	          _this.setState(state);
	        }
	      };
	      var selectionState = function selectionState(point) {
	        var currentSlot = _this.slotMetrics.closestSlotFromPoint(point, (0, _Selection.getBoundsForNode)(node));
	        if (!_this.state.selecting) {
	          _this._initialSlot = currentSlot;
	        }
	        var initialSlot = _this._initialSlot;
	        if (localizer.lte(initialSlot, currentSlot)) {
	          currentSlot = _this.slotMetrics.nextSlot(currentSlot);
	        } else if (localizer.gt(initialSlot, currentSlot)) {
	          initialSlot = _this.slotMetrics.nextSlot(initialSlot);
	        }
	        var selectRange = _this.slotMetrics.getRange(localizer.min(initialSlot, currentSlot), localizer.max(initialSlot, currentSlot));
	        return (0, _objectSpread2$1.default)((0, _objectSpread2$1.default)({}, selectRange), {}, {
	          selecting: true,
	          top: "".concat(selectRange.top, "%"),
	          height: "".concat(selectRange.height, "%")
	        });
	      };
	      var selectorClicksHandler = function selectorClicksHandler(box, actionType) {
	        if (!(0, _Selection.isEvent)(_this.containerRef.current, box)) {
	          var _selectionState = selectionState(box),
	            startDate = _selectionState.startDate,
	            endDate = _selectionState.endDate;
	          _this._selectSlot({
	            startDate: startDate,
	            endDate: endDate,
	            action: actionType,
	            box: box
	          });
	        }
	        _this.setState({
	          selecting: false
	        });
	      };
	      selector.on('selecting', maybeSelect);
	      selector.on('selectStart', maybeSelect);
	      selector.on('beforeSelect', function (box) {
	        if (_this.props.selectable !== 'ignoreEvents') return;
	        return !(0, _Selection.isEvent)(_this.containerRef.current, box);
	      });
	      selector.on('click', function (box) {
	        return selectorClicksHandler(box, 'click');
	      });
	      selector.on('doubleClick', function (box) {
	        return selectorClicksHandler(box, 'doubleClick');
	      });
	      selector.on('select', function (bounds) {
	        if (_this.state.selecting) {
	          _this._selectSlot((0, _objectSpread2$1.default)((0, _objectSpread2$1.default)({}, _this.state), {}, {
	            action: 'select',
	            bounds: bounds
	          }));
	          _this.setState({
	            selecting: false
	          });
	        }
	      });
	      selector.on('reset', function () {
	        if (_this.state.selecting) {
	          _this.setState({
	            selecting: false
	          });
	        }
	      });
	    };
	    _this._teardownSelectable = function () {
	      if (!_this._selector) return;
	      _this._selector.teardown();
	      _this._selector = null;
	    };
	    _this._selectSlot = function (_ref3) {
	      var startDate = _ref3.startDate,
	        endDate = _ref3.endDate,
	        action = _ref3.action,
	        bounds = _ref3.bounds,
	        box = _ref3.box;
	      var current = startDate,
	        slots = [];
	      while (_this.props.localizer.lte(current, endDate)) {
	        slots.push(current);
	        current = new Date(+current + _this.props.step * 60 * 1000); // using Date ensures not to create an endless loop the day DST begins
	      }

	      (0, _helpers$2.notify)(_this.props.onSelectSlot, {
	        slots: slots,
	        start: startDate,
	        end: endDate,
	        resourceId: _this.props.resource,
	        action: action,
	        bounds: bounds,
	        box: box
	      });
	    };
	    _this._select = function () {
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	      (0, _helpers$2.notify)(_this.props.onSelectEvent, args);
	    };
	    _this._doubleClick = function () {
	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }
	      (0, _helpers$2.notify)(_this.props.onDoubleClickEvent, args);
	    };
	    _this._keyPress = function () {
	      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	        args[_key4] = arguments[_key4];
	      }
	      (0, _helpers$2.notify)(_this.props.onKeyPressEvent, args);
	    };
	    _this.slotMetrics = TimeSlotUtils.getSlotMetrics(_this.props);
	    _this.containerRef = /*#__PURE__*/(0, _react$7.createRef)();
	    return _this;
	  }
	  (0, _createClass2$4.default)(DayColumn, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      this.props.selectable && this._selectable();
	      if (this.props.isNow) {
	        this.setTimeIndicatorPositionUpdateInterval();
	      }
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      this._teardownSelectable();
	      this.clearTimeIndicatorInterval();
	    }
	  }, {
	    key: "UNSAFE_componentWillReceiveProps",
	    value: function UNSAFE_componentWillReceiveProps(nextProps) {
	      if (nextProps.selectable && !this.props.selectable) this._selectable();
	      if (!nextProps.selectable && this.props.selectable) this._teardownSelectable();
	      this.slotMetrics = this.slotMetrics.update(nextProps);
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate(prevProps, prevState) {
	      var _this$props3 = this.props,
	        getNow = _this$props3.getNow,
	        isNow = _this$props3.isNow,
	        localizer = _this$props3.localizer,
	        date = _this$props3.date,
	        min = _this$props3.min,
	        max = _this$props3.max;
	      var getNowChanged = localizer.neq(prevProps.getNow(), getNow(), 'minutes');
	      if (prevProps.isNow !== isNow || getNowChanged) {
	        this.clearTimeIndicatorInterval();
	        if (isNow) {
	          var tail = !getNowChanged && localizer.eq(prevProps.date, date, 'minutes') && prevState.timeIndicatorPosition === this.state.timeIndicatorPosition;
	          this.setTimeIndicatorPositionUpdateInterval(tail);
	        }
	      } else if (isNow && (localizer.neq(prevProps.min, min, 'minutes') || localizer.neq(prevProps.max, max, 'minutes'))) {
	        this.positionTimeIndicator();
	      }
	    }

	    /**
	     * @param tail {Boolean} - whether `positionTimeIndicator` call should be
	     *   deferred or called upon setting interval (`true` - if deferred);
	     */
	  }, {
	    key: "setTimeIndicatorPositionUpdateInterval",
	    value: function setTimeIndicatorPositionUpdateInterval() {
	      var _this2 = this;
	      var tail = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	      if (!this.intervalTriggered && !tail) {
	        this.positionTimeIndicator();
	      }
	      this._timeIndicatorTimeout = window.setTimeout(function () {
	        _this2.intervalTriggered = true;
	        _this2.positionTimeIndicator();
	        _this2.setTimeIndicatorPositionUpdateInterval();
	      }, 60000);
	    }
	  }, {
	    key: "clearTimeIndicatorInterval",
	    value: function clearTimeIndicatorInterval() {
	      this.intervalTriggered = false;
	      window.clearTimeout(this._timeIndicatorTimeout);
	    }
	  }, {
	    key: "positionTimeIndicator",
	    value: function positionTimeIndicator() {
	      var _this$props4 = this.props,
	        min = _this$props4.min,
	        max = _this$props4.max,
	        getNow = _this$props4.getNow;
	      var current = getNow();
	      if (current >= min && current <= max) {
	        var top = this.slotMetrics.getCurrentTimePosition(current);
	        this.intervalTriggered = true;
	        this.setState({
	          timeIndicatorPosition: top
	        });
	      } else {
	        this.clearTimeIndicatorInterval();
	      }
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this$props5 = this.props,
	        date = _this$props5.date,
	        max = _this$props5.max,
	        rtl = _this$props5.rtl,
	        isNow = _this$props5.isNow,
	        resource = _this$props5.resource,
	        accessors = _this$props5.accessors,
	        localizer = _this$props5.localizer,
	        _this$props5$getters = _this$props5.getters,
	        dayProp = _this$props5$getters.dayProp,
	        getters = (0, _objectWithoutProperties2$2.default)(_this$props5$getters, _excluded$8),
	        _this$props5$componen = _this$props5.components,
	        EventContainer = _this$props5$componen.eventContainerWrapper,
	        components = (0, _objectWithoutProperties2$2.default)(_this$props5$componen, _excluded2);
	      var slotMetrics = this.slotMetrics;
	      var _this$state = this.state,
	        selecting = _this$state.selecting,
	        top = _this$state.top,
	        height = _this$state.height,
	        startDate = _this$state.startDate,
	        endDate = _this$state.endDate;
	      var selectDates = {
	        start: startDate,
	        end: endDate
	      };
	      var _dayProp = dayProp(max),
	        className = _dayProp.className,
	        style = _dayProp.style;
	      var DayColumnWrapperComponent = components.dayColumnWrapper || _DayColumnWrapper.default;
	      return /*#__PURE__*/_react$7.default.createElement(DayColumnWrapperComponent, {
	        ref: this.containerRef,
	        date: date,
	        style: style,
	        className: (0, _clsx$3.default)(className, 'rbc-day-slot', 'rbc-time-column', isNow && 'rbc-now', isNow && 'rbc-today',
	        // WHY
	        selecting && 'rbc-slot-selecting'),
	        slotMetrics: slotMetrics
	      }, slotMetrics.groups.map(function (grp, idx) {
	        return /*#__PURE__*/_react$7.default.createElement(_TimeSlotGroup$1.default, {
	          key: idx,
	          group: grp,
	          resource: resource,
	          getters: getters,
	          components: components
	        });
	      }), /*#__PURE__*/_react$7.default.createElement(EventContainer, {
	        localizer: localizer,
	        resource: resource,
	        accessors: accessors,
	        getters: getters,
	        components: components,
	        slotMetrics: slotMetrics
	      }, /*#__PURE__*/_react$7.default.createElement("div", {
	        className: (0, _clsx$3.default)('rbc-events-container', rtl && 'rtl')
	      }, this.renderEvents({
	        events: this.props.backgroundEvents,
	        isBackgroundEvent: true
	      }), this.renderEvents({
	        events: this.props.events
	      }))), selecting && /*#__PURE__*/_react$7.default.createElement("div", {
	        className: "rbc-slot-selection",
	        style: {
	          top: top,
	          height: height
	        }
	      }, /*#__PURE__*/_react$7.default.createElement("span", null, localizer.format(selectDates, 'selectRangeFormat'))), isNow && this.intervalTriggered && /*#__PURE__*/_react$7.default.createElement("div", {
	        className: "rbc-current-time-indicator",
	        style: {
	          top: "".concat(this.state.timeIndicatorPosition, "%")
	        }
	      }));
	    }
	  }]);
	  return DayColumn;
	}(_react$7.default.Component);
	DayColumn.defaultProps = {
	  dragThroughEvents: true,
	  timeslots: 2
	};
	var _default$6 = DayColumn;
	DayColumn$1.default = _default$6;

	var TimeGutter$1 = {};

	var _interopRequireWildcard$2 = interopRequireWildcardExports.default;
	var _interopRequireDefault$6 = interopRequireDefaultExports.default;
	Object.defineProperty(TimeGutter$1, "__esModule", {
	  value: true
	});
	TimeGutter$1.default = void 0;
	var _slicedToArray2$2 = _interopRequireDefault$6(slicedToArrayExports);
	var _react$6 = _interopRequireWildcard$2(React$1);
	var _clsx$2 = _interopRequireDefault$6(require$$9$1);
	var _TimeSlots = TimeSlots;
	var _TimeSlotGroup = _interopRequireDefault$6(TimeSlotGroup$1);
	/**
	 * Since the TimeGutter only displays the 'times' of slots in a day, and is separate
	 * from the Day Columns themselves, we check to see if the range contains an offset difference
	 * and, if so, change the beginning and end 'date' by a day to properly display the slots times
	 * used.
	 */
	function adjustForDST(_ref) {
	  var min = _ref.min,
	    max = _ref.max,
	    localizer = _ref.localizer;
	  if (localizer.getTimezoneOffset(min) !== localizer.getTimezoneOffset(max)) {
	    return {
	      start: localizer.add(min, -1, 'day'),
	      end: localizer.add(max, -1, 'day')
	    };
	  }
	  return {
	    start: min,
	    end: max
	  };
	}
	var TimeGutter = function TimeGutter(_ref2) {
	  var min = _ref2.min,
	    max = _ref2.max,
	    timeslots = _ref2.timeslots,
	    step = _ref2.step,
	    localizer = _ref2.localizer,
	    getNow = _ref2.getNow,
	    resource = _ref2.resource,
	    components = _ref2.components,
	    getters = _ref2.getters,
	    gutterRef = _ref2.gutterRef;
	  var TimeGutterWrapper = components.timeGutterWrapper;
	  var _useMemo = (0, _react$6.useMemo)(function () {
	      return adjustForDST({
	        min: min,
	        max: max,
	        localizer: localizer
	      });
	    },
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	    [min === null || min === void 0 ? void 0 : min.toISOString(), max === null || max === void 0 ? void 0 : max.toISOString(), localizer]),
	    start = _useMemo.start,
	    end = _useMemo.end;
	  var _useState = (0, _react$6.useState)((0, _TimeSlots.getSlotMetrics)({
	      min: start,
	      max: end,
	      timeslots: timeslots,
	      step: step,
	      localizer: localizer
	    })),
	    _useState2 = (0, _slicedToArray2$2.default)(_useState, 2),
	    slotMetrics = _useState2[0],
	    setSlotMetrics = _useState2[1];
	  (0, _react$6.useEffect)(function () {
	    if (slotMetrics) {
	      setSlotMetrics(slotMetrics.update({
	        min: start,
	        max: end,
	        timeslots: timeslots,
	        step: step,
	        localizer: localizer
	      }));
	    }
	    /**
	     * We don't want this to fire when slotMetrics is updated as it would recursively bomb
	     */
	    // eslint-disable-next-line react-hooks/exhaustive-deps
	  }, [start === null || start === void 0 ? void 0 : start.toISOString(), end === null || end === void 0 ? void 0 : end.toISOString(), timeslots, step]);
	  var renderSlot = (0, _react$6.useCallback)(function (value, idx) {
	    if (idx) return null; // don't return the first (0) idx

	    var isNow = slotMetrics.dateIsInGroup(getNow(), idx);
	    return /*#__PURE__*/_react$6.default.createElement("span", {
	      className: (0, _clsx$2.default)('rbc-label', isNow && 'rbc-now')
	    }, localizer.format(value, 'timeGutterFormat'));
	  }, [slotMetrics, localizer, getNow]);
	  return /*#__PURE__*/_react$6.default.createElement(TimeGutterWrapper, {
	    slotMetrics: slotMetrics
	  }, /*#__PURE__*/_react$6.default.createElement("div", {
	    className: "rbc-time-gutter rbc-time-column",
	    ref: gutterRef
	  }, slotMetrics.groups.map(function (grp, idx) {
	    return /*#__PURE__*/_react$6.default.createElement(_TimeSlotGroup.default, {
	      key: idx,
	      group: grp,
	      resource: resource,
	      components: components,
	      renderSlot: renderSlot,
	      getters: getters
	    });
	  })));
	};
	var _default$5 = /*#__PURE__*/_react$6.default.forwardRef(function (props, ref) {
	  return /*#__PURE__*/_react$6.default.createElement(TimeGutter, Object.assign({
	    gutterRef: ref
	  }, props));
	});
	TimeGutter$1.default = _default$5;

	var TimeGridHeader$1 = {};

	var require$$6 = /*@__PURE__*/getAugmentedNamespace(scrollbarSize$1);

	var ResourceHeader$1 = {};

	var _interopRequireDefault$5 = interopRequireDefaultExports.default;
	Object.defineProperty(ResourceHeader$1, "__esModule", {
	  value: true
	});
	ResourceHeader$1.default = void 0;
	var _react$5 = _interopRequireDefault$5(React$1);
	var ResourceHeader = function ResourceHeader(_ref) {
	  var label = _ref.label;
	  return /*#__PURE__*/_react$5.default.createElement(_react$5.default.Fragment, null, label);
	};
	var _default$4 = ResourceHeader;
	ResourceHeader$1.default = _default$4;

	var _interopRequireDefault$4 = interopRequireDefaultExports.default;
	Object.defineProperty(TimeGridHeader$1, "__esModule", {
	  value: true
	});
	TimeGridHeader$1.default = void 0;
	var _slicedToArray2$1 = _interopRequireDefault$4(slicedToArrayExports);
	var _classCallCheck2$3 = _interopRequireDefault$4(classCallCheckExports);
	var _createClass2$3 = _interopRequireDefault$4(createClassExports);
	var _inherits2$3 = _interopRequireDefault$4(inheritsExports);
	var _createSuper2$3 = _interopRequireDefault$4(createSuperExports);
	var _clsx$1 = _interopRequireDefault$4(require$$9$1);
	var _scrollbarSize$1 = _interopRequireDefault$4(require$$6);
	var _react$4 = _interopRequireDefault$4(React$1);
	var _DateContentRow = _interopRequireDefault$4(DateContentRow$1);
	var _Header = _interopRequireDefault$4(Header$1);
	var _ResourceHeader = _interopRequireDefault$4(ResourceHeader$1);
	var _helpers$1 = helpers;
	var TimeGridHeader = /*#__PURE__*/function (_React$Component) {
	  (0, _inherits2$3.default)(TimeGridHeader, _React$Component);
	  var _super = (0, _createSuper2$3.default)(TimeGridHeader);
	  function TimeGridHeader() {
	    var _this;
	    (0, _classCallCheck2$3.default)(this, TimeGridHeader);
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    _this = _super.call.apply(_super, [this].concat(args));
	    _this.handleHeaderClick = function (date, view, e) {
	      e.preventDefault();
	      (0, _helpers$1.notify)(_this.props.onDrillDown, [date, view]);
	    };
	    _this.renderRow = function (resource) {
	      var _this$props = _this.props,
	        events = _this$props.events,
	        rtl = _this$props.rtl,
	        selectable = _this$props.selectable,
	        getNow = _this$props.getNow,
	        range = _this$props.range,
	        getters = _this$props.getters,
	        localizer = _this$props.localizer,
	        accessors = _this$props.accessors,
	        components = _this$props.components,
	        resizable = _this$props.resizable;
	      var resourceId = accessors.resourceId(resource);
	      var eventsToDisplay = resource ? events.filter(function (event) {
	        return accessors.resource(event) === resourceId;
	      }) : events;
	      return /*#__PURE__*/_react$4.default.createElement(_DateContentRow.default, {
	        isAllDay: true,
	        rtl: rtl,
	        getNow: getNow,
	        minRows: 2
	        // Add +1 to include showMore button row in the row limit
	        ,
	        maxRows: _this.props.allDayMaxRows + 1,
	        range: range,
	        events: eventsToDisplay,
	        resourceId: resourceId,
	        className: "rbc-allday-cell",
	        selectable: selectable,
	        selected: _this.props.selected,
	        components: components,
	        accessors: accessors,
	        getters: getters,
	        localizer: localizer,
	        onSelect: _this.props.onSelectEvent,
	        onShowMore: _this.props.onShowMore,
	        onDoubleClick: _this.props.onDoubleClickEvent,
	        onKeyPress: _this.props.onKeyPressEvent,
	        onSelectSlot: _this.props.onSelectSlot,
	        longPressThreshold: _this.props.longPressThreshold,
	        resizable: resizable
	      });
	    };
	    return _this;
	  }
	  (0, _createClass2$3.default)(TimeGridHeader, [{
	    key: "renderHeaderCells",
	    value: function renderHeaderCells(range) {
	      var _this2 = this;
	      var _this$props2 = this.props,
	        localizer = _this$props2.localizer,
	        getDrilldownView = _this$props2.getDrilldownView,
	        getNow = _this$props2.getNow,
	        dayProp = _this$props2.getters.dayProp,
	        _this$props2$componen = _this$props2.components.header,
	        HeaderComponent = _this$props2$componen === void 0 ? _Header.default : _this$props2$componen;
	      var today = getNow();
	      return range.map(function (date, i) {
	        var drilldownView = getDrilldownView(date);
	        var label = localizer.format(date, 'dayFormat');
	        var _dayProp = dayProp(date),
	          className = _dayProp.className,
	          style = _dayProp.style;
	        var header = /*#__PURE__*/_react$4.default.createElement(HeaderComponent, {
	          date: date,
	          label: label,
	          localizer: localizer
	        });
	        return /*#__PURE__*/_react$4.default.createElement("div", {
	          key: i,
	          style: style,
	          className: (0, _clsx$1.default)('rbc-header', className, localizer.isSameDate(date, today) && 'rbc-today')
	        }, drilldownView ? /*#__PURE__*/_react$4.default.createElement("button", {
	          type: "button",
	          className: "rbc-button-link",
	          onClick: function onClick(e) {
	            return _this2.handleHeaderClick(date, drilldownView, e);
	          }
	        }, header) : /*#__PURE__*/_react$4.default.createElement("span", null, header));
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this3 = this;
	      var _this$props3 = this.props,
	        width = _this$props3.width,
	        rtl = _this$props3.rtl,
	        resources = _this$props3.resources,
	        range = _this$props3.range,
	        events = _this$props3.events,
	        getNow = _this$props3.getNow,
	        accessors = _this$props3.accessors,
	        selectable = _this$props3.selectable,
	        components = _this$props3.components,
	        getters = _this$props3.getters,
	        scrollRef = _this$props3.scrollRef,
	        localizer = _this$props3.localizer,
	        isOverflowing = _this$props3.isOverflowing,
	        _this$props3$componen = _this$props3.components,
	        TimeGutterHeader = _this$props3$componen.timeGutterHeader,
	        _this$props3$componen2 = _this$props3$componen.resourceHeader,
	        ResourceHeaderComponent = _this$props3$componen2 === void 0 ? _ResourceHeader.default : _this$props3$componen2,
	        resizable = _this$props3.resizable;
	      var style = {};
	      if (isOverflowing) {
	        style[rtl ? 'marginLeft' : 'marginRight'] = "".concat((0, _scrollbarSize$1.default)() - 1, "px");
	      }
	      var groupedEvents = resources.groupEvents(events);
	      return /*#__PURE__*/_react$4.default.createElement("div", {
	        style: style,
	        ref: scrollRef,
	        className: (0, _clsx$1.default)('rbc-time-header', isOverflowing && 'rbc-overflowing')
	      }, /*#__PURE__*/_react$4.default.createElement("div", {
	        className: "rbc-label rbc-time-header-gutter",
	        style: {
	          width: width,
	          minWidth: width,
	          maxWidth: width
	        }
	      }, TimeGutterHeader && /*#__PURE__*/_react$4.default.createElement(TimeGutterHeader, null)), resources.map(function (_ref, idx) {
	        var _ref2 = (0, _slicedToArray2$1.default)(_ref, 2),
	          id = _ref2[0],
	          resource = _ref2[1];
	        return /*#__PURE__*/_react$4.default.createElement("div", {
	          className: "rbc-time-header-content",
	          key: id || idx
	        }, resource && /*#__PURE__*/_react$4.default.createElement("div", {
	          className: "rbc-row rbc-row-resource",
	          key: "resource_".concat(idx)
	        }, /*#__PURE__*/_react$4.default.createElement("div", {
	          className: "rbc-header"
	        }, /*#__PURE__*/_react$4.default.createElement(ResourceHeaderComponent, {
	          index: idx,
	          label: accessors.resourceTitle(resource),
	          resource: resource
	        }))), /*#__PURE__*/_react$4.default.createElement("div", {
	          className: "rbc-row rbc-time-header-cell".concat(range.length <= 1 ? ' rbc-time-header-cell-single-day' : '')
	        }, _this3.renderHeaderCells(range)), /*#__PURE__*/_react$4.default.createElement(_DateContentRow.default, {
	          isAllDay: true,
	          rtl: rtl,
	          getNow: getNow,
	          minRows: 2
	          // Add +1 to include showMore button row in the row limit
	          ,
	          maxRows: _this3.props.allDayMaxRows + 1,
	          range: range,
	          events: groupedEvents.get(id) || [],
	          resourceId: resource && id,
	          className: "rbc-allday-cell",
	          selectable: selectable,
	          selected: _this3.props.selected,
	          components: components,
	          accessors: accessors,
	          getters: getters,
	          localizer: localizer,
	          onSelect: _this3.props.onSelectEvent,
	          onShowMore: _this3.props.onShowMore,
	          onDoubleClick: _this3.props.onDoubleClickEvent,
	          onKeyPress: _this3.props.onKeyPressEvent,
	          onSelectSlot: _this3.props.onSelectSlot,
	          longPressThreshold: _this3.props.longPressThreshold,
	          resizable: resizable
	        }));
	      }));
	    }
	  }]);
	  return TimeGridHeader;
	}(_react$4.default.Component);
	var _default$3 = TimeGridHeader;
	TimeGridHeader$1.default = _default$3;

	var require$$5 = /*@__PURE__*/getAugmentedNamespace(width);

	var Resources$1 = {};

	Object.defineProperty(Resources$1, "__esModule", {
	  value: true
	});
	Resources$1.NONE = void 0;
	Resources$1.default = Resources;
	var NONE = {};
	Resources$1.NONE = NONE;
	function Resources(resources, accessors) {
	  return {
	    map: function map(fn) {
	      if (!resources) return [fn([NONE, null], 0)];
	      return resources.map(function (resource, idx) {
	        return fn([accessors.resourceId(resource), resource], idx);
	      });
	    },
	    groupEvents: function groupEvents(events) {
	      var eventsByResource = new Map();
	      if (!resources) {
	        // Return all events if resources are not provided
	        eventsByResource.set(NONE, events);
	        return eventsByResource;
	      }
	      events.forEach(function (event) {
	        var id = accessors.resource(event) || NONE;
	        if (Array.isArray(id)) {
	          id.forEach(function (item) {
	            var resourceEvents = eventsByResource.get(item) || [];
	            resourceEvents.push(event);
	            eventsByResource.set(item, resourceEvents);
	          });
	        } else {
	          var resourceEvents = eventsByResource.get(id) || [];
	          resourceEvents.push(event);
	          eventsByResource.set(id, resourceEvents);
	        }
	      });
	      return eventsByResource;
	    }
	  };
	}

	var _interopRequireWildcard$1 = interopRequireWildcardExports.default;
	var _interopRequireDefault$3 = interopRequireDefaultExports.default;
	Object.defineProperty(TimeGrid$1, "__esModule", {
	  value: true
	});
	TimeGrid$1.default = void 0;
	var _slicedToArray2 = _interopRequireDefault$3(slicedToArrayExports);
	var _objectSpread2 = _interopRequireDefault$3(objectSpread2Exports);
	var _classCallCheck2$2 = _interopRequireDefault$3(classCallCheckExports);
	var _createClass2$2 = _interopRequireDefault$3(createClassExports);
	var _inherits2$2 = _interopRequireDefault$3(inheritsExports);
	var _createSuper2$2 = _interopRequireDefault$3(createSuperExports);
	var _react$3 = _interopRequireWildcard$1(React$1);
	var _clsx = _interopRequireDefault$3(require$$9$1);
	var animationFrame = _interopRequireWildcard$1(require$$10);
	var _memoizeOne = _interopRequireDefault$3(require$$11);
	var _DayColumn = _interopRequireDefault$3(DayColumn$1);
	var _TimeGutter = _interopRequireDefault$3(TimeGutter$1);
	var _TimeGridHeader = _interopRequireDefault$3(TimeGridHeader$1);
	var _PopOverlay = _interopRequireDefault$3(PopOverlay$1);
	var _width$1 = _interopRequireDefault$3(require$$5);
	var _position = _interopRequireDefault$3(require$$17);
	var _constants$3 = constants;
	var _eventLevels$1 = eventLevels$1;
	var _helpers = helpers;
	var _Resources = _interopRequireDefault$3(Resources$1);
	var TimeGrid = /*#__PURE__*/function (_Component) {
	  (0, _inherits2$2.default)(TimeGrid, _Component);
	  var _super = (0, _createSuper2$2.default)(TimeGrid);
	  function TimeGrid(props) {
	    var _this;
	    (0, _classCallCheck2$2.default)(this, TimeGrid);
	    _this = _super.call(this, props);
	    _this.handleScroll = function (e) {
	      if (_this.scrollRef.current) {
	        _this.scrollRef.current.scrollLeft = e.target.scrollLeft;
	      }
	    };
	    _this.handleResize = function () {
	      animationFrame.cancel(_this.rafHandle);
	      _this.rafHandle = animationFrame.request(_this.checkOverflow);
	    };
	    _this.handleKeyPressEvent = function () {
	      _this.clearSelection();
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      (0, _helpers.notify)(_this.props.onKeyPressEvent, args);
	    };
	    _this.handleSelectEvent = function () {
	      //cancel any pending selections so only the event click goes through.
	      _this.clearSelection();
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	      (0, _helpers.notify)(_this.props.onSelectEvent, args);
	    };
	    _this.handleDoubleClickEvent = function () {
	      _this.clearSelection();
	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }
	      (0, _helpers.notify)(_this.props.onDoubleClickEvent, args);
	    };
	    _this.handleShowMore = function (events, date, cell, slot, target) {
	      var _this$props = _this.props,
	        popup = _this$props.popup,
	        onDrillDown = _this$props.onDrillDown,
	        onShowMore = _this$props.onShowMore,
	        getDrilldownView = _this$props.getDrilldownView,
	        doShowMoreDrillDown = _this$props.doShowMoreDrillDown;
	      _this.clearSelection();
	      if (popup) {
	        var position = (0, _position.default)(cell, _this.containerRef.current);
	        _this.setState({
	          overlay: {
	            date: date,
	            events: events,
	            position: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, position), {}, {
	              width: '200px'
	            }),
	            target: target
	          }
	        });
	      } else if (doShowMoreDrillDown) {
	        (0, _helpers.notify)(onDrillDown, [date, getDrilldownView(date) || _constants$3.views.DAY]);
	      }
	      (0, _helpers.notify)(onShowMore, [events, date, slot]);
	    };
	    _this.handleSelectAllDaySlot = function (slots, slotInfo) {
	      var onSelectSlot = _this.props.onSelectSlot;
	      var start = new Date(slots[0]);
	      var end = new Date(slots[slots.length - 1]);
	      end.setDate(slots[slots.length - 1].getDate() + 1);
	      (0, _helpers.notify)(onSelectSlot, {
	        slots: slots,
	        start: start,
	        end: end,
	        action: slotInfo.action,
	        resourceId: slotInfo.resourceId
	      });
	    };
	    _this.overlayDisplay = function () {
	      _this.setState({
	        overlay: null
	      });
	    };
	    _this.checkOverflow = function () {
	      if (_this._updatingOverflow) return;
	      var content = _this.contentRef.current;
	      var isOverflowing = content.scrollHeight > content.clientHeight;
	      if (_this.state.isOverflowing !== isOverflowing) {
	        _this._updatingOverflow = true;
	        _this.setState({
	          isOverflowing: isOverflowing
	        }, function () {
	          _this._updatingOverflow = false;
	        });
	      }
	    };
	    _this.memoizedResources = (0, _memoizeOne.default)(function (resources, accessors) {
	      return (0, _Resources.default)(resources, accessors);
	    });
	    _this.state = {
	      gutterWidth: undefined,
	      isOverflowing: null
	    };
	    _this.scrollRef = /*#__PURE__*/_react$3.default.createRef();
	    _this.contentRef = /*#__PURE__*/_react$3.default.createRef();
	    _this.containerRef = /*#__PURE__*/_react$3.default.createRef();
	    _this._scrollRatio = null;
	    _this.gutterRef = /*#__PURE__*/(0, _react$3.createRef)();
	    return _this;
	  }
	  (0, _createClass2$2.default)(TimeGrid, [{
	    key: "getSnapshotBeforeUpdate",
	    value: function getSnapshotBeforeUpdate() {
	      this.checkOverflow();
	      return null;
	    }
	  }, {
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      if (this.props.width == null) {
	        this.measureGutter();
	      }
	      this.calculateScroll();
	      this.applyScroll();
	      window.addEventListener('resize', this.handleResize);
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      window.removeEventListener('resize', this.handleResize);
	      animationFrame.cancel(this.rafHandle);
	      if (this.measureGutterAnimationFrameRequest) {
	        window.cancelAnimationFrame(this.measureGutterAnimationFrameRequest);
	      }
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate() {
	      this.applyScroll();
	    }
	  }, {
	    key: "renderEvents",
	    value: function renderEvents(range, events, backgroundEvents, now) {
	      var _this2 = this;
	      var _this$props2 = this.props,
	        min = _this$props2.min,
	        max = _this$props2.max,
	        components = _this$props2.components,
	        accessors = _this$props2.accessors,
	        localizer = _this$props2.localizer,
	        dayLayoutAlgorithm = _this$props2.dayLayoutAlgorithm;
	      var resources = this.memoizedResources(this.props.resources, accessors);
	      var groupedEvents = resources.groupEvents(events);
	      var groupedBackgroundEvents = resources.groupEvents(backgroundEvents);
	      return resources.map(function (_ref, i) {
	        var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
	          id = _ref2[0],
	          resource = _ref2[1];
	        return range.map(function (date, jj) {
	          var daysEvents = (groupedEvents.get(id) || []).filter(function (event) {
	            return localizer.inRange(date, accessors.start(event), accessors.end(event), 'day');
	          });
	          var daysBackgroundEvents = (groupedBackgroundEvents.get(id) || []).filter(function (event) {
	            return localizer.inRange(date, accessors.start(event), accessors.end(event), 'day');
	          });
	          return /*#__PURE__*/_react$3.default.createElement(_DayColumn.default, Object.assign({}, _this2.props, {
	            localizer: localizer,
	            min: localizer.merge(date, min),
	            max: localizer.merge(date, max),
	            resource: resource && id,
	            components: components,
	            isNow: localizer.isSameDate(date, now),
	            key: i + '-' + jj,
	            date: date,
	            events: daysEvents,
	            backgroundEvents: daysBackgroundEvents,
	            dayLayoutAlgorithm: dayLayoutAlgorithm
	          }));
	        });
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this$props$allDayMax;
	      var _this$props3 = this.props,
	        events = _this$props3.events,
	        backgroundEvents = _this$props3.backgroundEvents,
	        range = _this$props3.range,
	        width = _this$props3.width,
	        rtl = _this$props3.rtl,
	        selected = _this$props3.selected,
	        getNow = _this$props3.getNow,
	        resources = _this$props3.resources,
	        components = _this$props3.components,
	        accessors = _this$props3.accessors,
	        getters = _this$props3.getters,
	        localizer = _this$props3.localizer,
	        min = _this$props3.min,
	        max = _this$props3.max,
	        showMultiDayTimes = _this$props3.showMultiDayTimes,
	        longPressThreshold = _this$props3.longPressThreshold,
	        resizable = _this$props3.resizable;
	      width = width || this.state.gutterWidth;
	      var start = range[0],
	        end = range[range.length - 1];
	      this.slots = range.length;
	      var allDayEvents = [],
	        rangeEvents = [],
	        rangeBackgroundEvents = [];
	      events.forEach(function (event) {
	        if ((0, _eventLevels$1.inRange)(event, start, end, accessors, localizer)) {
	          var eStart = accessors.start(event),
	            eEnd = accessors.end(event);
	          if (accessors.allDay(event) || localizer.startAndEndAreDateOnly(eStart, eEnd) || !showMultiDayTimes && !localizer.isSameDate(eStart, eEnd)) {
	            allDayEvents.push(event);
	          } else {
	            rangeEvents.push(event);
	          }
	        }
	      });
	      backgroundEvents.forEach(function (event) {
	        if ((0, _eventLevels$1.inRange)(event, start, end, accessors, localizer)) {
	          rangeBackgroundEvents.push(event);
	        }
	      });
	      allDayEvents.sort(function (a, b) {
	        return (0, _eventLevels$1.sortEvents)(a, b, accessors, localizer);
	      });
	      return /*#__PURE__*/_react$3.default.createElement("div", {
	        className: (0, _clsx.default)('rbc-time-view', resources && 'rbc-time-view-resources'),
	        ref: this.containerRef
	      }, /*#__PURE__*/_react$3.default.createElement(_TimeGridHeader.default, {
	        range: range,
	        events: allDayEvents,
	        width: width,
	        rtl: rtl,
	        getNow: getNow,
	        localizer: localizer,
	        selected: selected,
	        allDayMaxRows: this.props.showAllEvents ? Infinity : (_this$props$allDayMax = this.props.allDayMaxRows) !== null && _this$props$allDayMax !== void 0 ? _this$props$allDayMax : Infinity,
	        resources: this.memoizedResources(resources, accessors),
	        selectable: this.props.selectable,
	        accessors: accessors,
	        getters: getters,
	        components: components,
	        scrollRef: this.scrollRef,
	        isOverflowing: this.state.isOverflowing,
	        longPressThreshold: longPressThreshold,
	        onSelectSlot: this.handleSelectAllDaySlot,
	        onSelectEvent: this.handleSelectEvent,
	        onShowMore: this.handleShowMore,
	        onDoubleClickEvent: this.props.onDoubleClickEvent,
	        onKeyPressEvent: this.props.onKeyPressEvent,
	        onDrillDown: this.props.onDrillDown,
	        getDrilldownView: this.props.getDrilldownView,
	        resizable: resizable
	      }), this.props.popup && this.renderOverlay(), /*#__PURE__*/_react$3.default.createElement("div", {
	        ref: this.contentRef,
	        className: "rbc-time-content",
	        onScroll: this.handleScroll
	      }, /*#__PURE__*/_react$3.default.createElement(_TimeGutter.default, {
	        date: start,
	        ref: this.gutterRef,
	        localizer: localizer,
	        min: localizer.merge(start, min),
	        max: localizer.merge(start, max),
	        step: this.props.step,
	        getNow: this.props.getNow,
	        timeslots: this.props.timeslots,
	        components: components,
	        className: "rbc-time-gutter",
	        getters: getters
	      }), this.renderEvents(range, rangeEvents, rangeBackgroundEvents, getNow())));
	    }
	  }, {
	    key: "renderOverlay",
	    value: function renderOverlay() {
	      var _this$state$overlay,
	        _this$state,
	        _this3 = this;
	      var overlay = (_this$state$overlay = (_this$state = this.state) === null || _this$state === void 0 ? void 0 : _this$state.overlay) !== null && _this$state$overlay !== void 0 ? _this$state$overlay : {};
	      var _this$props4 = this.props,
	        accessors = _this$props4.accessors,
	        localizer = _this$props4.localizer,
	        components = _this$props4.components,
	        getters = _this$props4.getters,
	        selected = _this$props4.selected,
	        popupOffset = _this$props4.popupOffset,
	        handleDragStart = _this$props4.handleDragStart;
	      var onHide = function onHide() {
	        return _this3.setState({
	          overlay: null
	        });
	      };
	      return /*#__PURE__*/_react$3.default.createElement(_PopOverlay.default, {
	        overlay: overlay,
	        accessors: accessors,
	        localizer: localizer,
	        components: components,
	        getters: getters,
	        selected: selected,
	        popupOffset: popupOffset,
	        ref: this.containerRef,
	        handleKeyPressEvent: this.handleKeyPressEvent,
	        handleSelectEvent: this.handleSelectEvent,
	        handleDoubleClickEvent: this.handleDoubleClickEvent,
	        handleDragStart: handleDragStart,
	        show: !!overlay.position,
	        overlayDisplay: this.overlayDisplay,
	        onHide: onHide
	      });
	    }
	  }, {
	    key: "clearSelection",
	    value: function clearSelection() {
	      clearTimeout(this._selectTimer);
	      this._pendingSelection = [];
	    }
	  }, {
	    key: "measureGutter",
	    value: function measureGutter() {
	      var _this4 = this;
	      if (this.measureGutterAnimationFrameRequest) {
	        window.cancelAnimationFrame(this.measureGutterAnimationFrameRequest);
	      }
	      this.measureGutterAnimationFrameRequest = window.requestAnimationFrame(function () {
	        var _this4$gutterRef;
	        var width = (_this4$gutterRef = _this4.gutterRef) !== null && _this4$gutterRef !== void 0 && _this4$gutterRef.current ? (0, _width$1.default)(_this4.gutterRef.current) : undefined;
	        if (width && _this4.state.gutterWidth !== width) {
	          _this4.setState({
	            gutterWidth: width
	          });
	        }
	      });
	    }
	  }, {
	    key: "applyScroll",
	    value: function applyScroll() {
	      // If auto-scroll is disabled, we don't actually apply the scroll
	      if (this._scrollRatio != null && this.props.enableAutoScroll === true) {
	        var content = this.contentRef.current;
	        content.scrollTop = content.scrollHeight * this._scrollRatio;
	        // Only do this once
	        this._scrollRatio = null;
	      }
	    }
	  }, {
	    key: "calculateScroll",
	    value: function calculateScroll() {
	      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
	      var min = props.min,
	        max = props.max,
	        scrollToTime = props.scrollToTime,
	        localizer = props.localizer;
	      var diffMillis = localizer.diff(localizer.merge(scrollToTime, min), scrollToTime, 'milliseconds');
	      var totalMillis = localizer.diff(min, max, 'milliseconds');
	      this._scrollRatio = diffMillis / totalMillis;
	    }
	  }]);
	  return TimeGrid;
	}(_react$3.Component);
	TimeGrid$1.default = TimeGrid;
	TimeGrid.defaultProps = {
	  step: 30,
	  timeslots: 2
	};

	var _interopRequireDefault$2 = interopRequireDefaultExports.default;
	Object.defineProperty(Week$1, "__esModule", {
	  value: true
	});
	var default_1$2 = Week$1.default = void 0;
	var _toArray2 = _interopRequireDefault$2(toArrayExports);
	var _objectWithoutProperties2$1 = _interopRequireDefault$2(objectWithoutPropertiesExports);
	var _classCallCheck2$1 = _interopRequireDefault$2(classCallCheckExports);
	var _createClass2$1 = _interopRequireDefault$2(createClassExports);
	var _inherits2$1 = _interopRequireDefault$2(inheritsExports);
	var _createSuper2$1 = _interopRequireDefault$2(createSuperExports);
	var _react$2 = _interopRequireDefault$2(React$1);
	var _constants$2 = constants;
	var _TimeGrid$1 = _interopRequireDefault$2(TimeGrid$1);
	var _excluded$7 = ["date", "localizer", "min", "max", "scrollToTime", "enableAutoScroll"];
	var Week = /*#__PURE__*/function (_React$Component) {
	  (0, _inherits2$1.default)(Week, _React$Component);
	  var _super = (0, _createSuper2$1.default)(Week);
	  function Week() {
	    (0, _classCallCheck2$1.default)(this, Week);
	    return _super.apply(this, arguments);
	  }
	  (0, _createClass2$1.default)(Week, [{
	    key: "render",
	    value: function render() {
	      /**
	       * This allows us to default min, max, and scrollToTime
	       * using our localizer. This is necessary until such time
	       * as TimeGrid is converted to a functional component.
	       */
	      var _this$props = this.props,
	        date = _this$props.date,
	        localizer = _this$props.localizer,
	        _this$props$min = _this$props.min,
	        min = _this$props$min === void 0 ? localizer.startOf(new Date(), 'day') : _this$props$min,
	        _this$props$max = _this$props.max,
	        max = _this$props$max === void 0 ? localizer.endOf(new Date(), 'day') : _this$props$max,
	        _this$props$scrollToT = _this$props.scrollToTime,
	        scrollToTime = _this$props$scrollToT === void 0 ? localizer.startOf(new Date(), 'day') : _this$props$scrollToT,
	        _this$props$enableAut = _this$props.enableAutoScroll,
	        enableAutoScroll = _this$props$enableAut === void 0 ? true : _this$props$enableAut,
	        props = (0, _objectWithoutProperties2$1.default)(_this$props, _excluded$7);
	      var range = Week.range(date, this.props);
	      return /*#__PURE__*/_react$2.default.createElement(_TimeGrid$1.default, Object.assign({}, props, {
	        range: range,
	        eventOffset: 15,
	        localizer: localizer,
	        min: min,
	        max: max,
	        scrollToTime: scrollToTime,
	        enableAutoScroll: enableAutoScroll
	      }));
	    }
	  }]);
	  return Week;
	}(_react$2.default.Component);
	Week.defaultProps = _TimeGrid$1.default.defaultProps;
	Week.navigate = function (date, action, _ref) {
	  var localizer = _ref.localizer;
	  switch (action) {
	    case _constants$2.navigate.PREVIOUS:
	      return localizer.add(date, -1, 'week');
	    case _constants$2.navigate.NEXT:
	      return localizer.add(date, 1, 'week');
	    default:
	      return date;
	  }
	};
	Week.range = function (date, _ref2) {
	  var localizer = _ref2.localizer;
	  var firstOfWeek = localizer.startOfWeek();
	  var start = localizer.startOf(date, 'week', firstOfWeek);
	  var end = localizer.endOf(date, 'week', firstOfWeek);
	  return localizer.range(start, end);
	};
	Week.title = function (date, _ref3) {
	  var localizer = _ref3.localizer;
	  var _Week$range = Week.range(date, {
	      localizer: localizer
	    }),
	    _Week$range2 = (0, _toArray2.default)(_Week$range),
	    start = _Week$range2[0],
	    rest = _Week$range2.slice(1);
	  return localizer.format({
	    start: start,
	    end: rest.pop()
	  }, 'dayRangeHeaderFormat');
	};
	var _default$2 = Week;
	default_1$2 = Week$1.default = _default$2;

	class MPAWeekBase extends default_1$2 {
	  render() {
	    const {
	      eventStore
	    } = this.props;
	    return wp.element.createElement("div", {
	      className: "mpa-timegrid-container mpa-timegrid-container__week"
	    }, wp.element.createElement(Preloader, {
	      loading: eventStore.loading,
	      isOverlay: false
	    }), super.render());
	  }
	}
	const MPAWeek = withEventStore(MPAWeekBase);

	var Day$1 = {};

	var _interopRequireDefault$1 = interopRequireDefaultExports.default;
	Object.defineProperty(Day$1, "__esModule", {
	  value: true
	});
	var default_1$1 = Day$1.default = void 0;
	var _objectWithoutProperties2 = _interopRequireDefault$1(objectWithoutPropertiesExports);
	var _classCallCheck2 = _interopRequireDefault$1(classCallCheckExports);
	var _createClass2 = _interopRequireDefault$1(createClassExports);
	var _inherits2 = _interopRequireDefault$1(inheritsExports);
	var _createSuper2 = _interopRequireDefault$1(createSuperExports);
	var _react$1 = _interopRequireDefault$1(React$1);
	var _constants$1 = constants;
	var _TimeGrid = _interopRequireDefault$1(TimeGrid$1);
	var _excluded$6 = ["date", "localizer", "min", "max", "scrollToTime", "enableAutoScroll"];
	var Day = /*#__PURE__*/function (_React$Component) {
	  (0, _inherits2.default)(Day, _React$Component);
	  var _super = (0, _createSuper2.default)(Day);
	  function Day() {
	    (0, _classCallCheck2.default)(this, Day);
	    return _super.apply(this, arguments);
	  }
	  (0, _createClass2.default)(Day, [{
	    key: "render",
	    value: function render() {
	      /**
	       * This allows us to default min, max, and scrollToTime
	       * using our localizer. This is necessary until such time
	       * as TODO: TimeGrid is converted to a functional component.
	       */
	      var _this$props = this.props,
	        date = _this$props.date,
	        localizer = _this$props.localizer,
	        _this$props$min = _this$props.min,
	        min = _this$props$min === void 0 ? localizer.startOf(new Date(), 'day') : _this$props$min,
	        _this$props$max = _this$props.max,
	        max = _this$props$max === void 0 ? localizer.endOf(new Date(), 'day') : _this$props$max,
	        _this$props$scrollToT = _this$props.scrollToTime,
	        scrollToTime = _this$props$scrollToT === void 0 ? localizer.startOf(new Date(), 'day') : _this$props$scrollToT,
	        _this$props$enableAut = _this$props.enableAutoScroll,
	        enableAutoScroll = _this$props$enableAut === void 0 ? true : _this$props$enableAut,
	        props = (0, _objectWithoutProperties2.default)(_this$props, _excluded$6);
	      var range = Day.range(date, {
	        localizer: localizer
	      });
	      return /*#__PURE__*/_react$1.default.createElement(_TimeGrid.default, Object.assign({}, props, {
	        range: range,
	        eventOffset: 10,
	        localizer: localizer,
	        min: min,
	        max: max,
	        scrollToTime: scrollToTime,
	        enableAutoScroll: enableAutoScroll
	      }));
	    }
	  }]);
	  return Day;
	}(_react$1.default.Component);
	Day.range = function (date, _ref) {
	  var localizer = _ref.localizer;
	  return [localizer.startOf(date, 'day')];
	};
	Day.navigate = function (date, action, _ref2) {
	  var localizer = _ref2.localizer;
	  switch (action) {
	    case _constants$1.navigate.PREVIOUS:
	      return localizer.add(date, -1, 'day');
	    case _constants$1.navigate.NEXT:
	      return localizer.add(date, 1, 'day');
	    default:
	      return date;
	  }
	};
	Day.title = function (date, _ref3) {
	  var localizer = _ref3.localizer;
	  return localizer.format(date, 'dayHeaderFormat');
	};
	var _default$1 = Day;
	default_1$1 = Day$1.default = _default$1;

	class MPADayBase extends default_1$1 {
	  render() {
	    const {
	      eventStore
	    } = this.props;
	    return wp.element.createElement("div", {
	      className: "mpa-timegrid-container mpa-timegrid-container__day"
	    }, wp.element.createElement(Preloader, {
	      loading: eventStore.loading,
	      isOverlay: false
	    }), super.render());
	  }
	}
	const MPADay = withEventStore(MPADayBase);

	var Agenda$1 = {};

	var require$$3 = /*@__PURE__*/getAugmentedNamespace(addClass$1);

	var require$$4 = /*@__PURE__*/getAugmentedNamespace(removeClass$1);

	var _interopRequireDefault = interopRequireDefaultExports.default;
	var _interopRequireWildcard = interopRequireWildcardExports.default;
	Object.defineProperty(Agenda$1, "__esModule", {
	  value: true
	});
	var default_1 = Agenda$1.default = void 0;
	var _react = _interopRequireWildcard(React$1);
	var _addClass = _interopRequireDefault(require$$3);
	var _removeClass = _interopRequireDefault(require$$4);
	var _width = _interopRequireDefault(require$$5);
	var _scrollbarSize = _interopRequireDefault(require$$6);
	var _constants = constants;
	var _eventLevels = eventLevels$1;
	var _selection = selection;
	function Agenda(_ref) {
	  var accessors = _ref.accessors,
	    components = _ref.components,
	    date = _ref.date,
	    events = _ref.events,
	    getters = _ref.getters,
	    length = _ref.length,
	    localizer = _ref.localizer,
	    onDoubleClickEvent = _ref.onDoubleClickEvent,
	    onSelectEvent = _ref.onSelectEvent,
	    selected = _ref.selected;
	  var headerRef = (0, _react.useRef)(null);
	  var dateColRef = (0, _react.useRef)(null);
	  var timeColRef = (0, _react.useRef)(null);
	  var contentRef = (0, _react.useRef)(null);
	  var tbodyRef = (0, _react.useRef)(null);
	  (0, _react.useEffect)(function () {
	    _adjustHeader();
	  });
	  var renderDay = function renderDay(day, events, dayKey) {
	    var Event = components.event,
	      AgendaDate = components.date;
	    events = events.filter(function (e) {
	      return (0, _eventLevels.inRange)(e, localizer.startOf(day, 'day'), localizer.endOf(day, 'day'), accessors, localizer);
	    });
	    return events.map(function (event, idx) {
	      var title = accessors.title(event);
	      var end = accessors.end(event);
	      var start = accessors.start(event);
	      var userProps = getters.eventProp(event, start, end, (0, _selection.isSelected)(event, selected));
	      var dateLabel = idx === 0 && localizer.format(day, 'agendaDateFormat');
	      var first = idx === 0 ? /*#__PURE__*/_react.default.createElement("td", {
	        rowSpan: events.length,
	        className: "rbc-agenda-date-cell"
	      }, AgendaDate ? /*#__PURE__*/_react.default.createElement(AgendaDate, {
	        day: day,
	        label: dateLabel
	      }) : dateLabel) : false;
	      return /*#__PURE__*/_react.default.createElement("tr", {
	        key: dayKey + '_' + idx,
	        className: userProps.className,
	        style: userProps.style
	      }, first, /*#__PURE__*/_react.default.createElement("td", {
	        className: "rbc-agenda-time-cell"
	      }, timeRangeLabel(day, event)), /*#__PURE__*/_react.default.createElement("td", {
	        className: "rbc-agenda-event-cell",
	        onClick: function onClick(e) {
	          return onSelectEvent && onSelectEvent(event, e);
	        },
	        onDoubleClick: function onDoubleClick(e) {
	          return onDoubleClickEvent && onDoubleClickEvent(event, e);
	        }
	      }, Event ? /*#__PURE__*/_react.default.createElement(Event, {
	        event: event,
	        title: title
	      }) : title));
	    }, []);
	  };
	  var timeRangeLabel = function timeRangeLabel(day, event) {
	    var labelClass = '',
	      TimeComponent = components.time,
	      label = localizer.messages.allDay;
	    var end = accessors.end(event);
	    var start = accessors.start(event);
	    if (!accessors.allDay(event)) {
	      if (localizer.eq(start, end)) {
	        label = localizer.format(start, 'agendaTimeFormat');
	      } else if (localizer.isSameDate(start, end)) {
	        label = localizer.format({
	          start: start,
	          end: end
	        }, 'agendaTimeRangeFormat');
	      } else if (localizer.isSameDate(day, start)) {
	        label = localizer.format(start, 'agendaTimeFormat');
	      } else if (localizer.isSameDate(day, end)) {
	        label = localizer.format(end, 'agendaTimeFormat');
	      }
	    }
	    if (localizer.gt(day, start, 'day')) labelClass = 'rbc-continues-prior';
	    if (localizer.lt(day, end, 'day')) labelClass += ' rbc-continues-after';
	    return /*#__PURE__*/_react.default.createElement("span", {
	      className: labelClass.trim()
	    }, TimeComponent ? /*#__PURE__*/_react.default.createElement(TimeComponent, {
	      event: event,
	      day: day,
	      label: label
	    }) : label);
	  };
	  var _adjustHeader = function _adjustHeader() {
	    if (!tbodyRef.current) return;
	    var header = headerRef.current;
	    var firstRow = tbodyRef.current.firstChild;
	    if (!firstRow) return;
	    var isOverflowing = contentRef.current.scrollHeight > contentRef.current.clientHeight;
	    var _widths = [];
	    var widths = _widths;
	    _widths = [(0, _width.default)(firstRow.children[0]), (0, _width.default)(firstRow.children[1])];
	    if (widths[0] !== _widths[0] || widths[1] !== _widths[1]) {
	      dateColRef.current.style.width = _widths[0] + 'px';
	      timeColRef.current.style.width = _widths[1] + 'px';
	    }
	    if (isOverflowing) {
	      (0, _addClass.default)(header, 'rbc-header-overflowing');
	      header.style.marginRight = (0, _scrollbarSize.default)() + 'px';
	    } else {
	      (0, _removeClass.default)(header, 'rbc-header-overflowing');
	    }
	  };
	  var messages = localizer.messages;
	  var end = localizer.add(date, length, 'day');
	  var range = localizer.range(date, end, 'day');
	  events = events.filter(function (event) {
	    return (0, _eventLevels.inRange)(event, localizer.startOf(date, 'day'), localizer.endOf(end, 'day'), accessors, localizer);
	  });
	  events.sort(function (a, b) {
	    return +accessors.start(a) - +accessors.start(b);
	  });
	  return /*#__PURE__*/_react.default.createElement("div", {
	    className: "rbc-agenda-view"
	  }, events.length !== 0 ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement("table", {
	    ref: headerRef,
	    className: "rbc-agenda-table"
	  }, /*#__PURE__*/_react.default.createElement("thead", null, /*#__PURE__*/_react.default.createElement("tr", null, /*#__PURE__*/_react.default.createElement("th", {
	    className: "rbc-header",
	    ref: dateColRef
	  }, messages.date), /*#__PURE__*/_react.default.createElement("th", {
	    className: "rbc-header",
	    ref: timeColRef
	  }, messages.time), /*#__PURE__*/_react.default.createElement("th", {
	    className: "rbc-header"
	  }, messages.event)))), /*#__PURE__*/_react.default.createElement("div", {
	    className: "rbc-agenda-content",
	    ref: contentRef
	  }, /*#__PURE__*/_react.default.createElement("table", {
	    className: "rbc-agenda-table"
	  }, /*#__PURE__*/_react.default.createElement("tbody", {
	    ref: tbodyRef
	  }, range.map(function (day, idx) {
	    return renderDay(day, events, idx);
	  }))))) : /*#__PURE__*/_react.default.createElement("span", {
	    className: "rbc-agenda-empty"
	  }, messages.noEventsInRange));
	}
	Agenda.defaultProps = {
	  length: 30
	};
	Agenda.range = function (start, _ref2) {
	  var _ref2$length = _ref2.length,
	    length = _ref2$length === void 0 ? Agenda.defaultProps.length : _ref2$length,
	    localizer = _ref2.localizer;
	  var end = localizer.add(start, length, 'day');
	  return {
	    start: start,
	    end: end
	  };
	};
	Agenda.navigate = function (date, action, _ref3) {
	  var _ref3$length = _ref3.length,
	    length = _ref3$length === void 0 ? Agenda.defaultProps.length : _ref3$length,
	    localizer = _ref3.localizer;
	  switch (action) {
	    case _constants.navigate.PREVIOUS:
	      return localizer.add(date, -length, 'day');
	    case _constants.navigate.NEXT:
	      return localizer.add(date, length, 'day');
	    default:
	      return date;
	  }
	};
	Agenda.title = function (start, _ref4) {
	  var _ref4$length = _ref4.length,
	    length = _ref4$length === void 0 ? Agenda.defaultProps.length : _ref4$length,
	    localizer = _ref4.localizer;
	  var end = localizer.add(start, length, 'day');
	  return localizer.format({
	    start: start,
	    end: end
	  }, 'agendaHeaderFormat');
	};
	var _default = Agenda;
	default_1 = Agenda$1.default = _default;

	const MPAAgenda = props => {
	  const {
	    eventStore
	  } = useStores();
	  return wp.element.createElement("div", {
	    className: "mpa-timegrid-container mpa-timegrid-container__agenda"
	  }, wp.element.createElement(Preloader, {
	    loading: eventStore.loading,
	    isOverlay: false
	  }), wp.element.createElement(default_1, props));
	};
	MPAAgenda.range = default_1.range;
	MPAAgenda.title = default_1.title;
	MPAAgenda.navigate = default_1.navigate;

	var VIEWS = {
	  month: MPAMonth,
	  week: MPAWeek,
	  day: MPADay,
	  agenda: MPAAgenda
	};

	class URLFiltersStore {
	  urlParams = {};
	  constructor(routerStore) {
	    this.routerStore = routerStore;
	    makeAutoObservable(this);
	    this.routerStore.subscribe(({
	      location
	    }) => {
	      this.urlParams = new URLSearchParams(this.routerStore.location.search);
	    });
	  }
	  setServices(services) {
	    services ? this.urlParams.set('services', services) : this.urlParams.delete('services');
	  }
	  setLocations(locations) {
	    locations ? this.urlParams.set('locations', locations) : this.urlParams.delete('locations');
	  }
	  setEmployees(employees) {
	    employees ? this.urlParams.set('employees', employees) : this.urlParams.delete('employees');
	  }
	  setStatuses(statuses) {
	    statuses ? this.urlParams.set('statuses', statuses) : this.urlParams.delete('statuses');
	  }
	  setView(view) {
	    this.urlParams.set('view', view);
	  }
	  setDate(date) {
	    this.urlParams.set('date', moment$1(date).format('YYYY-MM-DD'));
	  }
	  getStatuses() {
	    let statusesString = this.urlParams.get('statuses');
	    if (statusesString === null) {
	      statusesString = 'confirmed,pending';
	    }
	    return statusesString;
	  }
	  getEmployees() {
	    let employeesString = this.urlParams.get('employees');
	    if (employeesString === null) {
	      employeesString = '';
	    }
	    return employeesString;
	  }
	  getLocations() {
	    let locationsString = this.urlParams.get('locations');
	    if (locationsString === null) {
	      locationsString = '';
	    }
	    return locationsString;
	  }
	  getServices() {
	    let servicesString = this.urlParams.get('services');
	    if (servicesString === null) {
	      servicesString = '';
	    }
	    return servicesString;
	  }
	  getDate() {
	    const date = this.urlParams.get('date');
	    if (date === null) {
	      return moment$1().startOf('week').format('YYYY-MM-DD');
	    }
	    return date;
	  }
	  getView() {
	    let view = this.urlParams.get('view');
	    if (view === null || !VIEWS.hasOwnProperty(view)) {
	      view = 'week';
	    }
	    return view;
	  }
	  updateHistory() {
	    const nextRouterWithParam = `${this.routerStore.location.pathname}?${this.urlParams.toString()}`;
	    this.routerStore.push(nextRouterWithParam);
	  }
	}

	class CalendarStore {
	  _minTime = new Date(0, 0, 1, 8, 0);
	  _maxTime = new Date(0, 0, 1, 20, 0);
	  constructor(rootStore) {
	    this.rootStore = rootStore;
	    makeAutoObservable(this);
	  }
	  get minTime() {
	    return this._minTime;
	  }
	  get maxTime() {
	    return this._maxTime;
	  }
	  get start() {
	    const {
	      urlFiltersStore
	    } = this.rootStore;
	    const view = urlFiltersStore.getView();
	    const date = urlFiltersStore.getDate();
	    let startDate = moment$1(date);
	    switch (view) {
	      case 'month':
	        startDate = startDate.startOf('month');
	        break;
	      case 'week':
	        startDate = startDate.startOf('week');
	        break;
	    }
	    return startDate.format('YYYY-MM-DD');
	  }
	  get end() {
	    const {
	      urlFiltersStore
	    } = this.rootStore;
	    const view = urlFiltersStore.getView();
	    const date = urlFiltersStore.getDate();
	    let endDate = moment$1(date);
	    switch (view) {
	      case 'month':
	        endDate = endDate.endOf('month');
	        break;
	      case 'week':
	        endDate = endDate.endOf('week');
	        break;
	    }
	    return endDate.format('YYYY-MM-DD');
	  }
	  defineTimePeriod(events) {
	    const BASE_DATE = {
	      year: 0,
	      month: 0,
	      date: 1
	    };
	    let currentViewMinTime = moment$1(this._minTime).set(BASE_DATE);
	    let currentViewMaxTime = moment$1(this._maxTime).set(BASE_DATE);
	    events.forEach(event => {
	      const currentEventStartTime = moment$1(event.start).set(BASE_DATE);
	      const currentEventEndTime = moment$1(event.end).set(BASE_DATE);
	      if (currentEventStartTime.isBefore(currentViewMinTime)) {
	        currentViewMinTime.hour(currentEventStartTime.hour());
	        currentViewMinTime.minute(currentEventStartTime.minute());
	      }
	      if (currentEventEndTime.isAfter(currentViewMaxTime)) {
	        currentViewMaxTime.hour(currentEventEndTime.hour());
	        currentViewMaxTime.minute(currentEventEndTime.minute());
	      }
	    });
	    this._minTime = currentViewMinTime.toDate();
	    this._maxTime = currentViewMaxTime.toDate();
	  }
	}

	/**
	 * @param {Array} array
	 * @return {Array}
	 *
	 * @since 1.0
	 */

	/**
	 * @since 1.21.0
	 *
	 * Sorts an array alphabetically based on a specified key.
	 *
	 * @param {Array} array Array to be sorted
	 * @param {String} key Key to sort by
	 * @return {Array} Sorted array
	 */
	function mpa_array_sort_by_alphabetical_key(array, key) {
	  return [...array].sort((a, b) => {
	    const aValue = (a[key] || "").toLowerCase();
	    const bValue = (b[key] || "").toLowerCase();
	    return aValue.localeCompare(bValue);
	  });
	}

	/**
	 * @since 1.21.0
	 *
	 * Groups an array of objects based on a specified criterion.
	 *
	 * @param {Array} options - The array of objects to be grouped.
	 * @param {Function} getKey - A function that defines the grouping key for each element.
	 * Returns the key value as a string.
	 *
	 * @returns {Object} An object where keys are the results of the getKey function, and values are arrays of grouped elements.
	 */
	function mpa_array_group_by_key(options, getKey) {
	  return options.reduce((acc, item) => {
	    const key = String(getKey(item));
	    if (!acc.hasOwnProperty(key)) {
	      acc[key] = [];
	    }
	    acc[key].push(item);
	    return acc;
	  }, {});
	}

	var routes = {"/mpa/v1":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{namespace:{},context:{}}}]},"/mpa/v1/bookings":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{context:{},page:{},per_page:{},search:{},after:{},before:{},exclude:{},include:{},offset:{},order:{},orderby:{},filter:{}}}]},"/mpa/v1/bookings/(?P<id>[\\d]+)":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{id:{},context:{}}}]},"/mpa/v1/payments":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{context:{},page:{},per_page:{},search:{},after:{},before:{},exclude:{},include:{},offset:{},order:{},orderby:{},filter:{}}}]},"/mpa/v1/payments/(?P<id>[\\d]+)":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{id:{},context:{}}}]},"/mpa/v1/reservations":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{context:{},page:{},per_page:{},search:{},after:{},before:{},exclude:{},include:{},offset:{},order:{},orderby:{},filter:{},uid:{},min_reservation_date:{},max_reservation_date:{},booking_id:{},service_id:{},employee_id:{},location_id:{},min_price:{},max_price:{}}}]},"/mpa/v1/reservations/(?P<id>[\\d]+)":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{id:{},context:{}}}]},"/mpa/v1/services":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{context:{},page:{},per_page:{},search:{},after:{},before:{},exclude:{},include:{},offset:{},order:{},orderby:{},filter:{}}}]},"/mpa/v1/services/(?P<id>[\\d]+)":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{id:{},context:{}}}]},"/mpa/v1/locations":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{context:{},page:{},per_page:{},search:{},after:{},before:{},exclude:{},include:{},offset:{},order:{},orderby:{},filter:{}}}]},"/mpa/v1/locations/(?P<id>[\\d]+)":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{id:{},context:{}}}]},"/mpa/v1/employees":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{context:{},page:{},per_page:{},search:{},after:{},before:{},exclude:{},include:{},offset:{},order:{},orderby:{},filter:{}}}]},"/mpa/v1/employees/(?P<id>[\\d]+)":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{id:{},context:{}}}]},"/mpa/v1/coupons":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{context:{},page:{},per_page:{},search:{},after:{},before:{},exclude:{},include:{},offset:{},order:{},orderby:{},filter:{}}}]},"/mpa/v1/coupons/(?P<id>[\\d]+)":{namespace:"mpa/v1",methods:["GET"],endpoints:[{methods:["GET"],args:{id:{},context:{}}}]}};

	function mpa_rest_request() {
	  const url = mpaData.restAPI.root;
	  const nonce = {
	    nonce: mpaData.restAPI.nonce
	  };
	  const namespace = 'mpa/v1';
	  return new WPAPI({
	    endpoint: url,
	    routes: routes
	  }).auth(nonce).namespace(namespace);
	}

	function implement_default_request_filters(request, args = {}, embed) {
	  const availableDefaultFilters = ['context', 'page', 'per_page', 'search', 'after', 'before', 'exclude', 'include', 'offset', 'order', 'orderby', 'filter', '_fields', 'embed'];

	  // For better performance, set per_page = 100.
	  // This helps reduce the number of requests per render.
	  if (args.per_page === undefined) {
	    args.per_page = 100;
	  }
	  availableDefaultFilters.forEach(filter => {
	    if (args[filter] !== undefined) {
	      request.param(filter, args[filter]);
	    }
	  });
	  if (embed !== false) {
	    request.embed();
	  }
	  return request;
	}

	/**
	 * @param {Object} args
	 *     @param {Date|String} args['min_reservation_date']
	 *     @param {Date|String} args['max_reservation_date']
	 *     @param {String} args['booking_id']
	 *     @param {String} args['service_id']
	 *     @param {String} args['employee_id']
	 *     @param {String} args['location_id']
	 *     @param {Number} args['min_price']
	 *     @param {Number} args['max_price']
	 * @param {bool} embed Optional.
	 * @return {Promise}
	 */
	function get_reservations(args, embed = false) {
	  let request = mpa_rest_request().reservations();
	  request = implement_default_request_filters(request, args, embed);

	  // Add date range
	  if (args.min_reservation_date !== undefined) {
	    request.param('min_reservation_date', args.min_reservation_date);
	  }
	  if (args.max_reservation_date !== undefined) {
	    request.param('max_reservation_date', args.max_reservation_date);
	  }
	  if (args.booking_id !== undefined) {
	    request.param('booking_id', args.booking_id);
	  }
	  if (args.service_id !== undefined) {
	    request.param('service_id', args.service_id);
	  }
	  if (args.employee_id !== undefined) {
	    request.param('employee_id', args.employee_id);
	  }
	  if (args.location_id !== undefined) {
	    request.param('location_id', args.location_id);
	  }
	  if (args.min_price !== undefined) {
	    request.param('min_price', args.min_price);
	  }
	  if (args.max_price !== undefined) {
	    request.param('max_price', args.max_price);
	  }
	  return request;
	}
	function get_services(args, embed = false) {
	  const request = mpa_rest_request().services();
	  return implement_default_request_filters(request, args, embed);
	}
	function get_locations(args, embed = false) {
	  const request = mpa_rest_request().locations();
	  return implement_default_request_filters(request, args, embed);
	}
	function get_employees(args, embed = false) {
	  const request = mpa_rest_request().employees();
	  return implement_default_request_filters(request, args, embed);
	}
	function get_all(requestPromise) {
	  return requestPromise.then(function (response) {
	    if (!response._paging || !response._paging.next) {
	      return response;
	    }
	    // Request the next page and return both responses as one collection
	    return Promise.all([response, get_all(response._paging.next)]).then(function (responses) {
	      return responses.flat();
	    });
	  });
	}

	var chroma$1 = {exports: {}};

	/**
	 * chroma.js - JavaScript library for color conversions
	 *
	 * Copyright (c) 2011-2019, Gregor Aisch
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice, this
	 * list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 * this list of conditions and the following disclaimer in the documentation
	 * and/or other materials provided with the distribution.
	 *
	 * 3. The name Gregor Aisch may not be used to endorse or promote products
	 * derived from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
	 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 * -------------------------------------------------------
	 *
	 * chroma.js includes colors from colorbrewer2.org, which are released under
	 * the following license:
	 *
	 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
	 * and The Pennsylvania State University.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing,
	 * software distributed under the License is distributed on an
	 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
	 * either express or implied. See the License for the specific
	 * language governing permissions and limitations under the License.
	 *
	 * ------------------------------------------------------
	 *
	 * Named colors are taken from X11 Color Names.
	 * http://www.w3.org/TR/css3-color/#svg-color
	 *
	 * @preserve
	 */

	(function (module, exports) {
		(function (global, factory) {
		    module.exports = factory() ;
		})(commonjsGlobal, (function () {
		    var limit$2 = function (x, min, max) {
		        if ( min === void 0 ) min=0;
		        if ( max === void 0 ) max=1;

		        return x < min ? min : x > max ? max : x;
		    };

		    var limit$1 = limit$2;

		    var clip_rgb$3 = function (rgb) {
		        rgb._clipped = false;
		        rgb._unclipped = rgb.slice(0);
		        for (var i=0; i<=3; i++) {
		            if (i < 3) {
		                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }
		                rgb[i] = limit$1(rgb[i], 0, 255);
		            } else if (i === 3) {
		                rgb[i] = limit$1(rgb[i], 0, 1);
		            }
		        }
		        return rgb;
		    };

		    // ported from jQuery's $.type
		    var classToType = {};
		    for (var i$1 = 0, list$1 = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i$1 < list$1.length; i$1 += 1) {
		        var name = list$1[i$1];

		        classToType[("[object " + name + "]")] = name.toLowerCase();
		    }
		    var type$p = function(obj) {
		        return classToType[Object.prototype.toString.call(obj)] || "object";
		    };

		    var type$o = type$p;

		    var unpack$B = function (args, keyOrder) {
		        if ( keyOrder === void 0 ) keyOrder=null;

		    	// if called with more than 3 arguments, we return the arguments
		        if (args.length >= 3) { return Array.prototype.slice.call(args); }
		        // with less than 3 args we check if first arg is object
		        // and use the keyOrder string to extract and sort properties
		    	if (type$o(args[0]) == 'object' && keyOrder) {
		    		return keyOrder.split('')
		    			.filter(function (k) { return args[0][k] !== undefined; })
		    			.map(function (k) { return args[0][k]; });
		    	}
		    	// otherwise we just return the first argument
		    	// (which we suppose is an array of args)
		        return args[0];
		    };

		    var type$n = type$p;

		    var last$4 = function (args) {
		        if (args.length < 2) { return null; }
		        var l = args.length-1;
		        if (type$n(args[l]) == 'string') { return args[l].toLowerCase(); }
		        return null;
		    };

		    var PI$2 = Math.PI;

		    var utils = {
		    	clip_rgb: clip_rgb$3,
		    	limit: limit$2,
		    	type: type$p,
		    	unpack: unpack$B,
		    	last: last$4,
		    	PI: PI$2,
		    	TWOPI: PI$2*2,
		    	PITHIRD: PI$2/3,
		    	DEG2RAD: PI$2 / 180,
		    	RAD2DEG: 180 / PI$2
		    };

		    var input$h = {
		    	format: {},
		    	autodetect: []
		    };

		    var last$3 = utils.last;
		    var clip_rgb$2 = utils.clip_rgb;
		    var type$m = utils.type;
		    var _input = input$h;

		    var Color$D = function Color() {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var me = this;
		        if (type$m(args[0]) === 'object' &&
		            args[0].constructor &&
		            args[0].constructor === this.constructor) {
		            // the argument is already a Color instance
		            return args[0];
		        }

		        // last argument could be the mode
		        var mode = last$3(args);
		        var autodetect = false;

		        if (!mode) {
		            autodetect = true;
		            if (!_input.sorted) {
		                _input.autodetect = _input.autodetect.sort(function (a,b) { return b.p - a.p; });
		                _input.sorted = true;
		            }
		            // auto-detect format
		            for (var i = 0, list = _input.autodetect; i < list.length; i += 1) {
		                var chk = list[i];

		                mode = chk.test.apply(chk, args);
		                if (mode) { break; }
		            }
		        }

		        if (_input.format[mode]) {
		            var rgb = _input.format[mode].apply(null, autodetect ? args : args.slice(0,-1));
		            me._rgb = clip_rgb$2(rgb);
		        } else {
		            throw new Error('unknown format: '+args);
		        }

		        // add alpha channel
		        if (me._rgb.length === 3) { me._rgb.push(1); }
		    };

		    Color$D.prototype.toString = function toString () {
		        if (type$m(this.hex) == 'function') { return this.hex(); }
		        return ("[" + (this._rgb.join(',')) + "]");
		    };

		    var Color_1 = Color$D;

		    var chroma$k = function () {
		    	var args = [], len = arguments.length;
		    	while ( len-- ) args[ len ] = arguments[ len ];

		    	return new (Function.prototype.bind.apply( chroma$k.Color, [ null ].concat( args) ));
		    };

		    chroma$k.Color = Color_1;
		    chroma$k.version = '2.4.2';

		    var chroma_1 = chroma$k;

		    var unpack$A = utils.unpack;
		    var max$2 = Math.max;

		    var rgb2cmyk$1 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var ref = unpack$A(args, 'rgb');
		        var r = ref[0];
		        var g = ref[1];
		        var b = ref[2];
		        r = r / 255;
		        g = g / 255;
		        b = b / 255;
		        var k = 1 - max$2(r,max$2(g,b));
		        var f = k < 1 ? 1 / (1-k) : 0;
		        var c = (1-r-k) * f;
		        var m = (1-g-k) * f;
		        var y = (1-b-k) * f;
		        return [c,m,y,k];
		    };

		    var rgb2cmyk_1 = rgb2cmyk$1;

		    var unpack$z = utils.unpack;

		    var cmyk2rgb = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        args = unpack$z(args, 'cmyk');
		        var c = args[0];
		        var m = args[1];
		        var y = args[2];
		        var k = args[3];
		        var alpha = args.length > 4 ? args[4] : 1;
		        if (k === 1) { return [0,0,0,alpha]; }
		        return [
		            c >= 1 ? 0 : 255 * (1-c) * (1-k), // r
		            m >= 1 ? 0 : 255 * (1-m) * (1-k), // g
		            y >= 1 ? 0 : 255 * (1-y) * (1-k), // b
		            alpha
		        ];
		    };

		    var cmyk2rgb_1 = cmyk2rgb;

		    var chroma$j = chroma_1;
		    var Color$C = Color_1;
		    var input$g = input$h;
		    var unpack$y = utils.unpack;
		    var type$l = utils.type;

		    var rgb2cmyk = rgb2cmyk_1;

		    Color$C.prototype.cmyk = function() {
		        return rgb2cmyk(this._rgb);
		    };

		    chroma$j.cmyk = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$C, [ null ].concat( args, ['cmyk']) ));
		    };

		    input$g.format.cmyk = cmyk2rgb_1;

		    input$g.autodetect.push({
		        p: 2,
		        test: function () {
		            var args = [], len = arguments.length;
		            while ( len-- ) args[ len ] = arguments[ len ];

		            args = unpack$y(args, 'cmyk');
		            if (type$l(args) === 'array' && args.length === 4) {
		                return 'cmyk';
		            }
		        }
		    });

		    var unpack$x = utils.unpack;
		    var last$2 = utils.last;
		    var rnd = function (a) { return Math.round(a*100)/100; };

		    /*
		     * supported arguments:
		     * - hsl2css(h,s,l)
		     * - hsl2css(h,s,l,a)
		     * - hsl2css([h,s,l], mode)
		     * - hsl2css([h,s,l,a], mode)
		     * - hsl2css({h,s,l,a}, mode)
		     */
		    var hsl2css$1 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var hsla = unpack$x(args, 'hsla');
		        var mode = last$2(args) || 'lsa';
		        hsla[0] = rnd(hsla[0] || 0);
		        hsla[1] = rnd(hsla[1]*100) + '%';
		        hsla[2] = rnd(hsla[2]*100) + '%';
		        if (mode === 'hsla' || (hsla.length > 3 && hsla[3]<1)) {
		            hsla[3] = hsla.length > 3 ? hsla[3] : 1;
		            mode = 'hsla';
		        } else {
		            hsla.length = 3;
		        }
		        return (mode + "(" + (hsla.join(',')) + ")");
		    };

		    var hsl2css_1 = hsl2css$1;

		    var unpack$w = utils.unpack;

		    /*
		     * supported arguments:
		     * - rgb2hsl(r,g,b)
		     * - rgb2hsl(r,g,b,a)
		     * - rgb2hsl([r,g,b])
		     * - rgb2hsl([r,g,b,a])
		     * - rgb2hsl({r,g,b,a})
		     */
		    var rgb2hsl$3 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        args = unpack$w(args, 'rgba');
		        var r = args[0];
		        var g = args[1];
		        var b = args[2];

		        r /= 255;
		        g /= 255;
		        b /= 255;

		        var min = Math.min(r, g, b);
		        var max = Math.max(r, g, b);

		        var l = (max + min) / 2;
		        var s, h;

		        if (max === min){
		            s = 0;
		            h = Number.NaN;
		        } else {
		            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
		        }

		        if (r == max) { h = (g - b) / (max - min); }
		        else if (g == max) { h = 2 + (b - r) / (max - min); }
		        else if (b == max) { h = 4 + (r - g) / (max - min); }

		        h *= 60;
		        if (h < 0) { h += 360; }
		        if (args.length>3 && args[3]!==undefined) { return [h,s,l,args[3]]; }
		        return [h,s,l];
		    };

		    var rgb2hsl_1 = rgb2hsl$3;

		    var unpack$v = utils.unpack;
		    var last$1 = utils.last;
		    var hsl2css = hsl2css_1;
		    var rgb2hsl$2 = rgb2hsl_1;
		    var round$6 = Math.round;

		    /*
		     * supported arguments:
		     * - rgb2css(r,g,b)
		     * - rgb2css(r,g,b,a)
		     * - rgb2css([r,g,b], mode)
		     * - rgb2css([r,g,b,a], mode)
		     * - rgb2css({r,g,b,a}, mode)
		     */
		    var rgb2css$1 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var rgba = unpack$v(args, 'rgba');
		        var mode = last$1(args) || 'rgb';
		        if (mode.substr(0,3) == 'hsl') {
		            return hsl2css(rgb2hsl$2(rgba), mode);
		        }
		        rgba[0] = round$6(rgba[0]);
		        rgba[1] = round$6(rgba[1]);
		        rgba[2] = round$6(rgba[2]);
		        if (mode === 'rgba' || (rgba.length > 3 && rgba[3]<1)) {
		            rgba[3] = rgba.length > 3 ? rgba[3] : 1;
		            mode = 'rgba';
		        }
		        return (mode + "(" + (rgba.slice(0,mode==='rgb'?3:4).join(',')) + ")");
		    };

		    var rgb2css_1 = rgb2css$1;

		    var unpack$u = utils.unpack;
		    var round$5 = Math.round;

		    var hsl2rgb$1 = function () {
		        var assign;

		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];
		        args = unpack$u(args, 'hsl');
		        var h = args[0];
		        var s = args[1];
		        var l = args[2];
		        var r,g,b;
		        if (s === 0) {
		            r = g = b = l*255;
		        } else {
		            var t3 = [0,0,0];
		            var c = [0,0,0];
		            var t2 = l < 0.5 ? l * (1+s) : l+s-l*s;
		            var t1 = 2 * l - t2;
		            var h_ = h / 360;
		            t3[0] = h_ + 1/3;
		            t3[1] = h_;
		            t3[2] = h_ - 1/3;
		            for (var i=0; i<3; i++) {
		                if (t3[i] < 0) { t3[i] += 1; }
		                if (t3[i] > 1) { t3[i] -= 1; }
		                if (6 * t3[i] < 1)
		                    { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }
		                else if (2 * t3[i] < 1)
		                    { c[i] = t2; }
		                else if (3 * t3[i] < 2)
		                    { c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6; }
		                else
		                    { c[i] = t1; }
		            }
		            (assign = [round$5(c[0]*255),round$5(c[1]*255),round$5(c[2]*255)], r = assign[0], g = assign[1], b = assign[2]);
		        }
		        if (args.length > 3) {
		            // keep alpha channel
		            return [r,g,b,args[3]];
		        }
		        return [r,g,b,1];
		    };

		    var hsl2rgb_1 = hsl2rgb$1;

		    var hsl2rgb = hsl2rgb_1;
		    var input$f = input$h;

		    var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
		    var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
		    var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
		    var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
		    var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
		    var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;

		    var round$4 = Math.round;

		    var css2rgb$1 = function (css) {
		        css = css.toLowerCase().trim();
		        var m;

		        if (input$f.format.named) {
		            try {
		                return input$f.format.named(css);
		            } catch (e) {
		                // eslint-disable-next-line
		            }
		        }

		        // rgb(250,20,0)
		        if ((m = css.match(RE_RGB))) {
		            var rgb = m.slice(1,4);
		            for (var i=0; i<3; i++) {
		                rgb[i] = +rgb[i];
		            }
		            rgb[3] = 1;  // default alpha
		            return rgb;
		        }

		        // rgba(250,20,0,0.4)
		        if ((m = css.match(RE_RGBA))) {
		            var rgb$1 = m.slice(1,5);
		            for (var i$1=0; i$1<4; i$1++) {
		                rgb$1[i$1] = +rgb$1[i$1];
		            }
		            return rgb$1;
		        }

		        // rgb(100%,0%,0%)
		        if ((m = css.match(RE_RGB_PCT))) {
		            var rgb$2 = m.slice(1,4);
		            for (var i$2=0; i$2<3; i$2++) {
		                rgb$2[i$2] = round$4(rgb$2[i$2] * 2.55);
		            }
		            rgb$2[3] = 1;  // default alpha
		            return rgb$2;
		        }

		        // rgba(100%,0%,0%,0.4)
		        if ((m = css.match(RE_RGBA_PCT))) {
		            var rgb$3 = m.slice(1,5);
		            for (var i$3=0; i$3<3; i$3++) {
		                rgb$3[i$3] = round$4(rgb$3[i$3] * 2.55);
		            }
		            rgb$3[3] = +rgb$3[3];
		            return rgb$3;
		        }

		        // hsl(0,100%,50%)
		        if ((m = css.match(RE_HSL))) {
		            var hsl = m.slice(1,4);
		            hsl[1] *= 0.01;
		            hsl[2] *= 0.01;
		            var rgb$4 = hsl2rgb(hsl);
		            rgb$4[3] = 1;
		            return rgb$4;
		        }

		        // hsla(0,100%,50%,0.5)
		        if ((m = css.match(RE_HSLA))) {
		            var hsl$1 = m.slice(1,4);
		            hsl$1[1] *= 0.01;
		            hsl$1[2] *= 0.01;
		            var rgb$5 = hsl2rgb(hsl$1);
		            rgb$5[3] = +m[4];  // default alpha = 1
		            return rgb$5;
		        }
		    };

		    css2rgb$1.test = function (s) {
		        return RE_RGB.test(s) ||
		            RE_RGBA.test(s) ||
		            RE_RGB_PCT.test(s) ||
		            RE_RGBA_PCT.test(s) ||
		            RE_HSL.test(s) ||
		            RE_HSLA.test(s);
		    };

		    var css2rgb_1 = css2rgb$1;

		    var chroma$i = chroma_1;
		    var Color$B = Color_1;
		    var input$e = input$h;
		    var type$k = utils.type;

		    var rgb2css = rgb2css_1;
		    var css2rgb = css2rgb_1;

		    Color$B.prototype.css = function(mode) {
		        return rgb2css(this._rgb, mode);
		    };

		    chroma$i.css = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$B, [ null ].concat( args, ['css']) ));
		    };

		    input$e.format.css = css2rgb;

		    input$e.autodetect.push({
		        p: 5,
		        test: function (h) {
		            var rest = [], len = arguments.length - 1;
		            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

		            if (!rest.length && type$k(h) === 'string' && css2rgb.test(h)) {
		                return 'css';
		            }
		        }
		    });

		    var Color$A = Color_1;
		    var chroma$h = chroma_1;
		    var input$d = input$h;
		    var unpack$t = utils.unpack;

		    input$d.format.gl = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var rgb = unpack$t(args, 'rgba');
		        rgb[0] *= 255;
		        rgb[1] *= 255;
		        rgb[2] *= 255;
		        return rgb;
		    };

		    chroma$h.gl = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$A, [ null ].concat( args, ['gl']) ));
		    };

		    Color$A.prototype.gl = function() {
		        var rgb = this._rgb;
		        return [rgb[0]/255, rgb[1]/255, rgb[2]/255, rgb[3]];
		    };

		    var unpack$s = utils.unpack;

		    var rgb2hcg$1 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var ref = unpack$s(args, 'rgb');
		        var r = ref[0];
		        var g = ref[1];
		        var b = ref[2];
		        var min = Math.min(r, g, b);
		        var max = Math.max(r, g, b);
		        var delta = max - min;
		        var c = delta * 100 / 255;
		        var _g = min / (255 - delta) * 100;
		        var h;
		        if (delta === 0) {
		            h = Number.NaN;
		        } else {
		            if (r === max) { h = (g - b) / delta; }
		            if (g === max) { h = 2+(b - r) / delta; }
		            if (b === max) { h = 4+(r - g) / delta; }
		            h *= 60;
		            if (h < 0) { h += 360; }
		        }
		        return [h, c, _g];
		    };

		    var rgb2hcg_1 = rgb2hcg$1;

		    var unpack$r = utils.unpack;
		    var floor$3 = Math.floor;

		    /*
		     * this is basically just HSV with some minor tweaks
		     *
		     * hue.. [0..360]
		     * chroma .. [0..1]
		     * grayness .. [0..1]
		     */

		    var hcg2rgb = function () {
		        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];
		        args = unpack$r(args, 'hcg');
		        var h = args[0];
		        var c = args[1];
		        var _g = args[2];
		        var r,g,b;
		        _g = _g * 255;
		        var _c = c * 255;
		        if (c === 0) {
		            r = g = b = _g;
		        } else {
		            if (h === 360) { h = 0; }
		            if (h > 360) { h -= 360; }
		            if (h < 0) { h += 360; }
		            h /= 60;
		            var i = floor$3(h);
		            var f = h - i;
		            var p = _g * (1 - c);
		            var q = p + _c * (1 - f);
		            var t = p + _c * f;
		            var v = p + _c;
		            switch (i) {
		                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
		                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
		                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
		                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
		                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
		                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
		            }
		        }
		        return [r, g, b, args.length > 3 ? args[3] : 1];
		    };

		    var hcg2rgb_1 = hcg2rgb;

		    var unpack$q = utils.unpack;
		    var type$j = utils.type;
		    var chroma$g = chroma_1;
		    var Color$z = Color_1;
		    var input$c = input$h;

		    var rgb2hcg = rgb2hcg_1;

		    Color$z.prototype.hcg = function() {
		        return rgb2hcg(this._rgb);
		    };

		    chroma$g.hcg = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$z, [ null ].concat( args, ['hcg']) ));
		    };

		    input$c.format.hcg = hcg2rgb_1;

		    input$c.autodetect.push({
		        p: 1,
		        test: function () {
		            var args = [], len = arguments.length;
		            while ( len-- ) args[ len ] = arguments[ len ];

		            args = unpack$q(args, 'hcg');
		            if (type$j(args) === 'array' && args.length === 3) {
		                return 'hcg';
		            }
		        }
		    });

		    var unpack$p = utils.unpack;
		    var last = utils.last;
		    var round$3 = Math.round;

		    var rgb2hex$2 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var ref = unpack$p(args, 'rgba');
		        var r = ref[0];
		        var g = ref[1];
		        var b = ref[2];
		        var a = ref[3];
		        var mode = last(args) || 'auto';
		        if (a === undefined) { a = 1; }
		        if (mode === 'auto') {
		            mode = a < 1 ? 'rgba' : 'rgb';
		        }
		        r = round$3(r);
		        g = round$3(g);
		        b = round$3(b);
		        var u = r << 16 | g << 8 | b;
		        var str = "000000" + u.toString(16); //#.toUpperCase();
		        str = str.substr(str.length - 6);
		        var hxa = '0' + round$3(a * 255).toString(16);
		        hxa = hxa.substr(hxa.length - 2);
		        switch (mode.toLowerCase()) {
		            case 'rgba': return ("#" + str + hxa);
		            case 'argb': return ("#" + hxa + str);
		            default: return ("#" + str);
		        }
		    };

		    var rgb2hex_1 = rgb2hex$2;

		    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
		    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;

		    var hex2rgb$1 = function (hex) {
		        if (hex.match(RE_HEX)) {
		            // remove optional leading #
		            if (hex.length === 4 || hex.length === 7) {
		                hex = hex.substr(1);
		            }
		            // expand short-notation to full six-digit
		            if (hex.length === 3) {
		                hex = hex.split('');
		                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
		            }
		            var u = parseInt(hex, 16);
		            var r = u >> 16;
		            var g = u >> 8 & 0xFF;
		            var b = u & 0xFF;
		            return [r,g,b,1];
		        }

		        // match rgba hex format, eg #FF000077
		        if (hex.match(RE_HEXA)) {
		            if (hex.length === 5 || hex.length === 9) {
		                // remove optional leading #
		                hex = hex.substr(1);
		            }
		            // expand short-notation to full eight-digit
		            if (hex.length === 4) {
		                hex = hex.split('');
		                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];
		            }
		            var u$1 = parseInt(hex, 16);
		            var r$1 = u$1 >> 24 & 0xFF;
		            var g$1 = u$1 >> 16 & 0xFF;
		            var b$1 = u$1 >> 8 & 0xFF;
		            var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;
		            return [r$1,g$1,b$1,a];
		        }

		        // we used to check for css colors here
		        // if _input.css? and rgb = _input.css hex
		        //     return rgb

		        throw new Error(("unknown hex color: " + hex));
		    };

		    var hex2rgb_1 = hex2rgb$1;

		    var chroma$f = chroma_1;
		    var Color$y = Color_1;
		    var type$i = utils.type;
		    var input$b = input$h;

		    var rgb2hex$1 = rgb2hex_1;

		    Color$y.prototype.hex = function(mode) {
		        return rgb2hex$1(this._rgb, mode);
		    };

		    chroma$f.hex = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$y, [ null ].concat( args, ['hex']) ));
		    };

		    input$b.format.hex = hex2rgb_1;
		    input$b.autodetect.push({
		        p: 4,
		        test: function (h) {
		            var rest = [], len = arguments.length - 1;
		            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

		            if (!rest.length && type$i(h) === 'string' && [3,4,5,6,7,8,9].indexOf(h.length) >= 0) {
		                return 'hex';
		            }
		        }
		    });

		    var unpack$o = utils.unpack;
		    var TWOPI$2 = utils.TWOPI;
		    var min$2 = Math.min;
		    var sqrt$4 = Math.sqrt;
		    var acos = Math.acos;

		    var rgb2hsi$1 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        /*
		        borrowed from here:
		        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
		        */
		        var ref = unpack$o(args, 'rgb');
		        var r = ref[0];
		        var g = ref[1];
		        var b = ref[2];
		        r /= 255;
		        g /= 255;
		        b /= 255;
		        var h;
		        var min_ = min$2(r,g,b);
		        var i = (r+g+b) / 3;
		        var s = i > 0 ? 1 - min_/i : 0;
		        if (s === 0) {
		            h = NaN;
		        } else {
		            h = ((r-g)+(r-b)) / 2;
		            h /= sqrt$4((r-g)*(r-g) + (r-b)*(g-b));
		            h = acos(h);
		            if (b > g) {
		                h = TWOPI$2 - h;
		            }
		            h /= TWOPI$2;
		        }
		        return [h*360,s,i];
		    };

		    var rgb2hsi_1 = rgb2hsi$1;

		    var unpack$n = utils.unpack;
		    var limit = utils.limit;
		    var TWOPI$1 = utils.TWOPI;
		    var PITHIRD = utils.PITHIRD;
		    var cos$4 = Math.cos;

		    /*
		     * hue [0..360]
		     * saturation [0..1]
		     * intensity [0..1]
		     */
		    var hsi2rgb = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        /*
		        borrowed from here:
		        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
		        */
		        args = unpack$n(args, 'hsi');
		        var h = args[0];
		        var s = args[1];
		        var i = args[2];
		        var r,g,b;

		        if (isNaN(h)) { h = 0; }
		        if (isNaN(s)) { s = 0; }
		        // normalize hue
		        if (h > 360) { h -= 360; }
		        if (h < 0) { h += 360; }
		        h /= 360;
		        if (h < 1/3) {
		            b = (1-s)/3;
		            r = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
		            g = 1 - (b+r);
		        } else if (h < 2/3) {
		            h -= 1/3;
		            r = (1-s)/3;
		            g = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
		            b = 1 - (r+g);
		        } else {
		            h -= 2/3;
		            g = (1-s)/3;
		            b = (1+s*cos$4(TWOPI$1*h)/cos$4(PITHIRD-TWOPI$1*h))/3;
		            r = 1 - (g+b);
		        }
		        r = limit(i*r*3);
		        g = limit(i*g*3);
		        b = limit(i*b*3);
		        return [r*255, g*255, b*255, args.length > 3 ? args[3] : 1];
		    };

		    var hsi2rgb_1 = hsi2rgb;

		    var unpack$m = utils.unpack;
		    var type$h = utils.type;
		    var chroma$e = chroma_1;
		    var Color$x = Color_1;
		    var input$a = input$h;

		    var rgb2hsi = rgb2hsi_1;

		    Color$x.prototype.hsi = function() {
		        return rgb2hsi(this._rgb);
		    };

		    chroma$e.hsi = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$x, [ null ].concat( args, ['hsi']) ));
		    };

		    input$a.format.hsi = hsi2rgb_1;

		    input$a.autodetect.push({
		        p: 2,
		        test: function () {
		            var args = [], len = arguments.length;
		            while ( len-- ) args[ len ] = arguments[ len ];

		            args = unpack$m(args, 'hsi');
		            if (type$h(args) === 'array' && args.length === 3) {
		                return 'hsi';
		            }
		        }
		    });

		    var unpack$l = utils.unpack;
		    var type$g = utils.type;
		    var chroma$d = chroma_1;
		    var Color$w = Color_1;
		    var input$9 = input$h;

		    var rgb2hsl$1 = rgb2hsl_1;

		    Color$w.prototype.hsl = function() {
		        return rgb2hsl$1(this._rgb);
		    };

		    chroma$d.hsl = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$w, [ null ].concat( args, ['hsl']) ));
		    };

		    input$9.format.hsl = hsl2rgb_1;

		    input$9.autodetect.push({
		        p: 2,
		        test: function () {
		            var args = [], len = arguments.length;
		            while ( len-- ) args[ len ] = arguments[ len ];

		            args = unpack$l(args, 'hsl');
		            if (type$g(args) === 'array' && args.length === 3) {
		                return 'hsl';
		            }
		        }
		    });

		    var unpack$k = utils.unpack;
		    var min$1 = Math.min;
		    var max$1 = Math.max;

		    /*
		     * supported arguments:
		     * - rgb2hsv(r,g,b)
		     * - rgb2hsv([r,g,b])
		     * - rgb2hsv({r,g,b})
		     */
		    var rgb2hsl = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        args = unpack$k(args, 'rgb');
		        var r = args[0];
		        var g = args[1];
		        var b = args[2];
		        var min_ = min$1(r, g, b);
		        var max_ = max$1(r, g, b);
		        var delta = max_ - min_;
		        var h,s,v;
		        v = max_ / 255.0;
		        if (max_ === 0) {
		            h = Number.NaN;
		            s = 0;
		        } else {
		            s = delta / max_;
		            if (r === max_) { h = (g - b) / delta; }
		            if (g === max_) { h = 2+(b - r) / delta; }
		            if (b === max_) { h = 4+(r - g) / delta; }
		            h *= 60;
		            if (h < 0) { h += 360; }
		        }
		        return [h, s, v]
		    };

		    var rgb2hsv$1 = rgb2hsl;

		    var unpack$j = utils.unpack;
		    var floor$2 = Math.floor;

		    var hsv2rgb = function () {
		        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;

		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];
		        args = unpack$j(args, 'hsv');
		        var h = args[0];
		        var s = args[1];
		        var v = args[2];
		        var r,g,b;
		        v *= 255;
		        if (s === 0) {
		            r = g = b = v;
		        } else {
		            if (h === 360) { h = 0; }
		            if (h > 360) { h -= 360; }
		            if (h < 0) { h += 360; }
		            h /= 60;

		            var i = floor$2(h);
		            var f = h - i;
		            var p = v * (1 - s);
		            var q = v * (1 - s * f);
		            var t = v * (1 - s * (1 - f));

		            switch (i) {
		                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break
		                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break
		                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break
		                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break
		                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break
		                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break
		            }
		        }
		        return [r,g,b,args.length > 3?args[3]:1];
		    };

		    var hsv2rgb_1 = hsv2rgb;

		    var unpack$i = utils.unpack;
		    var type$f = utils.type;
		    var chroma$c = chroma_1;
		    var Color$v = Color_1;
		    var input$8 = input$h;

		    var rgb2hsv = rgb2hsv$1;

		    Color$v.prototype.hsv = function() {
		        return rgb2hsv(this._rgb);
		    };

		    chroma$c.hsv = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$v, [ null ].concat( args, ['hsv']) ));
		    };

		    input$8.format.hsv = hsv2rgb_1;

		    input$8.autodetect.push({
		        p: 2,
		        test: function () {
		            var args = [], len = arguments.length;
		            while ( len-- ) args[ len ] = arguments[ len ];

		            args = unpack$i(args, 'hsv');
		            if (type$f(args) === 'array' && args.length === 3) {
		                return 'hsv';
		            }
		        }
		    });

		    var labConstants = {
		        // Corresponds roughly to RGB brighter/darker
		        Kn: 18,

		        // D65 standard referent
		        Xn: 0.950470,
		        Yn: 1,
		        Zn: 1.088830,

		        t0: 0.137931034,  // 4 / 29
		        t1: 0.206896552,  // 6 / 29
		        t2: 0.12841855,   // 3 * t1 * t1
		        t3: 0.008856452,  // t1 * t1 * t1
		    };

		    var LAB_CONSTANTS$3 = labConstants;
		    var unpack$h = utils.unpack;
		    var pow$a = Math.pow;

		    var rgb2lab$2 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var ref = unpack$h(args, 'rgb');
		        var r = ref[0];
		        var g = ref[1];
		        var b = ref[2];
		        var ref$1 = rgb2xyz(r,g,b);
		        var x = ref$1[0];
		        var y = ref$1[1];
		        var z = ref$1[2];
		        var l = 116 * y - 16;
		        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
		    };

		    var rgb_xyz = function (r) {
		        if ((r /= 255) <= 0.04045) { return r / 12.92; }
		        return pow$a((r + 0.055) / 1.055, 2.4);
		    };

		    var xyz_lab = function (t) {
		        if (t > LAB_CONSTANTS$3.t3) { return pow$a(t, 1 / 3); }
		        return t / LAB_CONSTANTS$3.t2 + LAB_CONSTANTS$3.t0;
		    };

		    var rgb2xyz = function (r,g,b) {
		        r = rgb_xyz(r);
		        g = rgb_xyz(g);
		        b = rgb_xyz(b);
		        var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS$3.Xn);
		        var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / LAB_CONSTANTS$3.Yn);
		        var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / LAB_CONSTANTS$3.Zn);
		        return [x,y,z];
		    };

		    var rgb2lab_1 = rgb2lab$2;

		    var LAB_CONSTANTS$2 = labConstants;
		    var unpack$g = utils.unpack;
		    var pow$9 = Math.pow;

		    /*
		     * L* [0..100]
		     * a [-100..100]
		     * b [-100..100]
		     */
		    var lab2rgb$1 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        args = unpack$g(args, 'lab');
		        var l = args[0];
		        var a = args[1];
		        var b = args[2];
		        var x,y,z, r,g,b_;

		        y = (l + 16) / 116;
		        x = isNaN(a) ? y : y + a / 500;
		        z = isNaN(b) ? y : y - b / 200;

		        y = LAB_CONSTANTS$2.Yn * lab_xyz(y);
		        x = LAB_CONSTANTS$2.Xn * lab_xyz(x);
		        z = LAB_CONSTANTS$2.Zn * lab_xyz(z);

		        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);  // D65 -> sRGB
		        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
		        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);

		        return [r,g,b_,args.length > 3 ? args[3] : 1];
		    };

		    var xyz_rgb = function (r) {
		        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$9(r, 1 / 2.4) - 0.055)
		    };

		    var lab_xyz = function (t) {
		        return t > LAB_CONSTANTS$2.t1 ? t * t * t : LAB_CONSTANTS$2.t2 * (t - LAB_CONSTANTS$2.t0)
		    };

		    var lab2rgb_1 = lab2rgb$1;

		    var unpack$f = utils.unpack;
		    var type$e = utils.type;
		    var chroma$b = chroma_1;
		    var Color$u = Color_1;
		    var input$7 = input$h;

		    var rgb2lab$1 = rgb2lab_1;

		    Color$u.prototype.lab = function() {
		        return rgb2lab$1(this._rgb);
		    };

		    chroma$b.lab = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$u, [ null ].concat( args, ['lab']) ));
		    };

		    input$7.format.lab = lab2rgb_1;

		    input$7.autodetect.push({
		        p: 2,
		        test: function () {
		            var args = [], len = arguments.length;
		            while ( len-- ) args[ len ] = arguments[ len ];

		            args = unpack$f(args, 'lab');
		            if (type$e(args) === 'array' && args.length === 3) {
		                return 'lab';
		            }
		        }
		    });

		    var unpack$e = utils.unpack;
		    var RAD2DEG = utils.RAD2DEG;
		    var sqrt$3 = Math.sqrt;
		    var atan2$2 = Math.atan2;
		    var round$2 = Math.round;

		    var lab2lch$2 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var ref = unpack$e(args, 'lab');
		        var l = ref[0];
		        var a = ref[1];
		        var b = ref[2];
		        var c = sqrt$3(a * a + b * b);
		        var h = (atan2$2(b, a) * RAD2DEG + 360) % 360;
		        if (round$2(c*10000) === 0) { h = Number.NaN; }
		        return [l, c, h];
		    };

		    var lab2lch_1 = lab2lch$2;

		    var unpack$d = utils.unpack;
		    var rgb2lab = rgb2lab_1;
		    var lab2lch$1 = lab2lch_1;

		    var rgb2lch$1 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var ref = unpack$d(args, 'rgb');
		        var r = ref[0];
		        var g = ref[1];
		        var b = ref[2];
		        var ref$1 = rgb2lab(r,g,b);
		        var l = ref$1[0];
		        var a = ref$1[1];
		        var b_ = ref$1[2];
		        return lab2lch$1(l,a,b_);
		    };

		    var rgb2lch_1 = rgb2lch$1;

		    var unpack$c = utils.unpack;
		    var DEG2RAD = utils.DEG2RAD;
		    var sin$3 = Math.sin;
		    var cos$3 = Math.cos;

		    var lch2lab$2 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        /*
		        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.
		        These formulas were invented by David Dalrymple to obtain maximum contrast without going
		        out of gamut if the parameters are in the range 0-1.

		        A saturation multiplier was added by Gregor Aisch
		        */
		        var ref = unpack$c(args, 'lch');
		        var l = ref[0];
		        var c = ref[1];
		        var h = ref[2];
		        if (isNaN(h)) { h = 0; }
		        h = h * DEG2RAD;
		        return [l, cos$3(h) * c, sin$3(h) * c]
		    };

		    var lch2lab_1 = lch2lab$2;

		    var unpack$b = utils.unpack;
		    var lch2lab$1 = lch2lab_1;
		    var lab2rgb = lab2rgb_1;

		    var lch2rgb$1 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        args = unpack$b(args, 'lch');
		        var l = args[0];
		        var c = args[1];
		        var h = args[2];
		        var ref = lch2lab$1 (l,c,h);
		        var L = ref[0];
		        var a = ref[1];
		        var b_ = ref[2];
		        var ref$1 = lab2rgb (L,a,b_);
		        var r = ref$1[0];
		        var g = ref$1[1];
		        var b = ref$1[2];
		        return [r, g, b, args.length > 3 ? args[3] : 1];
		    };

		    var lch2rgb_1 = lch2rgb$1;

		    var unpack$a = utils.unpack;
		    var lch2rgb = lch2rgb_1;

		    var hcl2rgb = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var hcl = unpack$a(args, 'hcl').reverse();
		        return lch2rgb.apply(void 0, hcl);
		    };

		    var hcl2rgb_1 = hcl2rgb;

		    var unpack$9 = utils.unpack;
		    var type$d = utils.type;
		    var chroma$a = chroma_1;
		    var Color$t = Color_1;
		    var input$6 = input$h;

		    var rgb2lch = rgb2lch_1;

		    Color$t.prototype.lch = function() { return rgb2lch(this._rgb); };
		    Color$t.prototype.hcl = function() { return rgb2lch(this._rgb).reverse(); };

		    chroma$a.lch = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$t, [ null ].concat( args, ['lch']) ));
		    };
		    chroma$a.hcl = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$t, [ null ].concat( args, ['hcl']) ));
		    };

		    input$6.format.lch = lch2rgb_1;
		    input$6.format.hcl = hcl2rgb_1;

		    ['lch','hcl'].forEach(function (m) { return input$6.autodetect.push({
		        p: 2,
		        test: function () {
		            var args = [], len = arguments.length;
		            while ( len-- ) args[ len ] = arguments[ len ];

		            args = unpack$9(args, m);
		            if (type$d(args) === 'array' && args.length === 3) {
		                return m;
		            }
		        }
		    }); });

		    /**
		    	X11 color names

		    	http://www.w3.org/TR/css3-color/#svg-color
		    */

		    var w3cx11$1 = {
		        aliceblue: '#f0f8ff',
		        antiquewhite: '#faebd7',
		        aqua: '#00ffff',
		        aquamarine: '#7fffd4',
		        azure: '#f0ffff',
		        beige: '#f5f5dc',
		        bisque: '#ffe4c4',
		        black: '#000000',
		        blanchedalmond: '#ffebcd',
		        blue: '#0000ff',
		        blueviolet: '#8a2be2',
		        brown: '#a52a2a',
		        burlywood: '#deb887',
		        cadetblue: '#5f9ea0',
		        chartreuse: '#7fff00',
		        chocolate: '#d2691e',
		        coral: '#ff7f50',
		        cornflower: '#6495ed',
		        cornflowerblue: '#6495ed',
		        cornsilk: '#fff8dc',
		        crimson: '#dc143c',
		        cyan: '#00ffff',
		        darkblue: '#00008b',
		        darkcyan: '#008b8b',
		        darkgoldenrod: '#b8860b',
		        darkgray: '#a9a9a9',
		        darkgreen: '#006400',
		        darkgrey: '#a9a9a9',
		        darkkhaki: '#bdb76b',
		        darkmagenta: '#8b008b',
		        darkolivegreen: '#556b2f',
		        darkorange: '#ff8c00',
		        darkorchid: '#9932cc',
		        darkred: '#8b0000',
		        darksalmon: '#e9967a',
		        darkseagreen: '#8fbc8f',
		        darkslateblue: '#483d8b',
		        darkslategray: '#2f4f4f',
		        darkslategrey: '#2f4f4f',
		        darkturquoise: '#00ced1',
		        darkviolet: '#9400d3',
		        deeppink: '#ff1493',
		        deepskyblue: '#00bfff',
		        dimgray: '#696969',
		        dimgrey: '#696969',
		        dodgerblue: '#1e90ff',
		        firebrick: '#b22222',
		        floralwhite: '#fffaf0',
		        forestgreen: '#228b22',
		        fuchsia: '#ff00ff',
		        gainsboro: '#dcdcdc',
		        ghostwhite: '#f8f8ff',
		        gold: '#ffd700',
		        goldenrod: '#daa520',
		        gray: '#808080',
		        green: '#008000',
		        greenyellow: '#adff2f',
		        grey: '#808080',
		        honeydew: '#f0fff0',
		        hotpink: '#ff69b4',
		        indianred: '#cd5c5c',
		        indigo: '#4b0082',
		        ivory: '#fffff0',
		        khaki: '#f0e68c',
		        laserlemon: '#ffff54',
		        lavender: '#e6e6fa',
		        lavenderblush: '#fff0f5',
		        lawngreen: '#7cfc00',
		        lemonchiffon: '#fffacd',
		        lightblue: '#add8e6',
		        lightcoral: '#f08080',
		        lightcyan: '#e0ffff',
		        lightgoldenrod: '#fafad2',
		        lightgoldenrodyellow: '#fafad2',
		        lightgray: '#d3d3d3',
		        lightgreen: '#90ee90',
		        lightgrey: '#d3d3d3',
		        lightpink: '#ffb6c1',
		        lightsalmon: '#ffa07a',
		        lightseagreen: '#20b2aa',
		        lightskyblue: '#87cefa',
		        lightslategray: '#778899',
		        lightslategrey: '#778899',
		        lightsteelblue: '#b0c4de',
		        lightyellow: '#ffffe0',
		        lime: '#00ff00',
		        limegreen: '#32cd32',
		        linen: '#faf0e6',
		        magenta: '#ff00ff',
		        maroon: '#800000',
		        maroon2: '#7f0000',
		        maroon3: '#b03060',
		        mediumaquamarine: '#66cdaa',
		        mediumblue: '#0000cd',
		        mediumorchid: '#ba55d3',
		        mediumpurple: '#9370db',
		        mediumseagreen: '#3cb371',
		        mediumslateblue: '#7b68ee',
		        mediumspringgreen: '#00fa9a',
		        mediumturquoise: '#48d1cc',
		        mediumvioletred: '#c71585',
		        midnightblue: '#191970',
		        mintcream: '#f5fffa',
		        mistyrose: '#ffe4e1',
		        moccasin: '#ffe4b5',
		        navajowhite: '#ffdead',
		        navy: '#000080',
		        oldlace: '#fdf5e6',
		        olive: '#808000',
		        olivedrab: '#6b8e23',
		        orange: '#ffa500',
		        orangered: '#ff4500',
		        orchid: '#da70d6',
		        palegoldenrod: '#eee8aa',
		        palegreen: '#98fb98',
		        paleturquoise: '#afeeee',
		        palevioletred: '#db7093',
		        papayawhip: '#ffefd5',
		        peachpuff: '#ffdab9',
		        peru: '#cd853f',
		        pink: '#ffc0cb',
		        plum: '#dda0dd',
		        powderblue: '#b0e0e6',
		        purple: '#800080',
		        purple2: '#7f007f',
		        purple3: '#a020f0',
		        rebeccapurple: '#663399',
		        red: '#ff0000',
		        rosybrown: '#bc8f8f',
		        royalblue: '#4169e1',
		        saddlebrown: '#8b4513',
		        salmon: '#fa8072',
		        sandybrown: '#f4a460',
		        seagreen: '#2e8b57',
		        seashell: '#fff5ee',
		        sienna: '#a0522d',
		        silver: '#c0c0c0',
		        skyblue: '#87ceeb',
		        slateblue: '#6a5acd',
		        slategray: '#708090',
		        slategrey: '#708090',
		        snow: '#fffafa',
		        springgreen: '#00ff7f',
		        steelblue: '#4682b4',
		        tan: '#d2b48c',
		        teal: '#008080',
		        thistle: '#d8bfd8',
		        tomato: '#ff6347',
		        turquoise: '#40e0d0',
		        violet: '#ee82ee',
		        wheat: '#f5deb3',
		        white: '#ffffff',
		        whitesmoke: '#f5f5f5',
		        yellow: '#ffff00',
		        yellowgreen: '#9acd32'
		    };

		    var w3cx11_1 = w3cx11$1;

		    var Color$s = Color_1;
		    var input$5 = input$h;
		    var type$c = utils.type;

		    var w3cx11 = w3cx11_1;
		    var hex2rgb = hex2rgb_1;
		    var rgb2hex = rgb2hex_1;

		    Color$s.prototype.name = function() {
		        var hex = rgb2hex(this._rgb, 'rgb');
		        for (var i = 0, list = Object.keys(w3cx11); i < list.length; i += 1) {
		            var n = list[i];

		            if (w3cx11[n] === hex) { return n.toLowerCase(); }
		        }
		        return hex;
		    };

		    input$5.format.named = function (name) {
		        name = name.toLowerCase();
		        if (w3cx11[name]) { return hex2rgb(w3cx11[name]); }
		        throw new Error('unknown color name: '+name);
		    };

		    input$5.autodetect.push({
		        p: 5,
		        test: function (h) {
		            var rest = [], len = arguments.length - 1;
		            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];

		            if (!rest.length && type$c(h) === 'string' && w3cx11[h.toLowerCase()]) {
		                return 'named';
		            }
		        }
		    });

		    var unpack$8 = utils.unpack;

		    var rgb2num$1 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var ref = unpack$8(args, 'rgb');
		        var r = ref[0];
		        var g = ref[1];
		        var b = ref[2];
		        return (r << 16) + (g << 8) + b;
		    };

		    var rgb2num_1 = rgb2num$1;

		    var type$b = utils.type;

		    var num2rgb = function (num) {
		        if (type$b(num) == "number" && num >= 0 && num <= 0xFFFFFF) {
		            var r = num >> 16;
		            var g = (num >> 8) & 0xFF;
		            var b = num & 0xFF;
		            return [r,g,b,1];
		        }
		        throw new Error("unknown num color: "+num);
		    };

		    var num2rgb_1 = num2rgb;

		    var chroma$9 = chroma_1;
		    var Color$r = Color_1;
		    var input$4 = input$h;
		    var type$a = utils.type;

		    var rgb2num = rgb2num_1;

		    Color$r.prototype.num = function() {
		        return rgb2num(this._rgb);
		    };

		    chroma$9.num = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$r, [ null ].concat( args, ['num']) ));
		    };

		    input$4.format.num = num2rgb_1;

		    input$4.autodetect.push({
		        p: 5,
		        test: function () {
		            var args = [], len = arguments.length;
		            while ( len-- ) args[ len ] = arguments[ len ];

		            if (args.length === 1 && type$a(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {
		                return 'num';
		            }
		        }
		    });

		    var chroma$8 = chroma_1;
		    var Color$q = Color_1;
		    var input$3 = input$h;
		    var unpack$7 = utils.unpack;
		    var type$9 = utils.type;
		    var round$1 = Math.round;

		    Color$q.prototype.rgb = function(rnd) {
		        if ( rnd === void 0 ) rnd=true;

		        if (rnd === false) { return this._rgb.slice(0,3); }
		        return this._rgb.slice(0,3).map(round$1);
		    };

		    Color$q.prototype.rgba = function(rnd) {
		        if ( rnd === void 0 ) rnd=true;

		        return this._rgb.slice(0,4).map(function (v,i) {
		            return i<3 ? (rnd === false ? v : round$1(v)) : v;
		        });
		    };

		    chroma$8.rgb = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$q, [ null ].concat( args, ['rgb']) ));
		    };

		    input$3.format.rgb = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var rgba = unpack$7(args, 'rgba');
		        if (rgba[3] === undefined) { rgba[3] = 1; }
		        return rgba;
		    };

		    input$3.autodetect.push({
		        p: 3,
		        test: function () {
		            var args = [], len = arguments.length;
		            while ( len-- ) args[ len ] = arguments[ len ];

		            args = unpack$7(args, 'rgba');
		            if (type$9(args) === 'array' && (args.length === 3 ||
		                args.length === 4 && type$9(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {
		                return 'rgb';
		            }
		        }
		    });

		    /*
		     * Based on implementation by Neil Bartlett
		     * https://github.com/neilbartlett/color-temperature
		     */

		    var log$1 = Math.log;

		    var temperature2rgb$1 = function (kelvin) {
		        var temp = kelvin / 100;
		        var r,g,b;
		        if (temp < 66) {
		            r = 255;
		            g = temp < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log$1(g);
		            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log$1(b);
		        } else {
		            r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log$1(r);
		            g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log$1(g);
		            b = 255;
		        }
		        return [r,g,b,1];
		    };

		    var temperature2rgb_1 = temperature2rgb$1;

		    /*
		     * Based on implementation by Neil Bartlett
		     * https://github.com/neilbartlett/color-temperature
		     **/

		    var temperature2rgb = temperature2rgb_1;
		    var unpack$6 = utils.unpack;
		    var round = Math.round;

		    var rgb2temperature$1 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var rgb = unpack$6(args, 'rgb');
		        var r = rgb[0], b = rgb[2];
		        var minTemp = 1000;
		        var maxTemp = 40000;
		        var eps = 0.4;
		        var temp;
		        while (maxTemp - minTemp > eps) {
		            temp = (maxTemp + minTemp) * 0.5;
		            var rgb$1 = temperature2rgb(temp);
		            if ((rgb$1[2] / rgb$1[0]) >= (b / r)) {
		                maxTemp = temp;
		            } else {
		                minTemp = temp;
		            }
		        }
		        return round(temp);
		    };

		    var rgb2temperature_1 = rgb2temperature$1;

		    var chroma$7 = chroma_1;
		    var Color$p = Color_1;
		    var input$2 = input$h;

		    var rgb2temperature = rgb2temperature_1;

		    Color$p.prototype.temp =
		    Color$p.prototype.kelvin =
		    Color$p.prototype.temperature = function() {
		        return rgb2temperature(this._rgb);
		    };

		    chroma$7.temp =
		    chroma$7.kelvin =
		    chroma$7.temperature = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$p, [ null ].concat( args, ['temp']) ));
		    };

		    input$2.format.temp =
		    input$2.format.kelvin =
		    input$2.format.temperature = temperature2rgb_1;

		    var unpack$5 = utils.unpack;
		    var cbrt = Math.cbrt;
		    var pow$8 = Math.pow;
		    var sign$1 = Math.sign;

		    var rgb2oklab$2 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        // OKLab color space implementation taken from
		        // https://bottosson.github.io/posts/oklab/
		        var ref = unpack$5(args, 'rgb');
		        var r = ref[0];
		        var g = ref[1];
		        var b = ref[2];
		        var ref$1 = [rgb2lrgb(r / 255), rgb2lrgb(g / 255), rgb2lrgb(b / 255)];
		        var lr = ref$1[0];
		        var lg = ref$1[1];
		        var lb = ref$1[2];
		        var l = cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
		        var m = cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
		        var s = cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);

		        return [
		            0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,
		            1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,
		            0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s
		        ];
		    };

		    var rgb2oklab_1 = rgb2oklab$2;

		    function rgb2lrgb(c) {
		        var abs = Math.abs(c);
		        if (abs < 0.04045) {
		            return c / 12.92;
		        }
		        return (sign$1(c) || 1) * pow$8((abs + 0.055) / 1.055, 2.4);
		    }

		    var unpack$4 = utils.unpack;
		    var pow$7 = Math.pow;
		    var sign = Math.sign;

		    /*
		     * L* [0..100]
		     * a [-100..100]
		     * b [-100..100]
		     */
		    var oklab2rgb$1 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        args = unpack$4(args, 'lab');
		        var L = args[0];
		        var a = args[1];
		        var b = args[2];

		        var l = pow$7(L + 0.3963377774 * a + 0.2158037573 * b, 3);
		        var m = pow$7(L - 0.1055613458 * a - 0.0638541728 * b, 3);
		        var s = pow$7(L - 0.0894841775 * a - 1.291485548 * b, 3);

		        return [
		            255 * lrgb2rgb(+4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s),
		            255 * lrgb2rgb(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s),
		            255 * lrgb2rgb(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s),
		            args.length > 3 ? args[3] : 1
		        ];
		    };

		    var oklab2rgb_1 = oklab2rgb$1;

		    function lrgb2rgb(c) {
		        var abs = Math.abs(c);
		        if (abs > 0.0031308) {
		            return (sign(c) || 1) * (1.055 * pow$7(abs, 1 / 2.4) - 0.055);
		        }
		        return c * 12.92;
		    }

		    var unpack$3 = utils.unpack;
		    var type$8 = utils.type;
		    var chroma$6 = chroma_1;
		    var Color$o = Color_1;
		    var input$1 = input$h;

		    var rgb2oklab$1 = rgb2oklab_1;

		    Color$o.prototype.oklab = function () {
		        return rgb2oklab$1(this._rgb);
		    };

		    chroma$6.oklab = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$o, [ null ].concat( args, ['oklab']) ));
		    };

		    input$1.format.oklab = oklab2rgb_1;

		    input$1.autodetect.push({
		        p: 3,
		        test: function () {
		            var args = [], len = arguments.length;
		            while ( len-- ) args[ len ] = arguments[ len ];

		            args = unpack$3(args, 'oklab');
		            if (type$8(args) === 'array' && args.length === 3) {
		                return 'oklab';
		            }
		        }
		    });

		    var unpack$2 = utils.unpack;
		    var rgb2oklab = rgb2oklab_1;
		    var lab2lch = lab2lch_1;

		    var rgb2oklch$1 = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        var ref = unpack$2(args, 'rgb');
		        var r = ref[0];
		        var g = ref[1];
		        var b = ref[2];
		        var ref$1 = rgb2oklab(r, g, b);
		        var l = ref$1[0];
		        var a = ref$1[1];
		        var b_ = ref$1[2];
		        return lab2lch(l, a, b_);
		    };

		    var rgb2oklch_1 = rgb2oklch$1;

		    var unpack$1 = utils.unpack;
		    var lch2lab = lch2lab_1;
		    var oklab2rgb = oklab2rgb_1;

		    var oklch2rgb = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        args = unpack$1(args, 'lch');
		        var l = args[0];
		        var c = args[1];
		        var h = args[2];
		        var ref = lch2lab(l, c, h);
		        var L = ref[0];
		        var a = ref[1];
		        var b_ = ref[2];
		        var ref$1 = oklab2rgb(L, a, b_);
		        var r = ref$1[0];
		        var g = ref$1[1];
		        var b = ref$1[2];
		        return [r, g, b, args.length > 3 ? args[3] : 1];
		    };

		    var oklch2rgb_1 = oklch2rgb;

		    var unpack = utils.unpack;
		    var type$7 = utils.type;
		    var chroma$5 = chroma_1;
		    var Color$n = Color_1;
		    var input = input$h;

		    var rgb2oklch = rgb2oklch_1;

		    Color$n.prototype.oklch = function () {
		        return rgb2oklch(this._rgb);
		    };

		    chroma$5.oklch = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        return new (Function.prototype.bind.apply( Color$n, [ null ].concat( args, ['oklch']) ));
		    };

		    input.format.oklch = oklch2rgb_1;

		    input.autodetect.push({
		        p: 3,
		        test: function () {
		            var args = [], len = arguments.length;
		            while ( len-- ) args[ len ] = arguments[ len ];

		            args = unpack(args, 'oklch');
		            if (type$7(args) === 'array' && args.length === 3) {
		                return 'oklch';
		            }
		        }
		    });

		    var Color$m = Color_1;
		    var type$6 = utils.type;

		    Color$m.prototype.alpha = function(a, mutate) {
		        if ( mutate === void 0 ) mutate=false;

		        if (a !== undefined && type$6(a) === 'number') {
		            if (mutate) {
		                this._rgb[3] = a;
		                return this;
		            }
		            return new Color$m([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');
		        }
		        return this._rgb[3];
		    };

		    var Color$l = Color_1;

		    Color$l.prototype.clipped = function() {
		        return this._rgb._clipped || false;
		    };

		    var Color$k = Color_1;
		    var LAB_CONSTANTS$1 = labConstants;

		    Color$k.prototype.darken = function(amount) {
		    	if ( amount === void 0 ) amount=1;

		    	var me = this;
		    	var lab = me.lab();
		    	lab[0] -= LAB_CONSTANTS$1.Kn * amount;
		    	return new Color$k(lab, 'lab').alpha(me.alpha(), true);
		    };

		    Color$k.prototype.brighten = function(amount) {
		    	if ( amount === void 0 ) amount=1;

		    	return this.darken(-amount);
		    };

		    Color$k.prototype.darker = Color$k.prototype.darken;
		    Color$k.prototype.brighter = Color$k.prototype.brighten;

		    var Color$j = Color_1;

		    Color$j.prototype.get = function (mc) {
		        var ref = mc.split('.');
		        var mode = ref[0];
		        var channel = ref[1];
		        var src = this[mode]();
		        if (channel) {
		            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
		            if (i > -1) { return src[i]; }
		            throw new Error(("unknown channel " + channel + " in mode " + mode));
		        } else {
		            return src;
		        }
		    };

		    var Color$i = Color_1;
		    var type$5 = utils.type;
		    var pow$6 = Math.pow;

		    var EPS = 1e-7;
		    var MAX_ITER = 20;

		    Color$i.prototype.luminance = function(lum) {
		        if (lum !== undefined && type$5(lum) === 'number') {
		            if (lum === 0) {
		                // return pure black
		                return new Color$i([0,0,0,this._rgb[3]], 'rgb');
		            }
		            if (lum === 1) {
		                // return pure white
		                return new Color$i([255,255,255,this._rgb[3]], 'rgb');
		            }
		            // compute new color using...
		            var cur_lum = this.luminance();
		            var mode = 'rgb';
		            var max_iter = MAX_ITER;

		            var test = function (low, high) {
		                var mid = low.interpolate(high, 0.5, mode);
		                var lm = mid.luminance();
		                if (Math.abs(lum - lm) < EPS || !max_iter--) {
		                    // close enough
		                    return mid;
		                }
		                return lm > lum ? test(low, mid) : test(mid, high);
		            };

		            var rgb = (cur_lum > lum ? test(new Color$i([0,0,0]), this) : test(this, new Color$i([255,255,255]))).rgb();
		            return new Color$i(rgb.concat( [this._rgb[3]]));
		        }
		        return rgb2luminance.apply(void 0, (this._rgb).slice(0,3));
		    };


		    var rgb2luminance = function (r,g,b) {
		        // relative luminance
		        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
		        r = luminance_x(r);
		        g = luminance_x(g);
		        b = luminance_x(b);
		        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
		    };

		    var luminance_x = function (x) {
		        x /= 255;
		        return x <= 0.03928 ? x/12.92 : pow$6((x+0.055)/1.055, 2.4);
		    };

		    var interpolator$1 = {};

		    var Color$h = Color_1;
		    var type$4 = utils.type;
		    var interpolator = interpolator$1;

		    var mix$1 = function (col1, col2, f) {
		        if ( f === void 0 ) f=0.5;
		        var rest = [], len = arguments.length - 3;
		        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];

		        var mode = rest[0] || 'lrgb';
		        if (!interpolator[mode] && !rest.length) {
		            // fall back to the first supported mode
		            mode = Object.keys(interpolator)[0];
		        }
		        if (!interpolator[mode]) {
		            throw new Error(("interpolation mode " + mode + " is not defined"));
		        }
		        if (type$4(col1) !== 'object') { col1 = new Color$h(col1); }
		        if (type$4(col2) !== 'object') { col2 = new Color$h(col2); }
		        return interpolator[mode](col1, col2, f)
		            .alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
		    };

		    var Color$g = Color_1;
		    var mix = mix$1;

		    Color$g.prototype.mix =
		    Color$g.prototype.interpolate = function(col2, f) {
		    	if ( f === void 0 ) f=0.5;
		    	var rest = [], len = arguments.length - 2;
		    	while ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];

		    	return mix.apply(void 0, [ this, col2, f ].concat( rest ));
		    };

		    var Color$f = Color_1;

		    Color$f.prototype.premultiply = function(mutate) {
		    	if ( mutate === void 0 ) mutate=false;

		    	var rgb = this._rgb;
		    	var a = rgb[3];
		    	if (mutate) {
		    		this._rgb = [rgb[0]*a, rgb[1]*a, rgb[2]*a, a];
		    		return this;
		    	} else {
		    		return new Color$f([rgb[0]*a, rgb[1]*a, rgb[2]*a, a], 'rgb');
		    	}
		    };

		    var Color$e = Color_1;
		    var LAB_CONSTANTS = labConstants;

		    Color$e.prototype.saturate = function(amount) {
		    	if ( amount === void 0 ) amount=1;

		    	var me = this;
		    	var lch = me.lch();
		    	lch[1] += LAB_CONSTANTS.Kn * amount;
		    	if (lch[1] < 0) { lch[1] = 0; }
		    	return new Color$e(lch, 'lch').alpha(me.alpha(), true);
		    };

		    Color$e.prototype.desaturate = function(amount) {
		    	if ( amount === void 0 ) amount=1;

		    	return this.saturate(-amount);
		    };

		    var Color$d = Color_1;
		    var type$3 = utils.type;

		    Color$d.prototype.set = function (mc, value, mutate) {
		        if ( mutate === void 0 ) mutate = false;

		        var ref = mc.split('.');
		        var mode = ref[0];
		        var channel = ref[1];
		        var src = this[mode]();
		        if (channel) {
		            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);
		            if (i > -1) {
		                if (type$3(value) == 'string') {
		                    switch (value.charAt(0)) {
		                        case '+':
		                            src[i] += +value;
		                            break;
		                        case '-':
		                            src[i] += +value;
		                            break;
		                        case '*':
		                            src[i] *= +value.substr(1);
		                            break;
		                        case '/':
		                            src[i] /= +value.substr(1);
		                            break;
		                        default:
		                            src[i] = +value;
		                    }
		                } else if (type$3(value) === 'number') {
		                    src[i] = value;
		                } else {
		                    throw new Error("unsupported value for Color.set");
		                }
		                var out = new Color$d(src, mode);
		                if (mutate) {
		                    this._rgb = out._rgb;
		                    return this;
		                }
		                return out;
		            }
		            throw new Error(("unknown channel " + channel + " in mode " + mode));
		        } else {
		            return src;
		        }
		    };

		    var Color$c = Color_1;

		    var rgb = function (col1, col2, f) {
		        var xyz0 = col1._rgb;
		        var xyz1 = col2._rgb;
		        return new Color$c(
		            xyz0[0] + f * (xyz1[0]-xyz0[0]),
		            xyz0[1] + f * (xyz1[1]-xyz0[1]),
		            xyz0[2] + f * (xyz1[2]-xyz0[2]),
		            'rgb'
		        )
		    };

		    // register interpolator
		    interpolator$1.rgb = rgb;

		    var Color$b = Color_1;
		    var sqrt$2 = Math.sqrt;
		    var pow$5 = Math.pow;

		    var lrgb = function (col1, col2, f) {
		        var ref = col1._rgb;
		        var x1 = ref[0];
		        var y1 = ref[1];
		        var z1 = ref[2];
		        var ref$1 = col2._rgb;
		        var x2 = ref$1[0];
		        var y2 = ref$1[1];
		        var z2 = ref$1[2];
		        return new Color$b(
		            sqrt$2(pow$5(x1,2) * (1-f) + pow$5(x2,2) * f),
		            sqrt$2(pow$5(y1,2) * (1-f) + pow$5(y2,2) * f),
		            sqrt$2(pow$5(z1,2) * (1-f) + pow$5(z2,2) * f),
		            'rgb'
		        )
		    };

		    // register interpolator
		    interpolator$1.lrgb = lrgb;

		    var Color$a = Color_1;

		    var lab = function (col1, col2, f) {
		        var xyz0 = col1.lab();
		        var xyz1 = col2.lab();
		        return new Color$a(
		            xyz0[0] + f * (xyz1[0]-xyz0[0]),
		            xyz0[1] + f * (xyz1[1]-xyz0[1]),
		            xyz0[2] + f * (xyz1[2]-xyz0[2]),
		            'lab'
		        )
		    };

		    // register interpolator
		    interpolator$1.lab = lab;

		    var Color$9 = Color_1;

		    var _hsx = function (col1, col2, f, m) {
		        var assign, assign$1;

		        var xyz0, xyz1;
		        if (m === 'hsl') {
		            xyz0 = col1.hsl();
		            xyz1 = col2.hsl();
		        } else if (m === 'hsv') {
		            xyz0 = col1.hsv();
		            xyz1 = col2.hsv();
		        } else if (m === 'hcg') {
		            xyz0 = col1.hcg();
		            xyz1 = col2.hcg();
		        } else if (m === 'hsi') {
		            xyz0 = col1.hsi();
		            xyz1 = col2.hsi();
		        } else if (m === 'lch' || m === 'hcl') {
		            m = 'hcl';
		            xyz0 = col1.hcl();
		            xyz1 = col2.hcl();
		        } else if (m === 'oklch') {
		            xyz0 = col1.oklch().reverse();
		            xyz1 = col2.oklch().reverse();
		        }

		        var hue0, hue1, sat0, sat1, lbv0, lbv1;
		        if (m.substr(0, 1) === 'h' || m === 'oklch') {
		            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);
		            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);
		        }

		        var sat, hue, lbv, dh;

		        if (!isNaN(hue0) && !isNaN(hue1)) {
		            // both colors have hue
		            if (hue1 > hue0 && hue1 - hue0 > 180) {
		                dh = hue1 - (hue0 + 360);
		            } else if (hue1 < hue0 && hue0 - hue1 > 180) {
		                dh = hue1 + 360 - hue0;
		            } else {
		                dh = hue1 - hue0;
		            }
		            hue = hue0 + f * dh;
		        } else if (!isNaN(hue0)) {
		            hue = hue0;
		            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }
		        } else if (!isNaN(hue1)) {
		            hue = hue1;
		            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }
		        } else {
		            hue = Number.NaN;
		        }

		        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }
		        lbv = lbv0 + f * (lbv1 - lbv0);
		        return m === 'oklch' ? new Color$9([lbv, sat, hue], m) : new Color$9([hue, sat, lbv], m);
		    };

		    var interpolate_hsx$5 = _hsx;

		    var lch = function (col1, col2, f) {
		    	return interpolate_hsx$5(col1, col2, f, 'lch');
		    };

		    // register interpolator
		    interpolator$1.lch = lch;
		    interpolator$1.hcl = lch;

		    var Color$8 = Color_1;

		    var num = function (col1, col2, f) {
		        var c1 = col1.num();
		        var c2 = col2.num();
		        return new Color$8(c1 + f * (c2-c1), 'num')
		    };

		    // register interpolator
		    interpolator$1.num = num;

		    var interpolate_hsx$4 = _hsx;

		    var hcg = function (col1, col2, f) {
		    	return interpolate_hsx$4(col1, col2, f, 'hcg');
		    };

		    // register interpolator
		    interpolator$1.hcg = hcg;

		    var interpolate_hsx$3 = _hsx;

		    var hsi = function (col1, col2, f) {
		    	return interpolate_hsx$3(col1, col2, f, 'hsi');
		    };

		    // register interpolator
		    interpolator$1.hsi = hsi;

		    var interpolate_hsx$2 = _hsx;

		    var hsl = function (col1, col2, f) {
		    	return interpolate_hsx$2(col1, col2, f, 'hsl');
		    };

		    // register interpolator
		    interpolator$1.hsl = hsl;

		    var interpolate_hsx$1 = _hsx;

		    var hsv = function (col1, col2, f) {
		    	return interpolate_hsx$1(col1, col2, f, 'hsv');
		    };

		    // register interpolator
		    interpolator$1.hsv = hsv;

		    var Color$7 = Color_1;

		    var oklab = function (col1, col2, f) {
		        var xyz0 = col1.oklab();
		        var xyz1 = col2.oklab();
		        return new Color$7(
		            xyz0[0] + f * (xyz1[0] - xyz0[0]),
		            xyz0[1] + f * (xyz1[1] - xyz0[1]),
		            xyz0[2] + f * (xyz1[2] - xyz0[2]),
		            'oklab'
		        );
		    };

		    // register interpolator
		    interpolator$1.oklab = oklab;

		    var interpolate_hsx = _hsx;

		    var oklch = function (col1, col2, f) {
		        return interpolate_hsx(col1, col2, f, 'oklch');
		    };

		    // register interpolator
		    interpolator$1.oklch = oklch;

		    var Color$6 = Color_1;
		    var clip_rgb$1 = utils.clip_rgb;
		    var pow$4 = Math.pow;
		    var sqrt$1 = Math.sqrt;
		    var PI$1 = Math.PI;
		    var cos$2 = Math.cos;
		    var sin$2 = Math.sin;
		    var atan2$1 = Math.atan2;

		    var average = function (colors, mode, weights) {
		        if ( mode === void 0 ) mode='lrgb';
		        if ( weights === void 0 ) weights=null;

		        var l = colors.length;
		        if (!weights) { weights = Array.from(new Array(l)).map(function () { return 1; }); }
		        // normalize weights
		        var k = l / weights.reduce(function(a, b) { return a + b; });
		        weights.forEach(function (w,i) { weights[i] *= k; });
		        // convert colors to Color objects
		        colors = colors.map(function (c) { return new Color$6(c); });
		        if (mode === 'lrgb') {
		            return _average_lrgb(colors, weights)
		        }
		        var first = colors.shift();
		        var xyz = first.get(mode);
		        var cnt = [];
		        var dx = 0;
		        var dy = 0;
		        // initial color
		        for (var i=0; i<xyz.length; i++) {
		            xyz[i] = (xyz[i] || 0) * weights[0];
		            cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);
		            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {
		                var A = xyz[i] / 180 * PI$1;
		                dx += cos$2(A) * weights[0];
		                dy += sin$2(A) * weights[0];
		            }
		        }

		        var alpha = first.alpha() * weights[0];
		        colors.forEach(function (c,ci) {
		            var xyz2 = c.get(mode);
		            alpha += c.alpha() * weights[ci+1];
		            for (var i=0; i<xyz.length; i++) {
		                if (!isNaN(xyz2[i])) {
		                    cnt[i] += weights[ci+1];
		                    if (mode.charAt(i) === 'h') {
		                        var A = xyz2[i] / 180 * PI$1;
		                        dx += cos$2(A) * weights[ci+1];
		                        dy += sin$2(A) * weights[ci+1];
		                    } else {
		                        xyz[i] += xyz2[i] * weights[ci+1];
		                    }
		                }
		            }
		        });

		        for (var i$1=0; i$1<xyz.length; i$1++) {
		            if (mode.charAt(i$1) === 'h') {
		                var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;
		                while (A$1 < 0) { A$1 += 360; }
		                while (A$1 >= 360) { A$1 -= 360; }
		                xyz[i$1] = A$1;
		            } else {
		                xyz[i$1] = xyz[i$1]/cnt[i$1];
		            }
		        }
		        alpha /= l;
		        return (new Color$6(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true);
		    };


		    var _average_lrgb = function (colors, weights) {
		        var l = colors.length;
		        var xyz = [0,0,0,0];
		        for (var i=0; i < colors.length; i++) {
		            var col = colors[i];
		            var f = weights[i] / l;
		            var rgb = col._rgb;
		            xyz[0] += pow$4(rgb[0],2) * f;
		            xyz[1] += pow$4(rgb[1],2) * f;
		            xyz[2] += pow$4(rgb[2],2) * f;
		            xyz[3] += rgb[3] * f;
		        }
		        xyz[0] = sqrt$1(xyz[0]);
		        xyz[1] = sqrt$1(xyz[1]);
		        xyz[2] = sqrt$1(xyz[2]);
		        if (xyz[3] > 0.9999999) { xyz[3] = 1; }
		        return new Color$6(clip_rgb$1(xyz));
		    };

		    // minimal multi-purpose interface

		    // @requires utils color analyze

		    var chroma$4 = chroma_1;
		    var type$2 = utils.type;

		    var pow$3 = Math.pow;

		    var scale$2 = function(colors) {

		        // constructor
		        var _mode = 'rgb';
		        var _nacol = chroma$4('#ccc');
		        var _spread = 0;
		        // const _fixed = false;
		        var _domain = [0, 1];
		        var _pos = [];
		        var _padding = [0,0];
		        var _classes = false;
		        var _colors = [];
		        var _out = false;
		        var _min = 0;
		        var _max = 1;
		        var _correctLightness = false;
		        var _colorCache = {};
		        var _useCache = true;
		        var _gamma = 1;

		        // private methods

		        var setColors = function(colors) {
		            colors = colors || ['#fff', '#000'];
		            if (colors && type$2(colors) === 'string' && chroma$4.brewer &&
		                chroma$4.brewer[colors.toLowerCase()]) {
		                colors = chroma$4.brewer[colors.toLowerCase()];
		            }
		            if (type$2(colors) === 'array') {
		                // handle single color
		                if (colors.length === 1) {
		                    colors = [colors[0], colors[0]];
		                }
		                // make a copy of the colors
		                colors = colors.slice(0);
		                // convert to chroma classes
		                for (var c=0; c<colors.length; c++) {
		                    colors[c] = chroma$4(colors[c]);
		                }
		                // auto-fill color position
		                _pos.length = 0;
		                for (var c$1=0; c$1<colors.length; c$1++) {
		                    _pos.push(c$1/(colors.length-1));
		                }
		            }
		            resetCache();
		            return _colors = colors;
		        };

		        var getClass = function(value) {
		            if (_classes != null) {
		                var n = _classes.length-1;
		                var i = 0;
		                while (i < n && value >= _classes[i]) {
		                    i++;
		                }
		                return i-1;
		            }
		            return 0;
		        };

		        var tMapLightness = function (t) { return t; };
		        var tMapDomain = function (t) { return t; };

		        // const classifyValue = function(value) {
		        //     let val = value;
		        //     if (_classes.length > 2) {
		        //         const n = _classes.length-1;
		        //         const i = getClass(value);
		        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class
		        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class
		        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));
		        //     }
		        //     return val;
		        // };

		        var getColor = function(val, bypassMap) {
		            var col, t;
		            if (bypassMap == null) { bypassMap = false; }
		            if (isNaN(val) || (val === null)) { return _nacol; }
		            if (!bypassMap) {
		                if (_classes && (_classes.length > 2)) {
		                    // find the class
		                    var c = getClass(val);
		                    t = c / (_classes.length-2);
		                } else if (_max !== _min) {
		                    // just interpolate between min/max
		                    t = (val - _min) / (_max - _min);
		                } else {
		                    t = 1;
		                }
		            } else {
		                t = val;
		            }

		            // domain map
		            t = tMapDomain(t);

		            if (!bypassMap) {
		                t = tMapLightness(t);  // lightness correction
		            }

		            if (_gamma !== 1) { t = pow$3(t, _gamma); }

		            t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));

		            t = Math.min(1, Math.max(0, t));

		            var k = Math.floor(t * 10000);

		            if (_useCache && _colorCache[k]) {
		                col = _colorCache[k];
		            } else {
		                if (type$2(_colors) === 'array') {
		                    //for i in [0.._pos.length-1]
		                    for (var i=0; i<_pos.length; i++) {
		                        var p = _pos[i];
		                        if (t <= p) {
		                            col = _colors[i];
		                            break;
		                        }
		                        if ((t >= p) && (i === (_pos.length-1))) {
		                            col = _colors[i];
		                            break;
		                        }
		                        if (t > p && t < _pos[i+1]) {
		                            t = (t-p)/(_pos[i+1]-p);
		                            col = chroma$4.interpolate(_colors[i], _colors[i+1], t, _mode);
		                            break;
		                        }
		                    }
		                } else if (type$2(_colors) === 'function') {
		                    col = _colors(t);
		                }
		                if (_useCache) { _colorCache[k] = col; }
		            }
		            return col;
		        };

		        var resetCache = function () { return _colorCache = {}; };

		        setColors(colors);

		        // public interface

		        var f = function(v) {
		            var c = chroma$4(getColor(v));
		            if (_out && c[_out]) { return c[_out](); } else { return c; }
		        };

		        f.classes = function(classes) {
		            if (classes != null) {
		                if (type$2(classes) === 'array') {
		                    _classes = classes;
		                    _domain = [classes[0], classes[classes.length-1]];
		                } else {
		                    var d = chroma$4.analyze(_domain);
		                    if (classes === 0) {
		                        _classes = [d.min, d.max];
		                    } else {
		                        _classes = chroma$4.limits(d, 'e', classes);
		                    }
		                }
		                return f;
		            }
		            return _classes;
		        };


		        f.domain = function(domain) {
		            if (!arguments.length) {
		                return _domain;
		            }
		            _min = domain[0];
		            _max = domain[domain.length-1];
		            _pos = [];
		            var k = _colors.length;
		            if ((domain.length === k) && (_min !== _max)) {
		                // update positions
		                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {
		                    var d = list[i];

		                  _pos.push((d-_min) / (_max-_min));
		                }
		            } else {
		                for (var c=0; c<k; c++) {
		                    _pos.push(c/(k-1));
		                }
		                if (domain.length > 2) {
		                    // set domain map
		                    var tOut = domain.map(function (d,i) { return i/(domain.length-1); });
		                    var tBreaks = domain.map(function (d) { return (d - _min) / (_max - _min); });
		                    if (!tBreaks.every(function (val, i) { return tOut[i] === val; })) {
		                        tMapDomain = function (t) {
		                            if (t <= 0 || t >= 1) { return t; }
		                            var i = 0;
		                            while (t >= tBreaks[i+1]) { i++; }
		                            var f = (t - tBreaks[i]) / (tBreaks[i+1] - tBreaks[i]);
		                            var out = tOut[i] + f * (tOut[i+1] - tOut[i]);
		                            return out;
		                        };
		                    }

		                }
		            }
		            _domain = [_min, _max];
		            return f;
		        };

		        f.mode = function(_m) {
		            if (!arguments.length) {
		                return _mode;
		            }
		            _mode = _m;
		            resetCache();
		            return f;
		        };

		        f.range = function(colors, _pos) {
		            setColors(colors);
		            return f;
		        };

		        f.out = function(_o) {
		            _out = _o;
		            return f;
		        };

		        f.spread = function(val) {
		            if (!arguments.length) {
		                return _spread;
		            }
		            _spread = val;
		            return f;
		        };

		        f.correctLightness = function(v) {
		            if (v == null) { v = true; }
		            _correctLightness = v;
		            resetCache();
		            if (_correctLightness) {
		                tMapLightness = function(t) {
		                    var L0 = getColor(0, true).lab()[0];
		                    var L1 = getColor(1, true).lab()[0];
		                    var pol = L0 > L1;
		                    var L_actual = getColor(t, true).lab()[0];
		                    var L_ideal = L0 + ((L1 - L0) * t);
		                    var L_diff = L_actual - L_ideal;
		                    var t0 = 0;
		                    var t1 = 1;
		                    var max_iter = 20;
		                    while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {
		                        (function() {
		                            if (pol) { L_diff *= -1; }
		                            if (L_diff < 0) {
		                                t0 = t;
		                                t += (t1 - t) * 0.5;
		                            } else {
		                                t1 = t;
		                                t += (t0 - t) * 0.5;
		                            }
		                            L_actual = getColor(t, true).lab()[0];
		                            return L_diff = L_actual - L_ideal;
		                        })();
		                    }
		                    return t;
		                };
		            } else {
		                tMapLightness = function (t) { return t; };
		            }
		            return f;
		        };

		        f.padding = function(p) {
		            if (p != null) {
		                if (type$2(p) === 'number') {
		                    p = [p,p];
		                }
		                _padding = p;
		                return f;
		            } else {
		                return _padding;
		            }
		        };

		        f.colors = function(numColors, out) {
		            // If no arguments are given, return the original colors that were provided
		            if (arguments.length < 2) { out = 'hex'; }
		            var result = [];

		            if (arguments.length === 0) {
		                result = _colors.slice(0);

		            } else if (numColors === 1) {
		                result = [f(0.5)];

		            } else if (numColors > 1) {
		                var dm = _domain[0];
		                var dd = _domain[1] - dm;
		                result = __range__(0, numColors, false).map(function (i) { return f( dm + ((i/(numColors-1)) * dd) ); });

		            } else { // returns all colors based on the defined classes
		                colors = [];
		                var samples = [];
		                if (_classes && (_classes.length > 2)) {
		                    for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
		                        samples.push((_classes[i-1]+_classes[i])*0.5);
		                    }
		                } else {
		                    samples = _domain;
		                }
		                result = samples.map(function (v) { return f(v); });
		            }

		            if (chroma$4[out]) {
		                result = result.map(function (c) { return c[out](); });
		            }
		            return result;
		        };

		        f.cache = function(c) {
		            if (c != null) {
		                _useCache = c;
		                return f;
		            } else {
		                return _useCache;
		            }
		        };

		        f.gamma = function(g) {
		            if (g != null) {
		                _gamma = g;
		                return f;
		            } else {
		                return _gamma;
		            }
		        };

		        f.nodata = function(d) {
		            if (d != null) {
		                _nacol = chroma$4(d);
		                return f;
		            } else {
		                return _nacol;
		            }
		        };

		        return f;
		    };

		    function __range__(left, right, inclusive) {
		      var range = [];
		      var ascending = left < right;
		      var end = !inclusive ? right : ascending ? right + 1 : right - 1;
		      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
		        range.push(i);
		      }
		      return range;
		    }

		    //
		    // interpolates between a set of colors uzing a bezier spline
		    //

		    // @requires utils lab
		    var Color$5 = Color_1;

		    var scale$1 = scale$2;

		    // nth row of the pascal triangle
		    var binom_row = function(n) {
		        var row = [1, 1];
		        for (var i = 1; i < n; i++) {
		            var newrow = [1];
		            for (var j = 1; j <= row.length; j++) {
		                newrow[j] = (row[j] || 0) + row[j - 1];
		            }
		            row = newrow;
		        }
		        return row;
		    };

		    var bezier = function(colors) {
		        var assign, assign$1, assign$2;

		        var I, lab0, lab1, lab2;
		        colors = colors.map(function (c) { return new Color$5(c); });
		        if (colors.length === 2) {
		            // linear interpolation
		            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);
		            I = function(t) {
		                var lab = ([0, 1, 2].map(function (i) { return lab0[i] + (t * (lab1[i] - lab0[i])); }));
		                return new Color$5(lab, 'lab');
		            };
		        } else if (colors.length === 3) {
		            // quadratic bezier interpolation
		            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);
		            I = function(t) {
		                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i]); }));
		                return new Color$5(lab, 'lab');
		            };
		        } else if (colors.length === 4) {
		            // cubic bezier interpolation
		            var lab3;
		            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);
		            I = function(t) {
		                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * lab1[i]) + (3 * (1-t) * t * t * lab2[i]) + (t*t*t * lab3[i]); }));
		                return new Color$5(lab, 'lab');
		            };
		        } else if (colors.length >= 5) {
		            // general case (degree n bezier)
		            var labs, row, n;
		            labs = colors.map(function (c) { return c.lab(); });
		            n = colors.length - 1;
		            row = binom_row(n);
		            I = function (t) {
		                var u = 1 - t;
		                var lab = ([0, 1, 2].map(function (i) { return labs.reduce(function (sum, el, j) { return (sum + row[j] * Math.pow( u, (n - j) ) * Math.pow( t, j ) * el[i]); }, 0); }));
		                return new Color$5(lab, 'lab');
		            };
		        } else {
		            throw new RangeError("No point in running bezier with only one color.")
		        }
		        return I;
		    };

		    var bezier_1 = function (colors) {
		        var f = bezier(colors);
		        f.scale = function () { return scale$1(f); };
		        return f;
		    };

		    /*
		     * interpolates between a set of colors uzing a bezier spline
		     * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/
		     */

		    var chroma$3 = chroma_1;

		    var blend = function (bottom, top, mode) {
		        if (!blend[mode]) {
		            throw new Error('unknown blend mode ' + mode);
		        }
		        return blend[mode](bottom, top);
		    };

		    var blend_f = function (f) { return function (bottom,top) {
		            var c0 = chroma$3(top).rgb();
		            var c1 = chroma$3(bottom).rgb();
		            return chroma$3.rgb(f(c0, c1));
		        }; };

		    var each = function (f) { return function (c0, c1) {
		            var out = [];
		            out[0] = f(c0[0], c1[0]);
		            out[1] = f(c0[1], c1[1]);
		            out[2] = f(c0[2], c1[2]);
		            return out;
		        }; };

		    var normal = function (a) { return a; };
		    var multiply = function (a,b) { return a * b / 255; };
		    var darken = function (a,b) { return a > b ? b : a; };
		    var lighten = function (a,b) { return a > b ? a : b; };
		    var screen = function (a,b) { return 255 * (1 - (1-a/255) * (1-b/255)); };
		    var overlay = function (a,b) { return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255 ) * ( 1 - b / 255 )); };
		    var burn = function (a,b) { return 255 * (1 - (1 - b / 255) / (a/255)); };
		    var dodge = function (a,b) {
		        if (a === 255) { return 255; }
		        a = 255 * (b / 255) / (1 - a / 255);
		        return a > 255 ? 255 : a
		    };

		    // # add = (a,b) ->
		    // #     if (a + b > 255) then 255 else a + b

		    blend.normal = blend_f(each(normal));
		    blend.multiply = blend_f(each(multiply));
		    blend.screen = blend_f(each(screen));
		    blend.overlay = blend_f(each(overlay));
		    blend.darken = blend_f(each(darken));
		    blend.lighten = blend_f(each(lighten));
		    blend.dodge = blend_f(each(dodge));
		    blend.burn = blend_f(each(burn));
		    // blend.add = blend_f(each(add));

		    var blend_1 = blend;

		    // cubehelix interpolation
		    // based on D.A. Green "A colour scheme for the display of astronomical intensity images"
		    // http://astron-soc.in/bulletin/11June/289392011.pdf

		    var type$1 = utils.type;
		    var clip_rgb = utils.clip_rgb;
		    var TWOPI = utils.TWOPI;
		    var pow$2 = Math.pow;
		    var sin$1 = Math.sin;
		    var cos$1 = Math.cos;
		    var chroma$2 = chroma_1;

		    var cubehelix = function(start, rotations, hue, gamma, lightness) {
		        if ( start === void 0 ) start=300;
		        if ( rotations === void 0 ) rotations=-1.5;
		        if ( hue === void 0 ) hue=1;
		        if ( gamma === void 0 ) gamma=1;
		        if ( lightness === void 0 ) lightness=[0,1];

		        var dh = 0, dl;
		        if (type$1(lightness) === 'array') {
		            dl = lightness[1] - lightness[0];
		        } else {
		            dl = 0;
		            lightness = [lightness, lightness];
		        }

		        var f = function(fract) {
		            var a = TWOPI * (((start+120)/360) + (rotations * fract));
		            var l = pow$2(lightness[0] + (dl * fract), gamma);
		            var h = dh !== 0 ? hue[0] + (fract * dh) : hue;
		            var amp = (h * l * (1-l)) / 2;
		            var cos_a = cos$1(a);
		            var sin_a = sin$1(a);
		            var r = l + (amp * ((-0.14861 * cos_a) + (1.78277* sin_a)));
		            var g = l + (amp * ((-0.29227 * cos_a) - (0.90649* sin_a)));
		            var b = l + (amp * (+1.97294 * cos_a));
		            return chroma$2(clip_rgb([r*255,g*255,b*255,1]));
		        };

		        f.start = function(s) {
		            if ((s == null)) { return start; }
		            start = s;
		            return f;
		        };

		        f.rotations = function(r) {
		            if ((r == null)) { return rotations; }
		            rotations = r;
		            return f;
		        };

		        f.gamma = function(g) {
		            if ((g == null)) { return gamma; }
		            gamma = g;
		            return f;
		        };

		        f.hue = function(h) {
		            if ((h == null)) { return hue; }
		            hue = h;
		            if (type$1(hue) === 'array') {
		                dh = hue[1] - hue[0];
		                if (dh === 0) { hue = hue[1]; }
		            } else {
		                dh = 0;
		            }
		            return f;
		        };

		        f.lightness = function(h) {
		            if ((h == null)) { return lightness; }
		            if (type$1(h) === 'array') {
		                lightness = h;
		                dl = h[1] - h[0];
		            } else {
		                lightness = [h,h];
		                dl = 0;
		            }
		            return f;
		        };

		        f.scale = function () { return chroma$2.scale(f); };

		        f.hue(hue);

		        return f;
		    };

		    var Color$4 = Color_1;
		    var digits = '0123456789abcdef';

		    var floor$1 = Math.floor;
		    var random = Math.random;

		    var random_1 = function () {
		        var code = '#';
		        for (var i=0; i<6; i++) {
		            code += digits.charAt(floor$1(random() * 16));
		        }
		        return new Color$4(code, 'hex');
		    };

		    var type = type$p;
		    var log = Math.log;
		    var pow$1 = Math.pow;
		    var floor = Math.floor;
		    var abs$1 = Math.abs;


		    var analyze = function (data, key) {
		        if ( key === void 0 ) key=null;

		        var r = {
		            min: Number.MAX_VALUE,
		            max: Number.MAX_VALUE*-1,
		            sum: 0,
		            values: [],
		            count: 0
		        };
		        if (type(data) === 'object') {
		            data = Object.values(data);
		        }
		        data.forEach(function (val) {
		            if (key && type(val) === 'object') { val = val[key]; }
		            if (val !== undefined && val !== null && !isNaN(val)) {
		                r.values.push(val);
		                r.sum += val;
		                if (val < r.min) { r.min = val; }
		                if (val > r.max) { r.max = val; }
		                r.count += 1;
		            }
		        });

		        r.domain = [r.min, r.max];

		        r.limits = function (mode, num) { return limits(r, mode, num); };

		        return r;
		    };


		    var limits = function (data, mode, num) {
		        if ( mode === void 0 ) mode='equal';
		        if ( num === void 0 ) num=7;

		        if (type(data) == 'array') {
		            data = analyze(data);
		        }
		        var min = data.min;
		        var max = data.max;
		        var values = data.values.sort(function (a,b) { return a-b; });

		        if (num === 1) { return [min,max]; }

		        var limits = [];

		        if (mode.substr(0,1) === 'c') { // continuous
		            limits.push(min);
		            limits.push(max);
		        }

		        if (mode.substr(0,1) === 'e') { // equal interval
		            limits.push(min);
		            for (var i=1; i<num; i++) {
		                limits.push(min+((i/num)*(max-min)));
		            }
		            limits.push(max);
		        }

		        else if (mode.substr(0,1) === 'l') { // log scale
		            if (min <= 0) {
		                throw new Error('Logarithmic scales are only possible for values > 0');
		            }
		            var min_log = Math.LOG10E * log(min);
		            var max_log = Math.LOG10E * log(max);
		            limits.push(min);
		            for (var i$1=1; i$1<num; i$1++) {
		                limits.push(pow$1(10, min_log + ((i$1/num) * (max_log - min_log))));
		            }
		            limits.push(max);
		        }

		        else if (mode.substr(0,1) === 'q') { // quantile scale
		            limits.push(min);
		            for (var i$2=1; i$2<num; i$2++) {
		                var p = ((values.length-1) * i$2)/num;
		                var pb = floor(p);
		                if (pb === p) {
		                    limits.push(values[pb]);
		                } else { // p > pb
		                    var pr = p - pb;
		                    limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));
		                }
		            }
		            limits.push(max);

		        }

		        else if (mode.substr(0,1) === 'k') { // k-means clustering
		            /*
		            implementation based on
		            http://code.google.com/p/figue/source/browse/trunk/figue.js#336
		            simplified for 1-d input values
		            */
		            var cluster;
		            var n = values.length;
		            var assignments = new Array(n);
		            var clusterSizes = new Array(num);
		            var repeat = true;
		            var nb_iters = 0;
		            var centroids = null;

		            // get seed values
		            centroids = [];
		            centroids.push(min);
		            for (var i$3=1; i$3<num; i$3++) {
		                centroids.push(min + ((i$3/num) * (max-min)));
		            }
		            centroids.push(max);

		            while (repeat) {
		                // assignment step
		                for (var j=0; j<num; j++) {
		                    clusterSizes[j] = 0;
		                }
		                for (var i$4=0; i$4<n; i$4++) {
		                    var value = values[i$4];
		                    var mindist = Number.MAX_VALUE;
		                    var best = (void 0);
		                    for (var j$1=0; j$1<num; j$1++) {
		                        var dist = abs$1(centroids[j$1]-value);
		                        if (dist < mindist) {
		                            mindist = dist;
		                            best = j$1;
		                        }
		                        clusterSizes[best]++;
		                        assignments[i$4] = best;
		                    }
		                }

		                // update centroids step
		                var newCentroids = new Array(num);
		                for (var j$2=0; j$2<num; j$2++) {
		                    newCentroids[j$2] = null;
		                }
		                for (var i$5=0; i$5<n; i$5++) {
		                    cluster = assignments[i$5];
		                    if (newCentroids[cluster] === null) {
		                        newCentroids[cluster] = values[i$5];
		                    } else {
		                        newCentroids[cluster] += values[i$5];
		                    }
		                }
		                for (var j$3=0; j$3<num; j$3++) {
		                    newCentroids[j$3] *= 1/clusterSizes[j$3];
		                }

		                // check convergence
		                repeat = false;
		                for (var j$4=0; j$4<num; j$4++) {
		                    if (newCentroids[j$4] !== centroids[j$4]) {
		                        repeat = true;
		                        break;
		                    }
		                }

		                centroids = newCentroids;
		                nb_iters++;

		                if (nb_iters > 200) {
		                    repeat = false;
		                }
		            }

		            // finished k-means clustering
		            // the next part is borrowed from gabrielflor.it
		            var kClusters = {};
		            for (var j$5=0; j$5<num; j$5++) {
		                kClusters[j$5] = [];
		            }
		            for (var i$6=0; i$6<n; i$6++) {
		                cluster = assignments[i$6];
		                kClusters[cluster].push(values[i$6]);
		            }
		            var tmpKMeansBreaks = [];
		            for (var j$6=0; j$6<num; j$6++) {
		                tmpKMeansBreaks.push(kClusters[j$6][0]);
		                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length-1]);
		            }
		            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a,b){ return a-b; });
		            limits.push(tmpKMeansBreaks[0]);
		            for (var i$7=1; i$7 < tmpKMeansBreaks.length; i$7+= 2) {
		                var v = tmpKMeansBreaks[i$7];
		                if (!isNaN(v) && (limits.indexOf(v) === -1)) {
		                    limits.push(v);
		                }
		            }
		        }
		        return limits;
		    };

		    var analyze_1 = {analyze: analyze, limits: limits};

		    var Color$3 = Color_1;


		    var contrast = function (a, b) {
		        // WCAG contrast ratio
		        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
		        a = new Color$3(a);
		        b = new Color$3(b);
		        var l1 = a.luminance();
		        var l2 = b.luminance();
		        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
		    };

		    var Color$2 = Color_1;
		    var sqrt = Math.sqrt;
		    var pow = Math.pow;
		    var min = Math.min;
		    var max = Math.max;
		    var atan2 = Math.atan2;
		    var abs = Math.abs;
		    var cos = Math.cos;
		    var sin = Math.sin;
		    var exp = Math.exp;
		    var PI = Math.PI;

		    var deltaE = function(a, b, Kl, Kc, Kh) {
		        if ( Kl === void 0 ) Kl=1;
		        if ( Kc === void 0 ) Kc=1;
		        if ( Kh === void 0 ) Kh=1;

		        // Delta E (CIE 2000)
		        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html
		        var rad2deg = function(rad) {
		            return 360 * rad / (2 * PI);
		        };
		        var deg2rad = function(deg) {
		            return (2 * PI * deg) / 360;
		        };
		        a = new Color$2(a);
		        b = new Color$2(b);
		        var ref = Array.from(a.lab());
		        var L1 = ref[0];
		        var a1 = ref[1];
		        var b1 = ref[2];
		        var ref$1 = Array.from(b.lab());
		        var L2 = ref$1[0];
		        var a2 = ref$1[1];
		        var b2 = ref$1[2];
		        var avgL = (L1 + L2)/2;
		        var C1 = sqrt(pow(a1, 2) + pow(b1, 2));
		        var C2 = sqrt(pow(a2, 2) + pow(b2, 2));
		        var avgC = (C1 + C2)/2;
		        var G = 0.5*(1-sqrt(pow(avgC, 7)/(pow(avgC, 7) + pow(25, 7))));
		        var a1p = a1*(1+G);
		        var a2p = a2*(1+G);
		        var C1p = sqrt(pow(a1p, 2) + pow(b1, 2));
		        var C2p = sqrt(pow(a2p, 2) + pow(b2, 2));
		        var avgCp = (C1p + C2p)/2;
		        var arctan1 = rad2deg(atan2(b1, a1p));
		        var arctan2 = rad2deg(atan2(b2, a2p));
		        var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
		        var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
		        var avgHp = abs(h1p - h2p) > 180 ? (h1p + h2p + 360)/2 : (h1p + h2p)/2;
		        var T = 1 - 0.17*cos(deg2rad(avgHp - 30)) + 0.24*cos(deg2rad(2*avgHp)) + 0.32*cos(deg2rad(3*avgHp + 6)) - 0.2*cos(deg2rad(4*avgHp - 63));
		        var deltaHp = h2p - h1p;
		        deltaHp = abs(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
		        deltaHp = 2*sqrt(C1p*C2p)*sin(deg2rad(deltaHp)/2);
		        var deltaL = L2 - L1;
		        var deltaCp = C2p - C1p;    
		        var sl = 1 + (0.015*pow(avgL - 50, 2))/sqrt(20 + pow(avgL - 50, 2));
		        var sc = 1 + 0.045*avgCp;
		        var sh = 1 + 0.015*avgCp*T;
		        var deltaTheta = 30*exp(-pow((avgHp - 275)/25, 2));
		        var Rc = 2*sqrt(pow(avgCp, 7)/(pow(avgCp, 7) + pow(25, 7)));
		        var Rt = -Rc*sin(2*deg2rad(deltaTheta));
		        var result = sqrt(pow(deltaL/(Kl*sl), 2) + pow(deltaCp/(Kc*sc), 2) + pow(deltaHp/(Kh*sh), 2) + Rt*(deltaCp/(Kc*sc))*(deltaHp/(Kh*sh)));
		        return max(0, min(100, result));
		    };

		    var Color$1 = Color_1;

		    // simple Euclidean distance
		    var distance = function(a, b, mode) {
		        if ( mode === void 0 ) mode='lab';

		        // Delta E (CIE 1976)
		        // see http://www.brucelindbloom.com/index.html?Equations.html
		        a = new Color$1(a);
		        b = new Color$1(b);
		        var l1 = a.get(mode);
		        var l2 = b.get(mode);
		        var sum_sq = 0;
		        for (var i in l1) {
		            var d = (l1[i] || 0) - (l2[i] || 0);
		            sum_sq += d*d;
		        }
		        return Math.sqrt(sum_sq);
		    };

		    var Color = Color_1;

		    var valid = function () {
		        var args = [], len = arguments.length;
		        while ( len-- ) args[ len ] = arguments[ len ];

		        try {
		            new (Function.prototype.bind.apply( Color, [ null ].concat( args) ));
		            return true;
		        } catch (e) {
		            return false;
		        }
		    };

		    // some pre-defined color scales:
		    var chroma$1 = chroma_1;

		    var scale = scale$2;

		    var scales = {
		    	cool: function cool() { return scale([chroma$1.hsl(180,1,.9), chroma$1.hsl(250,.7,.4)]) },
		    	hot: function hot() { return scale(['#000','#f00','#ff0','#fff']).mode('rgb') }
		    };

		    /**
		        ColorBrewer colors for chroma.js

		        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
		        Pennsylvania State University.

		        Licensed under the Apache License, Version 2.0 (the "License");
		        you may not use this file except in compliance with the License.
		        You may obtain a copy of the License at
		        http://www.apache.org/licenses/LICENSE-2.0

		        Unless required by applicable law or agreed to in writing, software distributed
		        under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
		        CONDITIONS OF ANY KIND, either express or implied. See the License for the
		        specific language governing permissions and limitations under the License.
		    */

		    var colorbrewer = {
		        // sequential
		        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
		        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
		        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
		        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
		        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
		        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
		        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
		        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
		        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
		        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
		        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
		        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
		        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
		        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
		        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
		        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
		        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
		        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
		        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],

		        // diverging

		        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
		        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
		        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
		        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
		        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
		        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
		        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
		        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
		        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],

		        // qualitative

		        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
		        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
		        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
		        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
		        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
		        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
		        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
		        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
		    };

		    // add lowercase aliases for case-insensitive matches
		    for (var i = 0, list = Object.keys(colorbrewer); i < list.length; i += 1) {
		        var key = list[i];

		        colorbrewer[key.toLowerCase()] = colorbrewer[key];
		    }

		    var colorbrewer_1 = colorbrewer;

		    var chroma = chroma_1;

		    // feel free to comment out anything to rollup
		    // a smaller chroma.js built

		    // io --> convert colors

















		    // operators --> modify existing Colors










		    // interpolators












		    // generators -- > create new colors
		    chroma.average = average;
		    chroma.bezier = bezier_1;
		    chroma.blend = blend_1;
		    chroma.cubehelix = cubehelix;
		    chroma.mix = chroma.interpolate = mix$1;
		    chroma.random = random_1;
		    chroma.scale = scale$2;

		    // other utility methods
		    chroma.analyze = analyze_1.analyze;
		    chroma.contrast = contrast;
		    chroma.deltaE = deltaE;
		    chroma.distance = distance;
		    chroma.limits = analyze_1.limits;
		    chroma.valid = valid;

		    // scale
		    chroma.scales = scales;

		    // colors
		    chroma.colors = w3cx11_1;
		    chroma.brewer = colorbrewer_1;

		    var chroma_js = chroma;

		    return chroma_js;

		})); 
	} (chroma$1));

	var chromaExports = chroma$1.exports;
	var chroma = /*@__PURE__*/getDefaultExportFromCjs(chromaExports);

	/**
	 * @param {Object} params
	 * @param {string} params.min_reservation_date
	 * @param {string} params.max_reservation_date
	 * @param {string} params.service_id
	 * @param {string} params.location_id
	 * @param {string} params.employee_id
	 * @param {string} params.orderby
	 * @param {string} params.order
	 */
	async function get_reservations_list(params) {
	  let events = [];
	  let args = {};
	  if (params.min_reservation_date !== '') {
	    args.min_reservation_date = params.min_reservation_date;
	  }
	  if (params.max_reservation_date !== '') {
	    args.max_reservation_date = params.max_reservation_date;
	  }
	  if (params.service_id !== '') {
	    args.service_id = params.service_id;
	  }
	  if (params.location_id !== '') {
	    args.location_id = params.location_id;
	  }
	  if (params.employee_id !== '') {
	    args.employee_id = params.employee_id;
	  }
	  if (params.orderby !== '') {
	    args.orderby = params.orderby;
	  }
	  if (params.order !== '') {
	    args.order = params.order;
	  }
	  const reservationsRequestPromise = get_reservations(args, true);
	  const allReservations = await get_all(reservationsRequestPromise);
	  allReservations.forEach(function (reservation) {
	    var _reservation$_embedde, _reservation$_embedde2, _reservation$_embedde3, _reservation$_embedde4;
	    let booking = (_reservation$_embedde = reservation._embedded?.booking_id?.[0]) !== null && _reservation$_embedde !== void 0 ? _reservation$_embedde : {};
	    let location = (_reservation$_embedde2 = reservation._embedded?.location_id?.[0]) !== null && _reservation$_embedde2 !== void 0 ? _reservation$_embedde2 : {};
	    let employee = (_reservation$_embedde3 = reservation._embedded?.employee_id?.[0]) !== null && _reservation$_embedde3 !== void 0 ? _reservation$_embedde3 : {};
	    let service = (_reservation$_embedde4 = reservation._embedded?.service_id?.[0]) !== null && _reservation$_embedde4 !== void 0 ? _reservation$_embedde4 : {};
	    events.push({
	      id: reservation.id,
	      title: '#' + reservation.id,
	      start: new Date(reservation.reservation_start_time),
	      end: new Date(reservation.reservation_end_time),
	      rich_info: {
	        reservation: {
	          capacity: reservation.capacity,
	          price: reservation.price
	        },
	        booking: {
	          id: booking?.id || 0,
	          status: booking?.status || '',
	          customer: {
	            name: booking?.customer?.name || '',
	            email: booking?.customer?.email || '',
	            phone: booking?.customer?.phone || ''
	          }
	        },
	        location: {
	          id: location?.id || 0,
	          title: location?.title || ''
	        },
	        employee: {
	          id: employee?.id || 0,
	          name: employee?.name || ''
	        },
	        service: {
	          id: service?.id || 0,
	          title: service?.title || ''
	        },
	        coupon: {
	          id: booking?.coupon || 0
	        },
	        payments: booking?.payments || []
	      }
	    });
	  });
	  return events;
	}

	/**
	 * @param {Object[]} options
	 *  @param {Number} options['value']
	 *  @param {String} options['label']
	 *  @param {String[]} options['categories']
	 *
	 * @return {Object[]}
	 *  {String} label
	 *  {Object[]} options
	 *      {Number} options['value']
	 *      {String} options['label']
	 */
	function group_options_by_categories(options) {
	  const grouped = mpa_array_group_by_key(options, item => item.categories);
	  return Object.keys(grouped).map(key => ({
	    label: window.wp.htmlEntities.decodeEntities(key),
	    options: grouped[key]
	  }));
	}
	async function get_services_list() {
	  let services = [];
	  const args = {
	    _fields: ['id', 'title', 'categories', 'color']
	  };
	  const servicesRequestPromise = get_services(args, false);
	  const allServices = await get_all(servicesRequestPromise);
	  allServices.map(function (service) {
	    services.push({
	      value: service.id,
	      label: service.title,
	      // Price need for use in coupons analytics.
	      // Better move price to another store
	      price: service.price,
	      backgroundColor: service.color,
	      textColor: chroma.contrast(service.color, 'white') > 4.5 ? 'white' : 'black',
	      categories: service.categories.map(category => category.name).filter(name => name !== undefined)
	    });
	  });
	  // sort by services label
	  services = mpa_array_sort_by_alphabetical_key(services, 'label');
	  // group services by service categories
	  services = group_options_by_categories(services);
	  // sort by categories
	  services = mpa_array_sort_by_alphabetical_key(services, 'label');
	  return services;
	}
	async function get_locations_list() {
	  let locations = [];
	  const args = {
	    _fields: ['id', 'title']
	  };
	  const locationsRequestPromise = get_locations(args, false);
	  const allLocations = await get_all(locationsRequestPromise);
	  allLocations.map(function (location) {
	    locations.push({
	      value: location.id,
	      label: location.title
	    });
	  });
	  return mpa_array_sort_by_alphabetical_key(locations, 'label');
	}
	async function get_employees_list() {
	  let employees = [];
	  const args = {
	    _fields: ['id', 'name']
	  };
	  const employeesRequestPromise = get_employees(args, false);
	  const allEmployees = await get_all(employeesRequestPromise);
	  allEmployees.map(function (employee) {
	    employees.push({
	      value: employee.id,
	      label: employee.name
	    });
	  });
	  return mpa_array_sort_by_alphabetical_key(employees, 'label');
	}

	class PromiseRaceConditionGuardUtils {
	  constructor() {
	    this.lastPromise = null;
	    this.cancel = () => {
	      this.lastPromise = null;
	    };
	  }
	  getGuardedPromise(promise) {
	    this.lastPromise = promise;
	    return this.lastPromise.then(this.preventRaceCondition());
	  }
	  preventRaceCondition() {
	    const currentPromise = this.lastPromise;
	    return response => {
	      if (this.lastPromise !== currentPromise) {
	        return new Promise(() => null);
	      }
	      return response;
	    };
	  }
	}

	class EventStore {
	  loading = false;
	  events = [];
	  constructor(urlFiltersStore, filtersStore, calendarStore) {
	    this.urlFiltersStore = urlFiltersStore;
	    this.filtersStore = filtersStore;
	    this.calendarStore = calendarStore;
	    makeAutoObservable(this);
	    this.fetchCalendarEvents = this.fetchCalendarEvents.bind(this);
	    this.applyFilterByStatuses = this.applyFilterByStatuses.bind(this);
	    this.raceConditionGuard = new PromiseRaceConditionGuardUtils();
	    this.urlFiltersStore.routerStore.subscribe(({
	      location
	    }) => {
	      this.fetchCalendarEvents();
	    });
	  }
	  applyFilterByStatuses(events) {
	    const selectedStatuses = this.urlFiltersStore.getStatuses().split(',');
	    if (Array.isArray(selectedStatuses) && selectedStatuses.length) {
	      events = events.filter(function (event) {
	        return true === selectedStatuses.includes(event.rich_info.booking.status);
	      });
	    }
	    return events;
	  }
	  getServiceColors(serviceId) {
	    const services = toJS(this.filtersStore.services);
	    let findedService = undefined;
	    services.forEach(serviceGroup => {
	      serviceGroup.options.forEach(service => {
	        if (service.value === serviceId) {
	          findedService = service;
	        }
	      });
	    });
	    return findedService;
	  }
	  applyColors(events) {
	    return events.map(event => {
	      const serviceColors = this.getServiceColors(event.rich_info.service.id);
	      if (serviceColors !== undefined) {
	        event.backgroundColor = serviceColors.backgroundColor;
	        event.textColor = serviceColors.textColor;
	      }
	      return event;
	    });
	  }
	  async fetchCalendarEvents() {
	    const params = {
	      min_reservation_date: this.calendarStore.start,
	      max_reservation_date: this.calendarStore.end,
	      service_id: this.urlFiltersStore.getServices(),
	      location_id: this.urlFiltersStore.getLocations(),
	      employee_id: this.urlFiltersStore.getEmployees(),
	      orderby: 'reservation_start_time'
	    };
	    this.loading = true;
	    this.raceConditionGuard.getGuardedPromise(get_reservations_list(params)).then(events => {
	      // We can't filter reservations by their booking status via api without additional requests, because reservations has only booking id, but not status.
	      // Apply filter by status after receiving data.
	      events = this.applyFilterByStatuses(events);
	      events = this.applyColors(events);
	      runInAction(() => {
	        this.calendarStore.defineTimePeriod(events);
	        this.events = events;
	        this.loading = false;
	      });
	    });
	  }
	}

	class PermissionStore {
	  constructor(rootStore) {
	    this.rootStore = rootStore;
	    this.edit_others_booking = mpaData.permissions.edit_others_mpa_bookings;
	  }
	}

	class FiltersStore {
	  servicesLoading = true;
	  locationsLoading = true;
	  employeesLoading = true;
	  locations = [];
	  services = [];
	  employees = [];
	  employeesDisabled = false;
	  statuses = [{
	    value: 'confirmed',
	    label: 'Confirmed'
	  }, {
	    value: 'pending',
	    label: 'Pending'
	  }, {
	    value: 'cancelled',
	    label: 'Cancelled'
	  }];
	  constructor(urlFiltersStore) {
	    this.urlFiltersStore = urlFiltersStore;
	    makeAutoObservable(this);
	    this.initServices();
	    this.initLocations();
	    this.initEmployees();
	  }
	  initServices() {
	    get_services_list().then(services => {
	      runInAction(() => {
	        this.services = services;
	        this.servicesLoading = false;
	      });
	    });
	  }
	  initLocations() {
	    get_locations_list().then(locations => {
	      runInAction(() => {
	        this.locations = locations;
	        this.locationsLoading = false;
	      });
	    });
	  }
	  initEmployees() {
	    get_employees_list().then(employees => {
	      runInAction(() => {
	        this.employees = employees;
	        this.employeesLoading = false;
	        if (employees.length === 1) {
	          this.urlFiltersStore.setEmployees(employees[0].value.toString());
	          this.employeesDisabled = true;
	        }
	      });
	    });
	  }
	}

	const browserHistory = createBrowserHistory();
	const routerStoreInstance = new RouterStore(browserHistory);
	class RootStore {
	  constructor() {
	    this.urlFiltersStore = new URLFiltersStore(routerStoreInstance);
	    this.calendarStore = new CalendarStore(this);
	    this.filtersStore = new FiltersStore(this.urlFiltersStore);
	    this.eventStore = new EventStore(this.urlFiltersStore, this.filtersStore, this.calendarStore);
	    this.permissionStore = new PermissionStore(this);
	  }
	}
	const StoresContext = React.createContext(new RootStore());

	// this will be the function available for the app to connect to the stores
	const useStores = () => React.useContext(StoresContext);

	const localTranslate = (text, domain = '') => text;
	const localTranslateWithContext = (text, context, domain = '') => text;
	const localSprintf = (format, ...args) => {
	  let argIndex = 0;
	  return format.replace(/%([sdf])/g, (match, specifier) => {
	    if (argIndex >= args.length) return match;
	    let value = args[argIndex++];
	    switch (specifier) {
	      case 's':
	        return String(value);
	      case 'd':
	        return parseInt(value, 10);
	      case 'f':
	        return parseFloat(value);
	      default:
	        return match;
	    }
	  });
	};
	const __ = typeof wp !== 'undefined' && wp.i18n && wp.i18n.__ ? wp.i18n.__ : localTranslate;
	typeof wp !== 'undefined' && wp.i18n && wp.i18n._x ? wp.i18n._x : localTranslateWithContext;
	const sprintf = typeof wp !== 'undefined' && wp.i18n && wp.i18n.sprintf ? wp.i18n.sprintf : localSprintf;

	/**
	 *
	 * @param props
	 * @param props.event
	 * @param props.localizer Optional
	 * @return {JSX.Element}
	 * @constructor
	 */
	const EventDetailsView = props => {
	  let date = '',
	    time = '',
	    bookingId = '',
	    bookingStatus = '',
	    employeeName = '',
	    serviceTitle = '',
	    locationTitle = '',
	    customerName = '',
	    customerEmail = '',
	    customerPhone = '',
	    bookingEditUrl = '',
	    locationEditUrl = '',
	    employeeEditUrl = '',
	    serviceEditUrl = '',
	    customerMailtoUrl = '',
	    customerTelUrl = '';
	  const {
	    event,
	    localizer
	  } = props;
	  if (event !== null) {
	    const bookingInfo = event.rich_info.booking;
	    const employeeInfo = event.rich_info.employee;
	    const serviceInfo = event.rich_info.service;
	    const locationInfo = event.rich_info.location;
	    bookingId = bookingInfo.id;
	    bookingStatus = bookingInfo.status;
	    bookingEditUrl = mpaData.urls.admin + "post.php?post=" + bookingId + "&action=edit";
	    customerName = bookingInfo.customer.name;
	    customerEmail = bookingInfo.customer.email;
	    customerPhone = bookingInfo.customer.phone;
	    customerMailtoUrl = "mailto:" + customerEmail;
	    customerTelUrl = "tel:" + customerPhone;
	    employeeName = employeeInfo.name;
	    employeeEditUrl = mpaData.urls.admin + "post.php?post=" + employeeInfo.id + "&action=edit";
	    serviceTitle = serviceInfo.title;
	    serviceEditUrl = mpaData.urls.admin + "post.php?post=" + serviceInfo.id + "&action=edit";
	    locationTitle = locationInfo.title;
	    locationEditUrl = mpaData.urls.admin + "post.php?post=" + locationInfo.id + "&action=edit";
	  }
	  if (localizer !== undefined && event.start !== undefined && event.end !== undefined) {
	    const start = localizer.format(event.start, 'LT');
	    const end = localizer.format(event.end, 'LT');
	    date = wp.element.createElement("div", {
	      className: "mpa-event-details__item"
	    }, wp.element.createElement("div", {
	      className: "mpa-event-details__item-title"
	    }, __('Date', 'motopress-appointment')), wp.element.createElement("div", {
	      className: "mpa-event-details__item-content"
	    }, localizer.format(event.start, 'll')));
	    time = wp.element.createElement("div", {
	      className: "mpa-event-details__item"
	    }, wp.element.createElement("div", {
	      className: "mpa-event-details__item-title"
	    }, __('Time', 'motopress-appointment')), wp.element.createElement("div", {
	      className: "mpa-event-details__item-content"
	    }, start, " - ", end));
	  }
	  return wp.element.createElement("div", {
	    className: "mpa-event-details"
	  }, wp.element.createElement("div", {
	    className: "mpa-event-details__item"
	  }, wp.element.createElement("div", {
	    className: "mpa-event-details__item-title"
	  }, __('Booking', 'motopress-appointment')), wp.element.createElement("div", {
	    className: "mpa-event-details__item-content"
	  }, wp.element.createElement("a", {
	    href: bookingEditUrl,
	    target: "_blank"
	  }, "#", bookingId))), wp.element.createElement("div", {
	    className: "mpa-event-details__item"
	  }, wp.element.createElement("div", {
	    className: "mpa-event-details__item-title"
	  }, __('Status', 'motopress-appointment')), wp.element.createElement("div", {
	    className: "mpa-event-details__item-content"
	  }, bookingStatus)), date, time, wp.element.createElement("div", {
	    className: "mpa-event-details__item"
	  }, wp.element.createElement("div", {
	    className: "mpa-event-details__item-title"
	  }, __('Employee', 'motopress-appointment')), wp.element.createElement("div", {
	    className: "mpa-event-details__item-content"
	  }, wp.element.createElement("a", {
	    href: employeeEditUrl,
	    target: "_blank"
	  }, employeeName))), wp.element.createElement("div", {
	    className: "mpa-event-details__item"
	  }, wp.element.createElement("div", {
	    className: "mpa-event-details__item-title"
	  }, __('Service', 'motopress-appointment')), wp.element.createElement("div", {
	    className: "mpa-event-details__item-content"
	  }, wp.element.createElement("a", {
	    href: serviceEditUrl,
	    target: "_blank"
	  }, serviceTitle))), wp.element.createElement("div", {
	    className: "mpa-event-details__item"
	  }, wp.element.createElement("div", {
	    className: "mpa-event-details__item-title"
	  }, __('Location', 'motopress-appointment')), wp.element.createElement("div", {
	    className: "mpa-event-details__item-content"
	  }, wp.element.createElement("a", {
	    href: locationEditUrl,
	    target: "_blank"
	  }, locationTitle))), wp.element.createElement("div", {
	    className: "mpa-event-details__item"
	  }, wp.element.createElement("div", {
	    className: "mpa-event-details__item-title"
	  }, __('Customer', 'motopress-appointment')), wp.element.createElement("div", {
	    className: "mpa-event-details__item-content mpa-event-customer-details"
	  }, wp.element.createElement("div", {
	    className: "mpa-event-customer-details__item"
	  }, customerName), wp.element.createElement("div", {
	    className: "mpa-event-customer-details__item"
	  }, wp.element.createElement("a", {
	    href: customerMailtoUrl
	  }, customerEmail)), wp.element.createElement("div", {
	    className: "mpa-event-customer-details__item"
	  }, wp.element.createElement("a", {
	    href: customerTelUrl
	  }, customerPhone)))));
	};

	const AgendaEvent = props => {
	  const {
	    event
	  } = props;
	  return wp.element.createElement("div", {
	    className: "rbc-agenda-event-cell-details"
	  }, wp.element.createElement(EventDetailsView, {
	    event: event
	  }));
	};

	const RichEvent = props => {
	  const {
	    event
	  } = props;
	  return wp.element.createElement(React.Fragment, null, wp.element.createElement("div", {
	    className: "mpa-rbc-event__service"
	  }, " ", event.rich_info.service.title, " "), wp.element.createElement("div", {
	    className: "mpa-rbc-event__employee"
	  }, " ", event.rich_info.employee.name, " "));
	};

	const {
	  Modal: Modal$1,
	  Button
	} = wp.components;
	function ModalWithFooter(props) {
	  const {
	    isOpen,
	    onRequestClose,
	    title,
	    content,
	    buttonLabel,
	    buttonUrl
	  } = props;
	  return wp.element.createElement(React.Fragment, null, isOpen && wp.element.createElement(Modal$1, {
	    title: title,
	    onRequestClose: onRequestClose,
	    className: "mpa-modal mpa-modal_with-footer"
	  }, wp.element.createElement("div", {
	    className: "mpa-modal-content"
	  }, content), wp.element.createElement("div", {
	    className: "mpa-modal-footer"
	  }, wp.element.createElement(Button, {
	    isPrimary: true,
	    href: buttonUrl,
	    target: "_blank"
	  }, buttonLabel))));
	}

	const {
	  Modal
	} = wp.components;
	function MpaModal(props) {
	  const {
	    isOpen,
	    onRequestClose,
	    title,
	    content
	  } = props;
	  return wp.element.createElement(React.Fragment, null, isOpen && wp.element.createElement(Modal, {
	    title: title,
	    onRequestClose: onRequestClose,
	    className: "mpa-modal"
	  }, wp.element.createElement("div", {
	    className: "mpa-modal-content"
	  }, content)));
	}

	function EventModal(props) {
	  const {
	    isOpen,
	    close,
	    event,
	    localizer
	  } = props;
	  const {
	    permissionStore
	  } = useStores();
	  let bookingId = '',
	    bookingEditUrl = '';
	  if (event !== null) {
	    bookingId = event.rich_info.booking.id;
	    bookingEditUrl = mpaData.urls.admin + "post.php?post=" + bookingId + "&action=edit";
	  }
	  return wp.element.createElement(React.Fragment, null, permissionStore.edit_others_booking ? wp.element.createElement(ModalWithFooter, {
	    isOpen: isOpen,
	    onRequestClose: close,
	    title: __('Reservation details', 'motopress-appointment'),
	    content: event && wp.element.createElement(EventDetailsView, {
	      event: event,
	      localizer: localizer
	    }),
	    buttonLabel: __('View Booking', 'motopress-appointment'),
	    buttonUrl: bookingEditUrl
	  }) : wp.element.createElement(MpaModal, {
	    isOpen: isOpen,
	    onRequestClose: close,
	    title: __('Reservation details', 'motopress-appointment'),
	    content: event && wp.element.createElement(EventDetailsView, {
	      event: event,
	      localizer: localizer
	    })
	  }));
	}

	var classnames = {exports: {}};

	/*!
		Copyright (c) 2018 Jed Watson.
		Licensed under the MIT License (MIT), see
		http://jedwatson.github.io/classnames
	*/

	(function (module) {
		/* global define */

		(function () {

			var hasOwn = {}.hasOwnProperty;

			function classNames() {
				var classes = [];

				for (var i = 0; i < arguments.length; i++) {
					var arg = arguments[i];
					if (!arg) continue;

					var argType = typeof arg;

					if (argType === 'string' || argType === 'number') {
						classes.push(arg);
					} else if (Array.isArray(arg)) {
						if (arg.length) {
							var inner = classNames.apply(null, arg);
							if (inner) {
								classes.push(inner);
							}
						}
					} else if (argType === 'object') {
						if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
							classes.push(arg.toString());
							continue;
						}

						for (var key in arg) {
							if (hasOwn.call(arg, key) && arg[key]) {
								classes.push(key);
							}
						}
					}
				}

				return classes.join(' ');
			}

			if (module.exports) {
				classNames.default = classNames;
				module.exports = classNames;
			} else {
				window.classNames = classNames;
			}
		}()); 
	} (classnames));

	var classnamesExports = classnames.exports;
	var classNames$1 = /*@__PURE__*/getDefaultExportFromCjs(classnamesExports);

	var jsxRuntime = {exports: {}};

	var reactJsxRuntime_production_min = {};

	/**
	 * @license React
	 * react-jsx-runtime.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var f$1=React$1,k$1=Symbol.for("react.element"),l$1=Symbol.for("react.fragment"),m$1=Object.prototype.hasOwnProperty,n$1=f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$1={key:!0,ref:!0,__self:!0,__source:!0};
	function q$1(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m$1.call(a,b)&&!p$1.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return {$$typeof:k$1,type:c,key:e,ref:h,props:d,_owner:n$1.current}}reactJsxRuntime_production_min.Fragment=l$1;reactJsxRuntime_production_min.jsx=q$1;reactJsxRuntime_production_min.jsxs=q$1;

	{
	  jsxRuntime.exports = reactJsxRuntime_production_min;
	}

	var jsxRuntimeExports = jsxRuntime.exports;

	const propTypes$1 = {
	  /**
	   * Specify whether the feedback is for valid or invalid fields
	   *
	   * @type {('valid'|'invalid')}
	   */
	  type: PropTypes.string,
	  /** Display feedback as a tooltip. */
	  tooltip: PropTypes.bool,
	  as: PropTypes.elementType
	};
	const Feedback = /*#__PURE__*/React__namespace.forwardRef(
	// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
	({
	  as: Component = 'div',
	  className,
	  type = 'valid',
	  tooltip = false,
	  ...props
	}, ref) => /*#__PURE__*/jsxRuntimeExports.jsx(Component, {
	  ...props,
	  ref: ref,
	  className: classNames$1(className, `${type}-${tooltip ? 'tooltip' : 'feedback'}`)
	}));
	Feedback.displayName = 'Feedback';
	Feedback.propTypes = propTypes$1;
	var Feedback$1 = Feedback;

	// TODO

	const FormContext = /*#__PURE__*/React__namespace.createContext({});
	var FormContext$1 = FormContext;

	const DEFAULT_BREAKPOINTS = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];
	const DEFAULT_MIN_BREAKPOINT = 'xs';
	const ThemeContext$1 = /*#__PURE__*/React__namespace.createContext({
	  prefixes: {},
	  breakpoints: DEFAULT_BREAKPOINTS,
	  minBreakpoint: DEFAULT_MIN_BREAKPOINT
	});
	function useBootstrapPrefix(prefix, defaultPrefix) {
	  const {
	    prefixes
	  } = React$1.useContext(ThemeContext$1);
	  return prefix || prefixes[defaultPrefix] || defaultPrefix;
	}
	function useBootstrapBreakpoints() {
	  const {
	    breakpoints
	  } = React$1.useContext(ThemeContext$1);
	  return breakpoints;
	}
	function useBootstrapMinBreakpoint() {
	  const {
	    minBreakpoint
	  } = React$1.useContext(ThemeContext$1);
	  return minBreakpoint;
	}

	const FormCheckInput = /*#__PURE__*/React__namespace.forwardRef(({
	  id,
	  bsPrefix,
	  className,
	  type = 'checkbox',
	  isValid = false,
	  isInvalid = false,
	  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
	  as: Component = 'input',
	  ...props
	}, ref) => {
	  const {
	    controlId
	  } = React$1.useContext(FormContext$1);
	  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-check-input');
	  return /*#__PURE__*/jsxRuntimeExports.jsx(Component, {
	    ...props,
	    ref: ref,
	    type: type,
	    id: id || controlId,
	    className: classNames$1(className, bsPrefix, isValid && 'is-valid', isInvalid && 'is-invalid')
	  });
	});
	FormCheckInput.displayName = 'FormCheckInput';
	var FormCheckInput$1 = FormCheckInput;

	const FormCheckLabel = /*#__PURE__*/React__namespace.forwardRef(({
	  bsPrefix,
	  className,
	  htmlFor,
	  ...props
	}, ref) => {
	  const {
	    controlId
	  } = React$1.useContext(FormContext$1);
	  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-check-label');
	  return /*#__PURE__*/jsxRuntimeExports.jsx("label", {
	    ...props,
	    ref: ref,
	    htmlFor: htmlFor || controlId,
	    className: classNames$1(className, bsPrefix)
	  });
	});
	FormCheckLabel.displayName = 'FormCheckLabel';
	var FormCheckLabel$1 = FormCheckLabel;

	/**
	 * Finds whether a component's `children` prop includes a React element of the
	 * specified type.
	 */
	function hasChildOfType(children, type) {
	  return React__namespace.Children.toArray(children).some(child => /*#__PURE__*/React__namespace.isValidElement(child) && child.type === type);
	}

	const FormCheck = /*#__PURE__*/React__namespace.forwardRef(({
	  id,
	  bsPrefix,
	  bsSwitchPrefix,
	  inline = false,
	  reverse = false,
	  disabled = false,
	  isValid = false,
	  isInvalid = false,
	  feedbackTooltip = false,
	  feedback,
	  feedbackType,
	  className,
	  style,
	  title = '',
	  type = 'checkbox',
	  label,
	  children,
	  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
	  as = 'input',
	  ...props
	}, ref) => {
	  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-check');
	  bsSwitchPrefix = useBootstrapPrefix(bsSwitchPrefix, 'form-switch');
	  const {
	    controlId
	  } = React$1.useContext(FormContext$1);
	  const innerFormContext = React$1.useMemo(() => ({
	    controlId: id || controlId
	  }), [controlId, id]);
	  const hasLabel = !children && label != null && label !== false || hasChildOfType(children, FormCheckLabel$1);
	  const input = /*#__PURE__*/jsxRuntimeExports.jsx(FormCheckInput$1, {
	    ...props,
	    type: type === 'switch' ? 'checkbox' : type,
	    ref: ref,
	    isValid: isValid,
	    isInvalid: isInvalid,
	    disabled: disabled,
	    as: as
	  });
	  return /*#__PURE__*/jsxRuntimeExports.jsx(FormContext$1.Provider, {
	    value: innerFormContext,
	    children: /*#__PURE__*/jsxRuntimeExports.jsx("div", {
	      style: style,
	      className: classNames$1(className, hasLabel && bsPrefix, inline && `${bsPrefix}-inline`, reverse && `${bsPrefix}-reverse`, type === 'switch' && bsSwitchPrefix),
	      children: children || /*#__PURE__*/jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
	        children: [input, hasLabel && /*#__PURE__*/jsxRuntimeExports.jsx(FormCheckLabel$1, {
	          title: title,
	          children: label
	        }), feedback && /*#__PURE__*/jsxRuntimeExports.jsx(Feedback$1, {
	          type: feedbackType,
	          tooltip: feedbackTooltip,
	          children: feedback
	        })]
	      })
	    })
	  });
	});
	FormCheck.displayName = 'FormCheck';
	var FormCheck$1 = Object.assign(FormCheck, {
	  Input: FormCheckInput$1,
	  Label: FormCheckLabel$1
	});

	const FormControl = /*#__PURE__*/React__namespace.forwardRef(({
	  bsPrefix,
	  type,
	  size,
	  htmlSize,
	  id,
	  className,
	  isValid = false,
	  isInvalid = false,
	  plaintext,
	  readOnly,
	  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
	  as: Component = 'input',
	  ...props
	}, ref) => {
	  const {
	    controlId
	  } = React$1.useContext(FormContext$1);
	  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-control');
	  let classes;
	  if (plaintext) {
	    classes = {
	      [`${bsPrefix}-plaintext`]: true
	    };
	  } else {
	    classes = {
	      [bsPrefix]: true,
	      [`${bsPrefix}-${size}`]: size
	    };
	  }
	  return /*#__PURE__*/jsxRuntimeExports.jsx(Component, {
	    ...props,
	    type: type,
	    size: htmlSize,
	    ref: ref,
	    readOnly: readOnly,
	    id: id || controlId,
	    className: classNames$1(className, classes, isValid && `is-valid`, isInvalid && `is-invalid`, type === 'color' && `${bsPrefix}-color`)
	  });
	});
	FormControl.displayName = 'FormControl';
	var FormControl$1 = Object.assign(FormControl, {
	  Feedback: Feedback$1
	});

	var rHyphen = /-(.)/g;
	function camelize(string) {
	  return string.replace(rHyphen, function (_, chr) {
	    return chr.toUpperCase();
	  });
	}

	const pascalCase = str => str[0].toUpperCase() + camelize(str).slice(1);
	// TODO: emstricten & fix the typing here! `createWithBsPrefix<TElementType>...`
	function createWithBsPrefix(prefix, {
	  displayName = pascalCase(prefix),
	  Component,
	  defaultProps
	} = {}) {
	  const BsComponent = /*#__PURE__*/React__namespace.forwardRef(({
	    className,
	    bsPrefix,
	    as: Tag = Component || 'div',
	    ...props
	  }, ref) => {
	    const componentProps = {
	      ...defaultProps,
	      ...props
	    };
	    const resolvedPrefix = useBootstrapPrefix(bsPrefix, prefix);
	    return /*#__PURE__*/jsxRuntimeExports.jsx(Tag, {
	      ref: ref,
	      className: classNames$1(className, resolvedPrefix),
	      ...componentProps
	    });
	  });
	  BsComponent.displayName = displayName;
	  return BsComponent;
	}

	var FormFloating = createWithBsPrefix('form-floating');

	const FormGroup = /*#__PURE__*/React__namespace.forwardRef(({
	  controlId,
	  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
	  as: Component = 'div',
	  ...props
	}, ref) => {
	  const context = React$1.useMemo(() => ({
	    controlId
	  }), [controlId]);
	  return /*#__PURE__*/jsxRuntimeExports.jsx(FormContext$1.Provider, {
	    value: context,
	    children: /*#__PURE__*/jsxRuntimeExports.jsx(Component, {
	      ...props,
	      ref: ref
	    })
	  });
	});
	FormGroup.displayName = 'FormGroup';
	var FormGroup$1 = FormGroup;

	function useCol({
	  as,
	  bsPrefix,
	  className,
	  ...props
	}) {
	  bsPrefix = useBootstrapPrefix(bsPrefix, 'col');
	  const breakpoints = useBootstrapBreakpoints();
	  const minBreakpoint = useBootstrapMinBreakpoint();
	  const spans = [];
	  const classes = [];
	  breakpoints.forEach(brkPoint => {
	    const propValue = props[brkPoint];
	    delete props[brkPoint];
	    let span;
	    let offset;
	    let order;
	    if (typeof propValue === 'object' && propValue != null) {
	      ({
	        span,
	        offset,
	        order
	      } = propValue);
	    } else {
	      span = propValue;
	    }
	    const infix = brkPoint !== minBreakpoint ? `-${brkPoint}` : '';
	    if (span) spans.push(span === true ? `${bsPrefix}${infix}` : `${bsPrefix}${infix}-${span}`);
	    if (order != null) classes.push(`order${infix}-${order}`);
	    if (offset != null) classes.push(`offset${infix}-${offset}`);
	  });
	  return [{
	    ...props,
	    className: classNames$1(className, ...spans, ...classes)
	  }, {
	    as,
	    bsPrefix,
	    spans
	  }];
	}
	const Col = /*#__PURE__*/React__namespace.forwardRef(
	// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
	(props, ref) => {
	  const [{
	    className,
	    ...colProps
	  }, {
	    as: Component = 'div',
	    bsPrefix,
	    spans
	  }] = useCol(props);
	  return /*#__PURE__*/jsxRuntimeExports.jsx(Component, {
	    ...colProps,
	    ref: ref,
	    className: classNames$1(className, !spans.length && bsPrefix)
	  });
	});
	Col.displayName = 'Col';
	var Col$1 = Col;

	const FormLabel = /*#__PURE__*/React__namespace.forwardRef(({
	  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
	  as: Component = 'label',
	  bsPrefix,
	  column = false,
	  visuallyHidden = false,
	  className,
	  htmlFor,
	  ...props
	}, ref) => {
	  const {
	    controlId
	  } = React$1.useContext(FormContext$1);
	  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-label');
	  let columnClass = 'col-form-label';
	  if (typeof column === 'string') columnClass = `${columnClass} ${columnClass}-${column}`;
	  const classes = classNames$1(className, bsPrefix, visuallyHidden && 'visually-hidden', column && columnClass);
	  htmlFor = htmlFor || controlId;
	  if (column) return /*#__PURE__*/jsxRuntimeExports.jsx(Col$1, {
	    ref: ref,
	    as: "label",
	    className: classes,
	    htmlFor: htmlFor,
	    ...props
	  });
	  return (
	    /*#__PURE__*/
	    // eslint-disable-next-line jsx-a11y/label-has-for, jsx-a11y/label-has-associated-control
	    jsxRuntimeExports.jsx(Component, {
	      ref: ref,
	      className: classes,
	      htmlFor: htmlFor,
	      ...props
	    })
	  );
	});
	FormLabel.displayName = 'FormLabel';
	var FormLabel$1 = FormLabel;

	const FormRange = /*#__PURE__*/React__namespace.forwardRef(({
	  bsPrefix,
	  className,
	  id,
	  ...props
	}, ref) => {
	  const {
	    controlId
	  } = React$1.useContext(FormContext$1);
	  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-range');
	  return /*#__PURE__*/jsxRuntimeExports.jsx("input", {
	    ...props,
	    type: "range",
	    ref: ref,
	    className: classNames$1(className, bsPrefix),
	    id: id || controlId
	  });
	});
	FormRange.displayName = 'FormRange';
	var FormRange$1 = FormRange;

	const FormSelect = /*#__PURE__*/React__namespace.forwardRef(({
	  bsPrefix,
	  size,
	  htmlSize,
	  className,
	  isValid = false,
	  isInvalid = false,
	  id,
	  ...props
	}, ref) => {
	  const {
	    controlId
	  } = React$1.useContext(FormContext$1);
	  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-select');
	  return /*#__PURE__*/jsxRuntimeExports.jsx("select", {
	    ...props,
	    size: htmlSize,
	    ref: ref,
	    className: classNames$1(className, bsPrefix, size && `${bsPrefix}-${size}`, isValid && `is-valid`, isInvalid && `is-invalid`),
	    id: id || controlId
	  });
	});
	FormSelect.displayName = 'FormSelect';
	var FormSelect$1 = FormSelect;

	const FormText = /*#__PURE__*/React__namespace.forwardRef(
	// Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
	({
	  bsPrefix,
	  className,
	  as: Component = 'small',
	  muted,
	  ...props
	}, ref) => {
	  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-text');
	  return /*#__PURE__*/jsxRuntimeExports.jsx(Component, {
	    ...props,
	    ref: ref,
	    className: classNames$1(className, bsPrefix, muted && 'text-muted')
	  });
	});
	FormText.displayName = 'FormText';
	var FormText$1 = FormText;

	const Switch = /*#__PURE__*/React__namespace.forwardRef((props, ref) => /*#__PURE__*/jsxRuntimeExports.jsx(FormCheck$1, {
	  ...props,
	  ref: ref,
	  type: "switch"
	}));
	Switch.displayName = 'Switch';
	var Switch$1 = Object.assign(Switch, {
	  Input: FormCheck$1.Input,
	  Label: FormCheck$1.Label
	});

	const FloatingLabel = /*#__PURE__*/React__namespace.forwardRef(({
	  bsPrefix,
	  className,
	  children,
	  controlId,
	  label,
	  ...props
	}, ref) => {
	  bsPrefix = useBootstrapPrefix(bsPrefix, 'form-floating');
	  return /*#__PURE__*/jsxRuntimeExports.jsxs(FormGroup$1, {
	    ref: ref,
	    className: classNames$1(className, bsPrefix),
	    controlId: controlId,
	    ...props,
	    children: [children, /*#__PURE__*/jsxRuntimeExports.jsx("label", {
	      htmlFor: controlId,
	      children: label
	    })]
	  });
	});
	FloatingLabel.displayName = 'FloatingLabel';
	var FloatingLabel$1 = FloatingLabel;

	const propTypes = {
	  /**
	   * The Form `ref` will be forwarded to the underlying element,
	   * which means, unless it's rendered `as` a composite component,
	   * it will be a DOM node, when resolved.
	   *
	   * @type {ReactRef}
	   * @alias ref
	   */
	  _ref: PropTypes.any,
	  /**
	   * Mark a form as having been validated. Setting it to `true` will
	   * toggle any validation styles on the forms elements.
	   */
	  validated: PropTypes.bool,
	  as: PropTypes.elementType
	};
	const Form = /*#__PURE__*/React__namespace.forwardRef(({
	  className,
	  validated,
	  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
	  as: Component = 'form',
	  ...props
	}, ref) => /*#__PURE__*/jsxRuntimeExports.jsx(Component, {
	  ...props,
	  ref: ref,
	  className: classNames$1(className, validated && 'was-validated')
	}));
	Form.displayName = 'Form';
	Form.propTypes = propTypes;
	var Form$1 = Object.assign(Form, {
	  Group: FormGroup$1,
	  Control: FormControl$1,
	  Floating: FormFloating,
	  Check: FormCheck$1,
	  Switch: Switch$1,
	  Label: FormLabel$1,
	  Text: FormText$1,
	  Range: FormRange$1,
	  Select: FormSelect$1,
	  FloatingLabel: FloatingLabel$1
	});

	var _excluded$5 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
	function useStateManager(_ref) {
	  var _ref$defaultInputValu = _ref.defaultInputValue,
	    defaultInputValue = _ref$defaultInputValu === void 0 ? '' : _ref$defaultInputValu,
	    _ref$defaultMenuIsOpe = _ref.defaultMenuIsOpen,
	    defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe,
	    _ref$defaultValue = _ref.defaultValue,
	    defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue,
	    propsInputValue = _ref.inputValue,
	    propsMenuIsOpen = _ref.menuIsOpen,
	    propsOnChange = _ref.onChange,
	    propsOnInputChange = _ref.onInputChange,
	    propsOnMenuClose = _ref.onMenuClose,
	    propsOnMenuOpen = _ref.onMenuOpen,
	    propsValue = _ref.value,
	    restSelectProps = _objectWithoutProperties(_ref, _excluded$5);
	  var _useState = React$1.useState(propsInputValue !== undefined ? propsInputValue : defaultInputValue),
	    _useState2 = _slicedToArray(_useState, 2),
	    stateInputValue = _useState2[0],
	    setStateInputValue = _useState2[1];
	  var _useState3 = React$1.useState(propsMenuIsOpen !== undefined ? propsMenuIsOpen : defaultMenuIsOpen),
	    _useState4 = _slicedToArray(_useState3, 2),
	    stateMenuIsOpen = _useState4[0],
	    setStateMenuIsOpen = _useState4[1];
	  var _useState5 = React$1.useState(propsValue !== undefined ? propsValue : defaultValue),
	    _useState6 = _slicedToArray(_useState5, 2),
	    stateValue = _useState6[0],
	    setStateValue = _useState6[1];
	  var onChange = React$1.useCallback(function (value, actionMeta) {
	    if (typeof propsOnChange === 'function') {
	      propsOnChange(value, actionMeta);
	    }
	    setStateValue(value);
	  }, [propsOnChange]);
	  var onInputChange = React$1.useCallback(function (value, actionMeta) {
	    var newValue;
	    if (typeof propsOnInputChange === 'function') {
	      newValue = propsOnInputChange(value, actionMeta);
	    }
	    setStateInputValue(newValue !== undefined ? newValue : value);
	  }, [propsOnInputChange]);
	  var onMenuOpen = React$1.useCallback(function () {
	    if (typeof propsOnMenuOpen === 'function') {
	      propsOnMenuOpen();
	    }
	    setStateMenuIsOpen(true);
	  }, [propsOnMenuOpen]);
	  var onMenuClose = React$1.useCallback(function () {
	    if (typeof propsOnMenuClose === 'function') {
	      propsOnMenuClose();
	    }
	    setStateMenuIsOpen(false);
	  }, [propsOnMenuClose]);
	  var inputValue = propsInputValue !== undefined ? propsInputValue : stateInputValue;
	  var menuIsOpen = propsMenuIsOpen !== undefined ? propsMenuIsOpen : stateMenuIsOpen;
	  var value = propsValue !== undefined ? propsValue : stateValue;
	  return _objectSpread2$8(_objectSpread2$8({}, restSelectProps), {}, {
	    inputValue: inputValue,
	    menuIsOpen: menuIsOpen,
	    onChange: onChange,
	    onInputChange: onInputChange,
	    onMenuClose: onMenuClose,
	    onMenuOpen: onMenuOpen,
	    value: value
	  });
	}

	/*

	Based off glamor's StyleSheet, thanks Sunil 

	high performance StyleSheet for css-in-js systems

	- uses multiple style tags behind the scenes for millions of rules
	- uses `insertRule` for appending in production for *much* faster performance

	// usage

	import { StyleSheet } from '@emotion/sheet'

	let styleSheet = new StyleSheet({ key: '', container: document.head })

	styleSheet.insert('#box { border: 1px solid red; }')
	- appends a css rule into the stylesheet

	styleSheet.flush()
	- empties the stylesheet of all its contents

	*/
	// $FlowFixMe
	function sheetForTag(tag) {
	  if (tag.sheet) {
	    // $FlowFixMe
	    return tag.sheet;
	  } // this weirdness brought to you by firefox

	  /* istanbul ignore next */


	  for (var i = 0; i < document.styleSheets.length; i++) {
	    if (document.styleSheets[i].ownerNode === tag) {
	      // $FlowFixMe
	      return document.styleSheets[i];
	    }
	  }
	}

	function createStyleElement(options) {
	  var tag = document.createElement('style');
	  tag.setAttribute('data-emotion', options.key);

	  if (options.nonce !== undefined) {
	    tag.setAttribute('nonce', options.nonce);
	  }

	  tag.appendChild(document.createTextNode(''));
	  tag.setAttribute('data-s', '');
	  return tag;
	}

	var StyleSheet = /*#__PURE__*/function () {
	  // Using Node instead of HTMLElement since container may be a ShadowRoot
	  function StyleSheet(options) {
	    var _this = this;

	    this._insertTag = function (tag) {
	      var before;

	      if (_this.tags.length === 0) {
	        if (_this.insertionPoint) {
	          before = _this.insertionPoint.nextSibling;
	        } else if (_this.prepend) {
	          before = _this.container.firstChild;
	        } else {
	          before = _this.before;
	        }
	      } else {
	        before = _this.tags[_this.tags.length - 1].nextSibling;
	      }

	      _this.container.insertBefore(tag, before);

	      _this.tags.push(tag);
	    };

	    this.isSpeedy = options.speedy === undefined ? "production" === 'production' : options.speedy;
	    this.tags = [];
	    this.ctr = 0;
	    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

	    this.key = options.key;
	    this.container = options.container;
	    this.prepend = options.prepend;
	    this.insertionPoint = options.insertionPoint;
	    this.before = null;
	  }

	  var _proto = StyleSheet.prototype;

	  _proto.hydrate = function hydrate(nodes) {
	    nodes.forEach(this._insertTag);
	  };

	  _proto.insert = function insert(rule) {
	    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
	    // it's 1 in dev because we insert source maps that map a single rule to a location
	    // and you can only have one source map per style tag
	    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
	      this._insertTag(createStyleElement(this));
	    }

	    var tag = this.tags[this.tags.length - 1];

	    if (this.isSpeedy) {
	      var sheet = sheetForTag(tag);

	      try {
	        // this is the ultrafast version, works across browsers
	        // the big drawback is that the css won't be editable in devtools
	        sheet.insertRule(rule, sheet.cssRules.length);
	      } catch (e) {
	      }
	    } else {
	      tag.appendChild(document.createTextNode(rule));
	    }

	    this.ctr++;
	  };

	  _proto.flush = function flush() {
	    // $FlowFixMe
	    this.tags.forEach(function (tag) {
	      return tag.parentNode && tag.parentNode.removeChild(tag);
	    });
	    this.tags = [];
	    this.ctr = 0;
	  };

	  return StyleSheet;
	}();

	var MS = '-ms-';
	var MOZ = '-moz-';
	var WEBKIT = '-webkit-';

	var COMMENT = 'comm';
	var RULESET = 'rule';
	var DECLARATION = 'decl';
	var IMPORT = '@import';
	var KEYFRAMES = '@keyframes';
	var LAYER = '@layer';

	/**
	 * @param {number}
	 * @return {number}
	 */
	var abs = Math.abs;

	/**
	 * @param {number}
	 * @return {string}
	 */
	var from = String.fromCharCode;

	/**
	 * @param {object}
	 * @return {object}
	 */
	var assign = Object.assign;

	/**
	 * @param {string} value
	 * @param {number} length
	 * @return {number}
	 */
	function hash (value, length) {
		return charat(value, 0) ^ 45 ? (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3) : 0
	}

	/**
	 * @param {string} value
	 * @return {string}
	 */
	function trim (value) {
		return value.trim()
	}

	/**
	 * @param {string} value
	 * @param {RegExp} pattern
	 * @return {string?}
	 */
	function match (value, pattern) {
		return (value = pattern.exec(value)) ? value[0] : value
	}

	/**
	 * @param {string} value
	 * @param {(string|RegExp)} pattern
	 * @param {string} replacement
	 * @return {string}
	 */
	function replace (value, pattern, replacement) {
		return value.replace(pattern, replacement)
	}

	/**
	 * @param {string} value
	 * @param {string} search
	 * @return {number}
	 */
	function indexof (value, search) {
		return value.indexOf(search)
	}

	/**
	 * @param {string} value
	 * @param {number} index
	 * @return {number}
	 */
	function charat (value, index) {
		return value.charCodeAt(index) | 0
	}

	/**
	 * @param {string} value
	 * @param {number} begin
	 * @param {number} end
	 * @return {string}
	 */
	function substr (value, begin, end) {
		return value.slice(begin, end)
	}

	/**
	 * @param {string} value
	 * @return {number}
	 */
	function strlen (value) {
		return value.length
	}

	/**
	 * @param {any[]} value
	 * @return {number}
	 */
	function sizeof (value) {
		return value.length
	}

	/**
	 * @param {any} value
	 * @param {any[]} array
	 * @return {any}
	 */
	function append (value, array) {
		return array.push(value), value
	}

	/**
	 * @param {string[]} array
	 * @param {function} callback
	 * @return {string}
	 */
	function combine (array, callback) {
		return array.map(callback).join('')
	}

	var line = 1;
	var column = 1;
	var length = 0;
	var position = 0;
	var character = 0;
	var characters = '';

	/**
	 * @param {string} value
	 * @param {object | null} root
	 * @param {object | null} parent
	 * @param {string} type
	 * @param {string[] | string} props
	 * @param {object[] | string} children
	 * @param {number} length
	 */
	function node (value, root, parent, type, props, children, length) {
		return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
	}

	/**
	 * @param {object} root
	 * @param {object} props
	 * @return {object}
	 */
	function copy (root, props) {
		return assign(node('', null, null, '', null, null, 0), root, {length: -root.length}, props)
	}

	/**
	 * @return {number}
	 */
	function char () {
		return character
	}

	/**
	 * @return {number}
	 */
	function prev () {
		character = position > 0 ? charat(characters, --position) : 0;

		if (column--, character === 10)
			column = 1, line--;

		return character
	}

	/**
	 * @return {number}
	 */
	function next () {
		character = position < length ? charat(characters, position++) : 0;

		if (column++, character === 10)
			column = 1, line++;

		return character
	}

	/**
	 * @return {number}
	 */
	function peek () {
		return charat(characters, position)
	}

	/**
	 * @return {number}
	 */
	function caret () {
		return position
	}

	/**
	 * @param {number} begin
	 * @param {number} end
	 * @return {string}
	 */
	function slice (begin, end) {
		return substr(characters, begin, end)
	}

	/**
	 * @param {number} type
	 * @return {number}
	 */
	function token (type) {
		switch (type) {
			// \0 \t \n \r \s whitespace token
			case 0: case 9: case 10: case 13: case 32:
				return 5
			// ! + , / > @ ~ isolate token
			case 33: case 43: case 44: case 47: case 62: case 64: case 126:
			// ; { } breakpoint token
			case 59: case 123: case 125:
				return 4
			// : accompanied token
			case 58:
				return 3
			// " ' ( [ opening delimit token
			case 34: case 39: case 40: case 91:
				return 2
			// ) ] closing delimit token
			case 41: case 93:
				return 1
		}

		return 0
	}

	/**
	 * @param {string} value
	 * @return {any[]}
	 */
	function alloc (value) {
		return line = column = 1, length = strlen(characters = value), position = 0, []
	}

	/**
	 * @param {any} value
	 * @return {any}
	 */
	function dealloc (value) {
		return characters = '', value
	}

	/**
	 * @param {number} type
	 * @return {string}
	 */
	function delimit (type) {
		return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
	}

	/**
	 * @param {number} type
	 * @return {string}
	 */
	function whitespace (type) {
		while (character = peek())
			if (character < 33)
				next();
			else
				break

		return token(type) > 2 || token(character) > 3 ? '' : ' '
	}

	/**
	 * @param {number} index
	 * @param {number} count
	 * @return {string}
	 */
	function escaping (index, count) {
		while (--count && next())
			// not 0-9 A-F a-f
			if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
				break

		return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
	}

	/**
	 * @param {number} type
	 * @return {number}
	 */
	function delimiter (type) {
		while (next())
			switch (character) {
				// ] ) " '
				case type:
					return position
				// " '
				case 34: case 39:
					if (type !== 34 && type !== 39)
						delimiter(character);
					break
				// (
				case 40:
					if (type === 41)
						delimiter(type);
					break
				// \
				case 92:
					next();
					break
			}

		return position
	}

	/**
	 * @param {number} type
	 * @param {number} index
	 * @return {number}
	 */
	function commenter (type, index) {
		while (next())
			// //
			if (type + character === 47 + 10)
				break
			// /*
			else if (type + character === 42 + 42 && peek() === 47)
				break

		return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next())
	}

	/**
	 * @param {number} index
	 * @return {string}
	 */
	function identifier (index) {
		while (!token(peek()))
			next();

		return slice(index, position)
	}

	/**
	 * @param {string} value
	 * @return {object[]}
	 */
	function compile (value) {
		return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value))
	}

	/**
	 * @param {string} value
	 * @param {object} root
	 * @param {object?} parent
	 * @param {string[]} rule
	 * @param {string[]} rules
	 * @param {string[]} rulesets
	 * @param {number[]} pseudo
	 * @param {number[]} points
	 * @param {string[]} declarations
	 * @return {object}
	 */
	function parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
		var index = 0;
		var offset = 0;
		var length = pseudo;
		var atrule = 0;
		var property = 0;
		var previous = 0;
		var variable = 1;
		var scanning = 1;
		var ampersand = 1;
		var character = 0;
		var type = '';
		var props = rules;
		var children = rulesets;
		var reference = rule;
		var characters = type;

		while (scanning)
			switch (previous = character, character = next()) {
				// (
				case 40:
					if (previous != 108 && charat(characters, length - 1) == 58) {
						if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f') != -1)
							ampersand = -1;
						break
					}
				// " ' [
				case 34: case 39: case 91:
					characters += delimit(character);
					break
				// \t \n \r \s
				case 9: case 10: case 13: case 32:
					characters += whitespace(previous);
					break
				// \
				case 92:
					characters += escaping(caret() - 1, 7);
					continue
				// /
				case 47:
					switch (peek()) {
						case 42: case 47:
							append(comment(commenter(next(), caret()), root, parent), declarations);
							break
						default:
							characters += '/';
					}
					break
				// {
				case 123 * variable:
					points[index++] = strlen(characters) * ampersand;
				// } ; \0
				case 125 * variable: case 59: case 0:
					switch (character) {
						// \0 }
						case 0: case 125: scanning = 0;
						// ;
						case 59 + offset: if (ampersand == -1) characters = replace(characters, /\f/g, '');
							if (property > 0 && (strlen(characters) - length))
								append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
							break
						// @ ;
						case 59: characters += ';';
						// { rule/at-rule
						default:
							append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);

							if (character === 123)
								if (offset === 0)
									parse(characters, root, reference, reference, props, rulesets, length, points, children);
								else
									switch (atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule) {
										// d l m s
										case 100: case 108: case 109: case 115:
											parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
											break
										default:
											parse(characters, reference, reference, reference, [''], children, 0, points, children);
									}
					}

					index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
					break
				// :
				case 58:
					length = 1 + strlen(characters), property = previous;
				default:
					if (variable < 1)
						if (character == 123)
							--variable;
						else if (character == 125 && variable++ == 0 && prev() == 125)
							continue

					switch (characters += from(character), character * variable) {
						// &
						case 38:
							ampersand = offset > 0 ? 1 : (characters += '\f', -1);
							break
						// ,
						case 44:
							points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
							break
						// @
						case 64:
							// -
							if (peek() === 45)
								characters += delimit(next());

							atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
							break
						// -
						case 45:
							if (previous === 45 && strlen(characters) == 2)
								variable = 0;
					}
			}

		return rulesets
	}

	/**
	 * @param {string} value
	 * @param {object} root
	 * @param {object?} parent
	 * @param {number} index
	 * @param {number} offset
	 * @param {string[]} rules
	 * @param {number[]} points
	 * @param {string} type
	 * @param {string[]} props
	 * @param {string[]} children
	 * @param {number} length
	 * @return {object}
	 */
	function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
		var post = offset - 1;
		var rule = offset === 0 ? rules : [''];
		var size = sizeof(rule);

		for (var i = 0, j = 0, k = 0; i < index; ++i)
			for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
				if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x])))
					props[k++] = z;

		return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length)
	}

	/**
	 * @param {number} value
	 * @param {object} root
	 * @param {object?} parent
	 * @return {object}
	 */
	function comment (value, root, parent) {
		return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0)
	}

	/**
	 * @param {string} value
	 * @param {object} root
	 * @param {object?} parent
	 * @param {number} length
	 * @return {object}
	 */
	function declaration (value, root, parent, length) {
		return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length)
	}

	/**
	 * @param {object[]} children
	 * @param {function} callback
	 * @return {string}
	 */
	function serialize (children, callback) {
		var output = '';
		var length = sizeof(children);

		for (var i = 0; i < length; i++)
			output += callback(children[i], i, children, callback) || '';

		return output
	}

	/**
	 * @param {object} element
	 * @param {number} index
	 * @param {object[]} children
	 * @param {function} callback
	 * @return {string}
	 */
	function stringify (element, index, children, callback) {
		switch (element.type) {
			case LAYER: if (element.children.length) break
			case IMPORT: case DECLARATION: return element.return = element.return || element.value
			case COMMENT: return ''
			case KEYFRAMES: return element.return = element.value + '{' + serialize(element.children, callback) + '}'
			case RULESET: element.value = element.props.join(',');
		}

		return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
	}

	/**
	 * @param {function[]} collection
	 * @return {function}
	 */
	function middleware (collection) {
		var length = sizeof(collection);

		return function (element, index, children, callback) {
			var output = '';

			for (var i = 0; i < length; i++)
				output += collection[i](element, index, children, callback) || '';

			return output
		}
	}

	/**
	 * @param {function} callback
	 * @return {function}
	 */
	function rulesheet (callback) {
		return function (element) {
			if (!element.root)
				if (element = element.return)
					callback(element);
		}
	}

	var weakMemoize = function weakMemoize(func) {
	  // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps
	  var cache = new WeakMap();
	  return function (arg) {
	    if (cache.has(arg)) {
	      // $FlowFixMe
	      return cache.get(arg);
	    }

	    var ret = func(arg);
	    cache.set(arg, ret);
	    return ret;
	  };
	};

	function memoize(fn) {
	  var cache = Object.create(null);
	  return function (arg) {
	    if (cache[arg] === undefined) cache[arg] = fn(arg);
	    return cache[arg];
	  };
	}

	var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
	  var previous = 0;
	  var character = 0;

	  while (true) {
	    previous = character;
	    character = peek(); // &\f

	    if (previous === 38 && character === 12) {
	      points[index] = 1;
	    }

	    if (token(character)) {
	      break;
	    }

	    next();
	  }

	  return slice(begin, position);
	};

	var toRules = function toRules(parsed, points) {
	  // pretend we've started with a comma
	  var index = -1;
	  var character = 44;

	  do {
	    switch (token(character)) {
	      case 0:
	        // &\f
	        if (character === 38 && peek() === 12) {
	          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
	          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
	          // and when it should just concatenate the outer and inner selectors
	          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
	          points[index] = 1;
	        }

	        parsed[index] += identifierWithPointTracking(position - 1, points, index);
	        break;

	      case 2:
	        parsed[index] += delimit(character);
	        break;

	      case 4:
	        // comma
	        if (character === 44) {
	          // colon
	          parsed[++index] = peek() === 58 ? '&\f' : '';
	          points[index] = parsed[index].length;
	          break;
	        }

	      // fallthrough

	      default:
	        parsed[index] += from(character);
	    }
	  } while (character = next());

	  return parsed;
	};

	var getRules = function getRules(value, points) {
	  return dealloc(toRules(alloc(value), points));
	}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


	var fixedElements = /* #__PURE__ */new WeakMap();
	var compat = function compat(element) {
	  if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo
	  // negative .length indicates that this rule has been already prefixed
	  element.length < 1) {
	    return;
	  }

	  var value = element.value,
	      parent = element.parent;
	  var isImplicitRule = element.column === parent.column && element.line === parent.line;

	  while (parent.type !== 'rule') {
	    parent = parent.parent;
	    if (!parent) return;
	  } // short-circuit for the simplest case


	  if (element.props.length === 1 && value.charCodeAt(0) !== 58
	  /* colon */
	  && !fixedElements.get(parent)) {
	    return;
	  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
	  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


	  if (isImplicitRule) {
	    return;
	  }

	  fixedElements.set(element, true);
	  var points = [];
	  var rules = getRules(value, points);
	  var parentRules = parent.props;

	  for (var i = 0, k = 0; i < rules.length; i++) {
	    for (var j = 0; j < parentRules.length; j++, k++) {
	      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
	    }
	  }
	};
	var removeLabel = function removeLabel(element) {
	  if (element.type === 'decl') {
	    var value = element.value;

	    if ( // charcode for l
	    value.charCodeAt(0) === 108 && // charcode for b
	    value.charCodeAt(2) === 98) {
	      // this ignores label
	      element["return"] = '';
	      element.value = '';
	    }
	  }
	};

	/* eslint-disable no-fallthrough */

	function prefix(value, length) {
	  switch (hash(value, length)) {
	    // color-adjust
	    case 5103:
	      return WEBKIT + 'print-' + value + value;
	    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

	    case 5737:
	    case 4201:
	    case 3177:
	    case 3433:
	    case 1641:
	    case 4457:
	    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

	    case 5572:
	    case 6356:
	    case 5844:
	    case 3191:
	    case 6645:
	    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

	    case 6391:
	    case 5879:
	    case 5623:
	    case 6135:
	    case 4599:
	    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

	    case 4215:
	    case 6389:
	    case 5109:
	    case 5365:
	    case 5621:
	    case 3829:
	      return WEBKIT + value + value;
	    // appearance, user-select, transform, hyphens, text-size-adjust

	    case 5349:
	    case 4246:
	    case 4810:
	    case 6968:
	    case 2756:
	      return WEBKIT + value + MOZ + value + MS + value + value;
	    // flex, flex-direction

	    case 6828:
	    case 4268:
	      return WEBKIT + value + MS + value + value;
	    // order

	    case 6165:
	      return WEBKIT + value + MS + 'flex-' + value + value;
	    // align-items

	    case 5187:
	      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
	    // align-self

	    case 5443:
	      return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;
	    // align-content

	    case 4675:
	      return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;
	    // flex-shrink

	    case 5548:
	      return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
	    // flex-basis

	    case 5292:
	      return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
	    // flex-grow

	    case 6060:
	      return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
	    // transition

	    case 4554:
	      return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
	    // cursor

	    case 6187:
	      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
	    // background, background-image

	    case 5495:
	    case 3959:
	      return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
	    // justify-content

	    case 4968:
	      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
	    // (margin|padding)-inline-(start|end)

	    case 4095:
	    case 3583:
	    case 4068:
	    case 2532:
	      return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
	    // (min|max)?(width|height|inline-size|block-size)

	    case 8116:
	    case 7059:
	    case 5753:
	    case 5535:
	    case 5445:
	    case 5701:
	    case 4933:
	    case 4677:
	    case 5533:
	    case 5789:
	    case 5021:
	    case 4765:
	      // stretch, max-content, min-content, fill-available
	      if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
	        // (m)ax-content, (m)in-content
	        case 109:
	          // -
	          if (charat(value, length + 4) !== 45) break;
	        // (f)ill-available, (f)it-content

	        case 102:
	          return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
	        // (s)tretch

	        case 115:
	          return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;
	      }
	      break;
	    // position: sticky

	    case 4949:
	      // (s)ticky?
	      if (charat(value, length + 1) !== 115) break;
	    // display: (flex|inline-flex)

	    case 6444:
	      switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
	        // stic(k)y
	        case 107:
	          return replace(value, ':', ':' + WEBKIT) + value;
	        // (inline-)?fl(e)x

	        case 101:
	          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
	      }

	      break;
	    // writing-mode

	    case 5936:
	      switch (charat(value, length + 11)) {
	        // vertical-l(r)
	        case 114:
	          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
	        // vertical-r(l)

	        case 108:
	          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
	        // horizontal(-)tb

	        case 45:
	          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
	      }

	      return WEBKIT + value + MS + value + value;
	  }

	  return value;
	}

	var prefixer = function prefixer(element, index, children, callback) {
	  if (element.length > -1) if (!element["return"]) switch (element.type) {
	    case DECLARATION:
	      element["return"] = prefix(element.value, element.length);
	      break;

	    case KEYFRAMES:
	      return serialize([copy(element, {
	        value: replace(element.value, '@', '@' + WEBKIT)
	      })], callback);

	    case RULESET:
	      if (element.length) return combine(element.props, function (value) {
	        switch (match(value, /(::plac\w+|:read-\w+)/)) {
	          // :read-(only|write)
	          case ':read-only':
	          case ':read-write':
	            return serialize([copy(element, {
	              props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]
	            })], callback);
	          // :placeholder

	          case '::placeholder':
	            return serialize([copy(element, {
	              props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]
	            }), copy(element, {
	              props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]
	            }), copy(element, {
	              props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]
	            })], callback);
	        }

	        return '';
	      });
	  }
	};

	var isBrowser$3 = typeof document !== 'undefined';
	var getServerStylisCache = isBrowser$3 ? undefined : weakMemoize(function () {
	  return memoize(function () {
	    var cache = {};
	    return function (name) {
	      return cache[name];
	    };
	  });
	});
	var defaultStylisPlugins = [prefixer];

	var createCache = function createCache(options) {
	  var key = options.key;

	  if (isBrowser$3 && key === 'css') {
	    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
	    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
	    // note this very very intentionally targets all style elements regardless of the key to ensure
	    // that creating a cache works inside of render of a React component

	    Array.prototype.forEach.call(ssrStyles, function (node) {
	      // we want to only move elements which have a space in the data-emotion attribute value
	      // because that indicates that it is an Emotion 11 server-side rendered style elements
	      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
	      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
	      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
	      // will not result in the Emotion 10 styles being destroyed
	      var dataEmotionAttribute = node.getAttribute('data-emotion');

	      if (dataEmotionAttribute.indexOf(' ') === -1) {
	        return;
	      }
	      document.head.appendChild(node);
	      node.setAttribute('data-s', '');
	    });
	  }

	  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

	  var inserted = {};
	  var container;
	  var nodesToHydrate = [];

	  if (isBrowser$3) {
	    container = options.container || document.head;
	    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
	    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
	    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
	      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

	      for (var i = 1; i < attrib.length; i++) {
	        inserted[attrib[i]] = true;
	      }

	      nodesToHydrate.push(node);
	    });
	  }

	  var _insert;

	  var omnipresentPlugins = [compat, removeLabel];

	  if (isBrowser$3) {
	    var currentSheet;
	    var finalizingPlugins = [stringify, rulesheet(function (rule) {
	      currentSheet.insert(rule);
	    })];
	    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

	    var stylis = function stylis(styles) {
	      return serialize(compile(styles), serializer);
	    };

	    _insert = function insert(selector, serialized, sheet, shouldCache) {
	      currentSheet = sheet;

	      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

	      if (shouldCache) {
	        cache.inserted[serialized.name] = true;
	      }
	    };
	  } else {
	    var _finalizingPlugins = [stringify];

	    var _serializer = middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));

	    var _stylis = function _stylis(styles) {
	      return serialize(compile(styles), _serializer);
	    }; // $FlowFixMe


	    var serverStylisCache = getServerStylisCache(stylisPlugins)(key);

	    var getRules = function getRules(selector, serialized) {
	      var name = serialized.name;

	      if (serverStylisCache[name] === undefined) {
	        serverStylisCache[name] = _stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
	      }

	      return serverStylisCache[name];
	    };

	    _insert = function _insert(selector, serialized, sheet, shouldCache) {
	      var name = serialized.name;
	      var rules = getRules(selector, serialized);

	      if (cache.compat === undefined) {
	        // in regular mode, we don't set the styles on the inserted cache
	        // since we don't need to and that would be wasting memory
	        // we return them so that they are rendered in a style tag
	        if (shouldCache) {
	          cache.inserted[name] = true;
	        }

	        return rules;
	      } else {
	        // in compat mode, we put the styles on the inserted cache so
	        // that emotion-server can pull out the styles
	        // except when we don't want to cache it which was in Global but now
	        // is nowhere but we don't want to do a major right now
	        // and just in case we're going to leave the case here
	        // it's also not affecting client side bundle size
	        // so it's really not a big deal
	        if (shouldCache) {
	          cache.inserted[name] = rules;
	        } else {
	          return rules;
	        }
	      }
	    };
	  }

	  var cache = {
	    key: key,
	    sheet: new StyleSheet({
	      key: key,
	      container: container,
	      nonce: options.nonce,
	      speedy: options.speedy,
	      prepend: options.prepend,
	      insertionPoint: options.insertionPoint
	    }),
	    nonce: options.nonce,
	    inserted: inserted,
	    registered: {},
	    insert: _insert
	  };
	  cache.sheet.hydrate(nodesToHydrate);
	  return cache;
	};

	var reactIs$1 = {exports: {}};

	var reactIs_production_min = {};

	/** @license React v16.13.1
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w$1=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min.AsyncMode=l;reactIs_production_min.ConcurrentMode=m;reactIs_production_min.ContextConsumer=k;reactIs_production_min.ContextProvider=h;reactIs_production_min.Element=c;reactIs_production_min.ForwardRef=n;reactIs_production_min.Fragment=e;reactIs_production_min.Lazy=t;reactIs_production_min.Memo=r;reactIs_production_min.Portal=d;
	reactIs_production_min.Profiler=g;reactIs_production_min.StrictMode=f;reactIs_production_min.Suspense=p;reactIs_production_min.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min.isConcurrentMode=A;reactIs_production_min.isContextConsumer=function(a){return z(a)===k};reactIs_production_min.isContextProvider=function(a){return z(a)===h};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min.isForwardRef=function(a){return z(a)===n};reactIs_production_min.isFragment=function(a){return z(a)===e};reactIs_production_min.isLazy=function(a){return z(a)===t};
	reactIs_production_min.isMemo=function(a){return z(a)===r};reactIs_production_min.isPortal=function(a){return z(a)===d};reactIs_production_min.isProfiler=function(a){return z(a)===g};reactIs_production_min.isStrictMode=function(a){return z(a)===f};reactIs_production_min.isSuspense=function(a){return z(a)===p};
	reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w$1||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min.typeOf=z;

	{
	  reactIs$1.exports = reactIs_production_min;
	}

	var reactIsExports = reactIs$1.exports;

	var reactIs = reactIsExports;
	var FORWARD_REF_STATICS = {
	  '$$typeof': true,
	  render: true,
	  defaultProps: true,
	  displayName: true,
	  propTypes: true
	};
	var MEMO_STATICS = {
	  '$$typeof': true,
	  compare: true,
	  defaultProps: true,
	  displayName: true,
	  propTypes: true,
	  type: true
	};
	var TYPE_STATICS = {};
	TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
	TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

	var isBrowser$2 = typeof document !== 'undefined';
	function getRegisteredStyles(registered, registeredStyles, classNames) {
	  var rawClassName = '';
	  classNames.split(' ').forEach(function (className) {
	    if (registered[className] !== undefined) {
	      registeredStyles.push(registered[className] + ";");
	    } else {
	      rawClassName += className + " ";
	    }
	  });
	  return rawClassName;
	}
	var registerStyles = function registerStyles(cache, serialized, isStringTag) {
	  var className = cache.key + "-" + serialized.name;

	  if ( // we only need to add the styles to the registered cache if the
	  // class name could be used further down
	  // the tree but if it's a string tag, we know it won't
	  // so we don't have to add it to registered cache.
	  // this improves memory usage since we can avoid storing the whole style string
	  (isStringTag === false || // we need to always store it if we're in compat mode and
	  // in node since emotion-server relies on whether a style is in
	  // the registered cache to know whether a style is global or not
	  // also, note that this check will be dead code eliminated in the browser
	  isBrowser$2 === false && cache.compat !== undefined) && cache.registered[className] === undefined) {
	    cache.registered[className] = serialized.styles;
	  }
	};
	var insertStyles = function insertStyles(cache, serialized, isStringTag) {
	  registerStyles(cache, serialized, isStringTag);
	  var className = cache.key + "-" + serialized.name;

	  if (cache.inserted[serialized.name] === undefined) {
	    var stylesForSSR = '';
	    var current = serialized;

	    do {
	      var maybeStyles = cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

	      if (!isBrowser$2 && maybeStyles !== undefined) {
	        stylesForSSR += maybeStyles;
	      }

	      current = current.next;
	    } while (current !== undefined);

	    if (!isBrowser$2 && stylesForSSR.length !== 0) {
	      return stylesForSSR;
	    }
	  }
	};

	/* eslint-disable */
	// Inspired by https://github.com/garycourt/murmurhash-js
	// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
	function murmur2(str) {
	  // 'm' and 'r' are mixing constants generated offline.
	  // They're not really 'magic', they just happen to work well.
	  // const m = 0x5bd1e995;
	  // const r = 24;
	  // Initialize the hash
	  var h = 0; // Mix 4 bytes at a time into the hash

	  var k,
	      i = 0,
	      len = str.length;

	  for (; len >= 4; ++i, len -= 4) {
	    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
	    k =
	    /* Math.imul(k, m): */
	    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
	    k ^=
	    /* k >>> r: */
	    k >>> 24;
	    h =
	    /* Math.imul(k, m): */
	    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
	    /* Math.imul(h, m): */
	    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
	  } // Handle the last few bytes of the input array


	  switch (len) {
	    case 3:
	      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

	    case 2:
	      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

	    case 1:
	      h ^= str.charCodeAt(i) & 0xff;
	      h =
	      /* Math.imul(h, m): */
	      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
	  } // Do a few final mixes of the hash to ensure the last few
	  // bytes are well-incorporated.


	  h ^= h >>> 13;
	  h =
	  /* Math.imul(h, m): */
	  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
	  return ((h ^ h >>> 15) >>> 0).toString(36);
	}

	var unitlessKeys = {
	  animationIterationCount: 1,
	  aspectRatio: 1,
	  borderImageOutset: 1,
	  borderImageSlice: 1,
	  borderImageWidth: 1,
	  boxFlex: 1,
	  boxFlexGroup: 1,
	  boxOrdinalGroup: 1,
	  columnCount: 1,
	  columns: 1,
	  flex: 1,
	  flexGrow: 1,
	  flexPositive: 1,
	  flexShrink: 1,
	  flexNegative: 1,
	  flexOrder: 1,
	  gridRow: 1,
	  gridRowEnd: 1,
	  gridRowSpan: 1,
	  gridRowStart: 1,
	  gridColumn: 1,
	  gridColumnEnd: 1,
	  gridColumnSpan: 1,
	  gridColumnStart: 1,
	  msGridRow: 1,
	  msGridRowSpan: 1,
	  msGridColumn: 1,
	  msGridColumnSpan: 1,
	  fontWeight: 1,
	  lineHeight: 1,
	  opacity: 1,
	  order: 1,
	  orphans: 1,
	  tabSize: 1,
	  widows: 1,
	  zIndex: 1,
	  zoom: 1,
	  WebkitLineClamp: 1,
	  // SVG-related properties
	  fillOpacity: 1,
	  floodOpacity: 1,
	  stopOpacity: 1,
	  strokeDasharray: 1,
	  strokeDashoffset: 1,
	  strokeMiterlimit: 1,
	  strokeOpacity: 1,
	  strokeWidth: 1
	};

	var hyphenateRegex = /[A-Z]|^ms/g;
	var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

	var isCustomProperty = function isCustomProperty(property) {
	  return property.charCodeAt(1) === 45;
	};

	var isProcessableValue = function isProcessableValue(value) {
	  return value != null && typeof value !== 'boolean';
	};

	var processStyleName = /* #__PURE__ */memoize(function (styleName) {
	  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
	});

	var processStyleValue = function processStyleValue(key, value) {
	  switch (key) {
	    case 'animation':
	    case 'animationName':
	      {
	        if (typeof value === 'string') {
	          return value.replace(animationRegex, function (match, p1, p2) {
	            cursor = {
	              name: p1,
	              styles: p2,
	              next: cursor
	            };
	            return p1;
	          });
	        }
	      }
	  }

	  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
	    return value + 'px';
	  }

	  return value;
	};

	var noComponentSelectorMessage = 'Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.';

	function handleInterpolation(mergedProps, registered, interpolation) {
	  if (interpolation == null) {
	    return '';
	  }

	  if (interpolation.__emotion_styles !== undefined) {

	    return interpolation;
	  }

	  switch (typeof interpolation) {
	    case 'boolean':
	      {
	        return '';
	      }

	    case 'object':
	      {
	        if (interpolation.anim === 1) {
	          cursor = {
	            name: interpolation.name,
	            styles: interpolation.styles,
	            next: cursor
	          };
	          return interpolation.name;
	        }

	        if (interpolation.styles !== undefined) {
	          var next = interpolation.next;

	          if (next !== undefined) {
	            // not the most efficient thing ever but this is a pretty rare case
	            // and there will be very few iterations of this generally
	            while (next !== undefined) {
	              cursor = {
	                name: next.name,
	                styles: next.styles,
	                next: cursor
	              };
	              next = next.next;
	            }
	          }

	          var styles = interpolation.styles + ";";

	          return styles;
	        }

	        return createStringFromObject(mergedProps, registered, interpolation);
	      }

	    case 'function':
	      {
	        if (mergedProps !== undefined) {
	          var previousCursor = cursor;
	          var result = interpolation(mergedProps);
	          cursor = previousCursor;
	          return handleInterpolation(mergedProps, registered, result);
	        }

	        break;
	      }
	  } // finalize string values (regular strings and functions interpolated into css calls)


	  if (registered == null) {
	    return interpolation;
	  }

	  var cached = registered[interpolation];
	  return cached !== undefined ? cached : interpolation;
	}

	function createStringFromObject(mergedProps, registered, obj) {
	  var string = '';

	  if (Array.isArray(obj)) {
	    for (var i = 0; i < obj.length; i++) {
	      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
	    }
	  } else {
	    for (var _key in obj) {
	      var value = obj[_key];

	      if (typeof value !== 'object') {
	        if (registered != null && registered[value] !== undefined) {
	          string += _key + "{" + registered[value] + "}";
	        } else if (isProcessableValue(value)) {
	          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
	        }
	      } else {
	        if (_key === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {
	          throw new Error(noComponentSelectorMessage);
	        }

	        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
	          for (var _i = 0; _i < value.length; _i++) {
	            if (isProcessableValue(value[_i])) {
	              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
	            }
	          }
	        } else {
	          var interpolated = handleInterpolation(mergedProps, registered, value);

	          switch (_key) {
	            case 'animation':
	            case 'animationName':
	              {
	                string += processStyleName(_key) + ":" + interpolated + ";";
	                break;
	              }

	            default:
	              {

	                string += _key + "{" + interpolated + "}";
	              }
	          }
	        }
	      }
	    }
	  }

	  return string;
	}

	var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
	// keyframes are stored on the SerializedStyles object as a linked list


	var cursor;
	var serializeStyles = function serializeStyles(args, registered, mergedProps) {
	  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
	    return args[0];
	  }

	  var stringMode = true;
	  var styles = '';
	  cursor = undefined;
	  var strings = args[0];

	  if (strings == null || strings.raw === undefined) {
	    stringMode = false;
	    styles += handleInterpolation(mergedProps, registered, strings);
	  } else {

	    styles += strings[0];
	  } // we start at 1 since we've already handled the first arg


	  for (var i = 1; i < args.length; i++) {
	    styles += handleInterpolation(mergedProps, registered, args[i]);

	    if (stringMode) {

	      styles += strings[i];
	    }
	  }


	  labelPattern.lastIndex = 0;
	  var identifierName = '';
	  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

	  while ((match = labelPattern.exec(styles)) !== null) {
	    identifierName += '-' + // $FlowFixMe we know it's not null
	    match[1];
	  }

	  var name = murmur2(styles) + identifierName;

	  return {
	    name: name,
	    styles: styles,
	    next: cursor
	  };
	};

	var isBrowser$1 = typeof document !== 'undefined';

	var syncFallback = function syncFallback(create) {
	  return create();
	};

	var useInsertionEffect = React__namespace['useInsertion' + 'Effect'] ? React__namespace['useInsertion' + 'Effect'] : false;
	var useInsertionEffectAlwaysWithSyncFallback = !isBrowser$1 ? syncFallback : useInsertionEffect || syncFallback;

	var isBrowser = typeof document !== 'undefined';
	var hasOwnProperty = {}.hasOwnProperty;

	var EmotionCacheContext = /* #__PURE__ */React__namespace.createContext( // we're doing this to avoid preconstruct's dead code elimination in this one case
	// because this module is primarily intended for the browser and node
	// but it's also required in react native and similar environments sometimes
	// and we could have a special build just for that
	// but this is much easier and the native packages
	// might use a different theme context in the future anyway
	typeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({
	  key: 'css'
	}) : null);

	EmotionCacheContext.Provider;

	var withEmotionCache = function withEmotionCache(func) {
	  // $FlowFixMe
	  return /*#__PURE__*/React$1.forwardRef(function (props, ref) {
	    // the cache will never be null in the browser
	    var cache = React$1.useContext(EmotionCacheContext);
	    return func(props, cache, ref);
	  });
	};

	if (!isBrowser) {
	  withEmotionCache = function withEmotionCache(func) {
	    return function (props) {
	      var cache = React$1.useContext(EmotionCacheContext);

	      if (cache === null) {
	        // yes, we're potentially creating this on every render
	        // it doesn't actually matter though since it's only on the server
	        // so there will only every be a single render
	        // that could change in the future because of suspense and etc. but for now,
	        // this works and i don't want to optimise for a future thing that we aren't sure about
	        cache = createCache({
	          key: 'css'
	        });
	        return /*#__PURE__*/React__namespace.createElement(EmotionCacheContext.Provider, {
	          value: cache
	        }, func(props, cache));
	      } else {
	        return func(props, cache);
	      }
	    };
	  };
	}

	var ThemeContext = /* #__PURE__ */React__namespace.createContext({});

	var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
	var createEmotionProps = function createEmotionProps(type, props) {

	  var newProps = {};

	  for (var key in props) {
	    if (hasOwnProperty.call(props, key)) {
	      newProps[key] = props[key];
	    }
	  }

	  newProps[typePropName] = type; // For performance, only call getLabelFromStackTrace in development and when

	  return newProps;
	};

	var Insertion = function Insertion(_ref) {
	  var cache = _ref.cache,
	      serialized = _ref.serialized,
	      isStringTag = _ref.isStringTag;
	  registerStyles(cache, serialized, isStringTag);
	  var rules = useInsertionEffectAlwaysWithSyncFallback(function () {
	    return insertStyles(cache, serialized, isStringTag);
	  });

	  if (!isBrowser && rules !== undefined) {
	    var _ref2;

	    var serializedNames = serialized.name;
	    var next = serialized.next;

	    while (next !== undefined) {
	      serializedNames += ' ' + next.name;
	      next = next.next;
	    }

	    return /*#__PURE__*/React__namespace.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
	      __html: rules
	    }, _ref2.nonce = cache.sheet.nonce, _ref2));
	  }

	  return null;
	};

	var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
	  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
	  // not passing the registered cache to serializeStyles because it would
	  // make certain babel optimisations not possible

	  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
	    cssProp = cache.registered[cssProp];
	  }

	  var WrappedComponent = props[typePropName];
	  var registeredStyles = [cssProp];
	  var className = '';

	  if (typeof props.className === 'string') {
	    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
	  } else if (props.className != null) {
	    className = props.className + " ";
	  }

	  var serialized = serializeStyles(registeredStyles, undefined, React__namespace.useContext(ThemeContext));

	  className += cache.key + "-" + serialized.name;
	  var newProps = {};

	  for (var key in props) {
	    if (hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && ("production" === 'production' )) {
	      newProps[key] = props[key];
	    }
	  }

	  newProps.ref = ref;
	  newProps.className = className;
	  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(Insertion, {
	    cache: cache,
	    serialized: serialized,
	    isStringTag: typeof WrappedComponent === 'string'
	  }), /*#__PURE__*/React__namespace.createElement(WrappedComponent, newProps));
	});

	var Emotion$1 = Emotion;

	var jsx = function jsx(type, props) {
	  var args = arguments;

	  if (props == null || !hasOwnProperty.call(props, 'css')) {
	    // $FlowFixMe
	    return React__namespace.createElement.apply(undefined, args);
	  }

	  var argsLength = args.length;
	  var createElementArgArray = new Array(argsLength);
	  createElementArgArray[0] = Emotion$1;
	  createElementArgArray[1] = createEmotionProps(type, props);

	  for (var i = 2; i < argsLength; i++) {
	    createElementArgArray[i] = args[i];
	  } // $FlowFixMe


	  return React__namespace.createElement.apply(null, createElementArgArray);
	};

	function css$2() {
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return serializeStyles(args);
	}

	var keyframes = function keyframes() {
	  var insertable = css$2.apply(void 0, arguments);
	  var name = "animation-" + insertable.name; // $FlowFixMe

	  return {
	    name: name,
	    styles: "@keyframes " + name + "{" + insertable.styles + "}",
	    anim: 1,
	    toString: function toString() {
	      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
	    }
	  };
	};

	function _taggedTemplateLiteral(strings, raw) {
	  if (!raw) {
	    raw = strings.slice(0);
	  }
	  return Object.freeze(Object.defineProperties(strings, {
	    raw: {
	      value: Object.freeze(raw)
	    }
	  }));
	}

	function rectToClientRect(rect) {
	  return {
	    ...rect,
	    top: rect.y,
	    left: rect.x,
	    right: rect.x + rect.width,
	    bottom: rect.y + rect.height
	  };
	}

	function getWindow(node) {
	  var _node$ownerDocument;
	  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
	}

	function getComputedStyle$1(element) {
	  return getWindow(element).getComputedStyle(element);
	}

	function isNode(value) {
	  return value instanceof getWindow(value).Node;
	}
	function getNodeName(node) {
	  if (isNode(node)) {
	    return (node.nodeName || '').toLowerCase();
	  }
	  // Mocked nodes in testing environments may not be instances of Node. By
	  // returning `#document` an infinite loop won't occur.
	  // https://github.com/floating-ui/floating-ui/issues/2317
	  return '#document';
	}

	function isHTMLElement(value) {
	  return value instanceof getWindow(value).HTMLElement;
	}
	function isShadowRoot(node) {
	  // Browsers without `ShadowRoot` support.
	  if (typeof ShadowRoot === 'undefined') {
	    return false;
	  }
	  return node instanceof getWindow(node).ShadowRoot || node instanceof ShadowRoot;
	}
	function isOverflowElement(element) {
	  const {
	    overflow,
	    overflowX,
	    overflowY,
	    display
	  } = getComputedStyle$1(element);
	  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
	}
	function isSafari() {
	  if (typeof CSS === 'undefined' || !CSS.supports) return false;
	  return CSS.supports('-webkit-backdrop-filter', 'none');
	}
	function isLastTraversableNode(node) {
	  return ['html', 'body', '#document'].includes(getNodeName(node));
	}

	const min = Math.min;
	const max = Math.max;
	const round = Math.round;
	const floor = Math.floor;
	const createCoords = v => ({
	  x: v,
	  y: v
	});

	function getCssDimensions(element) {
	  const css = getComputedStyle$1(element);
	  // In testing environments, the `width` and `height` properties are empty
	  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
	  let width = parseFloat(css.width) || 0;
	  let height = parseFloat(css.height) || 0;
	  const hasOffset = isHTMLElement(element);
	  const offsetWidth = hasOffset ? element.offsetWidth : width;
	  const offsetHeight = hasOffset ? element.offsetHeight : height;
	  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
	  if (shouldFallback) {
	    width = offsetWidth;
	    height = offsetHeight;
	  }
	  return {
	    width,
	    height,
	    $: shouldFallback
	  };
	}

	function isElement(value) {
	  return value instanceof getWindow(value).Element;
	}

	function unwrapElement(element) {
	  return !isElement(element) ? element.contextElement : element;
	}

	function getScale(element) {
	  const domElement = unwrapElement(element);
	  if (!isHTMLElement(domElement)) {
	    return createCoords(1);
	  }
	  const rect = domElement.getBoundingClientRect();
	  const {
	    width,
	    height,
	    $
	  } = getCssDimensions(domElement);
	  let x = ($ ? round(rect.width) : rect.width) / width;
	  let y = ($ ? round(rect.height) : rect.height) / height;

	  // 0, NaN, or Infinity should always fallback to 1.

	  if (!x || !Number.isFinite(x)) {
	    x = 1;
	  }
	  if (!y || !Number.isFinite(y)) {
	    y = 1;
	  }
	  return {
	    x,
	    y
	  };
	}

	const noOffsets = /*#__PURE__*/createCoords(0);
	function getVisualOffsets(element) {
	  const win = getWindow(element);
	  if (!isSafari() || !win.visualViewport) {
	    return noOffsets;
	  }
	  return {
	    x: win.visualViewport.offsetLeft,
	    y: win.visualViewport.offsetTop
	  };
	}
	function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
	  if (isFixed === void 0) {
	    isFixed = false;
	  }
	  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
	    return false;
	  }
	  return isFixed;
	}

	function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
	  if (includeScale === void 0) {
	    includeScale = false;
	  }
	  if (isFixedStrategy === void 0) {
	    isFixedStrategy = false;
	  }
	  const clientRect = element.getBoundingClientRect();
	  const domElement = unwrapElement(element);
	  let scale = createCoords(1);
	  if (includeScale) {
	    if (offsetParent) {
	      if (isElement(offsetParent)) {
	        scale = getScale(offsetParent);
	      }
	    } else {
	      scale = getScale(element);
	    }
	  }
	  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
	  let x = (clientRect.left + visualOffsets.x) / scale.x;
	  let y = (clientRect.top + visualOffsets.y) / scale.y;
	  let width = clientRect.width / scale.x;
	  let height = clientRect.height / scale.y;
	  if (domElement) {
	    const win = getWindow(domElement);
	    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
	    let currentIFrame = win.frameElement;
	    while (currentIFrame && offsetParent && offsetWin !== win) {
	      const iframeScale = getScale(currentIFrame);
	      const iframeRect = currentIFrame.getBoundingClientRect();
	      const css = getComputedStyle(currentIFrame);
	      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
	      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
	      x *= iframeScale.x;
	      y *= iframeScale.y;
	      width *= iframeScale.x;
	      height *= iframeScale.y;
	      x += left;
	      y += top;
	      currentIFrame = getWindow(currentIFrame).frameElement;
	    }
	  }
	  return rectToClientRect({
	    width,
	    height,
	    x,
	    y
	  });
	}

	function getDocumentElement(node) {
	  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
	}

	function getParentNode(node) {
	  if (getNodeName(node) === 'html') {
	    return node;
	  }
	  const result =
	  // Step into the shadow DOM of the parent of a slotted node.
	  node.assignedSlot ||
	  // DOM Element detected.
	  node.parentNode ||
	  // ShadowRoot detected.
	  isShadowRoot(node) && node.host ||
	  // Fallback.
	  getDocumentElement(node);
	  return isShadowRoot(result) ? result.host : result;
	}

	function getNearestOverflowAncestor(node) {
	  const parentNode = getParentNode(node);
	  if (isLastTraversableNode(parentNode)) {
	    return node.ownerDocument ? node.ownerDocument.body : node.body;
	  }
	  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
	    return parentNode;
	  }
	  return getNearestOverflowAncestor(parentNode);
	}

	function getOverflowAncestors(node, list) {
	  var _node$ownerDocument;
	  if (list === void 0) {
	    list = [];
	  }
	  const scrollableAncestor = getNearestOverflowAncestor(node);
	  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
	  const win = getWindow(scrollableAncestor);
	  if (isBody) {
	    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
	  }
	  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
	}

	// https://samthor.au/2021/observing-dom/
	function observeMove(element, onMove) {
	  let io = null;
	  let timeoutId;
	  const root = getDocumentElement(element);
	  function cleanup() {
	    clearTimeout(timeoutId);
	    io && io.disconnect();
	    io = null;
	  }
	  function refresh(skip, threshold) {
	    if (skip === void 0) {
	      skip = false;
	    }
	    if (threshold === void 0) {
	      threshold = 1;
	    }
	    cleanup();
	    const {
	      left,
	      top,
	      width,
	      height
	    } = element.getBoundingClientRect();
	    if (!skip) {
	      onMove();
	    }
	    if (!width || !height) {
	      return;
	    }
	    const insetTop = floor(top);
	    const insetRight = floor(root.clientWidth - (left + width));
	    const insetBottom = floor(root.clientHeight - (top + height));
	    const insetLeft = floor(left);
	    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
	    const options = {
	      rootMargin,
	      threshold: max(0, min(1, threshold)) || 1
	    };
	    let isFirstUpdate = true;
	    function handleObserve(entries) {
	      const ratio = entries[0].intersectionRatio;
	      if (ratio !== threshold) {
	        if (!isFirstUpdate) {
	          return refresh();
	        }
	        if (!ratio) {
	          timeoutId = setTimeout(() => {
	            refresh(false, 1e-7);
	          }, 100);
	        } else {
	          refresh(false, ratio);
	        }
	      }
	      isFirstUpdate = false;
	    }

	    // Older browsers don't support a `document` as the root and will throw an
	    // error.
	    try {
	      io = new IntersectionObserver(handleObserve, {
	        ...options,
	        // Handle <iframe>s
	        root: root.ownerDocument
	      });
	    } catch (e) {
	      io = new IntersectionObserver(handleObserve, options);
	    }
	    io.observe(element);
	  }
	  refresh(true);
	  return cleanup;
	}

	/**
	 * Automatically updates the position of the floating element when necessary.
	 * Should only be called when the floating element is mounted on the DOM or
	 * visible on the screen.
	 * @returns cleanup function that should be invoked when the floating element is
	 * removed from the DOM or hidden from the screen.
	 * @see https://floating-ui.com/docs/autoUpdate
	 */
	function autoUpdate(reference, floating, update, options) {
	  if (options === void 0) {
	    options = {};
	  }
	  const {
	    ancestorScroll = true,
	    ancestorResize = true,
	    elementResize = typeof ResizeObserver === 'function',
	    layoutShift = typeof IntersectionObserver === 'function',
	    animationFrame = false
	  } = options;
	  const referenceEl = unwrapElement(reference);
	  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
	  ancestors.forEach(ancestor => {
	    ancestorScroll && ancestor.addEventListener('scroll', update, {
	      passive: true
	    });
	    ancestorResize && ancestor.addEventListener('resize', update);
	  });
	  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
	  let reobserveFrame = -1;
	  let resizeObserver = null;
	  if (elementResize) {
	    resizeObserver = new ResizeObserver(_ref => {
	      let [firstEntry] = _ref;
	      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
	        // Prevent update loops when using the `size` middleware.
	        // https://github.com/floating-ui/floating-ui/issues/1740
	        resizeObserver.unobserve(floating);
	        cancelAnimationFrame(reobserveFrame);
	        reobserveFrame = requestAnimationFrame(() => {
	          resizeObserver && resizeObserver.observe(floating);
	        });
	      }
	      update();
	    });
	    if (referenceEl && !animationFrame) {
	      resizeObserver.observe(referenceEl);
	    }
	    resizeObserver.observe(floating);
	  }
	  let frameId;
	  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
	  if (animationFrame) {
	    frameLoop();
	  }
	  function frameLoop() {
	    const nextRefRect = getBoundingClientRect(reference);
	    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
	      update();
	    }
	    prevRefRect = nextRefRect;
	    frameId = requestAnimationFrame(frameLoop);
	  }
	  update();
	  return () => {
	    ancestors.forEach(ancestor => {
	      ancestorScroll && ancestor.removeEventListener('scroll', update);
	      ancestorResize && ancestor.removeEventListener('resize', update);
	    });
	    cleanupIo && cleanupIo();
	    resizeObserver && resizeObserver.disconnect();
	    resizeObserver = null;
	    if (animationFrame) {
	      cancelAnimationFrame(frameId);
	    }
	  };
	}

	var index = typeof document !== 'undefined' ? React$1.useLayoutEffect : React$1.useEffect;

	var _excluded$3 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
	// ==============================
	// NO OP
	// ==============================

	var noop = function noop() {};

	// ==============================
	// Class Name Prefixer
	// ==============================

	/**
	 String representation of component state for styling with class names.

	 Expects an array of strings OR a string/object pair:
	 - className(['comp', 'comp-arg', 'comp-arg-2'])
	   @returns 'react-select__comp react-select__comp-arg react-select__comp-arg-2'
	 - className('comp', { some: true, state: false })
	   @returns 'react-select__comp react-select__comp--some'
	*/
	function applyPrefixToName(prefix, name) {
	  if (!name) {
	    return prefix;
	  } else if (name[0] === '-') {
	    return prefix + name;
	  } else {
	    return prefix + '__' + name;
	  }
	}
	function classNames(prefix, state) {
	  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    classNameList[_key - 2] = arguments[_key];
	  }
	  var arr = [].concat(classNameList);
	  if (state && prefix) {
	    for (var key in state) {
	      if (state.hasOwnProperty(key) && state[key]) {
	        arr.push("".concat(applyPrefixToName(prefix, key)));
	      }
	    }
	  }
	  return arr.filter(function (i) {
	    return i;
	  }).map(function (i) {
	    return String(i).trim();
	  }).join(' ');
	}
	// ==============================
	// Clean Value
	// ==============================

	var cleanValue = function cleanValue(value) {
	  if (isArray(value)) return value.filter(Boolean);
	  if (_typeof$1(value) === 'object' && value !== null) return [value];
	  return [];
	};

	// ==============================
	// Clean Common Props
	// ==============================

	var cleanCommonProps = function cleanCommonProps(props) {
	  //className
	  props.className;
	    props.clearValue;
	    props.cx;
	    props.getStyles;
	    props.getClassNames;
	    props.getValue;
	    props.hasValue;
	    props.isMulti;
	    props.isRtl;
	    props.options;
	    props.selectOption;
	    props.selectProps;
	    props.setValue;
	    props.theme;
	    var innerProps = _objectWithoutProperties(props, _excluded$3);
	  return _objectSpread2$8({}, innerProps);
	};

	// ==============================
	// Get Style Props
	// ==============================

	var getStyleProps = function getStyleProps(props, name, classNamesState) {
	  var cx = props.cx,
	    getStyles = props.getStyles,
	    getClassNames = props.getClassNames,
	    className = props.className;
	  return {
	    css: getStyles(name, props),
	    className: cx(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames(name, props), className)
	  };
	};

	// ==============================
	// Scroll Helpers
	// ==============================

	function isDocumentElement(el) {
	  return [document.documentElement, document.body, window].indexOf(el) > -1;
	}

	// Normalized Scroll Top
	// ------------------------------

	function normalizedHeight(el) {
	  if (isDocumentElement(el)) {
	    return window.innerHeight;
	  }
	  return el.clientHeight;
	}

	// Normalized scrollTo & scrollTop
	// ------------------------------

	function getScrollTop(el) {
	  if (isDocumentElement(el)) {
	    return window.pageYOffset;
	  }
	  return el.scrollTop;
	}
	function scrollTo(el, top) {
	  // with a scroll distance, we perform scroll on the element
	  if (isDocumentElement(el)) {
	    window.scrollTo(0, top);
	    return;
	  }
	  el.scrollTop = top;
	}

	// Get Scroll Parent
	// ------------------------------

	function getScrollParent(element) {
	  var style = getComputedStyle(element);
	  var excludeStaticParent = style.position === 'absolute';
	  var overflowRx = /(auto|scroll)/;
	  if (style.position === 'fixed') return document.documentElement;
	  for (var parent = element; parent = parent.parentElement;) {
	    style = getComputedStyle(parent);
	    if (excludeStaticParent && style.position === 'static') {
	      continue;
	    }
	    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
	      return parent;
	    }
	  }
	  return document.documentElement;
	}

	// Animated Scroll To
	// ------------------------------

	/**
	  @param t: time (elapsed)
	  @param b: initial value
	  @param c: amount of change
	  @param d: duration
	*/
	function easeOutCubic(t, b, c, d) {
	  return c * ((t = t / d - 1) * t * t + 1) + b;
	}
	function animatedScrollTo(element, to) {
	  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;
	  var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;
	  var start = getScrollTop(element);
	  var change = to - start;
	  var increment = 10;
	  var currentTime = 0;
	  function animateScroll() {
	    currentTime += increment;
	    var val = easeOutCubic(currentTime, start, change, duration);
	    scrollTo(element, val);
	    if (currentTime < duration) {
	      window.requestAnimationFrame(animateScroll);
	    } else {
	      callback(element);
	    }
	  }
	  animateScroll();
	}

	// Scroll Into View
	// ------------------------------

	function scrollIntoView(menuEl, focusedEl) {
	  var menuRect = menuEl.getBoundingClientRect();
	  var focusedRect = focusedEl.getBoundingClientRect();
	  var overScroll = focusedEl.offsetHeight / 3;
	  if (focusedRect.bottom + overScroll > menuRect.bottom) {
	    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
	  } else if (focusedRect.top - overScroll < menuRect.top) {
	    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
	  }
	}

	// ==============================
	// Get bounding client object
	// ==============================

	// cannot get keys using array notation with DOMRect
	function getBoundingClientObj(element) {
	  var rect = element.getBoundingClientRect();
	  return {
	    bottom: rect.bottom,
	    height: rect.height,
	    left: rect.left,
	    right: rect.right,
	    top: rect.top,
	    width: rect.width
	  };
	}

	// ==============================
	// Touch Capability Detector
	// ==============================

	function isTouchCapable() {
	  try {
	    document.createEvent('TouchEvent');
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	// ==============================
	// Mobile Device Detector
	// ==============================

	function isMobileDevice() {
	  try {
	    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
	  } catch (e) {
	    return false;
	  }
	}

	// ==============================
	// Passive Event Detector
	// ==============================

	// https://github.com/rafgraph/detect-it/blob/main/src/index.ts#L19-L36
	var passiveOptionAccessed = false;
	var options = {
	  get passive() {
	    return passiveOptionAccessed = true;
	  }
	};
	// check for SSR
	var w = typeof window !== 'undefined' ? window : {};
	if (w.addEventListener && w.removeEventListener) {
	  w.addEventListener('p', noop, options);
	  w.removeEventListener('p', noop, false);
	}
	var supportsPassiveEvents = passiveOptionAccessed;
	function notNullish(item) {
	  return item != null;
	}
	function isArray(arg) {
	  return Array.isArray(arg);
	}
	function valueTernary(isMulti, multiValue, singleValue) {
	  return isMulti ? multiValue : singleValue;
	}
	function singleValueAsValue(singleValue) {
	  return singleValue;
	}
	function multiValueAsValue(multiValue) {
	  return multiValue;
	}
	var removeProps = function removeProps(propsObj) {
	  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    properties[_key2 - 1] = arguments[_key2];
	  }
	  var propsMap = Object.entries(propsObj).filter(function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 1),
	      key = _ref2[0];
	    return !properties.includes(key);
	  });
	  return propsMap.reduce(function (newProps, _ref3) {
	    var _ref4 = _slicedToArray(_ref3, 2),
	      key = _ref4[0],
	      val = _ref4[1];
	    newProps[key] = val;
	    return newProps;
	  }, {});
	};

	function getMenuPlacement(_ref) {
	  var preferredMaxHeight = _ref.maxHeight,
	    menuEl = _ref.menuEl,
	    minHeight = _ref.minHeight,
	    preferredPlacement = _ref.placement,
	    shouldScroll = _ref.shouldScroll,
	    isFixedPosition = _ref.isFixedPosition,
	    controlHeight = _ref.controlHeight;
	  var scrollParent = getScrollParent(menuEl);
	  var defaultState = {
	    placement: 'bottom',
	    maxHeight: preferredMaxHeight
	  };

	  // something went wrong, return default state
	  if (!menuEl || !menuEl.offsetParent) return defaultState;

	  // we can't trust `scrollParent.scrollHeight` --> it may increase when
	  // the menu is rendered
	  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(),
	    scrollHeight = _scrollParent$getBoun.height;
	  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(),
	    menuBottom = _menuEl$getBoundingCl.bottom,
	    menuHeight = _menuEl$getBoundingCl.height,
	    menuTop = _menuEl$getBoundingCl.top;
	  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(),
	    containerTop = _menuEl$offsetParent$.top;
	  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
	  var scrollTop = getScrollTop(scrollParent);
	  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
	  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
	  var viewSpaceAbove = containerTop - marginTop;
	  var viewSpaceBelow = viewHeight - menuTop;
	  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
	  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
	  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
	  var scrollUp = scrollTop + menuTop - marginTop;
	  var scrollDuration = 160;
	  switch (preferredPlacement) {
	    case 'auto':
	    case 'bottom':
	      // 1: the menu will fit, do nothing
	      if (viewSpaceBelow >= menuHeight) {
	        return {
	          placement: 'bottom',
	          maxHeight: preferredMaxHeight
	        };
	      }

	      // 2: the menu will fit, if scrolled
	      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
	        if (shouldScroll) {
	          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
	        }
	        return {
	          placement: 'bottom',
	          maxHeight: preferredMaxHeight
	        };
	      }

	      // 3: the menu will fit, if constrained
	      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
	        if (shouldScroll) {
	          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
	        }

	        // we want to provide as much of the menu as possible to the user,
	        // so give them whatever is available below rather than the minHeight.
	        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
	        return {
	          placement: 'bottom',
	          maxHeight: constrainedHeight
	        };
	      }

	      // 4. Forked beviour when there isn't enough space below

	      // AUTO: flip the menu, render above
	      if (preferredPlacement === 'auto' || isFixedPosition) {
	        // may need to be constrained after flipping
	        var _constrainedHeight = preferredMaxHeight;
	        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
	        if (spaceAbove >= minHeight) {
	          _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight, preferredMaxHeight);
	        }
	        return {
	          placement: 'top',
	          maxHeight: _constrainedHeight
	        };
	      }

	      // BOTTOM: allow browser to increase scrollable area and immediately set scroll
	      if (preferredPlacement === 'bottom') {
	        if (shouldScroll) {
	          scrollTo(scrollParent, scrollDown);
	        }
	        return {
	          placement: 'bottom',
	          maxHeight: preferredMaxHeight
	        };
	      }
	      break;
	    case 'top':
	      // 1: the menu will fit, do nothing
	      if (viewSpaceAbove >= menuHeight) {
	        return {
	          placement: 'top',
	          maxHeight: preferredMaxHeight
	        };
	      }

	      // 2: the menu will fit, if scrolled
	      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
	        if (shouldScroll) {
	          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
	        }
	        return {
	          placement: 'top',
	          maxHeight: preferredMaxHeight
	        };
	      }

	      // 3: the menu will fit, if constrained
	      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
	        var _constrainedHeight2 = preferredMaxHeight;

	        // we want to provide as much of the menu as possible to the user,
	        // so give them whatever is available below rather than the minHeight.
	        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
	          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
	        }
	        if (shouldScroll) {
	          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
	        }
	        return {
	          placement: 'top',
	          maxHeight: _constrainedHeight2
	        };
	      }

	      // 4. not enough space, the browser WILL NOT increase scrollable area when
	      // absolutely positioned element rendered above the viewport (only below).
	      // Flip the menu, render below
	      return {
	        placement: 'bottom',
	        maxHeight: preferredMaxHeight
	      };
	    default:
	      throw new Error("Invalid placement provided \"".concat(preferredPlacement, "\"."));
	  }
	  return defaultState;
	}

	// Menu Component
	// ------------------------------

	function alignToControl(placement) {
	  var placementToCSSProp = {
	    bottom: 'top',
	    top: 'bottom'
	  };
	  return placement ? placementToCSSProp[placement] : 'bottom';
	}
	var coercePlacement = function coercePlacement(p) {
	  return p === 'auto' ? 'bottom' : p;
	};
	var menuCSS = function menuCSS(_ref2, unstyled) {
	  var _objectSpread2;
	  var placement = _ref2.placement,
	    _ref2$theme = _ref2.theme,
	    borderRadius = _ref2$theme.borderRadius,
	    spacing = _ref2$theme.spacing,
	    colors = _ref2$theme.colors;
	  return _objectSpread2$8((_objectSpread2 = {
	    label: 'menu'
	  }, _defineProperty$2(_objectSpread2, alignToControl(placement), '100%'), _defineProperty$2(_objectSpread2, "position", 'absolute'), _defineProperty$2(_objectSpread2, "width", '100%'), _defineProperty$2(_objectSpread2, "zIndex", 1), _objectSpread2), unstyled ? {} : {
	    backgroundColor: colors.neutral0,
	    borderRadius: borderRadius,
	    boxShadow: '0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)',
	    marginBottom: spacing.menuGutter,
	    marginTop: spacing.menuGutter
	  });
	};
	var PortalPlacementContext = /*#__PURE__*/React$1.createContext(null);

	// NOTE: internal only
	var MenuPlacer = function MenuPlacer(props) {
	  var children = props.children,
	    minMenuHeight = props.minMenuHeight,
	    maxMenuHeight = props.maxMenuHeight,
	    menuPlacement = props.menuPlacement,
	    menuPosition = props.menuPosition,
	    menuShouldScrollIntoView = props.menuShouldScrollIntoView,
	    theme = props.theme;
	  var _ref3 = React$1.useContext(PortalPlacementContext) || {},
	    setPortalPlacement = _ref3.setPortalPlacement;
	  var ref = React$1.useRef(null);
	  var _useState = React$1.useState(maxMenuHeight),
	    _useState2 = _slicedToArray(_useState, 2),
	    maxHeight = _useState2[0],
	    setMaxHeight = _useState2[1];
	  var _useState3 = React$1.useState(null),
	    _useState4 = _slicedToArray(_useState3, 2),
	    placement = _useState4[0],
	    setPlacement = _useState4[1];
	  var controlHeight = theme.spacing.controlHeight;
	  index(function () {
	    var menuEl = ref.current;
	    if (!menuEl) return;

	    // DO NOT scroll if position is fixed
	    var isFixedPosition = menuPosition === 'fixed';
	    var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
	    var state = getMenuPlacement({
	      maxHeight: maxMenuHeight,
	      menuEl: menuEl,
	      minHeight: minMenuHeight,
	      placement: menuPlacement,
	      shouldScroll: shouldScroll,
	      isFixedPosition: isFixedPosition,
	      controlHeight: controlHeight
	    });
	    setMaxHeight(state.maxHeight);
	    setPlacement(state.placement);
	    setPortalPlacement === null || setPortalPlacement === void 0 ? void 0 : setPortalPlacement(state.placement);
	  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight]);
	  return children({
	    ref: ref,
	    placerProps: _objectSpread2$8(_objectSpread2$8({}, props), {}, {
	      placement: placement || coercePlacement(menuPlacement),
	      maxHeight: maxHeight
	    })
	  });
	};
	var Menu = function Menu(props) {
	  var children = props.children,
	    innerRef = props.innerRef,
	    innerProps = props.innerProps;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'menu', {
	    menu: true
	  }), {
	    ref: innerRef
	  }, innerProps), children);
	};
	var Menu$1 = Menu;

	// ==============================
	// Menu List
	// ==============================

	var menuListCSS = function menuListCSS(_ref4, unstyled) {
	  var maxHeight = _ref4.maxHeight,
	    baseUnit = _ref4.theme.spacing.baseUnit;
	  return _objectSpread2$8({
	    maxHeight: maxHeight,
	    overflowY: 'auto',
	    position: 'relative',
	    // required for offset[Height, Top] > keyboard scroll
	    WebkitOverflowScrolling: 'touch'
	  }, unstyled ? {} : {
	    paddingBottom: baseUnit,
	    paddingTop: baseUnit
	  });
	};
	var MenuList = function MenuList(props) {
	  var children = props.children,
	    innerProps = props.innerProps,
	    innerRef = props.innerRef,
	    isMulti = props.isMulti;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'menuList', {
	    'menu-list': true,
	    'menu-list--is-multi': isMulti
	  }), {
	    ref: innerRef
	  }, innerProps), children);
	};

	// ==============================
	// Menu Notices
	// ==============================

	var noticeCSS = function noticeCSS(_ref5, unstyled) {
	  var _ref5$theme = _ref5.theme,
	    baseUnit = _ref5$theme.spacing.baseUnit,
	    colors = _ref5$theme.colors;
	  return _objectSpread2$8({
	    textAlign: 'center'
	  }, unstyled ? {} : {
	    color: colors.neutral40,
	    padding: "".concat(baseUnit * 2, "px ").concat(baseUnit * 3, "px")
	  });
	};
	var noOptionsMessageCSS = noticeCSS;
	var loadingMessageCSS = noticeCSS;
	var NoOptionsMessage = function NoOptionsMessage(props) {
	  var children = props.children,
	    innerProps = props.innerProps;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'noOptionsMessage', {
	    'menu-notice': true,
	    'menu-notice--no-options': true
	  }), innerProps), children);
	};
	NoOptionsMessage.defaultProps = {
	  children: 'No options'
	};
	var LoadingMessage = function LoadingMessage(props) {
	  var children = props.children,
	    innerProps = props.innerProps;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'loadingMessage', {
	    'menu-notice': true,
	    'menu-notice--loading': true
	  }), innerProps), children);
	};
	LoadingMessage.defaultProps = {
	  children: 'Loading...'
	};

	// ==============================
	// Menu Portal
	// ==============================

	var menuPortalCSS = function menuPortalCSS(_ref6) {
	  var rect = _ref6.rect,
	    offset = _ref6.offset,
	    position = _ref6.position;
	  return {
	    left: rect.left,
	    position: position,
	    top: offset,
	    width: rect.width,
	    zIndex: 1
	  };
	};
	var MenuPortal = function MenuPortal(props) {
	  var appendTo = props.appendTo,
	    children = props.children,
	    controlElement = props.controlElement,
	    innerProps = props.innerProps,
	    menuPlacement = props.menuPlacement,
	    menuPosition = props.menuPosition;
	  var menuPortalRef = React$1.useRef(null);
	  var cleanupRef = React$1.useRef(null);
	  var _useState5 = React$1.useState(coercePlacement(menuPlacement)),
	    _useState6 = _slicedToArray(_useState5, 2),
	    placement = _useState6[0],
	    setPortalPlacement = _useState6[1];
	  var portalPlacementContext = React$1.useMemo(function () {
	    return {
	      setPortalPlacement: setPortalPlacement
	    };
	  }, []);
	  var _useState7 = React$1.useState(null),
	    _useState8 = _slicedToArray(_useState7, 2),
	    computedPosition = _useState8[0],
	    setComputedPosition = _useState8[1];
	  var updateComputedPosition = React$1.useCallback(function () {
	    if (!controlElement) return;
	    var rect = getBoundingClientObj(controlElement);
	    var scrollDistance = menuPosition === 'fixed' ? 0 : window.pageYOffset;
	    var offset = rect[placement] + scrollDistance;
	    if (offset !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
	      setComputedPosition({
	        offset: offset,
	        rect: rect
	      });
	    }
	  }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
	  index(function () {
	    updateComputedPosition();
	  }, [updateComputedPosition]);
	  var runAutoUpdate = React$1.useCallback(function () {
	    if (typeof cleanupRef.current === 'function') {
	      cleanupRef.current();
	      cleanupRef.current = null;
	    }
	    if (controlElement && menuPortalRef.current) {
	      cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
	        elementResize: 'ResizeObserver' in window
	      });
	    }
	  }, [controlElement, updateComputedPosition]);
	  index(function () {
	    runAutoUpdate();
	  }, [runAutoUpdate]);
	  var setMenuPortalElement = React$1.useCallback(function (menuPortalElement) {
	    menuPortalRef.current = menuPortalElement;
	    runAutoUpdate();
	  }, [runAutoUpdate]);

	  // bail early if required elements aren't present
	  if (!appendTo && menuPosition !== 'fixed' || !computedPosition) return null;

	  // same wrapper element whether fixed or portalled
	  var menuWrapper = jsx("div", _extends$1({
	    ref: setMenuPortalElement
	  }, getStyleProps(_objectSpread2$8(_objectSpread2$8({}, props), {}, {
	    offset: computedPosition.offset,
	    position: menuPosition,
	    rect: computedPosition.rect
	  }), 'menuPortal', {
	    'menu-portal': true
	  }), innerProps), children);
	  return jsx(PortalPlacementContext.Provider, {
	    value: portalPlacementContext
	  }, appendTo ? /*#__PURE__*/ReactDOM.createPortal(menuWrapper, appendTo) : menuWrapper);
	};

	// ==============================
	// Root Container
	// ==============================

	var containerCSS = function containerCSS(_ref) {
	  var isDisabled = _ref.isDisabled,
	    isRtl = _ref.isRtl;
	  return {
	    label: 'container',
	    direction: isRtl ? 'rtl' : undefined,
	    pointerEvents: isDisabled ? 'none' : undefined,
	    // cancel mouse events when disabled
	    position: 'relative'
	  };
	};
	var SelectContainer = function SelectContainer(props) {
	  var children = props.children,
	    innerProps = props.innerProps,
	    isDisabled = props.isDisabled,
	    isRtl = props.isRtl;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'container', {
	    '--is-disabled': isDisabled,
	    '--is-rtl': isRtl
	  }), innerProps), children);
	};

	// ==============================
	// Value Container
	// ==============================

	var valueContainerCSS = function valueContainerCSS(_ref2, unstyled) {
	  var spacing = _ref2.theme.spacing,
	    isMulti = _ref2.isMulti,
	    hasValue = _ref2.hasValue,
	    controlShouldRenderValue = _ref2.selectProps.controlShouldRenderValue;
	  return _objectSpread2$8({
	    alignItems: 'center',
	    display: isMulti && hasValue && controlShouldRenderValue ? 'flex' : 'grid',
	    flex: 1,
	    flexWrap: 'wrap',
	    WebkitOverflowScrolling: 'touch',
	    position: 'relative',
	    overflow: 'hidden'
	  }, unstyled ? {} : {
	    padding: "".concat(spacing.baseUnit / 2, "px ").concat(spacing.baseUnit * 2, "px")
	  });
	};
	var ValueContainer = function ValueContainer(props) {
	  var children = props.children,
	    innerProps = props.innerProps,
	    isMulti = props.isMulti,
	    hasValue = props.hasValue;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'valueContainer', {
	    'value-container': true,
	    'value-container--is-multi': isMulti,
	    'value-container--has-value': hasValue
	  }), innerProps), children);
	};

	// ==============================
	// Indicator Container
	// ==============================

	var indicatorsContainerCSS = function indicatorsContainerCSS() {
	  return {
	    alignItems: 'center',
	    alignSelf: 'stretch',
	    display: 'flex',
	    flexShrink: 0
	  };
	};
	var IndicatorsContainer = function IndicatorsContainer(props) {
	  var children = props.children,
	    innerProps = props.innerProps;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'indicatorsContainer', {
	    indicators: true
	  }), innerProps), children);
	};

	var _templateObject;
	var _excluded$2 = ["size"];

	// ==============================
	// Dropdown & Clear Icons
	// ==============================
	var _ref2$2 = {
	  name: "8mmkcg",
	  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
	} ;
	var Svg = function Svg(_ref) {
	  var size = _ref.size,
	    props = _objectWithoutProperties(_ref, _excluded$2);
	  return jsx("svg", _extends$1({
	    height: size,
	    width: size,
	    viewBox: "0 0 20 20",
	    "aria-hidden": "true",
	    focusable: "false",
	    css: _ref2$2
	  }, props));
	};
	var CrossIcon = function CrossIcon(props) {
	  return jsx(Svg, _extends$1({
	    size: 20
	  }, props), jsx("path", {
	    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
	  }));
	};
	var DownChevron = function DownChevron(props) {
	  return jsx(Svg, _extends$1({
	    size: 20
	  }, props), jsx("path", {
	    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
	  }));
	};

	// ==============================
	// Dropdown & Clear Buttons
	// ==============================

	var baseCSS = function baseCSS(_ref3, unstyled) {
	  var isFocused = _ref3.isFocused,
	    _ref3$theme = _ref3.theme,
	    baseUnit = _ref3$theme.spacing.baseUnit,
	    colors = _ref3$theme.colors;
	  return _objectSpread2$8({
	    label: 'indicatorContainer',
	    display: 'flex',
	    transition: 'color 150ms'
	  }, unstyled ? {} : {
	    color: isFocused ? colors.neutral60 : colors.neutral20,
	    padding: baseUnit * 2,
	    ':hover': {
	      color: isFocused ? colors.neutral80 : colors.neutral40
	    }
	  });
	};
	var dropdownIndicatorCSS = baseCSS;
	var DropdownIndicator = function DropdownIndicator(props) {
	  var children = props.children,
	    innerProps = props.innerProps;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'dropdownIndicator', {
	    indicator: true,
	    'dropdown-indicator': true
	  }), innerProps), children || jsx(DownChevron, null));
	};
	var clearIndicatorCSS = baseCSS;
	var ClearIndicator = function ClearIndicator(props) {
	  var children = props.children,
	    innerProps = props.innerProps;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'clearIndicator', {
	    indicator: true,
	    'clear-indicator': true
	  }), innerProps), children || jsx(CrossIcon, null));
	};

	// ==============================
	// Separator
	// ==============================

	var indicatorSeparatorCSS = function indicatorSeparatorCSS(_ref4, unstyled) {
	  var isDisabled = _ref4.isDisabled,
	    _ref4$theme = _ref4.theme,
	    baseUnit = _ref4$theme.spacing.baseUnit,
	    colors = _ref4$theme.colors;
	  return _objectSpread2$8({
	    label: 'indicatorSeparator',
	    alignSelf: 'stretch',
	    width: 1
	  }, unstyled ? {} : {
	    backgroundColor: isDisabled ? colors.neutral10 : colors.neutral20,
	    marginBottom: baseUnit * 2,
	    marginTop: baseUnit * 2
	  });
	};
	var IndicatorSeparator = function IndicatorSeparator(props) {
	  var innerProps = props.innerProps;
	  return jsx("span", _extends$1({}, innerProps, getStyleProps(props, 'indicatorSeparator', {
	    'indicator-separator': true
	  })));
	};

	// ==============================
	// Loading
	// ==============================

	var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
	var loadingIndicatorCSS = function loadingIndicatorCSS(_ref5, unstyled) {
	  var isFocused = _ref5.isFocused,
	    size = _ref5.size,
	    _ref5$theme = _ref5.theme,
	    colors = _ref5$theme.colors,
	    baseUnit = _ref5$theme.spacing.baseUnit;
	  return _objectSpread2$8({
	    label: 'loadingIndicator',
	    display: 'flex',
	    transition: 'color 150ms',
	    alignSelf: 'center',
	    fontSize: size,
	    lineHeight: 1,
	    marginRight: size,
	    textAlign: 'center',
	    verticalAlign: 'middle'
	  }, unstyled ? {} : {
	    color: isFocused ? colors.neutral60 : colors.neutral20,
	    padding: baseUnit * 2
	  });
	};
	var LoadingDot = function LoadingDot(_ref6) {
	  var delay = _ref6.delay,
	    offset = _ref6.offset;
	  return jsx("span", {
	    css: /*#__PURE__*/css$2({
	      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay, "ms infinite;"),
	      backgroundColor: 'currentColor',
	      borderRadius: '1em',
	      display: 'inline-block',
	      marginLeft: offset ? '1em' : undefined,
	      height: '1em',
	      verticalAlign: 'top',
	      width: '1em'
	    }, "" , "" )
	  });
	};
	var LoadingIndicator = function LoadingIndicator(props) {
	  var innerProps = props.innerProps,
	    isRtl = props.isRtl;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'loadingIndicator', {
	    indicator: true,
	    'loading-indicator': true
	  }), innerProps), jsx(LoadingDot, {
	    delay: 0,
	    offset: isRtl
	  }), jsx(LoadingDot, {
	    delay: 160,
	    offset: true
	  }), jsx(LoadingDot, {
	    delay: 320,
	    offset: !isRtl
	  }));
	};
	LoadingIndicator.defaultProps = {
	  size: 4
	};

	var css$1 = function css(_ref, unstyled) {
	  var isDisabled = _ref.isDisabled,
	    isFocused = _ref.isFocused,
	    _ref$theme = _ref.theme,
	    colors = _ref$theme.colors,
	    borderRadius = _ref$theme.borderRadius,
	    spacing = _ref$theme.spacing;
	  return _objectSpread2$8({
	    label: 'control',
	    alignItems: 'center',
	    cursor: 'default',
	    display: 'flex',
	    flexWrap: 'wrap',
	    justifyContent: 'space-between',
	    minHeight: spacing.controlHeight,
	    outline: '0 !important',
	    position: 'relative',
	    transition: 'all 100ms'
	  }, unstyled ? {} : {
	    backgroundColor: isDisabled ? colors.neutral5 : colors.neutral0,
	    borderColor: isDisabled ? colors.neutral10 : isFocused ? colors.primary : colors.neutral20,
	    borderRadius: borderRadius,
	    borderStyle: 'solid',
	    borderWidth: 1,
	    boxShadow: isFocused ? "0 0 0 1px ".concat(colors.primary) : undefined,
	    '&:hover': {
	      borderColor: isFocused ? colors.primary : colors.neutral30
	    }
	  });
	};
	var Control = function Control(props) {
	  var children = props.children,
	    isDisabled = props.isDisabled,
	    isFocused = props.isFocused,
	    innerRef = props.innerRef,
	    innerProps = props.innerProps,
	    menuIsOpen = props.menuIsOpen;
	  return jsx("div", _extends$1({
	    ref: innerRef
	  }, getStyleProps(props, 'control', {
	    control: true,
	    'control--is-disabled': isDisabled,
	    'control--is-focused': isFocused,
	    'control--menu-is-open': menuIsOpen
	  }), innerProps), children);
	};
	var Control$1 = Control;

	var _excluded$1 = ["data"];
	var groupCSS = function groupCSS(_ref, unstyled) {
	  var spacing = _ref.theme.spacing;
	  return unstyled ? {} : {
	    paddingBottom: spacing.baseUnit * 2,
	    paddingTop: spacing.baseUnit * 2
	  };
	};
	var Group = function Group(props) {
	  var children = props.children,
	    cx = props.cx,
	    getStyles = props.getStyles,
	    getClassNames = props.getClassNames,
	    Heading = props.Heading,
	    headingProps = props.headingProps,
	    innerProps = props.innerProps,
	    label = props.label,
	    theme = props.theme,
	    selectProps = props.selectProps;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'group', {
	    group: true
	  }), innerProps), jsx(Heading, _extends$1({}, headingProps, {
	    selectProps: selectProps,
	    theme: theme,
	    getStyles: getStyles,
	    getClassNames: getClassNames,
	    cx: cx
	  }), label), jsx("div", null, children));
	};
	var groupHeadingCSS = function groupHeadingCSS(_ref2, unstyled) {
	  var _ref2$theme = _ref2.theme,
	    colors = _ref2$theme.colors,
	    spacing = _ref2$theme.spacing;
	  return _objectSpread2$8({
	    label: 'group',
	    cursor: 'default',
	    display: 'block'
	  }, unstyled ? {} : {
	    color: colors.neutral40,
	    fontSize: '75%',
	    fontWeight: 500,
	    marginBottom: '0.25em',
	    paddingLeft: spacing.baseUnit * 3,
	    paddingRight: spacing.baseUnit * 3,
	    textTransform: 'uppercase'
	  });
	};
	var GroupHeading = function GroupHeading(props) {
	  var _cleanCommonProps = cleanCommonProps(props);
	    _cleanCommonProps.data;
	    var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
	  return jsx("div", _extends$1({}, getStyleProps(props, 'groupHeading', {
	    'group-heading': true
	  }), innerProps));
	};
	var Group$1 = Group;

	var _excluded$4 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
	var inputCSS = function inputCSS(_ref, unstyled) {
	  var isDisabled = _ref.isDisabled,
	    value = _ref.value,
	    _ref$theme = _ref.theme,
	    spacing = _ref$theme.spacing,
	    colors = _ref$theme.colors;
	  return _objectSpread2$8(_objectSpread2$8({
	    visibility: isDisabled ? 'hidden' : 'visible',
	    // force css to recompute when value change due to @emotion bug.
	    // We can remove it whenever the bug is fixed.
	    transform: value ? 'translateZ(0)' : ''
	  }, containerStyle), unstyled ? {} : {
	    margin: spacing.baseUnit / 2,
	    paddingBottom: spacing.baseUnit / 2,
	    paddingTop: spacing.baseUnit / 2,
	    color: colors.neutral80
	  });
	};
	var spacingStyle = {
	  gridArea: '1 / 2',
	  font: 'inherit',
	  minWidth: '2px',
	  border: 0,
	  margin: 0,
	  outline: 0,
	  padding: 0
	};
	var containerStyle = {
	  flex: '1 1 auto',
	  display: 'inline-grid',
	  gridArea: '1 / 1 / 2 / 3',
	  gridTemplateColumns: '0 min-content',
	  '&:after': _objectSpread2$8({
	    content: 'attr(data-value) " "',
	    visibility: 'hidden',
	    whiteSpace: 'pre'
	  }, spacingStyle)
	};
	var inputStyle = function inputStyle(isHidden) {
	  return _objectSpread2$8({
	    label: 'input',
	    color: 'inherit',
	    background: 0,
	    opacity: isHidden ? 0 : 1,
	    width: '100%'
	  }, spacingStyle);
	};
	var Input = function Input(props) {
	  var cx = props.cx,
	    value = props.value;
	  var _cleanCommonProps = cleanCommonProps(props),
	    innerRef = _cleanCommonProps.innerRef,
	    isDisabled = _cleanCommonProps.isDisabled,
	    isHidden = _cleanCommonProps.isHidden,
	    inputClassName = _cleanCommonProps.inputClassName,
	    innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$4);
	  return jsx("div", _extends$1({}, getStyleProps(props, 'input', {
	    'input-container': true
	  }), {
	    "data-value": value || ''
	  }), jsx("input", _extends$1({
	    className: cx({
	      input: true
	    }, inputClassName),
	    ref: innerRef,
	    style: inputStyle(isHidden),
	    disabled: isDisabled
	  }, innerProps)));
	};
	var Input$1 = Input;

	var multiValueCSS = function multiValueCSS(_ref, unstyled) {
	  var _ref$theme = _ref.theme,
	    spacing = _ref$theme.spacing,
	    borderRadius = _ref$theme.borderRadius,
	    colors = _ref$theme.colors;
	  return _objectSpread2$8({
	    label: 'multiValue',
	    display: 'flex',
	    minWidth: 0
	  }, unstyled ? {} : {
	    backgroundColor: colors.neutral10,
	    borderRadius: borderRadius / 2,
	    margin: spacing.baseUnit / 2
	  });
	};
	var multiValueLabelCSS = function multiValueLabelCSS(_ref2, unstyled) {
	  var _ref2$theme = _ref2.theme,
	    borderRadius = _ref2$theme.borderRadius,
	    colors = _ref2$theme.colors,
	    cropWithEllipsis = _ref2.cropWithEllipsis;
	  return _objectSpread2$8({
	    overflow: 'hidden',
	    textOverflow: cropWithEllipsis || cropWithEllipsis === undefined ? 'ellipsis' : undefined,
	    whiteSpace: 'nowrap'
	  }, unstyled ? {} : {
	    borderRadius: borderRadius / 2,
	    color: colors.neutral80,
	    fontSize: '85%',
	    padding: 3,
	    paddingLeft: 6
	  });
	};
	var multiValueRemoveCSS = function multiValueRemoveCSS(_ref3, unstyled) {
	  var _ref3$theme = _ref3.theme,
	    spacing = _ref3$theme.spacing,
	    borderRadius = _ref3$theme.borderRadius,
	    colors = _ref3$theme.colors,
	    isFocused = _ref3.isFocused;
	  return _objectSpread2$8({
	    alignItems: 'center',
	    display: 'flex'
	  }, unstyled ? {} : {
	    borderRadius: borderRadius / 2,
	    backgroundColor: isFocused ? colors.dangerLight : undefined,
	    paddingLeft: spacing.baseUnit,
	    paddingRight: spacing.baseUnit,
	    ':hover': {
	      backgroundColor: colors.dangerLight,
	      color: colors.danger
	    }
	  });
	};
	var MultiValueGeneric = function MultiValueGeneric(_ref4) {
	  var children = _ref4.children,
	    innerProps = _ref4.innerProps;
	  return jsx("div", innerProps, children);
	};
	var MultiValueContainer = MultiValueGeneric;
	var MultiValueLabel = MultiValueGeneric;
	function MultiValueRemove(_ref5) {
	  var children = _ref5.children,
	    innerProps = _ref5.innerProps;
	  return jsx("div", _extends$1({
	    role: "button"
	  }, innerProps), children || jsx(CrossIcon, {
	    size: 14
	  }));
	}
	var MultiValue = function MultiValue(props) {
	  var children = props.children,
	    components = props.components,
	    data = props.data,
	    innerProps = props.innerProps,
	    isDisabled = props.isDisabled,
	    removeProps = props.removeProps,
	    selectProps = props.selectProps;
	  var Container = components.Container,
	    Label = components.Label,
	    Remove = components.Remove;
	  return jsx(Container, {
	    data: data,
	    innerProps: _objectSpread2$8(_objectSpread2$8({}, getStyleProps(props, 'multiValue', {
	      'multi-value': true,
	      'multi-value--is-disabled': isDisabled
	    })), innerProps),
	    selectProps: selectProps
	  }, jsx(Label, {
	    data: data,
	    innerProps: _objectSpread2$8({}, getStyleProps(props, 'multiValueLabel', {
	      'multi-value__label': true
	    })),
	    selectProps: selectProps
	  }, children), jsx(Remove, {
	    data: data,
	    innerProps: _objectSpread2$8(_objectSpread2$8({}, getStyleProps(props, 'multiValueRemove', {
	      'multi-value__remove': true
	    })), {}, {
	      'aria-label': "Remove ".concat(children || 'option')
	    }, removeProps),
	    selectProps: selectProps
	  }));
	};
	var MultiValue$1 = MultiValue;

	var optionCSS = function optionCSS(_ref, unstyled) {
	  var isDisabled = _ref.isDisabled,
	    isFocused = _ref.isFocused,
	    isSelected = _ref.isSelected,
	    _ref$theme = _ref.theme,
	    spacing = _ref$theme.spacing,
	    colors = _ref$theme.colors;
	  return _objectSpread2$8({
	    label: 'option',
	    cursor: 'default',
	    display: 'block',
	    fontSize: 'inherit',
	    width: '100%',
	    userSelect: 'none',
	    WebkitTapHighlightColor: 'rgba(0, 0, 0, 0)'
	  }, unstyled ? {} : {
	    backgroundColor: isSelected ? colors.primary : isFocused ? colors.primary25 : 'transparent',
	    color: isDisabled ? colors.neutral20 : isSelected ? colors.neutral0 : 'inherit',
	    padding: "".concat(spacing.baseUnit * 2, "px ").concat(spacing.baseUnit * 3, "px"),
	    // provide some affordance on touch devices
	    ':active': {
	      backgroundColor: !isDisabled ? isSelected ? colors.primary : colors.primary50 : undefined
	    }
	  });
	};
	var Option = function Option(props) {
	  var children = props.children,
	    isDisabled = props.isDisabled,
	    isFocused = props.isFocused,
	    isSelected = props.isSelected,
	    innerRef = props.innerRef,
	    innerProps = props.innerProps;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'option', {
	    option: true,
	    'option--is-disabled': isDisabled,
	    'option--is-focused': isFocused,
	    'option--is-selected': isSelected
	  }), {
	    ref: innerRef,
	    "aria-disabled": isDisabled
	  }, innerProps), children);
	};
	var Option$1 = Option;

	var placeholderCSS = function placeholderCSS(_ref, unstyled) {
	  var _ref$theme = _ref.theme,
	    spacing = _ref$theme.spacing,
	    colors = _ref$theme.colors;
	  return _objectSpread2$8({
	    label: 'placeholder',
	    gridArea: '1 / 1 / 2 / 3'
	  }, unstyled ? {} : {
	    color: colors.neutral50,
	    marginLeft: spacing.baseUnit / 2,
	    marginRight: spacing.baseUnit / 2
	  });
	};
	var Placeholder = function Placeholder(props) {
	  var children = props.children,
	    innerProps = props.innerProps;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'placeholder', {
	    placeholder: true
	  }), innerProps), children);
	};
	var Placeholder$1 = Placeholder;

	var css = function css(_ref, unstyled) {
	  var isDisabled = _ref.isDisabled,
	    _ref$theme = _ref.theme,
	    spacing = _ref$theme.spacing,
	    colors = _ref$theme.colors;
	  return _objectSpread2$8({
	    label: 'singleValue',
	    gridArea: '1 / 1 / 2 / 3',
	    maxWidth: '100%',
	    overflow: 'hidden',
	    textOverflow: 'ellipsis',
	    whiteSpace: 'nowrap'
	  }, unstyled ? {} : {
	    color: isDisabled ? colors.neutral40 : colors.neutral80,
	    marginLeft: spacing.baseUnit / 2,
	    marginRight: spacing.baseUnit / 2
	  });
	};
	var SingleValue = function SingleValue(props) {
	  var children = props.children,
	    isDisabled = props.isDisabled,
	    innerProps = props.innerProps;
	  return jsx("div", _extends$1({}, getStyleProps(props, 'singleValue', {
	    'single-value': true,
	    'single-value--is-disabled': isDisabled
	  }), innerProps), children);
	};
	var SingleValue$1 = SingleValue;

	var components = {
	  ClearIndicator: ClearIndicator,
	  Control: Control$1,
	  DropdownIndicator: DropdownIndicator,
	  DownChevron: DownChevron,
	  CrossIcon: CrossIcon,
	  Group: Group$1,
	  GroupHeading: GroupHeading,
	  IndicatorsContainer: IndicatorsContainer,
	  IndicatorSeparator: IndicatorSeparator,
	  Input: Input$1,
	  LoadingIndicator: LoadingIndicator,
	  Menu: Menu$1,
	  MenuList: MenuList,
	  MenuPortal: MenuPortal,
	  LoadingMessage: LoadingMessage,
	  NoOptionsMessage: NoOptionsMessage,
	  MultiValue: MultiValue$1,
	  MultiValueContainer: MultiValueContainer,
	  MultiValueLabel: MultiValueLabel,
	  MultiValueRemove: MultiValueRemove,
	  Option: Option$1,
	  Placeholder: Placeholder$1,
	  SelectContainer: SelectContainer,
	  SingleValue: SingleValue$1,
	  ValueContainer: ValueContainer
	};
	var defaultComponents = function defaultComponents(props) {
	  return _objectSpread2$8(_objectSpread2$8({}, components), props.components);
	};

	// Assistive text to describe visual elements. Hidden for sighted users.
	var _ref = {
	  name: "7pg0cj-a11yText",
	  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
	} ;
	var A11yText = function A11yText(props) {
	  return jsx("span", _extends$1({
	    css: _ref
	  }, props));
	};
	var A11yText$1 = A11yText;

	var defaultAriaLiveMessages = {
	  guidance: function guidance(props) {
	    var isSearchable = props.isSearchable,
	      isMulti = props.isMulti,
	      isDisabled = props.isDisabled,
	      tabSelectsValue = props.tabSelectsValue,
	      context = props.context;
	    switch (context) {
	      case 'menu':
	        return "Use Up and Down to choose options".concat(isDisabled ? '' : ', press Enter to select the currently focused option', ", press Escape to exit the menu").concat(tabSelectsValue ? ', press Tab to select the option and exit the menu' : '', ".");
	      case 'input':
	        return "".concat(props['aria-label'] || 'Select', " is focused ").concat(isSearchable ? ',type to refine list' : '', ", press Down to open the menu, ").concat(isMulti ? ' press left to focus selected values' : '');
	      case 'value':
	        return 'Use left and right to toggle between focused values, press Backspace to remove the currently focused value';
	      default:
	        return '';
	    }
	  },
	  onChange: function onChange(props) {
	    var action = props.action,
	      _props$label = props.label,
	      label = _props$label === void 0 ? '' : _props$label,
	      labels = props.labels,
	      isDisabled = props.isDisabled;
	    switch (action) {
	      case 'deselect-option':
	      case 'pop-value':
	      case 'remove-value':
	        return "option ".concat(label, ", deselected.");
	      case 'clear':
	        return 'All selected options have been cleared.';
	      case 'initial-input-focus':
	        return "option".concat(labels.length > 1 ? 's' : '', " ").concat(labels.join(','), ", selected.");
	      case 'select-option':
	        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");
	      default:
	        return '';
	    }
	  },
	  onFocus: function onFocus(props) {
	    var context = props.context,
	      focused = props.focused,
	      options = props.options,
	      _props$label2 = props.label,
	      label = _props$label2 === void 0 ? '' : _props$label2,
	      selectValue = props.selectValue,
	      isDisabled = props.isDisabled,
	      isSelected = props.isSelected;
	    var getArrayIndex = function getArrayIndex(arr, item) {
	      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : '';
	    };
	    if (context === 'value' && selectValue) {
	      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
	    }
	    if (context === 'menu') {
	      var disabled = isDisabled ? ' disabled' : '';
	      var status = "".concat(isSelected ? 'selected' : 'focused').concat(disabled);
	      return "option ".concat(label, " ").concat(status, ", ").concat(getArrayIndex(options, focused), ".");
	    }
	    return '';
	  },
	  onFilter: function onFilter(props) {
	    var inputValue = props.inputValue,
	      resultsMessage = props.resultsMessage;
	    return "".concat(resultsMessage).concat(inputValue ? ' for search term ' + inputValue : '', ".");
	  }
	};

	var LiveRegion = function LiveRegion(props) {
	  var ariaSelection = props.ariaSelection,
	    focusedOption = props.focusedOption,
	    focusedValue = props.focusedValue,
	    focusableOptions = props.focusableOptions,
	    isFocused = props.isFocused,
	    selectValue = props.selectValue,
	    selectProps = props.selectProps,
	    id = props.id;
	  var ariaLiveMessages = selectProps.ariaLiveMessages,
	    getOptionLabel = selectProps.getOptionLabel,
	    inputValue = selectProps.inputValue,
	    isMulti = selectProps.isMulti,
	    isOptionDisabled = selectProps.isOptionDisabled,
	    isSearchable = selectProps.isSearchable,
	    menuIsOpen = selectProps.menuIsOpen,
	    options = selectProps.options,
	    screenReaderStatus = selectProps.screenReaderStatus,
	    tabSelectsValue = selectProps.tabSelectsValue;
	  var ariaLabel = selectProps['aria-label'];
	  var ariaLive = selectProps['aria-live'];

	  // Update aria live message configuration when prop changes
	  var messages = React$1.useMemo(function () {
	    return _objectSpread2$8(_objectSpread2$8({}, defaultAriaLiveMessages), ariaLiveMessages || {});
	  }, [ariaLiveMessages]);

	  // Update aria live selected option when prop changes
	  var ariaSelected = React$1.useMemo(function () {
	    var message = '';
	    if (ariaSelection && messages.onChange) {
	      var option = ariaSelection.option,
	        selectedOptions = ariaSelection.options,
	        removedValue = ariaSelection.removedValue,
	        removedValues = ariaSelection.removedValues,
	        value = ariaSelection.value;
	      // select-option when !isMulti does not return option so we assume selected option is value
	      var asOption = function asOption(val) {
	        return !Array.isArray(val) ? val : null;
	      };

	      // If there is just one item from the action then get its label
	      var selected = removedValue || option || asOption(value);
	      var label = selected ? getOptionLabel(selected) : '';

	      // If there are multiple items from the action then return an array of labels
	      var multiSelected = selectedOptions || removedValues || undefined;
	      var labels = multiSelected ? multiSelected.map(getOptionLabel) : [];
	      var onChangeProps = _objectSpread2$8({
	        // multiSelected items are usually items that have already been selected
	        // or set by the user as a default value so we assume they are not disabled
	        isDisabled: selected && isOptionDisabled(selected, selectValue),
	        label: label,
	        labels: labels
	      }, ariaSelection);
	      message = messages.onChange(onChangeProps);
	    }
	    return message;
	  }, [ariaSelection, messages, isOptionDisabled, selectValue, getOptionLabel]);
	  var ariaFocused = React$1.useMemo(function () {
	    var focusMsg = '';
	    var focused = focusedOption || focusedValue;
	    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
	    if (focused && messages.onFocus) {
	      var onFocusProps = {
	        focused: focused,
	        label: getOptionLabel(focused),
	        isDisabled: isOptionDisabled(focused, selectValue),
	        isSelected: isSelected,
	        options: focusableOptions,
	        context: focused === focusedOption ? 'menu' : 'value',
	        selectValue: selectValue
	      };
	      focusMsg = messages.onFocus(onFocusProps);
	    }
	    return focusMsg;
	  }, [focusedOption, focusedValue, getOptionLabel, isOptionDisabled, messages, focusableOptions, selectValue]);
	  var ariaResults = React$1.useMemo(function () {
	    var resultsMsg = '';
	    if (menuIsOpen && options.length && messages.onFilter) {
	      var resultsMessage = screenReaderStatus({
	        count: focusableOptions.length
	      });
	      resultsMsg = messages.onFilter({
	        inputValue: inputValue,
	        resultsMessage: resultsMessage
	      });
	    }
	    return resultsMsg;
	  }, [focusableOptions, inputValue, menuIsOpen, messages, options, screenReaderStatus]);
	  var ariaGuidance = React$1.useMemo(function () {
	    var guidanceMsg = '';
	    if (messages.guidance) {
	      var context = focusedValue ? 'value' : menuIsOpen ? 'menu' : 'input';
	      guidanceMsg = messages.guidance({
	        'aria-label': ariaLabel,
	        context: context,
	        isDisabled: focusedOption && isOptionDisabled(focusedOption, selectValue),
	        isMulti: isMulti,
	        isSearchable: isSearchable,
	        tabSelectsValue: tabSelectsValue
	      });
	    }
	    return guidanceMsg;
	  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue]);
	  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
	  var ScreenReaderText = jsx(React$1.Fragment, null, jsx("span", {
	    id: "aria-selection"
	  }, ariaSelected), jsx("span", {
	    id: "aria-context"
	  }, ariaContext));
	  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus';
	  return jsx(React$1.Fragment, null, jsx(A11yText$1, {
	    id: id
	  }, isInitialFocus && ScreenReaderText), jsx(A11yText$1, {
	    "aria-live": ariaLive,
	    "aria-atomic": "false",
	    "aria-relevant": "additions text"
	  }, isFocused && !isInitialFocus && ScreenReaderText));
	};
	var LiveRegion$1 = LiveRegion;

	var diacritics = [{
	  base: 'A',
	  letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
	}, {
	  base: 'AA',
	  letters: "\uA732"
	}, {
	  base: 'AE',
	  letters: "\xC6\u01FC\u01E2"
	}, {
	  base: 'AO',
	  letters: "\uA734"
	}, {
	  base: 'AU',
	  letters: "\uA736"
	}, {
	  base: 'AV',
	  letters: "\uA738\uA73A"
	}, {
	  base: 'AY',
	  letters: "\uA73C"
	}, {
	  base: 'B',
	  letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
	}, {
	  base: 'C',
	  letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
	}, {
	  base: 'D',
	  letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
	}, {
	  base: 'DZ',
	  letters: "\u01F1\u01C4"
	}, {
	  base: 'Dz',
	  letters: "\u01F2\u01C5"
	}, {
	  base: 'E',
	  letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
	}, {
	  base: 'F',
	  letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
	}, {
	  base: 'G',
	  letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
	}, {
	  base: 'H',
	  letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
	}, {
	  base: 'I',
	  letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
	}, {
	  base: 'J',
	  letters: "J\u24BF\uFF2A\u0134\u0248"
	}, {
	  base: 'K',
	  letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
	}, {
	  base: 'L',
	  letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
	}, {
	  base: 'LJ',
	  letters: "\u01C7"
	}, {
	  base: 'Lj',
	  letters: "\u01C8"
	}, {
	  base: 'M',
	  letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
	}, {
	  base: 'N',
	  letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
	}, {
	  base: 'NJ',
	  letters: "\u01CA"
	}, {
	  base: 'Nj',
	  letters: "\u01CB"
	}, {
	  base: 'O',
	  letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
	}, {
	  base: 'OI',
	  letters: "\u01A2"
	}, {
	  base: 'OO',
	  letters: "\uA74E"
	}, {
	  base: 'OU',
	  letters: "\u0222"
	}, {
	  base: 'P',
	  letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
	}, {
	  base: 'Q',
	  letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
	}, {
	  base: 'R',
	  letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
	}, {
	  base: 'S',
	  letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
	}, {
	  base: 'T',
	  letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
	}, {
	  base: 'TZ',
	  letters: "\uA728"
	}, {
	  base: 'U',
	  letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
	}, {
	  base: 'V',
	  letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
	}, {
	  base: 'VY',
	  letters: "\uA760"
	}, {
	  base: 'W',
	  letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
	}, {
	  base: 'X',
	  letters: "X\u24CD\uFF38\u1E8A\u1E8C"
	}, {
	  base: 'Y',
	  letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
	}, {
	  base: 'Z',
	  letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
	}, {
	  base: 'a',
	  letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
	}, {
	  base: 'aa',
	  letters: "\uA733"
	}, {
	  base: 'ae',
	  letters: "\xE6\u01FD\u01E3"
	}, {
	  base: 'ao',
	  letters: "\uA735"
	}, {
	  base: 'au',
	  letters: "\uA737"
	}, {
	  base: 'av',
	  letters: "\uA739\uA73B"
	}, {
	  base: 'ay',
	  letters: "\uA73D"
	}, {
	  base: 'b',
	  letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
	}, {
	  base: 'c',
	  letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
	}, {
	  base: 'd',
	  letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
	}, {
	  base: 'dz',
	  letters: "\u01F3\u01C6"
	}, {
	  base: 'e',
	  letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
	}, {
	  base: 'f',
	  letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
	}, {
	  base: 'g',
	  letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
	}, {
	  base: 'h',
	  letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
	}, {
	  base: 'hv',
	  letters: "\u0195"
	}, {
	  base: 'i',
	  letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
	}, {
	  base: 'j',
	  letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
	}, {
	  base: 'k',
	  letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
	}, {
	  base: 'l',
	  letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
	}, {
	  base: 'lj',
	  letters: "\u01C9"
	}, {
	  base: 'm',
	  letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
	}, {
	  base: 'n',
	  letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
	}, {
	  base: 'nj',
	  letters: "\u01CC"
	}, {
	  base: 'o',
	  letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
	}, {
	  base: 'oi',
	  letters: "\u01A3"
	}, {
	  base: 'ou',
	  letters: "\u0223"
	}, {
	  base: 'oo',
	  letters: "\uA74F"
	}, {
	  base: 'p',
	  letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
	}, {
	  base: 'q',
	  letters: "q\u24E0\uFF51\u024B\uA757\uA759"
	}, {
	  base: 'r',
	  letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
	}, {
	  base: 's',
	  letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
	}, {
	  base: 't',
	  letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
	}, {
	  base: 'tz',
	  letters: "\uA729"
	}, {
	  base: 'u',
	  letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
	}, {
	  base: 'v',
	  letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
	}, {
	  base: 'vy',
	  letters: "\uA761"
	}, {
	  base: 'w',
	  letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
	}, {
	  base: 'x',
	  letters: "x\u24E7\uFF58\u1E8B\u1E8D"
	}, {
	  base: 'y',
	  letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
	}, {
	  base: 'z',
	  letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
	}];
	var anyDiacritic = new RegExp('[' + diacritics.map(function (d) {
	  return d.letters;
	}).join('') + ']', 'g');
	var diacriticToBase = {};
	for (var i = 0; i < diacritics.length; i++) {
	  var diacritic = diacritics[i];
	  for (var j = 0; j < diacritic.letters.length; j++) {
	    diacriticToBase[diacritic.letters[j]] = diacritic.base;
	  }
	}
	var stripDiacritics = function stripDiacritics(str) {
	  return str.replace(anyDiacritic, function (match) {
	    return diacriticToBase[match];
	  });
	};

	var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
	var trimString = function trimString(str) {
	  return str.replace(/^\s+|\s+$/g, '');
	};
	var defaultStringify = function defaultStringify(option) {
	  return "".concat(option.label, " ").concat(option.value);
	};
	var createFilter = function createFilter(config) {
	  return function (option, rawInput) {
	    // eslint-disable-next-line no-underscore-dangle
	    if (option.data.__isNew__) return true;
	    var _ignoreCase$ignoreAcc = _objectSpread2$8({
	        ignoreCase: true,
	        ignoreAccents: true,
	        stringify: defaultStringify,
	        trim: true,
	        matchFrom: 'any'
	      }, config),
	      ignoreCase = _ignoreCase$ignoreAcc.ignoreCase,
	      ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents,
	      stringify = _ignoreCase$ignoreAcc.stringify,
	      trim = _ignoreCase$ignoreAcc.trim,
	      matchFrom = _ignoreCase$ignoreAcc.matchFrom;
	    var input = trim ? trimString(rawInput) : rawInput;
	    var candidate = trim ? trimString(stringify(option)) : stringify(option);
	    if (ignoreCase) {
	      input = input.toLowerCase();
	      candidate = candidate.toLowerCase();
	    }
	    if (ignoreAccents) {
	      input = memoizedStripDiacriticsForInput(input);
	      candidate = stripDiacritics(candidate);
	    }
	    return matchFrom === 'start' ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
	  };
	};

	var _excluded = ["innerRef"];
	function DummyInput(_ref) {
	  var innerRef = _ref.innerRef,
	    props = _objectWithoutProperties(_ref, _excluded);
	  // Remove animation props not meant for HTML elements
	  var filteredProps = removeProps(props, 'onExited', 'in', 'enter', 'exit', 'appear');
	  return jsx("input", _extends$1({
	    ref: innerRef
	  }, filteredProps, {
	    css: /*#__PURE__*/css$2({
	      label: 'dummyInput',
	      // get rid of any default styles
	      background: 0,
	      border: 0,
	      // important! this hides the flashing cursor
	      caretColor: 'transparent',
	      fontSize: 'inherit',
	      gridArea: '1 / 1 / 2 / 3',
	      outline: 0,
	      padding: 0,
	      // important! without `width` browsers won't allow focus
	      width: 1,
	      // remove cursor on desktop
	      color: 'transparent',
	      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
	      left: -100,
	      opacity: 0,
	      position: 'relative',
	      transform: 'scale(.01)'
	    }, "" , "" )
	  }));
	}

	var cancelScroll = function cancelScroll(event) {
	  event.preventDefault();
	  event.stopPropagation();
	};
	function useScrollCapture(_ref) {
	  var isEnabled = _ref.isEnabled,
	    onBottomArrive = _ref.onBottomArrive,
	    onBottomLeave = _ref.onBottomLeave,
	    onTopArrive = _ref.onTopArrive,
	    onTopLeave = _ref.onTopLeave;
	  var isBottom = React$1.useRef(false);
	  var isTop = React$1.useRef(false);
	  var touchStart = React$1.useRef(0);
	  var scrollTarget = React$1.useRef(null);
	  var handleEventDelta = React$1.useCallback(function (event, delta) {
	    if (scrollTarget.current === null) return;
	    var _scrollTarget$current = scrollTarget.current,
	      scrollTop = _scrollTarget$current.scrollTop,
	      scrollHeight = _scrollTarget$current.scrollHeight,
	      clientHeight = _scrollTarget$current.clientHeight;
	    var target = scrollTarget.current;
	    var isDeltaPositive = delta > 0;
	    var availableScroll = scrollHeight - clientHeight - scrollTop;
	    var shouldCancelScroll = false;

	    // reset bottom/top flags
	    if (availableScroll > delta && isBottom.current) {
	      if (onBottomLeave) onBottomLeave(event);
	      isBottom.current = false;
	    }
	    if (isDeltaPositive && isTop.current) {
	      if (onTopLeave) onTopLeave(event);
	      isTop.current = false;
	    }

	    // bottom limit
	    if (isDeltaPositive && delta > availableScroll) {
	      if (onBottomArrive && !isBottom.current) {
	        onBottomArrive(event);
	      }
	      target.scrollTop = scrollHeight;
	      shouldCancelScroll = true;
	      isBottom.current = true;

	      // top limit
	    } else if (!isDeltaPositive && -delta > scrollTop) {
	      if (onTopArrive && !isTop.current) {
	        onTopArrive(event);
	      }
	      target.scrollTop = 0;
	      shouldCancelScroll = true;
	      isTop.current = true;
	    }

	    // cancel scroll
	    if (shouldCancelScroll) {
	      cancelScroll(event);
	    }
	  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
	  var onWheel = React$1.useCallback(function (event) {
	    handleEventDelta(event, event.deltaY);
	  }, [handleEventDelta]);
	  var onTouchStart = React$1.useCallback(function (event) {
	    // set touch start so we can calculate touchmove delta
	    touchStart.current = event.changedTouches[0].clientY;
	  }, []);
	  var onTouchMove = React$1.useCallback(function (event) {
	    var deltaY = touchStart.current - event.changedTouches[0].clientY;
	    handleEventDelta(event, deltaY);
	  }, [handleEventDelta]);
	  var startListening = React$1.useCallback(function (el) {
	    // bail early if no element is available to attach to
	    if (!el) return;
	    var notPassive = supportsPassiveEvents ? {
	      passive: false
	    } : false;
	    el.addEventListener('wheel', onWheel, notPassive);
	    el.addEventListener('touchstart', onTouchStart, notPassive);
	    el.addEventListener('touchmove', onTouchMove, notPassive);
	  }, [onTouchMove, onTouchStart, onWheel]);
	  var stopListening = React$1.useCallback(function (el) {
	    // bail early if no element is available to detach from
	    if (!el) return;
	    el.removeEventListener('wheel', onWheel, false);
	    el.removeEventListener('touchstart', onTouchStart, false);
	    el.removeEventListener('touchmove', onTouchMove, false);
	  }, [onTouchMove, onTouchStart, onWheel]);
	  React$1.useEffect(function () {
	    if (!isEnabled) return;
	    var element = scrollTarget.current;
	    startListening(element);
	    return function () {
	      stopListening(element);
	    };
	  }, [isEnabled, startListening, stopListening]);
	  return function (element) {
	    scrollTarget.current = element;
	  };
	}

	var STYLE_KEYS = ['boxSizing', 'height', 'overflow', 'paddingRight', 'position'];
	var LOCK_STYLES = {
	  boxSizing: 'border-box',
	  // account for possible declaration `width: 100%;` on body
	  overflow: 'hidden',
	  position: 'relative',
	  height: '100%'
	};
	function preventTouchMove(e) {
	  e.preventDefault();
	}
	function allowTouchMove(e) {
	  e.stopPropagation();
	}
	function preventInertiaScroll() {
	  var top = this.scrollTop;
	  var totalScroll = this.scrollHeight;
	  var currentScroll = top + this.offsetHeight;
	  if (top === 0) {
	    this.scrollTop = 1;
	  } else if (currentScroll === totalScroll) {
	    this.scrollTop = top - 1;
	  }
	}

	// `ontouchstart` check works on most browsers
	// `maxTouchPoints` works on IE10/11 and Surface
	function isTouchDevice() {
	  return 'ontouchstart' in window || navigator.maxTouchPoints;
	}
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	var activeScrollLocks = 0;
	var listenerOptions = {
	  capture: false,
	  passive: false
	};
	function useScrollLock(_ref) {
	  var isEnabled = _ref.isEnabled,
	    _ref$accountForScroll = _ref.accountForScrollbars,
	    accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
	  var originalStyles = React$1.useRef({});
	  var scrollTarget = React$1.useRef(null);
	  var addScrollLock = React$1.useCallback(function (touchScrollTarget) {
	    if (!canUseDOM) return;
	    var target = document.body;
	    var targetStyle = target && target.style;
	    if (accountForScrollbars) {
	      // store any styles already applied to the body
	      STYLE_KEYS.forEach(function (key) {
	        var val = targetStyle && targetStyle[key];
	        originalStyles.current[key] = val;
	      });
	    }

	    // apply the lock styles and padding if this is the first scroll lock
	    if (accountForScrollbars && activeScrollLocks < 1) {
	      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
	      var clientWidth = document.body ? document.body.clientWidth : 0;
	      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
	      Object.keys(LOCK_STYLES).forEach(function (key) {
	        var val = LOCK_STYLES[key];
	        if (targetStyle) {
	          targetStyle[key] = val;
	        }
	      });
	      if (targetStyle) {
	        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
	      }
	    }

	    // account for touch devices
	    if (target && isTouchDevice()) {
	      // Mobile Safari ignores { overflow: hidden } declaration on the body.
	      target.addEventListener('touchmove', preventTouchMove, listenerOptions);

	      // Allow scroll on provided target
	      if (touchScrollTarget) {
	        touchScrollTarget.addEventListener('touchstart', preventInertiaScroll, listenerOptions);
	        touchScrollTarget.addEventListener('touchmove', allowTouchMove, listenerOptions);
	      }
	    }

	    // increment active scroll locks
	    activeScrollLocks += 1;
	  }, [accountForScrollbars]);
	  var removeScrollLock = React$1.useCallback(function (touchScrollTarget) {
	    if (!canUseDOM) return;
	    var target = document.body;
	    var targetStyle = target && target.style;

	    // safely decrement active scroll locks
	    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);

	    // reapply original body styles, if any
	    if (accountForScrollbars && activeScrollLocks < 1) {
	      STYLE_KEYS.forEach(function (key) {
	        var val = originalStyles.current[key];
	        if (targetStyle) {
	          targetStyle[key] = val;
	        }
	      });
	    }

	    // remove touch listeners
	    if (target && isTouchDevice()) {
	      target.removeEventListener('touchmove', preventTouchMove, listenerOptions);
	      if (touchScrollTarget) {
	        touchScrollTarget.removeEventListener('touchstart', preventInertiaScroll, listenerOptions);
	        touchScrollTarget.removeEventListener('touchmove', allowTouchMove, listenerOptions);
	      }
	    }
	  }, [accountForScrollbars]);
	  React$1.useEffect(function () {
	    if (!isEnabled) return;
	    var element = scrollTarget.current;
	    addScrollLock(element);
	    return function () {
	      removeScrollLock(element);
	    };
	  }, [isEnabled, addScrollLock, removeScrollLock]);
	  return function (element) {
	    scrollTarget.current = element;
	  };
	}
	var blurSelectInput = function blurSelectInput() {
	  return document.activeElement && document.activeElement.blur();
	};
	var _ref2$1 = {
	  name: "1kfdb0e",
	  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
	} ;
	function ScrollManager(_ref) {
	  var children = _ref.children,
	    lockEnabled = _ref.lockEnabled,
	    _ref$captureEnabled = _ref.captureEnabled,
	    captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled,
	    onBottomArrive = _ref.onBottomArrive,
	    onBottomLeave = _ref.onBottomLeave,
	    onTopArrive = _ref.onTopArrive,
	    onTopLeave = _ref.onTopLeave;
	  var setScrollCaptureTarget = useScrollCapture({
	    isEnabled: captureEnabled,
	    onBottomArrive: onBottomArrive,
	    onBottomLeave: onBottomLeave,
	    onTopArrive: onTopArrive,
	    onTopLeave: onTopLeave
	  });
	  var setScrollLockTarget = useScrollLock({
	    isEnabled: lockEnabled
	  });
	  var targetRef = function targetRef(element) {
	    setScrollCaptureTarget(element);
	    setScrollLockTarget(element);
	  };
	  return jsx(React$1.Fragment, null, lockEnabled && jsx("div", {
	    onClick: blurSelectInput,
	    css: _ref2$1
	  }), children(targetRef));
	}
	var _ref2 = {
	  name: "1a0ro4n-requiredInput",
	  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
	} ;
	var RequiredInput = function RequiredInput(_ref) {
	  var name = _ref.name,
	    onFocus = _ref.onFocus;
	  return jsx("input", {
	    required: true,
	    name: name,
	    tabIndex: -1,
	    "aria-hidden": "true",
	    onFocus: onFocus,
	    css: _ref2
	    // Prevent `Switching from uncontrolled to controlled` error
	    ,
	    value: "",
	    onChange: function onChange() {}
	  });
	};
	var RequiredInput$1 = RequiredInput;

	var formatGroupLabel = function formatGroupLabel(group) {
	  return group.label;
	};
	var getOptionLabel$1 = function getOptionLabel(option) {
	  return option.label;
	};
	var getOptionValue$1 = function getOptionValue(option) {
	  return option.value;
	};
	var isOptionDisabled = function isOptionDisabled(option) {
	  return !!option.isDisabled;
	};

	var defaultStyles = {
	  clearIndicator: clearIndicatorCSS,
	  container: containerCSS,
	  control: css$1,
	  dropdownIndicator: dropdownIndicatorCSS,
	  group: groupCSS,
	  groupHeading: groupHeadingCSS,
	  indicatorsContainer: indicatorsContainerCSS,
	  indicatorSeparator: indicatorSeparatorCSS,
	  input: inputCSS,
	  loadingIndicator: loadingIndicatorCSS,
	  loadingMessage: loadingMessageCSS,
	  menu: menuCSS,
	  menuList: menuListCSS,
	  menuPortal: menuPortalCSS,
	  multiValue: multiValueCSS,
	  multiValueLabel: multiValueLabelCSS,
	  multiValueRemove: multiValueRemoveCSS,
	  noOptionsMessage: noOptionsMessageCSS,
	  option: optionCSS,
	  placeholder: placeholderCSS,
	  singleValue: css,
	  valueContainer: valueContainerCSS
	};

	var colors = {
	  primary: '#2684FF',
	  primary75: '#4C9AFF',
	  primary50: '#B2D4FF',
	  primary25: '#DEEBFF',
	  danger: '#DE350B',
	  dangerLight: '#FFBDAD',
	  neutral0: 'hsl(0, 0%, 100%)',
	  neutral5: 'hsl(0, 0%, 95%)',
	  neutral10: 'hsl(0, 0%, 90%)',
	  neutral20: 'hsl(0, 0%, 80%)',
	  neutral30: 'hsl(0, 0%, 70%)',
	  neutral40: 'hsl(0, 0%, 60%)',
	  neutral50: 'hsl(0, 0%, 50%)',
	  neutral60: 'hsl(0, 0%, 40%)',
	  neutral70: 'hsl(0, 0%, 30%)',
	  neutral80: 'hsl(0, 0%, 20%)',
	  neutral90: 'hsl(0, 0%, 10%)'
	};
	var borderRadius = 4;
	// Used to calculate consistent margin/padding on elements
	var baseUnit = 4;
	// The minimum height of the control
	var controlHeight = 38;
	// The amount of space between the control and menu */
	var menuGutter = baseUnit * 2;
	var spacing = {
	  baseUnit: baseUnit,
	  controlHeight: controlHeight,
	  menuGutter: menuGutter
	};
	var defaultTheme = {
	  borderRadius: borderRadius,
	  colors: colors,
	  spacing: spacing
	};

	var defaultProps = {
	  'aria-live': 'polite',
	  backspaceRemovesValue: true,
	  blurInputOnSelect: isTouchCapable(),
	  captureMenuScroll: !isTouchCapable(),
	  classNames: {},
	  closeMenuOnSelect: true,
	  closeMenuOnScroll: false,
	  components: {},
	  controlShouldRenderValue: true,
	  escapeClearsValue: false,
	  filterOption: createFilter(),
	  formatGroupLabel: formatGroupLabel,
	  getOptionLabel: getOptionLabel$1,
	  getOptionValue: getOptionValue$1,
	  isDisabled: false,
	  isLoading: false,
	  isMulti: false,
	  isRtl: false,
	  isSearchable: true,
	  isOptionDisabled: isOptionDisabled,
	  loadingMessage: function loadingMessage() {
	    return 'Loading...';
	  },
	  maxMenuHeight: 300,
	  minMenuHeight: 140,
	  menuIsOpen: false,
	  menuPlacement: 'bottom',
	  menuPosition: 'absolute',
	  menuShouldBlockScroll: false,
	  menuShouldScrollIntoView: !isMobileDevice(),
	  noOptionsMessage: function noOptionsMessage() {
	    return 'No options';
	  },
	  openMenuOnFocus: false,
	  openMenuOnClick: true,
	  options: [],
	  pageSize: 5,
	  placeholder: 'Select...',
	  screenReaderStatus: function screenReaderStatus(_ref) {
	    var count = _ref.count;
	    return "".concat(count, " result").concat(count !== 1 ? 's' : '', " available");
	  },
	  styles: {},
	  tabIndex: 0,
	  tabSelectsValue: true,
	  unstyled: false
	};
	function toCategorizedOption(props, option, selectValue, index) {
	  var isDisabled = _isOptionDisabled(props, option, selectValue);
	  var isSelected = _isOptionSelected(props, option, selectValue);
	  var label = getOptionLabel(props, option);
	  var value = getOptionValue(props, option);
	  return {
	    type: 'option',
	    data: option,
	    isDisabled: isDisabled,
	    isSelected: isSelected,
	    label: label,
	    value: value,
	    index: index
	  };
	}
	function buildCategorizedOptions(props, selectValue) {
	  return props.options.map(function (groupOrOption, groupOrOptionIndex) {
	    if ('options' in groupOrOption) {
	      var categorizedOptions = groupOrOption.options.map(function (option, optionIndex) {
	        return toCategorizedOption(props, option, selectValue, optionIndex);
	      }).filter(function (categorizedOption) {
	        return isFocusable(props, categorizedOption);
	      });
	      return categorizedOptions.length > 0 ? {
	        type: 'group',
	        data: groupOrOption,
	        options: categorizedOptions,
	        index: groupOrOptionIndex
	      } : undefined;
	    }
	    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
	    return isFocusable(props, categorizedOption) ? categorizedOption : undefined;
	  }).filter(notNullish);
	}
	function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
	  return categorizedOptions.reduce(function (optionsAccumulator, categorizedOption) {
	    if (categorizedOption.type === 'group') {
	      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function (option) {
	        return option.data;
	      })));
	    } else {
	      optionsAccumulator.push(categorizedOption.data);
	    }
	    return optionsAccumulator;
	  }, []);
	}
	function buildFocusableOptions(props, selectValue) {
	  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
	}
	function isFocusable(props, categorizedOption) {
	  var _props$inputValue = props.inputValue,
	    inputValue = _props$inputValue === void 0 ? '' : _props$inputValue;
	  var data = categorizedOption.data,
	    isSelected = categorizedOption.isSelected,
	    label = categorizedOption.label,
	    value = categorizedOption.value;
	  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
	    label: label,
	    value: value,
	    data: data
	  }, inputValue);
	}
	function getNextFocusedValue(state, nextSelectValue) {
	  var focusedValue = state.focusedValue,
	    lastSelectValue = state.selectValue;
	  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
	  if (lastFocusedIndex > -1) {
	    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
	    if (nextFocusedIndex > -1) {
	      // the focused value is still in the selectValue, return it
	      return focusedValue;
	    } else if (lastFocusedIndex < nextSelectValue.length) {
	      // the focusedValue is not present in the next selectValue array by
	      // reference, so return the new value at the same index
	      return nextSelectValue[lastFocusedIndex];
	    }
	  }
	  return null;
	}
	function getNextFocusedOption(state, options) {
	  var lastFocusedOption = state.focusedOption;
	  return lastFocusedOption && options.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options[0];
	}
	var getOptionLabel = function getOptionLabel(props, data) {
	  return props.getOptionLabel(data);
	};
	var getOptionValue = function getOptionValue(props, data) {
	  return props.getOptionValue(data);
	};
	function _isOptionDisabled(props, option, selectValue) {
	  return typeof props.isOptionDisabled === 'function' ? props.isOptionDisabled(option, selectValue) : false;
	}
	function _isOptionSelected(props, option, selectValue) {
	  if (selectValue.indexOf(option) > -1) return true;
	  if (typeof props.isOptionSelected === 'function') {
	    return props.isOptionSelected(option, selectValue);
	  }
	  var candidate = getOptionValue(props, option);
	  return selectValue.some(function (i) {
	    return getOptionValue(props, i) === candidate;
	  });
	}
	function _filterOption(props, option, inputValue) {
	  return props.filterOption ? props.filterOption(option, inputValue) : true;
	}
	var shouldHideSelectedOptions = function shouldHideSelectedOptions(props) {
	  var hideSelectedOptions = props.hideSelectedOptions,
	    isMulti = props.isMulti;
	  if (hideSelectedOptions === undefined) return isMulti;
	  return hideSelectedOptions;
	};
	var instanceId = 1;
	var Select = /*#__PURE__*/function (_Component) {
	  _inherits(Select, _Component);
	  var _super = _createSuper(Select);
	  // Misc. Instance Properties
	  // ------------------------------

	  // TODO

	  // Refs
	  // ------------------------------

	  // Lifecycle
	  // ------------------------------

	  function Select(_props) {
	    var _this;
	    _classCallCheck(this, Select);
	    _this = _super.call(this, _props);
	    _this.state = {
	      ariaSelection: null,
	      focusedOption: null,
	      focusedValue: null,
	      inputIsHidden: false,
	      isFocused: false,
	      selectValue: [],
	      clearFocusValueOnUpdate: false,
	      prevWasFocused: false,
	      inputIsHiddenAfterUpdate: undefined,
	      prevProps: undefined
	    };
	    _this.blockOptionHover = false;
	    _this.isComposing = false;
	    _this.commonProps = void 0;
	    _this.initialTouchX = 0;
	    _this.initialTouchY = 0;
	    _this.instancePrefix = '';
	    _this.openAfterFocus = false;
	    _this.scrollToFocusedOptionOnUpdate = false;
	    _this.userIsDragging = void 0;
	    _this.controlRef = null;
	    _this.getControlRef = function (ref) {
	      _this.controlRef = ref;
	    };
	    _this.focusedOptionRef = null;
	    _this.getFocusedOptionRef = function (ref) {
	      _this.focusedOptionRef = ref;
	    };
	    _this.menuListRef = null;
	    _this.getMenuListRef = function (ref) {
	      _this.menuListRef = ref;
	    };
	    _this.inputRef = null;
	    _this.getInputRef = function (ref) {
	      _this.inputRef = ref;
	    };
	    _this.focus = _this.focusInput;
	    _this.blur = _this.blurInput;
	    _this.onChange = function (newValue, actionMeta) {
	      var _this$props = _this.props,
	        onChange = _this$props.onChange,
	        name = _this$props.name;
	      actionMeta.name = name;
	      _this.ariaOnChange(newValue, actionMeta);
	      onChange(newValue, actionMeta);
	    };
	    _this.setValue = function (newValue, action, option) {
	      var _this$props2 = _this.props,
	        closeMenuOnSelect = _this$props2.closeMenuOnSelect,
	        isMulti = _this$props2.isMulti,
	        inputValue = _this$props2.inputValue;
	      _this.onInputChange('', {
	        action: 'set-value',
	        prevInputValue: inputValue
	      });
	      if (closeMenuOnSelect) {
	        _this.setState({
	          inputIsHiddenAfterUpdate: !isMulti
	        });
	        _this.onMenuClose();
	      }
	      // when the select value should change, we should reset focusedValue
	      _this.setState({
	        clearFocusValueOnUpdate: true
	      });
	      _this.onChange(newValue, {
	        action: action,
	        option: option
	      });
	    };
	    _this.selectOption = function (newValue) {
	      var _this$props3 = _this.props,
	        blurInputOnSelect = _this$props3.blurInputOnSelect,
	        isMulti = _this$props3.isMulti,
	        name = _this$props3.name;
	      var selectValue = _this.state.selectValue;
	      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
	      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
	      if (deselected) {
	        var candidate = _this.getOptionValue(newValue);
	        _this.setValue(multiValueAsValue(selectValue.filter(function (i) {
	          return _this.getOptionValue(i) !== candidate;
	        })), 'deselect-option', newValue);
	      } else if (!isDisabled) {
	        // Select option if option is not disabled
	        if (isMulti) {
	          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), 'select-option', newValue);
	        } else {
	          _this.setValue(singleValueAsValue(newValue), 'select-option');
	        }
	      } else {
	        _this.ariaOnChange(singleValueAsValue(newValue), {
	          action: 'select-option',
	          option: newValue,
	          name: name
	        });
	        return;
	      }
	      if (blurInputOnSelect) {
	        _this.blurInput();
	      }
	    };
	    _this.removeValue = function (removedValue) {
	      var isMulti = _this.props.isMulti;
	      var selectValue = _this.state.selectValue;
	      var candidate = _this.getOptionValue(removedValue);
	      var newValueArray = selectValue.filter(function (i) {
	        return _this.getOptionValue(i) !== candidate;
	      });
	      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
	      _this.onChange(newValue, {
	        action: 'remove-value',
	        removedValue: removedValue
	      });
	      _this.focusInput();
	    };
	    _this.clearValue = function () {
	      var selectValue = _this.state.selectValue;
	      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
	        action: 'clear',
	        removedValues: selectValue
	      });
	    };
	    _this.popValue = function () {
	      var isMulti = _this.props.isMulti;
	      var selectValue = _this.state.selectValue;
	      var lastSelectedValue = selectValue[selectValue.length - 1];
	      var newValueArray = selectValue.slice(0, selectValue.length - 1);
	      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
	      _this.onChange(newValue, {
	        action: 'pop-value',
	        removedValue: lastSelectedValue
	      });
	    };
	    _this.getValue = function () {
	      return _this.state.selectValue;
	    };
	    _this.cx = function () {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
	    };
	    _this.getOptionLabel = function (data) {
	      return getOptionLabel(_this.props, data);
	    };
	    _this.getOptionValue = function (data) {
	      return getOptionValue(_this.props, data);
	    };
	    _this.getStyles = function (key, props) {
	      var unstyled = _this.props.unstyled;
	      var base = defaultStyles[key](props, unstyled);
	      base.boxSizing = 'border-box';
	      var custom = _this.props.styles[key];
	      return custom ? custom(base, props) : base;
	    };
	    _this.getClassNames = function (key, props) {
	      var _this$props$className, _this$props$className2;
	      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
	    };
	    _this.getElementId = function (element) {
	      return "".concat(_this.instancePrefix, "-").concat(element);
	    };
	    _this.getComponents = function () {
	      return defaultComponents(_this.props);
	    };
	    _this.buildCategorizedOptions = function () {
	      return buildCategorizedOptions(_this.props, _this.state.selectValue);
	    };
	    _this.getCategorizedOptions = function () {
	      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
	    };
	    _this.buildFocusableOptions = function () {
	      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
	    };
	    _this.getFocusableOptions = function () {
	      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
	    };
	    _this.ariaOnChange = function (value, actionMeta) {
	      _this.setState({
	        ariaSelection: _objectSpread2$8({
	          value: value
	        }, actionMeta)
	      });
	    };
	    _this.onMenuMouseDown = function (event) {
	      if (event.button !== 0) {
	        return;
	      }
	      event.stopPropagation();
	      event.preventDefault();
	      _this.focusInput();
	    };
	    _this.onMenuMouseMove = function (event) {
	      _this.blockOptionHover = false;
	    };
	    _this.onControlMouseDown = function (event) {
	      // Event captured by dropdown indicator
	      if (event.defaultPrevented) {
	        return;
	      }
	      var openMenuOnClick = _this.props.openMenuOnClick;
	      if (!_this.state.isFocused) {
	        if (openMenuOnClick) {
	          _this.openAfterFocus = true;
	        }
	        _this.focusInput();
	      } else if (!_this.props.menuIsOpen) {
	        if (openMenuOnClick) {
	          _this.openMenu('first');
	        }
	      } else {
	        if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
	          _this.onMenuClose();
	        }
	      }
	      if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
	        event.preventDefault();
	      }
	    };
	    _this.onDropdownIndicatorMouseDown = function (event) {
	      // ignore mouse events that weren't triggered by the primary button
	      if (event && event.type === 'mousedown' && event.button !== 0) {
	        return;
	      }
	      if (_this.props.isDisabled) return;
	      var _this$props4 = _this.props,
	        isMulti = _this$props4.isMulti,
	        menuIsOpen = _this$props4.menuIsOpen;
	      _this.focusInput();
	      if (menuIsOpen) {
	        _this.setState({
	          inputIsHiddenAfterUpdate: !isMulti
	        });
	        _this.onMenuClose();
	      } else {
	        _this.openMenu('first');
	      }
	      event.preventDefault();
	    };
	    _this.onClearIndicatorMouseDown = function (event) {
	      // ignore mouse events that weren't triggered by the primary button
	      if (event && event.type === 'mousedown' && event.button !== 0) {
	        return;
	      }
	      _this.clearValue();
	      event.preventDefault();
	      _this.openAfterFocus = false;
	      if (event.type === 'touchend') {
	        _this.focusInput();
	      } else {
	        setTimeout(function () {
	          return _this.focusInput();
	        });
	      }
	    };
	    _this.onScroll = function (event) {
	      if (typeof _this.props.closeMenuOnScroll === 'boolean') {
	        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
	          _this.props.onMenuClose();
	        }
	      } else if (typeof _this.props.closeMenuOnScroll === 'function') {
	        if (_this.props.closeMenuOnScroll(event)) {
	          _this.props.onMenuClose();
	        }
	      }
	    };
	    _this.onCompositionStart = function () {
	      _this.isComposing = true;
	    };
	    _this.onCompositionEnd = function () {
	      _this.isComposing = false;
	    };
	    _this.onTouchStart = function (_ref2) {
	      var touches = _ref2.touches;
	      var touch = touches && touches.item(0);
	      if (!touch) {
	        return;
	      }
	      _this.initialTouchX = touch.clientX;
	      _this.initialTouchY = touch.clientY;
	      _this.userIsDragging = false;
	    };
	    _this.onTouchMove = function (_ref3) {
	      var touches = _ref3.touches;
	      var touch = touches && touches.item(0);
	      if (!touch) {
	        return;
	      }
	      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
	      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
	      var moveThreshold = 5;
	      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
	    };
	    _this.onTouchEnd = function (event) {
	      if (_this.userIsDragging) return;

	      // close the menu if the user taps outside
	      // we're checking on event.target here instead of event.currentTarget, because we want to assert information
	      // on events on child elements, not the document (which we've attached this handler to).
	      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
	        _this.blurInput();
	      }

	      // reset move vars
	      _this.initialTouchX = 0;
	      _this.initialTouchY = 0;
	    };
	    _this.onControlTouchEnd = function (event) {
	      if (_this.userIsDragging) return;
	      _this.onControlMouseDown(event);
	    };
	    _this.onClearIndicatorTouchEnd = function (event) {
	      if (_this.userIsDragging) return;
	      _this.onClearIndicatorMouseDown(event);
	    };
	    _this.onDropdownIndicatorTouchEnd = function (event) {
	      if (_this.userIsDragging) return;
	      _this.onDropdownIndicatorMouseDown(event);
	    };
	    _this.handleInputChange = function (event) {
	      var prevInputValue = _this.props.inputValue;
	      var inputValue = event.currentTarget.value;
	      _this.setState({
	        inputIsHiddenAfterUpdate: false
	      });
	      _this.onInputChange(inputValue, {
	        action: 'input-change',
	        prevInputValue: prevInputValue
	      });
	      if (!_this.props.menuIsOpen) {
	        _this.onMenuOpen();
	      }
	    };
	    _this.onInputFocus = function (event) {
	      if (_this.props.onFocus) {
	        _this.props.onFocus(event);
	      }
	      _this.setState({
	        inputIsHiddenAfterUpdate: false,
	        isFocused: true
	      });
	      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
	        _this.openMenu('first');
	      }
	      _this.openAfterFocus = false;
	    };
	    _this.onInputBlur = function (event) {
	      var prevInputValue = _this.props.inputValue;
	      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
	        _this.inputRef.focus();
	        return;
	      }
	      if (_this.props.onBlur) {
	        _this.props.onBlur(event);
	      }
	      _this.onInputChange('', {
	        action: 'input-blur',
	        prevInputValue: prevInputValue
	      });
	      _this.onMenuClose();
	      _this.setState({
	        focusedValue: null,
	        isFocused: false
	      });
	    };
	    _this.onOptionHover = function (focusedOption) {
	      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
	        return;
	      }
	      _this.setState({
	        focusedOption: focusedOption
	      });
	    };
	    _this.shouldHideSelectedOptions = function () {
	      return shouldHideSelectedOptions(_this.props);
	    };
	    _this.onValueInputFocus = function (e) {
	      e.preventDefault();
	      e.stopPropagation();
	      _this.focus();
	    };
	    _this.onKeyDown = function (event) {
	      var _this$props5 = _this.props,
	        isMulti = _this$props5.isMulti,
	        backspaceRemovesValue = _this$props5.backspaceRemovesValue,
	        escapeClearsValue = _this$props5.escapeClearsValue,
	        inputValue = _this$props5.inputValue,
	        isClearable = _this$props5.isClearable,
	        isDisabled = _this$props5.isDisabled,
	        menuIsOpen = _this$props5.menuIsOpen,
	        onKeyDown = _this$props5.onKeyDown,
	        tabSelectsValue = _this$props5.tabSelectsValue,
	        openMenuOnFocus = _this$props5.openMenuOnFocus;
	      var _this$state = _this.state,
	        focusedOption = _this$state.focusedOption,
	        focusedValue = _this$state.focusedValue,
	        selectValue = _this$state.selectValue;
	      if (isDisabled) return;
	      if (typeof onKeyDown === 'function') {
	        onKeyDown(event);
	        if (event.defaultPrevented) {
	          return;
	        }
	      }

	      // Block option hover events when the user has just pressed a key
	      _this.blockOptionHover = true;
	      switch (event.key) {
	        case 'ArrowLeft':
	          if (!isMulti || inputValue) return;
	          _this.focusValue('previous');
	          break;
	        case 'ArrowRight':
	          if (!isMulti || inputValue) return;
	          _this.focusValue('next');
	          break;
	        case 'Delete':
	        case 'Backspace':
	          if (inputValue) return;
	          if (focusedValue) {
	            _this.removeValue(focusedValue);
	          } else {
	            if (!backspaceRemovesValue) return;
	            if (isMulti) {
	              _this.popValue();
	            } else if (isClearable) {
	              _this.clearValue();
	            }
	          }
	          break;
	        case 'Tab':
	          if (_this.isComposing) return;
	          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption ||
	          // don't capture the event if the menu opens on focus and the focused
	          // option is already selected; it breaks the flow of navigation
	          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
	            return;
	          }
	          _this.selectOption(focusedOption);
	          break;
	        case 'Enter':
	          if (event.keyCode === 229) {
	            // ignore the keydown event from an Input Method Editor(IME)
	            // ref. https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode
	            break;
	          }
	          if (menuIsOpen) {
	            if (!focusedOption) return;
	            if (_this.isComposing) return;
	            _this.selectOption(focusedOption);
	            break;
	          }
	          return;
	        case 'Escape':
	          if (menuIsOpen) {
	            _this.setState({
	              inputIsHiddenAfterUpdate: false
	            });
	            _this.onInputChange('', {
	              action: 'menu-close',
	              prevInputValue: inputValue
	            });
	            _this.onMenuClose();
	          } else if (isClearable && escapeClearsValue) {
	            _this.clearValue();
	          }
	          break;
	        case ' ':
	          // space
	          if (inputValue) {
	            return;
	          }
	          if (!menuIsOpen) {
	            _this.openMenu('first');
	            break;
	          }
	          if (!focusedOption) return;
	          _this.selectOption(focusedOption);
	          break;
	        case 'ArrowUp':
	          if (menuIsOpen) {
	            _this.focusOption('up');
	          } else {
	            _this.openMenu('last');
	          }
	          break;
	        case 'ArrowDown':
	          if (menuIsOpen) {
	            _this.focusOption('down');
	          } else {
	            _this.openMenu('first');
	          }
	          break;
	        case 'PageUp':
	          if (!menuIsOpen) return;
	          _this.focusOption('pageup');
	          break;
	        case 'PageDown':
	          if (!menuIsOpen) return;
	          _this.focusOption('pagedown');
	          break;
	        case 'Home':
	          if (!menuIsOpen) return;
	          _this.focusOption('first');
	          break;
	        case 'End':
	          if (!menuIsOpen) return;
	          _this.focusOption('last');
	          break;
	        default:
	          return;
	      }
	      event.preventDefault();
	    };
	    _this.instancePrefix = 'react-select-' + (_this.props.instanceId || ++instanceId);
	    _this.state.selectValue = cleanValue(_props.value);

	    // Set focusedOption if menuIsOpen is set on init (e.g. defaultMenuIsOpen)
	    if (_props.menuIsOpen && _this.state.selectValue.length) {
	      var focusableOptions = _this.buildFocusableOptions();
	      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
	      _this.state.focusedOption = focusableOptions[optionIndex];
	    }
	    return _this;
	  }
	  _createClass$1(Select, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      this.startListeningComposition();
	      this.startListeningToTouch();
	      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
	        // Listen to all scroll events, and filter them out inside of 'onScroll'
	        document.addEventListener('scroll', this.onScroll, true);
	      }
	      if (this.props.autoFocus) {
	        this.focusInput();
	      }

	      // Scroll focusedOption into view if menuIsOpen is set on mount (e.g. defaultMenuIsOpen)
	      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
	        scrollIntoView(this.menuListRef, this.focusedOptionRef);
	      }
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate(prevProps) {
	      var _this$props6 = this.props,
	        isDisabled = _this$props6.isDisabled,
	        menuIsOpen = _this$props6.menuIsOpen;
	      var isFocused = this.state.isFocused;
	      if (
	      // ensure focus is restored correctly when the control becomes enabled
	      isFocused && !isDisabled && prevProps.isDisabled ||
	      // ensure focus is on the Input when the menu opens
	      isFocused && menuIsOpen && !prevProps.menuIsOpen) {
	        this.focusInput();
	      }
	      if (isFocused && isDisabled && !prevProps.isDisabled) {
	        // ensure select state gets blurred in case Select is programmatically disabled while focused
	        // eslint-disable-next-line react/no-did-update-set-state
	        this.setState({
	          isFocused: false
	        }, this.onMenuClose);
	      } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
	        // ensure select state gets focused in case Select is programatically re-enabled while focused (Firefox)
	        // eslint-disable-next-line react/no-did-update-set-state
	        this.setState({
	          isFocused: true
	        });
	      }

	      // scroll the focused option into view if necessary
	      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
	        scrollIntoView(this.menuListRef, this.focusedOptionRef);
	        this.scrollToFocusedOptionOnUpdate = false;
	      }
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      this.stopListeningComposition();
	      this.stopListeningToTouch();
	      document.removeEventListener('scroll', this.onScroll, true);
	    }

	    // ==============================
	    // Consumer Handlers
	    // ==============================
	  }, {
	    key: "onMenuOpen",
	    value: function onMenuOpen() {
	      this.props.onMenuOpen();
	    }
	  }, {
	    key: "onMenuClose",
	    value: function onMenuClose() {
	      this.onInputChange('', {
	        action: 'menu-close',
	        prevInputValue: this.props.inputValue
	      });
	      this.props.onMenuClose();
	    }
	  }, {
	    key: "onInputChange",
	    value: function onInputChange(newValue, actionMeta) {
	      this.props.onInputChange(newValue, actionMeta);
	    }

	    // ==============================
	    // Methods
	    // ==============================
	  }, {
	    key: "focusInput",
	    value: function focusInput() {
	      if (!this.inputRef) return;
	      this.inputRef.focus();
	    }
	  }, {
	    key: "blurInput",
	    value: function blurInput() {
	      if (!this.inputRef) return;
	      this.inputRef.blur();
	    }

	    // aliased for consumers
	  }, {
	    key: "openMenu",
	    value: function openMenu(focusOption) {
	      var _this2 = this;
	      var _this$state2 = this.state,
	        selectValue = _this$state2.selectValue,
	        isFocused = _this$state2.isFocused;
	      var focusableOptions = this.buildFocusableOptions();
	      var openAtIndex = focusOption === 'first' ? 0 : focusableOptions.length - 1;
	      if (!this.props.isMulti) {
	        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
	        if (selectedIndex > -1) {
	          openAtIndex = selectedIndex;
	        }
	      }

	      // only scroll if the menu isn't already open
	      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
	      this.setState({
	        inputIsHiddenAfterUpdate: false,
	        focusedValue: null,
	        focusedOption: focusableOptions[openAtIndex]
	      }, function () {
	        return _this2.onMenuOpen();
	      });
	    }
	  }, {
	    key: "focusValue",
	    value: function focusValue(direction) {
	      var _this$state3 = this.state,
	        selectValue = _this$state3.selectValue,
	        focusedValue = _this$state3.focusedValue;

	      // Only multiselects support value focusing
	      if (!this.props.isMulti) return;
	      this.setState({
	        focusedOption: null
	      });
	      var focusedIndex = selectValue.indexOf(focusedValue);
	      if (!focusedValue) {
	        focusedIndex = -1;
	      }
	      var lastIndex = selectValue.length - 1;
	      var nextFocus = -1;
	      if (!selectValue.length) return;
	      switch (direction) {
	        case 'previous':
	          if (focusedIndex === 0) {
	            // don't cycle from the start to the end
	            nextFocus = 0;
	          } else if (focusedIndex === -1) {
	            // if nothing is focused, focus the last value first
	            nextFocus = lastIndex;
	          } else {
	            nextFocus = focusedIndex - 1;
	          }
	          break;
	        case 'next':
	          if (focusedIndex > -1 && focusedIndex < lastIndex) {
	            nextFocus = focusedIndex + 1;
	          }
	          break;
	      }
	      this.setState({
	        inputIsHidden: nextFocus !== -1,
	        focusedValue: selectValue[nextFocus]
	      });
	    }
	  }, {
	    key: "focusOption",
	    value: function focusOption() {
	      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'first';
	      var pageSize = this.props.pageSize;
	      var focusedOption = this.state.focusedOption;
	      var options = this.getFocusableOptions();
	      if (!options.length) return;
	      var nextFocus = 0; // handles 'first'
	      var focusedIndex = options.indexOf(focusedOption);
	      if (!focusedOption) {
	        focusedIndex = -1;
	      }
	      if (direction === 'up') {
	        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options.length - 1;
	      } else if (direction === 'down') {
	        nextFocus = (focusedIndex + 1) % options.length;
	      } else if (direction === 'pageup') {
	        nextFocus = focusedIndex - pageSize;
	        if (nextFocus < 0) nextFocus = 0;
	      } else if (direction === 'pagedown') {
	        nextFocus = focusedIndex + pageSize;
	        if (nextFocus > options.length - 1) nextFocus = options.length - 1;
	      } else if (direction === 'last') {
	        nextFocus = options.length - 1;
	      }
	      this.scrollToFocusedOptionOnUpdate = true;
	      this.setState({
	        focusedOption: options[nextFocus],
	        focusedValue: null
	      });
	    }
	  }, {
	    key: "getTheme",
	    value:
	    // ==============================
	    // Getters
	    // ==============================

	    function getTheme() {
	      // Use the default theme if there are no customisations.
	      if (!this.props.theme) {
	        return defaultTheme;
	      }
	      // If the theme prop is a function, assume the function
	      // knows how to merge the passed-in default theme with
	      // its own modifications.
	      if (typeof this.props.theme === 'function') {
	        return this.props.theme(defaultTheme);
	      }
	      // Otherwise, if a plain theme object was passed in,
	      // overlay it with the default theme.
	      return _objectSpread2$8(_objectSpread2$8({}, defaultTheme), this.props.theme);
	    }
	  }, {
	    key: "getCommonProps",
	    value: function getCommonProps() {
	      var clearValue = this.clearValue,
	        cx = this.cx,
	        getStyles = this.getStyles,
	        getClassNames = this.getClassNames,
	        getValue = this.getValue,
	        selectOption = this.selectOption,
	        setValue = this.setValue,
	        props = this.props;
	      var isMulti = props.isMulti,
	        isRtl = props.isRtl,
	        options = props.options;
	      var hasValue = this.hasValue();
	      return {
	        clearValue: clearValue,
	        cx: cx,
	        getStyles: getStyles,
	        getClassNames: getClassNames,
	        getValue: getValue,
	        hasValue: hasValue,
	        isMulti: isMulti,
	        isRtl: isRtl,
	        options: options,
	        selectOption: selectOption,
	        selectProps: props,
	        setValue: setValue,
	        theme: this.getTheme()
	      };
	    }
	  }, {
	    key: "hasValue",
	    value: function hasValue() {
	      var selectValue = this.state.selectValue;
	      return selectValue.length > 0;
	    }
	  }, {
	    key: "hasOptions",
	    value: function hasOptions() {
	      return !!this.getFocusableOptions().length;
	    }
	  }, {
	    key: "isClearable",
	    value: function isClearable() {
	      var _this$props7 = this.props,
	        isClearable = _this$props7.isClearable,
	        isMulti = _this$props7.isMulti;

	      // single select, by default, IS NOT clearable
	      // multi select, by default, IS clearable
	      if (isClearable === undefined) return isMulti;
	      return isClearable;
	    }
	  }, {
	    key: "isOptionDisabled",
	    value: function isOptionDisabled(option, selectValue) {
	      return _isOptionDisabled(this.props, option, selectValue);
	    }
	  }, {
	    key: "isOptionSelected",
	    value: function isOptionSelected(option, selectValue) {
	      return _isOptionSelected(this.props, option, selectValue);
	    }
	  }, {
	    key: "filterOption",
	    value: function filterOption(option, inputValue) {
	      return _filterOption(this.props, option, inputValue);
	    }
	  }, {
	    key: "formatOptionLabel",
	    value: function formatOptionLabel(data, context) {
	      if (typeof this.props.formatOptionLabel === 'function') {
	        var _inputValue = this.props.inputValue;
	        var _selectValue = this.state.selectValue;
	        return this.props.formatOptionLabel(data, {
	          context: context,
	          inputValue: _inputValue,
	          selectValue: _selectValue
	        });
	      } else {
	        return this.getOptionLabel(data);
	      }
	    }
	  }, {
	    key: "formatGroupLabel",
	    value: function formatGroupLabel(data) {
	      return this.props.formatGroupLabel(data);
	    }

	    // ==============================
	    // Mouse Handlers
	    // ==============================
	  }, {
	    key: "startListeningComposition",
	    value:
	    // ==============================
	    // Composition Handlers
	    // ==============================

	    function startListeningComposition() {
	      if (document && document.addEventListener) {
	        document.addEventListener('compositionstart', this.onCompositionStart, false);
	        document.addEventListener('compositionend', this.onCompositionEnd, false);
	      }
	    }
	  }, {
	    key: "stopListeningComposition",
	    value: function stopListeningComposition() {
	      if (document && document.removeEventListener) {
	        document.removeEventListener('compositionstart', this.onCompositionStart);
	        document.removeEventListener('compositionend', this.onCompositionEnd);
	      }
	    }
	  }, {
	    key: "startListeningToTouch",
	    value:
	    // ==============================
	    // Touch Handlers
	    // ==============================

	    function startListeningToTouch() {
	      if (document && document.addEventListener) {
	        document.addEventListener('touchstart', this.onTouchStart, false);
	        document.addEventListener('touchmove', this.onTouchMove, false);
	        document.addEventListener('touchend', this.onTouchEnd, false);
	      }
	    }
	  }, {
	    key: "stopListeningToTouch",
	    value: function stopListeningToTouch() {
	      if (document && document.removeEventListener) {
	        document.removeEventListener('touchstart', this.onTouchStart);
	        document.removeEventListener('touchmove', this.onTouchMove);
	        document.removeEventListener('touchend', this.onTouchEnd);
	      }
	    }
	  }, {
	    key: "renderInput",
	    value:
	    // ==============================
	    // Renderers
	    // ==============================
	    function renderInput() {
	      var _this$props8 = this.props,
	        isDisabled = _this$props8.isDisabled,
	        isSearchable = _this$props8.isSearchable,
	        inputId = _this$props8.inputId,
	        inputValue = _this$props8.inputValue,
	        tabIndex = _this$props8.tabIndex,
	        form = _this$props8.form,
	        menuIsOpen = _this$props8.menuIsOpen,
	        required = _this$props8.required;
	      var _this$getComponents = this.getComponents(),
	        Input = _this$getComponents.Input;
	      var _this$state4 = this.state,
	        inputIsHidden = _this$state4.inputIsHidden,
	        ariaSelection = _this$state4.ariaSelection;
	      var commonProps = this.commonProps;
	      var id = inputId || this.getElementId('input');

	      // aria attributes makes the JSX "noisy", separated for clarity
	      var ariaAttributes = _objectSpread2$8(_objectSpread2$8(_objectSpread2$8({
	        'aria-autocomplete': 'list',
	        'aria-expanded': menuIsOpen,
	        'aria-haspopup': true,
	        'aria-errormessage': this.props['aria-errormessage'],
	        'aria-invalid': this.props['aria-invalid'],
	        'aria-label': this.props['aria-label'],
	        'aria-labelledby': this.props['aria-labelledby'],
	        'aria-required': required,
	        role: 'combobox'
	      }, menuIsOpen && {
	        'aria-controls': this.getElementId('listbox'),
	        'aria-owns': this.getElementId('listbox')
	      }), !isSearchable && {
	        'aria-readonly': true
	      }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus' && {
	        'aria-describedby': this.getElementId('live-region')
	      } : {
	        'aria-describedby': this.getElementId('placeholder')
	      });
	      if (!isSearchable) {
	        // use a dummy input to maintain focus/blur functionality
	        return /*#__PURE__*/React__namespace.createElement(DummyInput, _extends$1({
	          id: id,
	          innerRef: this.getInputRef,
	          onBlur: this.onInputBlur,
	          onChange: noop,
	          onFocus: this.onInputFocus,
	          disabled: isDisabled,
	          tabIndex: tabIndex,
	          inputMode: "none",
	          form: form,
	          value: ""
	        }, ariaAttributes));
	      }
	      return /*#__PURE__*/React__namespace.createElement(Input, _extends$1({}, commonProps, {
	        autoCapitalize: "none",
	        autoComplete: "off",
	        autoCorrect: "off",
	        id: id,
	        innerRef: this.getInputRef,
	        isDisabled: isDisabled,
	        isHidden: inputIsHidden,
	        onBlur: this.onInputBlur,
	        onChange: this.handleInputChange,
	        onFocus: this.onInputFocus,
	        spellCheck: "false",
	        tabIndex: tabIndex,
	        form: form,
	        type: "text",
	        value: inputValue
	      }, ariaAttributes));
	    }
	  }, {
	    key: "renderPlaceholderOrValue",
	    value: function renderPlaceholderOrValue() {
	      var _this3 = this;
	      var _this$getComponents2 = this.getComponents(),
	        MultiValue = _this$getComponents2.MultiValue,
	        MultiValueContainer = _this$getComponents2.MultiValueContainer,
	        MultiValueLabel = _this$getComponents2.MultiValueLabel,
	        MultiValueRemove = _this$getComponents2.MultiValueRemove,
	        SingleValue = _this$getComponents2.SingleValue,
	        Placeholder = _this$getComponents2.Placeholder;
	      var commonProps = this.commonProps;
	      var _this$props9 = this.props,
	        controlShouldRenderValue = _this$props9.controlShouldRenderValue,
	        isDisabled = _this$props9.isDisabled,
	        isMulti = _this$props9.isMulti,
	        inputValue = _this$props9.inputValue,
	        placeholder = _this$props9.placeholder;
	      var _this$state5 = this.state,
	        selectValue = _this$state5.selectValue,
	        focusedValue = _this$state5.focusedValue,
	        isFocused = _this$state5.isFocused;
	      if (!this.hasValue() || !controlShouldRenderValue) {
	        return inputValue ? null : /*#__PURE__*/React__namespace.createElement(Placeholder, _extends$1({}, commonProps, {
	          key: "placeholder",
	          isDisabled: isDisabled,
	          isFocused: isFocused,
	          innerProps: {
	            id: this.getElementId('placeholder')
	          }
	        }), placeholder);
	      }
	      if (isMulti) {
	        return selectValue.map(function (opt, index) {
	          var isOptionFocused = opt === focusedValue;
	          var key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
	          return /*#__PURE__*/React__namespace.createElement(MultiValue, _extends$1({}, commonProps, {
	            components: {
	              Container: MultiValueContainer,
	              Label: MultiValueLabel,
	              Remove: MultiValueRemove
	            },
	            isFocused: isOptionFocused,
	            isDisabled: isDisabled,
	            key: key,
	            index: index,
	            removeProps: {
	              onClick: function onClick() {
	                return _this3.removeValue(opt);
	              },
	              onTouchEnd: function onTouchEnd() {
	                return _this3.removeValue(opt);
	              },
	              onMouseDown: function onMouseDown(e) {
	                e.preventDefault();
	              }
	            },
	            data: opt
	          }), _this3.formatOptionLabel(opt, 'value'));
	        });
	      }
	      if (inputValue) {
	        return null;
	      }
	      var singleValue = selectValue[0];
	      return /*#__PURE__*/React__namespace.createElement(SingleValue, _extends$1({}, commonProps, {
	        data: singleValue,
	        isDisabled: isDisabled
	      }), this.formatOptionLabel(singleValue, 'value'));
	    }
	  }, {
	    key: "renderClearIndicator",
	    value: function renderClearIndicator() {
	      var _this$getComponents3 = this.getComponents(),
	        ClearIndicator = _this$getComponents3.ClearIndicator;
	      var commonProps = this.commonProps;
	      var _this$props10 = this.props,
	        isDisabled = _this$props10.isDisabled,
	        isLoading = _this$props10.isLoading;
	      var isFocused = this.state.isFocused;
	      if (!this.isClearable() || !ClearIndicator || isDisabled || !this.hasValue() || isLoading) {
	        return null;
	      }
	      var innerProps = {
	        onMouseDown: this.onClearIndicatorMouseDown,
	        onTouchEnd: this.onClearIndicatorTouchEnd,
	        'aria-hidden': 'true'
	      };
	      return /*#__PURE__*/React__namespace.createElement(ClearIndicator, _extends$1({}, commonProps, {
	        innerProps: innerProps,
	        isFocused: isFocused
	      }));
	    }
	  }, {
	    key: "renderLoadingIndicator",
	    value: function renderLoadingIndicator() {
	      var _this$getComponents4 = this.getComponents(),
	        LoadingIndicator = _this$getComponents4.LoadingIndicator;
	      var commonProps = this.commonProps;
	      var _this$props11 = this.props,
	        isDisabled = _this$props11.isDisabled,
	        isLoading = _this$props11.isLoading;
	      var isFocused = this.state.isFocused;
	      if (!LoadingIndicator || !isLoading) return null;
	      var innerProps = {
	        'aria-hidden': 'true'
	      };
	      return /*#__PURE__*/React__namespace.createElement(LoadingIndicator, _extends$1({}, commonProps, {
	        innerProps: innerProps,
	        isDisabled: isDisabled,
	        isFocused: isFocused
	      }));
	    }
	  }, {
	    key: "renderIndicatorSeparator",
	    value: function renderIndicatorSeparator() {
	      var _this$getComponents5 = this.getComponents(),
	        DropdownIndicator = _this$getComponents5.DropdownIndicator,
	        IndicatorSeparator = _this$getComponents5.IndicatorSeparator;

	      // separator doesn't make sense without the dropdown indicator
	      if (!DropdownIndicator || !IndicatorSeparator) return null;
	      var commonProps = this.commonProps;
	      var isDisabled = this.props.isDisabled;
	      var isFocused = this.state.isFocused;
	      return /*#__PURE__*/React__namespace.createElement(IndicatorSeparator, _extends$1({}, commonProps, {
	        isDisabled: isDisabled,
	        isFocused: isFocused
	      }));
	    }
	  }, {
	    key: "renderDropdownIndicator",
	    value: function renderDropdownIndicator() {
	      var _this$getComponents6 = this.getComponents(),
	        DropdownIndicator = _this$getComponents6.DropdownIndicator;
	      if (!DropdownIndicator) return null;
	      var commonProps = this.commonProps;
	      var isDisabled = this.props.isDisabled;
	      var isFocused = this.state.isFocused;
	      var innerProps = {
	        onMouseDown: this.onDropdownIndicatorMouseDown,
	        onTouchEnd: this.onDropdownIndicatorTouchEnd,
	        'aria-hidden': 'true'
	      };
	      return /*#__PURE__*/React__namespace.createElement(DropdownIndicator, _extends$1({}, commonProps, {
	        innerProps: innerProps,
	        isDisabled: isDisabled,
	        isFocused: isFocused
	      }));
	    }
	  }, {
	    key: "renderMenu",
	    value: function renderMenu() {
	      var _this4 = this;
	      var _this$getComponents7 = this.getComponents(),
	        Group = _this$getComponents7.Group,
	        GroupHeading = _this$getComponents7.GroupHeading,
	        Menu = _this$getComponents7.Menu,
	        MenuList = _this$getComponents7.MenuList,
	        MenuPortal = _this$getComponents7.MenuPortal,
	        LoadingMessage = _this$getComponents7.LoadingMessage,
	        NoOptionsMessage = _this$getComponents7.NoOptionsMessage,
	        Option = _this$getComponents7.Option;
	      var commonProps = this.commonProps;
	      var focusedOption = this.state.focusedOption;
	      var _this$props12 = this.props,
	        captureMenuScroll = _this$props12.captureMenuScroll,
	        inputValue = _this$props12.inputValue,
	        isLoading = _this$props12.isLoading,
	        loadingMessage = _this$props12.loadingMessage,
	        minMenuHeight = _this$props12.minMenuHeight,
	        maxMenuHeight = _this$props12.maxMenuHeight,
	        menuIsOpen = _this$props12.menuIsOpen,
	        menuPlacement = _this$props12.menuPlacement,
	        menuPosition = _this$props12.menuPosition,
	        menuPortalTarget = _this$props12.menuPortalTarget,
	        menuShouldBlockScroll = _this$props12.menuShouldBlockScroll,
	        menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView,
	        noOptionsMessage = _this$props12.noOptionsMessage,
	        onMenuScrollToTop = _this$props12.onMenuScrollToTop,
	        onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
	      if (!menuIsOpen) return null;

	      // TODO: Internal Option Type here
	      var render = function render(props, id) {
	        var type = props.type,
	          data = props.data,
	          isDisabled = props.isDisabled,
	          isSelected = props.isSelected,
	          label = props.label,
	          value = props.value;
	        var isFocused = focusedOption === data;
	        var onHover = isDisabled ? undefined : function () {
	          return _this4.onOptionHover(data);
	        };
	        var onSelect = isDisabled ? undefined : function () {
	          return _this4.selectOption(data);
	        };
	        var optionId = "".concat(_this4.getElementId('option'), "-").concat(id);
	        var innerProps = {
	          id: optionId,
	          onClick: onSelect,
	          onMouseMove: onHover,
	          onMouseOver: onHover,
	          tabIndex: -1
	        };
	        return /*#__PURE__*/React__namespace.createElement(Option, _extends$1({}, commonProps, {
	          innerProps: innerProps,
	          data: data,
	          isDisabled: isDisabled,
	          isSelected: isSelected,
	          key: optionId,
	          label: label,
	          type: type,
	          value: value,
	          isFocused: isFocused,
	          innerRef: isFocused ? _this4.getFocusedOptionRef : undefined
	        }), _this4.formatOptionLabel(props.data, 'menu'));
	      };
	      var menuUI;
	      if (this.hasOptions()) {
	        menuUI = this.getCategorizedOptions().map(function (item) {
	          if (item.type === 'group') {
	            var _data = item.data,
	              options = item.options,
	              groupIndex = item.index;
	            var groupId = "".concat(_this4.getElementId('group'), "-").concat(groupIndex);
	            var headingId = "".concat(groupId, "-heading");
	            return /*#__PURE__*/React__namespace.createElement(Group, _extends$1({}, commonProps, {
	              key: groupId,
	              data: _data,
	              options: options,
	              Heading: GroupHeading,
	              headingProps: {
	                id: headingId,
	                data: item.data
	              },
	              label: _this4.formatGroupLabel(item.data)
	            }), item.options.map(function (option) {
	              return render(option, "".concat(groupIndex, "-").concat(option.index));
	            }));
	          } else if (item.type === 'option') {
	            return render(item, "".concat(item.index));
	          }
	        });
	      } else if (isLoading) {
	        var message = loadingMessage({
	          inputValue: inputValue
	        });
	        if (message === null) return null;
	        menuUI = /*#__PURE__*/React__namespace.createElement(LoadingMessage, commonProps, message);
	      } else {
	        var _message = noOptionsMessage({
	          inputValue: inputValue
	        });
	        if (_message === null) return null;
	        menuUI = /*#__PURE__*/React__namespace.createElement(NoOptionsMessage, commonProps, _message);
	      }
	      var menuPlacementProps = {
	        minMenuHeight: minMenuHeight,
	        maxMenuHeight: maxMenuHeight,
	        menuPlacement: menuPlacement,
	        menuPosition: menuPosition,
	        menuShouldScrollIntoView: menuShouldScrollIntoView
	      };
	      var menuElement = /*#__PURE__*/React__namespace.createElement(MenuPlacer, _extends$1({}, commonProps, menuPlacementProps), function (_ref4) {
	        var ref = _ref4.ref,
	          _ref4$placerProps = _ref4.placerProps,
	          placement = _ref4$placerProps.placement,
	          maxHeight = _ref4$placerProps.maxHeight;
	        return /*#__PURE__*/React__namespace.createElement(Menu, _extends$1({}, commonProps, menuPlacementProps, {
	          innerRef: ref,
	          innerProps: {
	            onMouseDown: _this4.onMenuMouseDown,
	            onMouseMove: _this4.onMenuMouseMove,
	            id: _this4.getElementId('listbox')
	          },
	          isLoading: isLoading,
	          placement: placement
	        }), /*#__PURE__*/React__namespace.createElement(ScrollManager, {
	          captureEnabled: captureMenuScroll,
	          onTopArrive: onMenuScrollToTop,
	          onBottomArrive: onMenuScrollToBottom,
	          lockEnabled: menuShouldBlockScroll
	        }, function (scrollTargetRef) {
	          return /*#__PURE__*/React__namespace.createElement(MenuList, _extends$1({}, commonProps, {
	            innerRef: function innerRef(instance) {
	              _this4.getMenuListRef(instance);
	              scrollTargetRef(instance);
	            },
	            isLoading: isLoading,
	            maxHeight: maxHeight,
	            focusedOption: focusedOption
	          }), menuUI);
	        }));
	      });

	      // positioning behaviour is almost identical for portalled and fixed,
	      // so we use the same component. the actual portalling logic is forked
	      // within the component based on `menuPosition`
	      return menuPortalTarget || menuPosition === 'fixed' ? /*#__PURE__*/React__namespace.createElement(MenuPortal, _extends$1({}, commonProps, {
	        appendTo: menuPortalTarget,
	        controlElement: this.controlRef,
	        menuPlacement: menuPlacement,
	        menuPosition: menuPosition
	      }), menuElement) : menuElement;
	    }
	  }, {
	    key: "renderFormField",
	    value: function renderFormField() {
	      var _this5 = this;
	      var _this$props13 = this.props,
	        delimiter = _this$props13.delimiter,
	        isDisabled = _this$props13.isDisabled,
	        isMulti = _this$props13.isMulti,
	        name = _this$props13.name,
	        required = _this$props13.required;
	      var selectValue = this.state.selectValue;
	      if (required && !this.hasValue() && !isDisabled) {
	        return /*#__PURE__*/React__namespace.createElement(RequiredInput$1, {
	          name: name,
	          onFocus: this.onValueInputFocus
	        });
	      }
	      if (!name || isDisabled) return;
	      if (isMulti) {
	        if (delimiter) {
	          var value = selectValue.map(function (opt) {
	            return _this5.getOptionValue(opt);
	          }).join(delimiter);
	          return /*#__PURE__*/React__namespace.createElement("input", {
	            name: name,
	            type: "hidden",
	            value: value
	          });
	        } else {
	          var input = selectValue.length > 0 ? selectValue.map(function (opt, i) {
	            return /*#__PURE__*/React__namespace.createElement("input", {
	              key: "i-".concat(i),
	              name: name,
	              type: "hidden",
	              value: _this5.getOptionValue(opt)
	            });
	          }) : /*#__PURE__*/React__namespace.createElement("input", {
	            name: name,
	            type: "hidden",
	            value: ""
	          });
	          return /*#__PURE__*/React__namespace.createElement("div", null, input);
	        }
	      } else {
	        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : '';
	        return /*#__PURE__*/React__namespace.createElement("input", {
	          name: name,
	          type: "hidden",
	          value: _value
	        });
	      }
	    }
	  }, {
	    key: "renderLiveRegion",
	    value: function renderLiveRegion() {
	      var commonProps = this.commonProps;
	      var _this$state6 = this.state,
	        ariaSelection = _this$state6.ariaSelection,
	        focusedOption = _this$state6.focusedOption,
	        focusedValue = _this$state6.focusedValue,
	        isFocused = _this$state6.isFocused,
	        selectValue = _this$state6.selectValue;
	      var focusableOptions = this.getFocusableOptions();
	      return /*#__PURE__*/React__namespace.createElement(LiveRegion$1, _extends$1({}, commonProps, {
	        id: this.getElementId('live-region'),
	        ariaSelection: ariaSelection,
	        focusedOption: focusedOption,
	        focusedValue: focusedValue,
	        isFocused: isFocused,
	        selectValue: selectValue,
	        focusableOptions: focusableOptions
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this$getComponents8 = this.getComponents(),
	        Control = _this$getComponents8.Control,
	        IndicatorsContainer = _this$getComponents8.IndicatorsContainer,
	        SelectContainer = _this$getComponents8.SelectContainer,
	        ValueContainer = _this$getComponents8.ValueContainer;
	      var _this$props14 = this.props,
	        className = _this$props14.className,
	        id = _this$props14.id,
	        isDisabled = _this$props14.isDisabled,
	        menuIsOpen = _this$props14.menuIsOpen;
	      var isFocused = this.state.isFocused;
	      var commonProps = this.commonProps = this.getCommonProps();
	      return /*#__PURE__*/React__namespace.createElement(SelectContainer, _extends$1({}, commonProps, {
	        className: className,
	        innerProps: {
	          id: id,
	          onKeyDown: this.onKeyDown
	        },
	        isDisabled: isDisabled,
	        isFocused: isFocused
	      }), this.renderLiveRegion(), /*#__PURE__*/React__namespace.createElement(Control, _extends$1({}, commonProps, {
	        innerRef: this.getControlRef,
	        innerProps: {
	          onMouseDown: this.onControlMouseDown,
	          onTouchEnd: this.onControlTouchEnd
	        },
	        isDisabled: isDisabled,
	        isFocused: isFocused,
	        menuIsOpen: menuIsOpen
	      }), /*#__PURE__*/React__namespace.createElement(ValueContainer, _extends$1({}, commonProps, {
	        isDisabled: isDisabled
	      }), this.renderPlaceholderOrValue(), this.renderInput()), /*#__PURE__*/React__namespace.createElement(IndicatorsContainer, _extends$1({}, commonProps, {
	        isDisabled: isDisabled
	      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
	    }
	  }], [{
	    key: "getDerivedStateFromProps",
	    value: function getDerivedStateFromProps(props, state) {
	      var prevProps = state.prevProps,
	        clearFocusValueOnUpdate = state.clearFocusValueOnUpdate,
	        inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate,
	        ariaSelection = state.ariaSelection,
	        isFocused = state.isFocused,
	        prevWasFocused = state.prevWasFocused;
	      var options = props.options,
	        value = props.value,
	        menuIsOpen = props.menuIsOpen,
	        inputValue = props.inputValue,
	        isMulti = props.isMulti;
	      var selectValue = cleanValue(value);
	      var newMenuOptionsState = {};
	      if (prevProps && (value !== prevProps.value || options !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
	        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
	        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
	        var focusedOption = getNextFocusedOption(state, focusableOptions);
	        newMenuOptionsState = {
	          selectValue: selectValue,
	          focusedOption: focusedOption,
	          focusedValue: focusedValue,
	          clearFocusValueOnUpdate: false
	        };
	      }
	      // some updates should toggle the state of the input visibility
	      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
	        inputIsHidden: inputIsHiddenAfterUpdate,
	        inputIsHiddenAfterUpdate: undefined
	      } : {};
	      var newAriaSelection = ariaSelection;
	      var hasKeptFocus = isFocused && prevWasFocused;
	      if (isFocused && !hasKeptFocus) {
	        // If `value` or `defaultValue` props are not empty then announce them
	        // when the Select is initially focused
	        newAriaSelection = {
	          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
	          options: selectValue,
	          action: 'initial-input-focus'
	        };
	        hasKeptFocus = !prevWasFocused;
	      }

	      // If the 'initial-input-focus' action has been set already
	      // then reset the ariaSelection to null
	      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus') {
	        newAriaSelection = null;
	      }
	      return _objectSpread2$8(_objectSpread2$8(_objectSpread2$8({}, newMenuOptionsState), newInputIsHiddenState), {}, {
	        prevProps: props,
	        ariaSelection: newAriaSelection,
	        prevWasFocused: hasKeptFocus
	      });
	    }
	  }]);
	  return Select;
	}(React$1.Component);
	Select.defaultProps = defaultProps;

	var StateManagedSelect = /*#__PURE__*/React$1.forwardRef(function (props, ref) {
	  var baseSelectProps = useStateManager(props);
	  return /*#__PURE__*/React__namespace.createElement(Select, _extends$1({
	    ref: ref
	  }, baseSelectProps));
	});
	var StateManagedSelect$1 = StateManagedSelect;

	function EntityFilters({
	  urlFiltersStore,
	  filtersStore
	}) {
	  const OptionWithDot = props => {
	    var _toJS;
	    const color = (_toJS = toJS(props.data.backgroundColor)) !== null && _toJS !== void 0 ? _toJS : '#ECECEE';
	    return wp.element.createElement(components.Option, _extends$1({}, props, {
	      className: "mpa-multiselect-with-dot"
	    }), wp.element.createElement("div", {
	      className: "mpa-multiselect-option"
	    }, wp.element.createElement("div", {
	      className: "mpa-multiselect-option-dot",
	      style: {
	        backgroundColor: color
	      }
	    }), wp.element.createElement("div", {
	      className: "mpa-multiselect-option-title"
	    }, props.children), wp.element.createElement("div", {
	      className: "mpa-multiselect-option-hover"
	    }, wp.element.createElement("svg", {
	      width: "8",
	      height: "12",
	      viewBox: "0 0 8 12",
	      fill: "none",
	      xmlns: "http://www.w3.org/2000/svg"
	    }, wp.element.createElement("path", {
	      d: "M5.707 0L0 5.707L5.707 11.414L7.121 10L2.828 5.707L7.121 1.414L5.707 0Z",
	      fill: "#C1C0C0"
	    })))));
	  };
	  const multiselectStyles = {
	    groupHeading: (styles, {
	      data
	    }) => ({
	      ...styles,
	      display: toJS(data.label) ? 'block' : 'none'
	    }),
	    option: (styles, {
	      data,
	      isDisabled,
	      isFocused,
	      isSelected
	    }) => ({
	      ...styles,
	      cursor: isDisabled ? 'not-allowed' : 'pointer',
	      backgroundColor: isFocused ? '#f0f0f0' : undefined,
	      ':active': {
	        backgroundColor: '#f0f0f0'
	      }
	    }),
	    control: (styles, {
	      isDisabled,
	      isFocused
	    }) => ({
	      ...styles,
	      background: '#fff',
	      opacity: isDisabled ? 0.5 : 1,
	      border: isFocused ? 0 : 0,
	      // This line disable the blue border
	      boxShadow: isFocused ? 0 : 0,
	      '&:hover': {
	        border: isFocused ? 0 : 0
	      }
	    }),
	    multiValueRemove: (styles, {
	      data
	    }) => ({
	      ...styles,
	      ':hover': {
	        backgroundColor: '#b4b4b4',
	        cursor: 'pointer'
	      }
	    })
	  };
	  const multiselectOptionWithColorDotStyles = {
	    ...multiselectStyles,
	    option: (styles, {
	      data,
	      isDisabled,
	      isFocused,
	      isSelected
	    }) => ({
	      ...styles,
	      cursor: isDisabled ? 'not-allowed' : 'pointer',
	      backgroundColor: undefined,
	      ':active': {
	        backgroundColor: undefined
	      }
	    }),
	    multiValue: (styles, {
	      data
	    }) => {
	      return {
	        ...styles,
	        backgroundColor: data.backgroundColor
	      };
	    },
	    multiValueLabel: (styles, {
	      data
	    }) => ({
	      ...styles,
	      color: data.textColor
	    }),
	    multiValueRemove: (styles, {
	      data
	    }) => ({
	      ...styles,
	      color: data.textColor,
	      ':hover': {
	        cursor: 'pointer',
	        backgroundColor: chroma(data.backgroundColor).darken().css()
	      }
	    })
	  };
	  const onChangeStatusFilterHandler = selectedStatusesObject => {
	    const selectedStatuses = selectedStatusesObject.map(obj => obj.value).join(',');
	    urlFiltersStore.setStatuses(selectedStatuses);
	    urlFiltersStore.updateHistory();
	  };
	  const onChangeServicesFilterHandler = selectedServicesObject => {
	    const selectedServices = selectedServicesObject.map(obj => obj.value).join(',');
	    urlFiltersStore.setServices(selectedServices);
	    urlFiltersStore.updateHistory();
	  };
	  const onChangeLocationsFilterHandler = selectedLocationsObject => {
	    const selectedLocations = selectedLocationsObject.map(obj => obj.value).join(',');
	    urlFiltersStore.setLocations(selectedLocations);
	    urlFiltersStore.updateHistory();
	  };
	  const onChangeEmployeesFilterHandler = selectedEmployeesObject => {
	    const selectedEmployees = selectedEmployeesObject.map(obj => obj.value).join(',');
	    urlFiltersStore.setEmployees(selectedEmployees);
	    urlFiltersStore.updateHistory();
	  };

	  /**
	   * @param {Object[]} object Object of react-select data
	   * @param {string} object[].label
	   * @param {string} object[].value Optional. value or options
	   * @param {Object[]} object[].options  Optional. value or options
	   * @param {string[]} object[].options.categories
	   * @param {string[]} object[].options.categories
	   * @param {string} object[].options.label
	   * @param {string} object[].options.value
	   * @param idsString string with data separated by commas, based on which we filter the object.
	   * @return {Object} Filtered incoming object
	   */
	  const filterObjectBySelectedIds = (object, idsString) => {
	    const idsArray = idsString.split(',');
	    let selectedValue = [];
	    object.map(v => {
	      // for input select without groupby
	      if (v.value !== undefined && idsArray.includes(v.value.toString())) {
	        selectedValue.push(v);
	      }

	      // for input select with groupby headers
	      if (v.options !== undefined) {
	        v.options.map(function (option) {
	          if (idsArray.includes(option.value.toString())) {
	            selectedValue.push(option);
	          }
	        });
	      }
	    });
	    return selectedValue;
	  };
	  const selectedServices = () => {
	    const servicesString = urlFiltersStore.getServices();
	    const services = toJS(filtersStore.services);
	    return filterObjectBySelectedIds(services, servicesString);
	  };
	  const selectedLocations = () => {
	    const locationsString = urlFiltersStore.getLocations();
	    const locations = toJS(filtersStore.locations);
	    return filterObjectBySelectedIds(locations, locationsString);
	  };
	  const selectedEmployees = () => {
	    const employeesString = urlFiltersStore.getEmployees();
	    const employees = toJS(filtersStore.employees);
	    return filterObjectBySelectedIds(employees, employeesString);
	  };
	  const selectedStatuses = () => {
	    const statusesString = urlFiltersStore.getStatuses();
	    const statuses = toJS(filtersStore.statuses);
	    return filterObjectBySelectedIds(statuses, statusesString);
	  };
	  return wp.element.createElement(ObserverComponent, null, () => wp.element.createElement("div", {
	    className: "mpa-filters"
	  }, wp.element.createElement("div", {
	    className: "mpa-select-input-filters mpa-filters__row"
	  }, wp.element.createElement("div", {
	    className: "mpa-multiselect mpa-select-input-filters__item"
	  }, wp.element.createElement(Form$1.Label, {
	    htmlFor: "mpa-services-filter",
	    className: "mpa-multiselect__label"
	  }, __('Services', 'motopress-appointment')), wp.element.createElement(StateManagedSelect$1, {
	    inputId: "mpa-services-filter",
	    className: "mpa-multiselect-input",
	    classNamePrefix: "mpa-multiselect-input",
	    value: selectedServices(),
	    options: filtersStore.services,
	    closeMenuOnSelect: false,
	    isMulti: true,
	    isLoading: filtersStore.servicesLoading,
	    placeholder: __('All', 'motopress-appointment'),
	    styles: multiselectOptionWithColorDotStyles,
	    onChange: onChangeServicesFilterHandler,
	    components: {
	      Option: OptionWithDot
	    }
	  })), wp.element.createElement("div", {
	    className: "mpa-multiselect mpa-select-input-filters__item"
	  }, wp.element.createElement(Form$1.Label, {
	    htmlFor: "mpa-locations-filter",
	    className: "mpa-multiselect__label"
	  }, __('Locations', 'motopress-appointment')), wp.element.createElement(StateManagedSelect$1, {
	    inputId: "mpa-locations-filter",
	    className: "mpa-multiselect-input",
	    classNamePrefix: "mpa-multiselect-input",
	    value: selectedLocations(),
	    options: filtersStore.locations,
	    closeMenuOnSelect: false,
	    isMulti: true,
	    isLoading: filtersStore.locationsLoading,
	    placeholder: __('All', 'motopress-appointment'),
	    styles: multiselectStyles,
	    onChange: onChangeLocationsFilterHandler
	  }))), wp.element.createElement("div", {
	    className: "mpa-select-input-filters mpa-filters__row"
	  }, wp.element.createElement("div", {
	    className: "mpa-multiselect mpa-select-input-filters__item"
	  }, wp.element.createElement(Form$1.Label, {
	    htmlFor: "mpa-employees-filter",
	    className: "mpa-multiselect__label"
	  }, __('Employees', 'motopress-appointment')), wp.element.createElement(StateManagedSelect$1, {
	    inputId: "mpa-employees-filter",
	    className: "mpa-multiselect-input",
	    classNamePrefix: "mpa-multiselect-input",
	    value: selectedEmployees(),
	    isDisabled: filtersStore.employeesDisabled,
	    options: filtersStore.employees,
	    closeMenuOnSelect: false,
	    isMulti: true,
	    isLoading: filtersStore.employeesLoading,
	    placeholder: __('All', 'motopress-appointment'),
	    styles: multiselectStyles,
	    onChange: onChangeEmployeesFilterHandler
	  })), wp.element.createElement("div", {
	    className: "mpa-multiselect mpa-select-input-filters__item"
	  }, wp.element.createElement(Form$1.Label, {
	    htmlFor: "mpa-statuses-filter",
	    className: "mpa-select__label"
	  }, __('Statuses', 'motopress-appointment')), wp.element.createElement(StateManagedSelect$1, {
	    inputId: "mpa-statuses-filter",
	    className: "mpa-multiselect-input",
	    classNamePrefix: "mpa-multiselect-input",
	    value: selectedStatuses(),
	    options: filtersStore.statuses,
	    isMulti: true,
	    placeholder: __('All', 'motopress-appointment'),
	    styles: multiselectStyles,
	    onChange: onChangeStatusFilterHandler
	  })))));
	}

	const localizer = moment(moment$1);
	const localizedMessages = {
	  next: __('Next', 'motopress-appointment'),
	  previous: __('Previous', 'motopress-appointment'),
	  today: __('Today', 'motopress-appointment'),
	  month: __('Month', 'motopress-appointment'),
	  week: __('Week', 'motopress-appointment'),
	  day: __('Day', 'motopress-appointment'),
	  agenda: __('Timetable', 'motopress-appointment'),
	  noEventsInRange: __('There are no events in this range.', 'motopress-appointment'),
	  showMore: total => {
	    // Translators: %d: Count of hide calendar events.
	    return sprintf(__('+%d more', 'motopress-appointment'), total);
	  }
	};
	function CalendarPage() {
	  const [selectedEvent, setSelectedEvent] = React.useState(null);
	  const [modalOpen, setModalOpen] = React.useState(false);
	  const [triggerBrowserHistoryUpdate, setTriggerBrowserHistoryUpdate] = React.useState(false);
	  React.useEffect(() => {
	    if (triggerBrowserHistoryUpdate) {
	      urlFiltersStore.updateHistory();
	      setTriggerBrowserHistoryUpdate(false);
	    }
	  }, [triggerBrowserHistoryUpdate]);

	  // Date render format for agenda header, more friendly for different localizations then default format
	  const {
	    formats
	  } = React.useMemo(() => ({
	    formats: {
	      agendaHeaderFormat: ({
	        start,
	        end
	      }, culture, localizer) => localizer.format(start, 'll', culture) + ' - ' + localizer.format(end, 'll', culture)
	    }
	  }), []);
	  const {
	    eventStore,
	    calendarStore,
	    urlFiltersStore,
	    filtersStore
	  } = useStores();
	  const eventPropGetterHandler = (event, start, end, isSelected) => {
	    if (urlFiltersStore.getView() === 'agenda') {
	      return;
	    }
	    return {
	      style: {
	        borderColor: '#f0f0f1',
	        backgroundColor: event.backgroundColor,
	        color: event.textColor
	      }
	    };
	  };
	  const toggleModal = () => {
	    setModalOpen(!modalOpen);
	  };
	  const closeModal = () => {
	    setModalOpen(false);
	  };
	  const onSelectEventHandler = event => {
	    if (urlFiltersStore.getView() !== 'agenda') {
	      toggleModal();
	      setSelectedEvent(event);
	    }
	  };
	  const onNavigateHandler = date => {
	    urlFiltersStore.setDate(date);
	    setTriggerBrowserHistoryUpdate(true);
	  };
	  const onViewHandler = view => {
	    urlFiltersStore.setView(view);
	    setTriggerBrowserHistoryUpdate(true);
	  };
	  return wp.element.createElement(ObserverComponent, null, () => wp.element.createElement("div", {
	    className: "mpa-calendar"
	  }, wp.element.createElement("div", {
	    className: "mpa-calendar__header"
	  }, wp.element.createElement("h1", {
	    className: "wp-heading-inline"
	  }, __('Calendar', 'motopress-appointment'))), wp.element.createElement(EventModal, {
	    isOpen: modalOpen,
	    toggle: toggleModal,
	    event: selectedEvent,
	    close: closeModal,
	    localizer: localizer
	  }), wp.element.createElement(EntityFilters, {
	    urlFiltersStore: urlFiltersStore,
	    filtersStore: filtersStore
	  }), wp.element.createElement(Calendar$1, {
	    className: "mpa-calendar-content mpa-calendar__content",
	    eventPropGetter: eventPropGetterHandler,
	    localizer: localizer,
	    formats: formats,
	    messages: localizedMessages,
	    events: toJS(eventStore.events),
	    startAccessor: "start",
	    endAccessor: "end",
	    tooltipAccessor: null,
	    date: urlFiltersStore.getDate(),
	    selectable: false,
	    style: {
	      minHeight: "600px"
	    },
	    components: {
	      month: {
	        event: RichEvent
	      },
	      week: {
	        event: RichEvent
	      },
	      day: {
	        event: RichEvent
	      },
	      agenda: {
	        event: AgendaEvent
	      }
	    },
	    views: VIEWS,
	    view: urlFiltersStore.getView(),
	    onNavigate: onNavigateHandler,
	    onView: onViewHandler,
	    onSelectEvent: onSelectEventHandler,
	    min: calendarStore.minTime,
	    max: calendarStore.maxTime
	  })));
	}

	const {
	  createRoot,
	  render
	} = wp.element;
	const domElement = document.getElementById('app');

	// Condition for backward compatibility with WordPress version below 6.2
	if (createRoot) {
	  createRoot(domElement).render(wp.element.createElement(CalendarPage, null));
	} else {
	  render(wp.element.createElement(CalendarPage, null), domElement);
	}

})(mpaData, React, ReactDOM, WPAPI);
